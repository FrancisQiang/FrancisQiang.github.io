<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发编程学习——Java并发编程之美学习笔记五]]></title>
    <url>%2F2019%2F08%2F16%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[Java并发包中并发List介绍 并发包中的List只有 CopyOnWriteArrayList 。 CopyOnWriteArrayList是一个线程安全的List，对其的修改操作都是在底层的一个复制的数组上进行的，也就是使用了 写时复制 策略。 在CopyOnWriteArrayList中，每个对象里有一个array数组对象用来存放具体元素，ReentrantLock独占锁对象用来保证同时只有一个线程能对array进行修改。 如果让我们自己做一个写时复制的线程安全的List我们会怎么做？我们需要考虑什么？ 何时初始化list，初始化list元素为多少个，list是有限大小吗？ 如何保证线程安全？ 如何保证使用迭代器遍历list时的数据一致性。 主要方法解析构造方法12345678910111213141516171819202122// 默认初始化个数0public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;// 传入一个集合的时候，将集合复制到自身属性的array中public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements);&#125;// 传入为数组的时候直接复制public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125; 增加方法12345678910111213141516171819public boolean add(E e) &#123; // 获取独占锁并加锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取自身array并且复制一个快照 Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); // 在快照上进行操作 newElements[len] = e; // 将新的快照赋值给array属性 setArray(newElements); return true; &#125; finally &#123; // 最后解锁 lock.unlock(); &#125;&#125; 获取指定位置的元素123456789101112final Object[] getArray() &#123; return array;&#125;@SuppressWarnings("unchecked")private E get(Object[] a, int index) &#123; return (E) a[index];&#125;public E get(int index) &#123; return get(getArray(), index);&#125; 获取操作并没有加锁，可能会产生 弱一致性问题 。比如当线程A执行get，线程B执行删除操作。线程A这里可以分为两个步骤 1. 获取当前array 2. 通过获取到的array根据索引获得指定元素。 假如这个时候当线程A执行完步骤1，然后线程B执行删除操作，我们假设线程A需要获得的是index为1的元素，此时线程B将原来array复制到新的array中然后对这个新array进行remove(1)的操作，之后把这个新的array重新赋值到对象中的array中，当这一系列操作完成后，线程A获取指定元素，而这个时候线程A是通过原来array获取的，所以它仍能获取到index为1的元素。 例如对于以下程序 运行结果可能会是2或者3 123456789101112131415161718192021222324252627public class CopyOnWriteArrayListTest &#123; public static void main(String[] args) throws InterruptedException &#123; CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;(); copyOnWriteArrayList.add(1); copyOnWriteArrayList.add(2); copyOnWriteArrayList.add(3); copyOnWriteArrayList.add(4); Thread threadOne = new Thread(new Runnable() &#123; @Override public void run() &#123; copyOnWriteArrayList.remove(1); &#125; &#125;); Thread threadTwo = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(copyOnWriteArrayList.get(1)); &#125; &#125;); threadOne.start(); threadTwo.start(); threadTwo.join(); threadOne.join(); System.out.println("结束"); &#125;&#125; 修改指定元素123456789101112131415161718192021222324252627282930public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; // 获取锁并加锁 lock.lock(); try &#123; // 获取array Object[] elements = getArray(); // 获取原来的指定元素 E oldValue = get(elements, index); // 如果参数不和老值相同则进行更新 if (oldValue != element) &#123; int len = elements.length; // 复制array Object[] newElements = Arrays.copyOf(elements, len); // 在新的array中进行更新 newElements[index] = element; // 重新设置array setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics // 确保volatile语义还是需要重新设置array // 因为对于volatile变量的写操作happens-before对volatile // 变量的读操作 setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 删除指定元素1234567891011121314151617181920212223242526272829public E remove(int index) &#123; final ReentrantLock lock = this.lock; // 获取锁并加锁 lock.lock(); try &#123; // 进行快照的准备工作 Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; // 如果删除的是最后一个 if (numMoved == 0) // 直接移除最后一个的空间 setArray(Arrays.copyOf(elements, len - 1)); else &#123; // 创建一个快照 Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); // 将array设置为快照 setArray(newElements); &#125; return oldValue; &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 弱一致性的迭代器1234567891011121314151617181920212223242526272829static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; // 数组的快照 private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; // 判断是否还有下一个元素 public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; // 遍历的方法 @SuppressWarnings("unchecked") public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; 。。。。。&#125; 在snapshot中保存着当前array的快照,也就是说迭代器所操作的是array的一个快照，所以当其他线程对array进行更改的时候，迭代器是感知不到的，这又会产生弱一致性问题。 我们来看一下实例 1234567891011121314151617181920212223242526272829303132public class CopyOnWriteArrayListTest &#123; public static void main(String[] args) throws InterruptedException &#123; CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;(); copyOnWriteArrayList.add(1); copyOnWriteArrayList.add(2); copyOnWriteArrayList.add(3); copyOnWriteArrayList.add(4); copyOnWriteArrayList.add(5); Thread threadOne = new Thread(new Runnable() &#123; @Override public void run() &#123; copyOnWriteArrayList.set(1,123); copyOnWriteArrayList.remove(2); copyOnWriteArrayList.remove(3); &#125; &#125;); // 保证iterator先获取 Iterator&lt;Integer&gt; integerIterator = copyOnWriteArrayList.iterator(); threadOne.start(); threadOne.join(); while (integerIterator.hasNext()) &#123; System.out.println(integerIterator.next()); &#125; &#125;&#125; 我们可以看到运行结果是1 2 3 4 5 我们来看一下创建iterator的源码 1234567public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements;&#125; 其实跟上面讲到的获取和删除的弱一致性一样，因为修改和删除操作时对一个快照进行修改和删除的，并且最终把新的快照地址重新赋值给array，虽然此时的array指向的地址已经变了，但是原来迭代器中获取array的地址并没有改变，所以迭代器操作的还是原来的array，这就是写时复制产生的弱一致性问题。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——Java并发编程之美学习笔记四]]></title>
    <url>%2F2019%2F08%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[原子变量操作类 在JUC并发包中有很多原子变量类，比如AtomicInteger，AtomicLong和AtomicBoolean等。他们原理类似，这里讲解AtomicLong类，AtomicLong是原子性递增和递减类，其内部使用Unsafe实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public class AtomicLong extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 1927816293512124184L; // 获取unsafe实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 声明偏移量 private static final long valueOffset; // 判断JVM是否支持long类型无锁CAS static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); private static native boolean VMSupportsCS8(); static &#123; try &#123; // 获取value在Atomica中的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicLong.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // 实际的变量值 private volatile long value; // 初始化 public AtomicLong(long initialValue) &#123; value = initialValue; &#125; public AtomicLong() &#123; &#125; // 获取 public final long get() &#123; return value; &#125; // 设置 public final void set(long newValue) &#123; value = newValue; &#125; public final void lazySet(long newValue) &#123; unsafe.putOrderedLong(this, valueOffset, newValue); &#125; // 获取并设置long值，返回原来long的值 public final long getAndSet(long newValue) &#123; return unsafe.getAndSetLong(this, valueOffset, newValue); &#125; /** * 原子性设置值为被给予的更新值如果当前值与参数中到的expect期望值相等的话 * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update); &#125; // 和上面方法一样 但是可能会失败而且不提供保证 一般很少代替上面的方法 public final boolean weakCompareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update); &#125; // 原子性增加1 public final long getAndIncrement() &#123; return unsafe.getAndAddLong(this, valueOffset, 1L); &#125; // 原子性减1 public final long getAndDecrement() &#123; return unsafe.getAndAddLong(this, valueOffset, -1L); &#125; // 原子性增加指定的值 public final long getAndAdd(long delta) &#123; return unsafe.getAndAddLong(this, valueOffset, delta); &#125; // 增加1且返回更新后的值 public final long incrementAndGet() &#123; return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L; &#125; // 原子性减1且返回更新后的值 public final long decrementAndGet() &#123; return unsafe.getAndAddLong(this, valueOffset, -1L) - 1L; &#125; public final long addAndGet(long delta) &#123; return unsafe.getAndAddLong(this, valueOffset, delta) + delta; &#125; // 原子性更新循坏使用CAS 导致线程竞争 public final long getAndUpdate(LongUnaryOperator updateFunction) &#123; long prev, next; do &#123; prev = get(); next = updateFunction.applyAsLong(prev); &#125; while (!compareAndSet(prev, next)); return prev; &#125; public final long updateAndGet(LongUnaryOperator updateFunction) &#123; long prev, next; do &#123; prev = get(); next = updateFunction.applyAsLong(prev); &#125; while (!compareAndSet(prev, next)); return next; &#125; // 传入函数 自定义算法 public final long getAndAccumulate(long x, LongBinaryOperator accumulatorFunction) &#123; long prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsLong(prev, x); &#125; while (!compareAndSet(prev, next)); return prev; &#125; public final long accumulateAndGet(long x, LongBinaryOperator accumulatorFunction) &#123; long prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsLong(prev, x); &#125; while (!compareAndSet(prev, next)); return next; &#125; public String toString() &#123; return Long.toString(get()); &#125; public int intValue() &#123; return (int)get(); &#125; public long longValue() &#123; return get(); &#125; public float floatValue() &#123; return (float)get(); &#125; public double doubleValue() &#123; return (double)get(); &#125;&#125; 在这里AtomicLong类可以直接获取Unsafe是因为它本身是在rt.jar下面的是通过Bootstrap类加载器加载的。 上面的原子操作类都是使用的CAS非阻塞算法，性能更好，但是在高并发的情况下Atomicxxx还存放着性能问题(会导致线程一直竞争CAS，导致大量资源浪费)，在JDK1.8之后提供了高并发下的LongAdder类。 JDK8新增的原子操作类LongAdder 在AtomicLong中，在高并发的情况下大量线程会同时竞争更新同一个原子变量，这样会导致大量线程失败通过无线循环不断进行自旋尝试CAS的操作，这回白白浪费CPU资源。 因为AtomicLong是多个线程竞争同一个原子变量，而LongAdder中则将原子变量和线程一一对应，比如设置一个Cell数组，其中的元素对应着每个线程(通过一定的算法实现)，然后最后获取值的时候将base(基础值)和cell数组中的元素值相加。 LongAdder维护了一个延迟初始化的原子性更新数组(默认情况为null)和一个基础值base。由于cell占用的内存相对较大所以是在需要的时候创建，即惰性加载。 因为cell是一个数组，数组中的元素内存地址是连续的，这就很容易导致伪共享的问题，在LongAdder中使用了@Contented注解来避免。 LongAdder代码分析 我们围绕着6个问题去分析源码 LongAdder的结构是怎样的 答：继承了Striped64里面有一个base cell数组和cellBusy自旋操作标志 当前线程应该访问Cell数组里面的哪一个Cell元素 答：获取当前线程的探针(作为每个线程对应哪一个cell的算法基础)，根据当前线程的随机数ThreadLocalRandomProbe和cell元素个数计算当前要访问的cell元素的下标，如果发现对应下标的元素为空则新增一个Cell元素到数组中并在之前将cellBusy设置为1防止其他线程竞争 如何初始化Cell数组 答：懒加载 但需要操作的时候进行初始化操作 Cell数组如何进行扩容 答：当CPU个数大于cell元素进行扩容 这时会多个CPU(线程)争抢一个cell元素产生冲突 线程访问分配的Cell元素后有冲突后应该如何处理 答：进行扩容操作 如何保证线程操作被分配的Cell元素的原子性 答：使用volatile保证内存可见性，使用cas操作保证操作原子性 我们可以看到LongAdder继承Striped64，而Striped64中维持着base，cellBusy，cell三个变量。 base是用来计算LongAdder的真实值的(base和cell元素相加),cellBusy是用来实现自旋锁的，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组的时候使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。 我们来看一下Cell的构造 1234567891011121314151617181920212223@sun.misc.Contended static final class Cell &#123; // 维持着一个long,保证内存可见性声明为volatile volatile long value; Cell(long x) &#123; value = x; &#125; // 进行cas操作，是更新时原子性的 final boolean cas(long cmp, long val) &#123; return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val); &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long valueOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; ak = Cell.class; valueOffset = UNSAFE.objectFieldOffset (ak.getDeclaredField("value")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 我们来看一下LongAdder源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// 继承了Striped64public class LongAdder extends Striped64 implements Serializable &#123; private static final long serialVersionUID = 7249069246863182397L; public LongAdder() &#123; &#125; // 增加指定的值 主要操作 public void add(long x) &#123; Cell[] as; long b, v; int m; Cell a; // 如果数组为空且cas失败会进入 // 或者数组不为空并且没有cas操作的时候进入 if ((as = cells) != null || !casBase(b = base, b + x)) &#123; boolean uncontended = true; // 当数组为空直接进入 这里就是数组为空且刚刚cas失败进入 // 或者c数组不为空但再次cas失败则进入调用longAccumulate if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) longAccumulate(x, null, uncontended); &#125; &#125; // 增加1 public void increment() &#123; add(1L); &#125; // 减少1 public void decrement() &#123; add(-1L); &#125; // 计算所有的值即获取真正的value // 没有做加锁操作 所以并不是原子性的 会存在并发问题 public long sum() &#123; Cell[] as = cells; Cell a; long sum = base; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum; &#125; // 重置所有元素为0 public void reset() &#123; Cell[] as = cells; Cell a; base = 0L; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) a.value = 0L; &#125; &#125; &#125; // 计算并重置 public long sumThenReset() &#123; Cell[] as = cells; Cell a; long sum = base; base = 0L; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) &#123; sum += a.value; a.value = 0L; &#125; &#125; &#125; return sum; &#125; public String toString() &#123; return Long.toString(sum()); &#125; public long longValue() &#123; return sum(); &#125; public int intValue() &#123; return (int)sum(); &#125; public float floatValue() &#123; return (float)sum(); &#125; public double doubleValue() &#123; return (double)sum(); &#125; private static class SerializationProxy implements Serializable &#123; private static final long serialVersionUID = 7249069246863182397L; /** * The current value returned by sum(). * @serial */ private final long value; SerializationProxy(LongAdder a) &#123; value = a.sum(); &#125; /** * Return a &#123;@code LongAdder&#125; object with initial state * held by this proxy. * * @return a &#123;@code LongAdder&#125; object with initial state * held by this proxy. */ private Object readResolve() &#123; LongAdder a = new LongAdder(); a.base = value; return a; &#125; &#125; private Object writeReplace() &#123; return new SerializationProxy(this); &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.InvalidObjectException &#123; throw new java.io.InvalidObjectException("Proxy required"); &#125;&#125; 我们来看一下longAccumulate函数源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) &#123; // 获取当前线程的探针(作为每个线程对应哪一个cell的算法基础) int h; if ((h = getProbe()) == 0) &#123; ThreadLocalRandom.current(); // force initialization h = getProbe(); wasUncontended = true; &#125; boolean collide = false; // True if last slot nonempty for (;;) &#123; Cell[] as; Cell a; int n; long v; // 如果cell不为空 if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123; // 根据当前线程的随机数ThreadLocalRandomProbe和cell元素个数计算当前要访问的cell元素的下标，如果发现对应下标的元素为空则新增一个Cell元素到数组中并在之前将cellBusy设置为1防止其他线程竞争 if ((a = as[(n - 1) &amp; h]) == null) &#123; if (cellsBusy == 0) &#123; // Try to attach new Cell Cell r = new Cell(x); // Optimistically create if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123; boolean created = false; try &#123; // Recheck under lock Cell[] rs; int m, j; if ((rs = cells) != null &amp;&amp; (m = rs.length) &gt; 0 &amp;&amp; rs[j = (m - 1) &amp; h] == null) &#123; rs[j] = r; created = true; &#125; &#125; finally &#123; cellsBusy = 0; &#125; if (created) break; continue; // Slot is now non-empty &#125; &#125; collide = false; &#125; // 如果cas已经知道失败则重置标志 else if (!wasUncontended) // CAS already known to fail wasUncontended = true; // Continue after rehash // 进行cas操作成功直接返回 else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; // 如果cell元素个数大于CPU个数会产生冲突 冲突则进行扩容操作 else if (n &gt;= NCPU || cells != as) collide = false; // At max size or stale else if (!collide) collide = true; else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123; try &#123; if (cells == as) &#123; // Expand table unless stale // 移位增加两倍 Cell[] rs = new Cell[n &lt;&lt; 1]; for (int i = 0; i &lt; n; ++i) rs[i] = as[i]; cells = rs; &#125; &#125; finally &#123; // 扩容的时候进行cas操作避免其他线程进行扩容或者更新操作完成后设置cellBusy为0 cellsBusy = 0; &#125; collide = false; continue; // Retry with expanded table &#125; h = advanceProbe(h); &#125; // 如果为空则进行初始化 else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123; boolean init = false; try &#123; // Initialize table // 初始化 if (cells == as) &#123; Cell[] rs = new Cell[2]; rs[h &amp; 1] = new Cell(x); cells = rs; init = true; &#125; &#125; finally &#123; cellsBusy = 0; &#125; if (init) break; &#125; else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; // Fall back on using base &#125; &#125;``` ## LongAccumulator类原理探究 LongAccumulator比LongAdder更加强大，原因在于LongAdder中只有累加操作，而LongAccumulator中是自定义函数来实现的。我们来看一下LongAccumulator的accumulate函数和LongAdder中的add方法的区别```java public void accumulate(long x) &#123; Cell[] as; long b, v, r; int m; Cell a; if ((as = cells) != null || (r = function.applyAsLong(b = base, x)) != b &amp;&amp; !casBase(b, r)) &#123; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = (r = function.applyAsLong(v = a.value, x)) == v || a.cas(v, r))) // 这里传入了计算的值和一个函数 longAccumulate(x, function, uncontended); &#125; &#125; public void add(long x) &#123; Cell[] as; long b, v; int m; Cell a; if ((as = cells) != null || !casBase(b = base, b + x)) &#123; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) // 传入了值和一个null 我们可以猜测 传入null的时候给我们默认进行增加操作了 longAccumulate(x, null, uncontended); &#125; &#125; 我们继续回顾一下刚刚上面的longAccumulate方法源码中最后一个else if 12345678910111213141516171819// 很明显 当fn为null的时候使用了v + x操作 不然调用该fn的applyAsLong// 我们可以继续猜测这里面进行了自定义 else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break;// 这就是一个函数接口@FunctionalInterfacepublic interface LongBinaryOperator &#123; /** * Applies this operator to the given operands. * * @param left the first operand * @param right the second operand * @return the operator result */ long applyAsLong(long left, long right);&#125;]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——Java并发编程之美读书笔记三]]></title>
    <url>%2F2019%2F08%2F13%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Random类及其局限性 在JDK7之前包括现在Random都是使用比较广泛的随机数生成工具。在java.lang.Math中随机数生成也是使用的java.util.Random的实例。 下面是Random的一种常见的使用方式。 基本步骤就是生成一个Random实例，然后通过这个实例的方法去生成随机数字。 12345678910public class RandomTest &#123; public static void main(String[] args) &#123; Random random = new Random(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(random.nextInt(10)); &#125; &#125;&#125; 随机数的生成需要一个默认的种子，这个种子是一个long类型的数字。我们可以查看一下Random的源码。 1234567891011121314// 无参构造函数其实是通过当前时间生成long类型的种子的public Random() &#123; // 调用的是有参构造函数 this(seedUniquifier() ^ System.nanoTime());&#125;public Random(long seed) &#123; if (getClass() == Random.class) this.seed = new AtomicLong(initialScramble(seed)); else &#123; // subclass might have overriden setSeed this.seed = new AtomicLong(); setSeed(seed); &#125;&#125; 我们来看一下nextInt()方法的源码 123456789101112131415161718192021222324252627282930313233343536// 无参nextInt方法调用了next方法public int nextInt() &#123; return next(32);&#125;protected int next(int bits) &#123; long oldseed, nextseed; // 获取当前的seed AtomicLong seed = this.seed; do &#123; oldseed = seed.get(); // 通过旧种子生成新种子 nextseed = (oldseed * multiplier + addend) &amp; mask; // CAS操作更新种子 &#125; while (!seed.compareAndSet(oldseed, nextseed)); return (int)(nextseed &gt;&gt;&gt; (48 - bits));&#125;public int nextInt(int bound) &#123; // 参数校验 if (bound &lt;= 0) throw new IllegalArgumentException(BadBound); // 还是调用的next方法 // 后面通过计算控制范围 int r = next(31); int m = bound - 1; if ((bound &amp; m) == 0) // i.e., bound is a power of 2 r = (int)((bound * (long)r) &gt;&gt; 31); else &#123; for (int u = r; u - (r = u % bound) + m &lt; 0; u = next(31)) ; &#125; return r;&#125; 看了以上的代码，我们先不管种子是否是原子变量，如果多个线程去调用这个随机方法获得种子然后生成随机数，因为方法里新种子的生成依赖于旧种子，而旧种子是存放在共享变量里的，这里就会导致线程不安全问题，如果线程1生成一个种子，然后线程2和线程3同时调用该方法然后生成新种子，这个时候两个线程调用的旧种子是一样的，又因为旧种子变成新种子的算法是固定的，所以这两个线程得到的是同一个新种子，那么就意味着他们会生成同样的随机数。 而我们要注意的是在next方法里seed是被声明成AtomicLong类型的，它是原子变量，所以这样就可以解决线程安全的问题了(同一时刻只有一个线程能对这个原子变量进行操作)，后面原子变量的更新操作使用的是CAS操作，同一时刻只有一个线程能更新成功，这样就会 导致大量线程自旋重试 ，这样就极大地降低了并发性能。 ThreadLocalRandom ThreadLocalRandom很好的解决了Random在高并发场景下的缺陷和不足。与ThreadLocal的原理一样ThreadLocalRandom使用的也是 线程封闭技术 。 使用方式和Random差不多。 12345678public class RandomTest &#123; public static void main(String[] args) &#123; ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(threadLocalRandom.nextInt(10)); &#125; &#125;&#125; 因为在Random中种子是共享变量，所以在多线程环境下会出现线程安全问题。而ThreadLocalRandom则是把种子变为线程本地变量。这样每个线程就会通过自己线程里的旧种子去更新种子。 ThreadLocalRandom源码分析 我们可以发现ThreadLocalRandom是继承了Random类的，但是需要注意的是ThreadLocalRandom并没有使用Random的seed变量，具体的变量存放在Thread中的ThreadLocalRandomSeed中(存放在线程中)。当调用ThreadLocalRandom的nextInt方法的时候，会获取当前线程的ThreadLocalRandomSeed变量并通过这个种子更新种子然后使用新种子来随机生成数字。 其中ThreadLocalRandom中的seeder和probeGenerator是两个原子性变量，在初始化调用线程的种子和探针的时候会用到他们，每个线程只会调用一次。 另外instance是ThreadLocalRandom的一个实例而且是static的，也就是说多个线程获取的是同一个实例，但是因为种子是存放在线程中的，所以不会产生安全问题。 Unsafe机制123456789101112131415161718192021private static final sun.misc.Unsafe UNSAFE;private static final long SEED;private static final long PROBE;private static final long SECONDARY;static &#123; try &#123; // 获取Unsafe实例 UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; tk = Thread.class; // 获取threadLocalRandomSeed，threadLocalRandomProbe， // threadLocalRandomSecondarySeed在Thread中的偏移量 SEED = UNSAFE.objectFieldOffset (tk.getDeclaredField("threadLocalRandomSeed")); PROBE = UNSAFE.objectFieldOffset (tk.getDeclaredField("threadLocalRandomProbe")); SECONDARY = UNSAFE.objectFieldOffset (tk.getDeclaredField("threadLocalRandomSecondarySeed")); &#125; catch (Exception e) &#123; throw new Error(e); &#125;&#125; ThreadLocalRandom.current()方法123456789101112131415161718public static ThreadLocalRandom current() &#123; // 判断是否为第一次调用，为0则为第一次调用，如果是做初始化操作 if (UNSAFE.getInt(Thread.currentThread(), PROBE) == 0) localInit(); // 返回统一的static实例 return instance;&#125;// 初始化当前线程的种子变量static final void localInit() &#123; // 初始化探针 int p = probeGenerator.addAndGet(PROBE_INCREMENT); int probe = (p == 0) ? 1 : p; // skip 0 // 初始化seed long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT)); Thread t = Thread.currentThread(); UNSAFE.putLong(t, SEED, seed); UNSAFE.putInt(t, PROBE, probe);&#125; int nextInt(int bound)方法1234567891011121314151617181920212223242526public int nextInt(int bound) &#123; // 参数校验 if (bound &lt;= 0) throw new IllegalArgumentException(BadBound); // 根据当前线程中的种子计算新种子 int r = mix32(nextSeed()); int m = bound - 1; if ((bound &amp; m) == 0) // power of two r &amp;= m; else &#123; // reject over-represented candidates for (int u = r &gt;&gt;&gt; 1; u + m - (r = u % bound) &lt; 0; u = mix32(nextSeed()) &gt;&gt;&gt; 1) ; &#125; return r;&#125;final long nextSeed() &#123; Thread t; long r; // read and update per-thread seed // 更新种子 UNSAFE.putLong(t = Thread.currentThread(), SEED, // 这里获取线程种子并进行 + GAMMA操作 r = UNSAFE.getLong(t, SEED) + GAMMA); return r;&#125; 总结 因为Random的种子生成随机数的方法，在Random中的种子是共享的所以多线程会出现并发问题，而Random中将种子声明成原子变量并且使用CAS更新会导致在多线程环境下多个线程去竞争资源，从而导致大量线程自旋，浪费资源和降低并发能力。 在ThreadLocalRandom中使用了线程封闭技术来解决这个问题，线程封闭即使线程本地化，将共享变量进行本地化，从而避免了线程安全问题和提高了并发能力。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——隐藏在并发包中的管程]]></title>
    <url>%2F2019%2F08%2F12%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%9A%90%E8%97%8F%E5%9C%A8%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java SDK并发包中的管程 在Java SDK并发包中通过Lock和Condition两个接口来实现管程，其中Lock用于解决互斥问题，Condition用来解决同步问题。 再造管程的理由 在Java 1.5之前synchronized是不如SDK中的Lock的，但1.6版本之后synchronized做了很多优化，将性能追了上来，所以为什么还要重新“造轮子”的原因不是性能问题，而是 死锁问题中的不可抢占条件 。 我们知道，synchronized是无法破坏不可抢占条件的，因为当线程申请不到锁的时候会直接阻塞。这个阻塞不会释放资源。 而让我们重新去设计一把互斥锁，其实有三种方法去解决。 能够响应中断。因为申请不到锁之后阻塞也不释放资源，所以我们希望阻塞线程能被通知中断唤醒并且释放曾经拥有过的资源。 支持超时。如果线程在一段时间内没有获取到锁，不是进入阻塞状态而是返回一个错误，这样线程也将右机会释放曾经获得的锁了。 非阻塞地获取锁。获取失败的时候不是进入阻塞状态而是直接返回，这样线程就有机会释放曾经持有的锁了。 而这三种方案，在Lock接口中都有对应的API 对应的lockInterruptibly()是支持中断的API，tryLock()是支持非阻塞获取锁的API，tryLock(long time,TimeUnit unit)是支持超时的API。 如何保证可见性 对于synchronized来说因为happends-before规则可以保证可见性，而在ReentrantLock实现类中内部持有了一个volatile变量state，并且在lock和unlock的时候读写state， 通过volatile的happens-before规则 。 锁的最佳实践 永远只在更新对象的变量时加锁 永远只在访问可变的成员变量的时候加锁 永远不再调用其他对象的方法的时候加锁(也许其他方法里面有线程sleep()或者IO操作，其他类也可能加锁会导致死锁) 思考123456789101112131415161718192021222324class Account &#123; private int balance; private final Lock lock = new ReentrantLock(); // 转账 void transfer(Account tar, int amt)&#123; while (true) &#123; if(this.lock.tryLock()) &#123; try &#123; if (tar.lock.tryLock()) &#123; try &#123; this.balance -= amt; tar.balance += amt; &#125; finally &#123; tar.lock.unlock(); &#125; &#125;//if &#125; finally &#123; this.lock.unlock(); &#125; &#125;//if &#125;//while &#125;//transfer&#125; 上面的代码不会产生死锁，但是可能会产生活锁。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——Java并发编程之美读书笔记二]]></title>
    <url>%2F2019%2F08%2F12%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[什么是多线程并发编程 并发：同一个时间段多个任务同时都在执行。 并行：多个任务在单位时间内同时执行。 也就是说并发使用cpu在短时间内切换进程造成了多个任务同时执行的假象。而在多线程编程实践中，线程的个数往往大于CPU个数，所以一般都称多线程并发编程而不是多线程并行编程(意味着一个核上存在多个线程，所以是并发)。 为什么要进行多线程并发编程 多核CPU时代打破了单核CPU对多线程效能的限制(频繁切换线程会带来额外开销)，多线程并发编程可以显著提高性能以应对海量数据和请求。 Java中的线程安全问题 多个线程去改变或读取(至少有一个去改变)一个共享资源会产生线程安全问题。 Java中共享变量的内存可见性问题 Java内存规定，将所有变量都存放在主内存， 当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫工作内存 。 而这个线程的工作内存又是怎样的呢？ 上图是一个双核CPU系统架构，每个核都有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有CPU共享的二级缓存。 那么Java内存模型里面的工作内存，就对应着这里的L1或者L2或者CPU的寄存器 。 由于cache的存在会导致内存不可见，比如线程A和线程B要对一个共享变量x做增加的操作。 线程A首先去获取共享变量x的值，由于两级缓存都没有命中，那么线程A从主存中取出x的值为0并做增加操作，并且放入一级缓存和二级缓存，线程B也去获取共享变量x的值，首先一级缓存没有命中，二级缓存命中(刚刚线程A写入了二级共享缓存)，然后发现二级缓存中的值为1，然后进行增加操作并写入自己的一级缓存和二级缓存，主存。 这样看来没什么问题，但是如果线程A继续进行增加操作呢？线程A首先会去获取共享变量x的值，一级缓存命中！并且获取到了x的值为1，然后进行增加操作变为2，问题就出现了。 线程自己的工作内存(自己的缓存)会导致内存不可见性。 Java中的synchronized关键字 synchronized是Java提供的一种原子性内置锁，由于Java的线程和操作系统中的线程一一对应，所有当阻塞一个线程的时候，需要从用户态切换到内核态执行阻塞操作，这是一个很耗时的操作。而synchronized就会导致上下文切换。 synchronized的内存语意 synchronized代码块中的变量会 从线程的工作内存中清除 ，也就是说synchronized可以解决内存的不可见性。 Java中的volatile关键字 使用synchronized的方式可以解决内存不可见，volatile也可以。 当变量声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是把值刷新会主内存 。 volatile虽然解决了内存可见性问题，但是并不是原子操作，所以在多线程并发时也会出现异常。而一般在什么时候使用volatile关键字呢？ 写入变量不依赖与变量的当前值(加一和赋值操作),因为如果依赖于当前值，那么获取——计算——写入这三步不是原子操作，而不保证volatile的原子性。 读写变量时没有加锁。加锁已经保证了内存可见性，所以没必要把变量再声明为volatile了。 java中的原子性操作 因为 线程切换是CPU指令级别的 ，而Java中的一条语句通常是由很多指令组成的，所以在多线程环境下线程切换会导致很多并发不安全的问题，而synchronized会保证同时只有一个线程执行。 Java中的CAS操作 CAS即Compare and Swap，是JDK提供的非阻塞原子性操作，它通过硬件保证了比较——更新操作的原子性。 ABA问题 当线程1使用CAS修改初始值为A的变量X，那么线程1会首先获取当前变量X的值，然后使用CAS操作尝试修改X的值为B，但是这个时候线程2使用CAS修改变量的值为B然后又通过CAS操作修改变脸的值为A，此时线程1执行CAS的时候X的值虽然是A，然是这个A已经不是线程1获取时的A了。 解决：ABA问题就是变量的状态发生了环形转换，可以提供给变量的状态值配置一个时间戳来避免ABA问题产生。 Unsafe类 Unsafe类提供了硬件级别的原子性操作，里面的方法都是native方法，他们使用JNI方式访问本地C++实现库。 当我们要使用Unsafe类的时候，在本身getUnsafe()方法中会判断当前类加载是否是Bootstrap类加载器，如果不是抛出异常，而我们启动main函数所在的类是使用AppClassLoader加载的，所以在main函数这里面加载Unsafe类的时候，根据委托机制，会委托给Bootstrap去加载Unsafe类。 如果不加以限制，我们可以直接通过Unsafe操作内存，这是不安全的，所以我们需要在rt.jar包下使用Unsafe类，我们也可以通过万能的反射来实现。 Java指令重排序 Java内存模型允许编译器和处理器对指令重排序以提高运行性能。而多线程的环境下指令重排序会导致一些并发问题，而如果使用volatile修饰变量可以避免一些重排序和内存可见性问题。 写volatile变量的时候，可以确保volatile变量写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保对volatile变量读之后的操作不会被编译器重排序到volatile读之前。 伪共享什么是伪共享 为了解决内存和CPU之间的速度差异，CPU会添加一个或多个缓存存储器，而缓存在内部是 按行存储 的。因为局部性原理，当一个变量要存入缓存中其实是连带着周围的变量存入缓存的。所以存入Cache行的是内存而不是单个变量。 比如现在两个CPU，有两个变量x，y放入了缓存行，当线程1对CPU1的缓存行进行修改变量x的值的时候，因为缓存一致性协议，会导致CPU2对应的缓存行失效。所以线程2需要写入x或y的值的时候就要去二级缓存中查找。 为何出现伪共享 因为放入缓存行的是多个数据(是一个内存空间)。 如何避免伪共享 填充缓存行(创建一个对象封装相应的变量使对象空间和缓存行空间一样大)。 JDK8后使用sun.misc.Contended注解(会自动补齐缓存行)。 锁的概述乐观锁和悲观锁 悲观锁：对数据被外界修改保持保守态度，认为数据很容易就被其他线程修改，在对数据处理之前先加锁。 乐观锁：认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而在进行数据提交更新的时候，才会正式对数据冲突与否进行检测。 公平锁与非公平锁 公平锁：先来先获得锁。 非公平：后来的也可以抢占锁。 在一般情况下使用非公平锁，公平锁会带来额外开销。 独占锁和共享锁 独占锁：只能一个线程拥有 共享锁：多个线程拥有，比如说ReadWriteLock读写锁允许一个资源被多个线程进行读操作。 可重入锁 可重入锁：已经获得了锁的资源再次申请该锁的时候不会被阻塞，synchronized就是一个可重入锁。 自旋锁 当前线程在获取锁的时候，如果发现锁已经被占用，它不马上阻塞自己，而是在不放弃CPU使用权的情况下，多次(默认情况下是10次)尝试获取。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——Java并发编程之美读书笔记一]]></title>
    <url>%2F2019%2F08%2F11%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[什么是线程 在操作系统中，进程是资源分配的基本单位，线程是资源调度的基本单位，因为真正占用CPU的是线程。 对于整个Java应用程序来说是一个进程，里面有很多线程。在操作系统中说，线程不独立拥有资源(进程是拥有资源的基本单位)，但是线程还是会拥有自己独立的一些资源的比如说程序计数器，栈等。 程序计数器：用来记录当前线程要执行的指令地址。我的理解是，第一为了确定线程要执行的后面的指令地址，第二是为了确保线程切换的时候，线程能记住它的执行状态(当前执行到哪了)，当下一次再次获得CPU资源的时候，线程能从它私有的程序计数器中获取指令地址继续执行。但是如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行Java代码的时候记录的才是下一条指令的地址。 栈：对于任何语言来说，线程是需要有栈的，这个栈中存放是就是栈帧。因为，对于CPU来说，是没有方法层面的，当高级语言进行方法调用的时候其实对于CPU来说还是执行相应地址中的指令，所以在高级语言中需要有一个方法调用栈，每执行一次方法调用的时候将参数，返回地址存入栈帧中并压入方法栈，等到被调用的方法执行完再出栈取出返回地址继续执行指令。而因为栈帧和方法同生死共命运，所以局部变量，参数等都是放入栈帧中的。 总结：线程中这个栈是方法调用栈，其中基本单位是栈帧，每次该线程进行方法调用的时候创建栈帧并压入方法调用栈，栈帧中有相应的方法参数，返回地址，和局部变量(Java中局部变量在栈中的原因) 堆：堆是进程中最大的一块内存，堆是被进程中的所有线程所共享的。堆中主要存放的是new操作创建的对象实例(Java对象在堆中)。 方法区：用来存放JVM加载的类，常量及静态变量等信息，也是所有线程共享的。 线程创建与运行 线程创建有三种方式 实现Runnable接口并重写run方法 继承Thread类并重写run方法 使用FutureTask创建 使用继承的好处是，获取当前线程直接使用this就可以了，但是Java不支持多继承，所以该类继承了Thread类之后不能再继承其他类了(降低了可扩展性)，而且继承Thread类即将任务代码和线程耦合了。 实现Runnable接口并重写run方法，最后将该实现接口实例作为参数传入Thread构造函数中，这种方法将任务代码和线程之间解耦，并且解决了多继承的问题。 而对于上面两种创建线程的方法来说，线程是没有返回值的，因为run方法是void方法。要使线程具有返回值可以通过FutureTask创建线程。 具体的步骤是： 创建一个类实现Callable接口并重写call()方法 将该类作为参数传入Thread构造方法并启动线程 最后通过FutureTask.get()等待任务执行完毕返回结果 线程等待与通知wait()函数 它是Object中的一个方法，在并发编程中，它的调用者其实是共享变量，因为只有获得了synchronized隐式锁的线程才能使用wait方法，如果没有则会抛出IllegalMonitorStateException。 当线程调用这个wait方法的时候会被阻塞挂起，只有 其他线程调用了该共享变量的notify或者notifyAll(也就是说wait方法会释放当前共享变量的锁) 其他线程调用了该线程的interrupt()方法，该线程抛出InterruptedException异常并返回。 为了防范虚假唤醒，所以wait方法有它的编程范式 12345synchronized (obj) &#123; while(条件不满足) &#123; obj.wait(); &#125;&#125; wait(long timeout) 增加wait时间限制，如果超出时间限制，不管上文提到的两个情况是否满足，该线程还是会因为超时而返回。 wait(long timeout, int nanos) 差不多，内部其实调用的是wait(long timeout)函数 notify() 会随机唤醒一个在该共享变量下调用wait()方法而阻塞的线程。 被唤醒的线程不能直接执行，还需要重新获得共享变量的锁，才能继续执行。 notifyAll() 通知所有在该共享变量下因为调用wait而阻塞的线程。 等待线程执行终止的join方法 join方法是Thread直接提供的无参且返回值为void的方法。 作用是等待线程执行完毕。 让线程睡眠的sleep()方法 会让线程暂时让出指定时间的执行权，也就是在这期间不参与CPU调度，但是线程持有的监视器资源(比如锁)是不会释放的。 让出CPU执行权的yield()方法 当一个线程调用这个方法的时候就是在暗示线程调度器 当前线程请求让出自己的CPU使用，但是，线程调度器可以无条件忽略这个暗示。我们知道时间片轮转会让某个线程持有CPU资源一段时间，线程如果还没使用完这个时间就不想使用了，可以调用这个方法来告诉线程调度器可以进行下一轮的线程调度了。 线程中断 线程中断是线程之间的一种协作模式，通过设置中断标志不能直接终止线程的执行，而是 线程根据中断状态自己去处理 。 下面三个方法是关于线程中断的 void interrupt()方法 中断线程，例如线程A执行时，线程B可以通过调用线程A的interrupt()方法来设置线程A的中断标志为true，并立即返回，注意：仅仅是设置中断标志，线程A并没有真正被中断。若线程A调用了wait(),join(),sleep()方法而被阻塞挂起的时候，线程B调用线程A的interrupt()方法会在 调用这些方法的地方抛出InterruptedException而返回(注意：这里是wait()这些方法，而不是interrupt()方法) 。 boolean isInterrupted()方法 检测当前线程是否被中断，如果是返回true，否则false。 boolean interrupted()方法 检测 当前线程 是否被中断，如果是返回true，否则false。并且它还会清除中断状态。它是Thread的静态方法，不管在哪调用返回的都是当前执行的线程的中断状态并清楚中断状态。 如果某个线程为了等待某些条件发生而阻塞(一般会调用sleep，wait或join函数)，比如这个线程调用了sleep(3000)函数去等待某种条件发生，但是在1秒的时候条件已经满足，这个时候可以调用该线程的interrupt()方法来 强制sleep()抛出InterruptedException而返回，线程恢复到激活状态。 理解线程上下文切换 正如一开始所讲的程序计数器，程序技术器中保存了相应的下一个执行指令地址，栈中保存了执行的一些信息。这些就是线程上下文切换所需要的资源。 线程上下文切换的时机 当前线程CPU时间使用完处于就绪状态。 当前线程被其他线程中断。 线程死锁 死锁的四个必要条件：1. 互斥，2. 请求并占有， 3. 不可剥夺， 4. 环路等待 避免：破坏一个必要条件。 守护线程与用户线程 Java中的线程分为两类：分别为daemon线程和user线程。JVM在启动时会调用main函数，main函数所在的线程是user线程，其实JVM在启动时还启动了好多daemon线程比如垃圾回收线程。 用户线程和守护线程的区别：当最后一个用户线程结束的时候JVM会退出，而守护线程的消亡不会影响到JVM的退出。 比如在main函数中启动一个无限循环的用户线程，当主线程执行完毕的时候JVM不会退出，但是如果把这个无限循环的线程改为守护线程，那么在主线程结束后JVM会自动退出。 如何设置守护线程？ 1deamonThread.setDaemon(true); main线程运行结束后，JVM会自动启动一个叫做DestroyJavaVM的线程，该线程会等待所有 用户线程 结束后终止JVM进程。 而Tomcat的NIO实现NioEndPoint中会开启一组接受线程来接受用户的连接请求以及一组处理线程负责具体处理用户请求，这些线程线程被设置成了守护线程，即当tomcat收到shutdown命令之后并且没有其他用户线程存在的情况下，tomcat进程会马上消亡而不会等待处理线程处理完当前的请求。 ThreadLocal 线程本地化，可以将共享变量复制到线程本地存储空间。这是一种无锁的同步方式。 使用方式： 创建ThreadLocal变量，在线程运行方法中设置刚刚的threadLocal变量实例。 实现原理 当ThreadLocal实例在线程执行的时候第一次调用set或者get方法的时候会在线程中创建相应的threadLocals(这个是一个ThreadLocalMap，一种定制化的HashMap，里面存放了许多线程本地化变量)，key为当前ThreadLocal实例的引用，值为自己设置的值。后面调用就直接会在线程的threadLocals这个Map中进行操作。 注意当本地变量不再使用的时候最好使用remove将其删除，避免内存溢出。还要注意的是ThreadLocal不支持继承，也就是说子线程不会拥有父线程的threadLocals变量。 但是可以使用InheritableThreadLocal类，可以追溯Thread创建的源码，Thread在创建的过程中会判断父线程的inheritableThreadLocals(上图的Thread中有这个私有变量)是否为空，如果不为空那么将其复制到子线程的inheritableThreadLocals中去。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——为什么局部变量是线程安全的]]></title>
    <url>%2F2019%2F08%2F10%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%2F</url>
    <content type="text"><![CDATA[局部变量不存在数据竞争 在并发编程领域里，没有共享就没有伤害。对于局部变量是不存在数据竞争的，为什么呢？ 比如，下面代码里的 fibonacci() 这个方法，会根据传入的参数 n ，返回 1 到 n 的斐波那契数列，斐波那契数列类似这样： 1、1、2、3、5、8、13、21、34……第 1 项和第 2 项是 1，从第 3 项开始，每一项都等于前两项之和。在这个方法里面，有个局部变量：数组 r 用来保存数列的结果，每次计算完一项，都会更新数组 r 对应位置中的值。你可以思考这样一个问题，当多个线程调用 fibonacci() 这个方法的时候，数组 r 是否存在数据竞争（Data Race）呢？ 123456789101112// 返回斐波那契数列int[] fibonacci(int n) &#123; // 创建结果数组 int[] r = new int[n]; // 初始化第一、第二个数 r[0] = r[1] = 1; // ① // 计算 2..n for(int i = 2; i &lt; n; i++) &#123; r[i] = r[i-2] + r[i-1]; &#125; return r;&#125; 我们试想一下貌似多个线程同时执行fibonacci方法的时候对数组r的写入读取会发生数据竞争。 方法是如何被执行的 对于CPU来说是没有方法这一层面的，对于它来说任何操作都是一条条指令，那么CPU如果进行一个方法调用总要进行返回到调用方法的代码片段(地址)去执行，这个CPU是怎么做到的呢？ 答案就是栈，在我的关于栈的文章中提到过方法栈，CPU就是通过栈来实现返回到原来调用方法的地址的。 在线程执行进入方法的时候，会将这个方法的一些信息作为栈帧压入方法栈中。一些信息可能有参数，返回地址(这个肯定是必要的，因为出栈的时候需要用到，不然无法返回了)。但栈帧出栈的时候就意味着这个方法执行完了，所以隐含意思就是一个栈帧对应着一次一个方法的执行，栈帧和一次一个方法的执行是同生死共命运的。 而我们也知道，对于局部变量来说，在方法执行完就会消失，所以局部变量和栈帧就有着同样的性质了，即局部变量，栈帧，一次一个方法的执行这三者是同时消亡的。所以把局部变量放入栈帧中是最合适不过的了，现实也是这么做的。这也解释了Java中为什么局部变量是存放在栈中的，想要跨越方法的边界，那么变量就必须放入堆中。 线程与方法栈 从操作系统层面来说，每个线程不独立拥有资源，但是它还是拥有一些必要的资源比如线程控制块(也不算资源)，用户栈，内核栈。。所以线程是拥有自己的栈的，也就是说每个线程执行过程中都拥有自己的方法调用栈，而栈帧是在这个方法栈中的，栈帧里面拥有着局部变量，所以可以说，每个线程的局部变量根本不是一个地址，所以就不会出现数据竞争了，所以局部变量是线程安全的。 线程封闭 因为局部变量不存在并发问题，现在也成为了一个解决并发问题的重要思路了，叫线程封闭。 采用线程封闭技术的案例非常多，例如从数据库连接池里获取的连接 Connection，在 JDBC 规范里并没有要求这个 Connection 必须是线程安全的。数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程，从而保证了 Connection 不会有并发问题。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——创建多少线程才是合适的]]></title>
    <url>%2F2019%2F08%2F10%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E6%89%8D%E6%98%AF%E5%90%88%E9%80%82%E7%9A%84%2F</url>
    <content type="text"><![CDATA[为什么使用多线程 减少延迟，提高吞吐量。 延迟指从发出请求到收到响应过程的时间，吞吐量指单位时间内能完成的请求个数。 多线程应用场景 想要降低延迟提高吞吐量主要有两个维度的方法，第一个是优化算法，第二个是最大化硬件的利用率。前者属于算法范畴，后者就和并发编程息息相关了。而对于计算机硬件来说最主要的就是两个硬件，一个是IO一个是CPU。在操作系统层面，操作系统已经为我们对硬件的利用率做了很大的优化，但是还是不够，在CPU与IO配合使用的利用率更加需要我们程序员去优化。也就是说，我们需要去解决CPU和IO设备综合利用率的问题 例如在单线程中，假设CPU和IO的执行时间相同，那么这个时候CPU和IO设备的利用率都是50%。 但在双线程中，CPU和IO设备执行时间都是一样的，这个时候，CPU在等待IO的时候又可以去执行下一个线程的，这个时候CPU和IO的利用率就是100%。 所以，如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来提高吞吐量。 在单核时代，多线程主要就是用来平衡 CPU 和 I/O 设备的。如果程序只有 CPU 计算，而没有 I/O 操作的话，多线程不但不会提升性能，还会使性能变得更差，原因是增加了线程切换的成本。但是在多核时代，这种纯计算型的程序也可以利用多线程来提升性能。为什么呢？因为利用多核可以降低响应时间。 例如计算 1+2+… … +100 亿的值，如果在 4 核的 CPU 上利用 4 个线程执行，线程 A 计算 [1，25 亿)，线程 B 计算 [25 亿，50 亿)，线程 C 计算 [50，75 亿)，线程 D 计算 [75 亿，100 亿]，之后汇总，那么理论上应该比一个线程计算 [1，100 亿] 快将近 4 倍，响应时间能够降到 25%。一个线程，对于 4 核的 CPU，CPU 的利用率只有 25%，而 4 个线程，则能够将 CPU 的利用率提高到 100%。 创建多少线程合适 创建多少线程合适需要考虑应用场景，通常情况下我们的程序都是由IO操作和CPU操作一起执行的，而IO操作相对于CPU操作来说是非常耗时的。所以大部分情况下，I/O 操作执行的时间相对于 CPU 计算来说都非常长，这种场景我们一般都称为 I/O 密集型计算。 和 I/O 密集型计算相对的就是 CPU 密集型计算了，CPU 密集型计算大部分场景下都是纯 CPU 计算。I/O 密集型程序和 CPU 密集型程序，计算最佳线程数的方法是不同的。 对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的 CPU，每个核一个线程，理论上创建 4 个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，对于 CPU 密集型的计算场景，理论上线程的数量 =CPU 核数就是最合适的。不过在工程上，线程的数量一般会设置为CPU 核数 +1，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。 对于 I/O 密集型的计算场景，比如前面我们的例子中，如果 CPU 计算和 I/O 操作的耗时是 1:1，那么 2 个线程是最合适的。如果 CPU 计算和 I/O 操作的耗时是 1:2，那多少个线程合适呢？是 3 个线程，如下图所示：CPU 在 A、B、C 三个线程之间切换，对于线程 A，当 CPU 从 B、C 切换回来时，线程 A 正好执行完 I/O 操作。这样 CPU 和 I/O 设备的利用率都达到了 100%。 最佳线程数 =1 +（I/O 耗时 / CPU 耗时） 对于多核来说只需要乘上核数就行：最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——Java线程的生命周期]]></title>
    <url>%2F2019%2F08%2F10%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[通用线程模型 在操作系统中线程有五种状态，这也是通用的线程模型。这五种状态分别是初始状态(创建),可运行状态(就绪),运行状态,休眠状态(阻塞),终止状态(消亡)。 对于这五种状态，不同的编程语言会对他们进行简化合并或者细化，就比如Java把这五种状态进行了相应的更改。 Java线程模型 Java线程一共有六种状态，分别是：NEW（初始化状态），RUNNABLE（可运行 / 运行状态），BLOCKED（阻塞状态），WAITING（无时限等待），TIMED_WAITING（有时限等待），TERMINATED（终止状态）。 而对于BLOCKED，WAITTING，TIMED_WATTING这三种状态可以归于通用线程模型中的休眠状态(阻塞)，而对于通用线程中的运行状态和就绪(可运行状态)，在Java中则对他们进行了合并，合并成了Runnable状态。 Runnable与Blocked状态之间的转换 对于Runnable转换成Blocked状态只有一种情况，那就是在获取synchronized隐式锁失败的时候，线程会从可运行(Runnable)状态转换为Blocked阻塞状态。而当线程获取到了synchronized隐式锁的时候又会从Blocked状态转换到Runnable状态。 但是线程调用阻塞式API的时候不会从Runnable状态转换到Blocked状态，在操作系统层面，线程会进入休眠(阻塞状态)，但是在JVM层面，线程的状态是不会发生变化的，也就是说线程状态还是Runnable。JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。 Runnable和Waitting状态之间的转换 获得synchronized隐式锁的线程调用Object的wait方法 调用无参数的Thread.join(),其中的 join() 是一种线程同步方法，例如有一个线程对象 thread A，当调用 A.join() 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。 调用 LockSupport.park() 方法。其中的 LockSupport 对象，也许你有点陌生，其实 Java 并发包中的锁，都是基于它实现的。调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。 Runnable与Timed_Waitting状态之间的转换 调用带超时参数的 Thread.sleep(long millis) 方法 获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法 调用带超时参数的 Thread.join(long millis) 方法 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法； 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。 从New到Runnable状态 首先当线程创建的时候就是New状态，而创建线程有两种方式。 一是继承Thread类并重写run方法。 二是实现Runnable接口重写run方法并将该类作为创建Thread的参数。 123456789// 自定义线程对象class MyThread extends Thread &#123; public void run() &#123; // 线程需要执行的代码 ...... &#125;&#125;// 创建线程对象MyThread myThread = new MyThread(); 12345678910// 实现 Runnable 接口class Runner implements Runnable &#123; @Override public void run() &#123; // 线程需要执行的代码 ...... &#125;&#125;// 创建线程对象Thread thread = new Thread(new Runner()); 而对于从New状态到Runnable状态只需要调用线程的start()方法。 从Runnable状态到Terminated状态 调用stop()或者interrupt()方法，但是对于stop方法官方已经废弃，因为stop方法会直接杀死线程，如果线程已经获得隐式锁，那么这锁也会消失，也就意味着，其他线程再也获取不到这个锁了。类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了。 而 interrupt() 方法就温柔多了，interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。 比如有线程A和线程B，线程A调用了线程B的interrupt()方法，这个意思是指线程A告诉线程B——你现在被设置成了中断状态。但是线程B还可以进行操作(因为它有个isInterrupted来决定被中断之后执行的操作) 当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。 上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件，都是调用了类似 wait()、join()、sleep() 这样的方法，我们看这些方法的签名，发现都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。 当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回。 上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的 interrupt() 方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——管程]]></title>
    <url>%2F2019%2F08%2F09%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%A1%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是管程 管程：管理共享变量和操作共享变量的过程。为了解决信号量配对的复杂性以及分散在程序中降低了程序的可读性，管程通过一种数据结构对共享变量和对共享变量的操作进行了封装。 管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程更容易使用，所以 Java 选择了管程。 在Java1.5之前提供的是synchronized，wait，notify和notifyAll，这是java管程实现的一部分。 MESA模型 在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。 MESA模型实现互斥 这里的共享变量被封装起来了，其中对于共享变量queue的操作只能通过enq和deq，而这两个方法保证互斥性，只允许一个线程进入管程。 MESA墨香实现同步 对于同步则通过增加条件变量和相应的等待队列。 如果当条件变量不满足的时候则进入相应的等待队列，因为某个操作而导致条件允许的时候则唤醒相应的等待队列中的线程，并且再次获取锁来执行。因为要再次获取锁，所以这个条件只能是曾经满足过，所以当阻塞线程被唤醒再次获取锁需要执行的时候，有可能这个时候的条件又不允许了。 代码实现对于入队操作，如果队列已满，就需要等待直到队列不满，所以这里用了notFull.await();。 对于出队操作，如果队列为空，就需要等待直到队列不空，所以就用了notEmpty.await();。 如果入队成功，那么队列就不空了，就需要通知条件变量：队列不空notEmpty对应的等待队列。 如果出队成功，那就队列就不满了，就需要通知条件变量：队列不满notFull对应的等待队列。 1234567891011121314151617181920212223242526272829303132333435363738394041public class BlockedQueue&lt;T&gt;&#123; final Lock lock = new ReentrantLock(); // 条件变量：队列不满 final Condition notFull = lock.newCondition(); // 条件变量：队列不空 final Condition notEmpty = lock.newCondition(); // 入队 void enq(T x) &#123; lock.lock(); try &#123; while (队列已满)&#123; // 等待队列不满 notFull.await(); &#125; // 省略入队操作... // 入队后, 通知可出队 notEmpty.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; // 出队 void deq()&#123; lock.lock(); try &#123; while (队列已空)&#123; // 等待队列不空 notEmpty.await(); &#125; // 省略出队操作... // 出队后，通知可入队 notFull.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 这里的await和signal就类似于wait和notify。 对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 wait()。这个是 MESA 管程特有的。 123while(条件不满足) &#123; wait();&#125; Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，如何通知相关线程。管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？ Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。 Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。 MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。 notify() 何时可以使用 满足以下三个条件： 所有等待线程拥有相同的等待条件 所有等待线程被唤醒之后，执行相同的操作。 只需要唤醒一个线程。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——安全性，活跃性以及性能问题]]></title>
    <url>%2F2019%2F08%2F09%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安全性问题 在并发编程中需要考虑三个基本问题——安全性，活跃性以及性能。 所谓安全性就是指程序能否按照我们预期的执行。就比如线程安全这个概念，所谓线程安全和不安全无非就是指程序能否保证它的正确性，而这个正确性就是我们让程序按照我们所期望地执行。 而这种情况下只有存在共享数据并且该数据会发生变化的时候需要考虑安全性问题，通俗来讲就是是否存在多个线程对这个资源进行读写操作(至少有一个线程进行写操作)。 当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做数据竞争（Data Race）。 就比如以下的add10k方法，当多个线程调用的时候就会发生数据竞争。 123456789public class Test &#123; private long count = 0; void add10K() &#123; int idx = 0; while(idx++ &lt; 10000) &#123; count += 1; &#125; &#125;&#125; 那是不是在访问数据的地方，我们加个锁保护一下就能解决所有的并发问题了呢？显然没有这么简单。例如，对于上面示例，我们稍作修改，增加两个被 synchronized 修饰的 get() 和 set() 方法， add10K() 方法里面通过 get() 和 set() 方法来访问 value 变量，修改后的代码如下所示。对于修改后的代码，所有访问共享变量 value 的地方，我们都增加了互斥锁，此时是不存在数据竞争的。但很显然修改后的 add10K() 方法并不是线程安全的。 123456789101112131415public class Test &#123; private long count = 0; synchronized long get()&#123; return count； &#125; synchronized void set(long v)&#123; count = v; &#125; void add10K() &#123; int idx = 0; while(idx++ &lt; 10000) &#123; set(get()+1) &#125; &#125;&#125; 我们来解读一下，这时候同时存在两个线程访问add10k方法然后同时进入while循环，然后同时调用get方法，但是因为get方法是synchronized修饰的所以同时只有一个线程能访问，比如这个时候线程A获得了优先权进行调用，读取到count为0，然后这个时候get方法执行完线程A释放锁，线程B获得了锁进入get方法也读取到count为0，然后可能这个时候线程B有执行了加一操作并且获得了set方法的锁进入set方法将count设置为1，这个时候可能线程A也执行了+1操作并且获得了线程B刚刚释放的锁来进行set操作，这个时候count又会被设置为1，其实本该结果为2(因为进行了两次加一操)，但是因为线程执行顺序的问题而导致程序不是按照我们期望的执行，所以这个是咸亨不安全的。 这种问题，有个官方的称呼，叫竞态条件（Race Condition）。所谓竞态条件，指的是程序的执行结果依赖线程执行的顺序。例如上面的例子，如果两个线程完全同时执行，那么结果是 1；如果两个线程是前后执行，那么结果就是 2。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大 Bug。 下面再结合一个例子来说明下竞态条件，就是前面文章中提到的转账操作。转账操作里面有个判断条件——转出金额不能大于账户余额，但在并发环境里面，如果不加控制，当多个线程同时对一个账号执行转出操作时，就有可能出现超额转出问题。假设账户 A 有余额 200，线程 1 和线程 2 都要从账户 A 转出 150，在下面的代码里，有可能线程 1 和线程 2 同时执行到第 6 行，这样线程 1 和线程 2 都会发现转出金额 150 小于账户余额 200，于是就会发生超额转出的情况。 1234567891011class Account &#123; private int balance; // 转账 void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125;&#125; 那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：锁。 活跃性问题 所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是活锁和饥饿。 但有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。 可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。 解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。 那“饥饿”该怎么去理解呢？所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。“不患寡，而患不均”，如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。 解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。 那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。 性能问题 使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。 所以我们要尽量减少串行，那串行对性能的影响是怎么样的呢？假设串行百分比是 5%，我们用多核多线程相比单核单线程能提速多少呢？ 有个阿姆达尔（Amdahl）定律，代表了处理器并行运算之后效率提升的能力，它正好可以解决这个问题，具体公式如下： 公式里的 n 可以理解为 CPU 的核数，p 可以理解为并行百分比，那（1-p）就是串行百分比了，也就是我们假设的 5%。我们再假设 CPU 的核数（也就是 n）无穷大，那加速比 S 的极限就是 20。也就是说，如果我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。 所以使用锁的时候一定要关注对性能的影响。 那怎么才能避免锁带来的性能问题呢？这个问题很复杂，Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。 不过从方案层面，我们可以这样来解决这个问题。 第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好…… 第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。 性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。 吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。 延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。 并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。 总结 总之并发编程从微观上来讲就是要关注原子性，可见性，顺序性的问题。从宏观上来讲就要关注安全性，活跃性，性能的问题。而微观上三个问题的目的都是为了解决安全性的问题，但是解决问题的同时还可能产生新的问题，这就是活跃性的问题，而如何利用三个微观问题去解决安全问题随之带来了性能问题。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——使用等待通知机制优化循环等待]]></title>
    <url>%2F2019%2F08%2F09%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%2F</url>
    <content type="text"><![CDATA[什么是等待通知机制 在前面提到的破坏占用且等待条件的时候使用了死循环来获取资源，当apply()操作历时非常长或者并发量很大的时候，这个死循环是非常占cpu资源的，所以这种场景下可以使用等待通知机制来优化循环等待。 什么是等待通知机制？所谓等待就是当线程获取锁进入临界区想要获取相应资源而条件不满足获取不到的时候，线程自己进入阻塞状态(等待)并且释放锁，等到线程需要的资源都有的时候则通知线程它需要的资源曾经满足过。 为什么说曾经满足过，因为当线程被通知唤醒的时候还需要重新获得互斥锁，在这个阶段是有时差的，所以这个时候可能会出现一些情况导致刚刚满足的资源又被其它线程拿走了。 完美的就医流程 就医流程就可以比作这个等待通知机制。 患者需要挂号，等待叫号 等到叫到自己的号的时候就可以找医生就诊了。(获取互斥锁) 就诊过程医生可能要叫患者去做一些检查。同时叫下一个患者(因为某种条件，资源不符合线程释放锁进入阻塞状态) 患者做完检查，拿着报告重新分诊(资源满足要重新获得互斥锁) 医生再次叫到自己号的时候，患者再去找医生就诊(条件资源满足重新获得锁) 使用synchronized实现等待-通知机制 在Java语言中可以通过synchronized结合wait(),notify(),notifyAll()这三个方法来实现等待-通知机制。 在下面这个图里，左边有一个等待队列，同一时刻，只允许一个线程进入 synchronized 保护的临界区（这个临界区可以看作大夫的诊室），当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列里等待（相当于患者分诊等待）。这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。 在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。如上图所示，当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。 线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。 上面我们一直强调 wait()、notify()、notifyAll() 方法操作的等待队列是互斥锁的等待队列，所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait()、this.notify()、this.notifyAll()；如果 synchronized 锁定的是 target，那么对应的一定是 target.wait()、target.notify()、target.notifyAll() 。而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException 代码实现12345678910111213141516171819202122232425class Allocator &#123; private List&lt;Object&gt; als; // 一次性申请所有资源 synchronized void apply( Object from, Object to)&#123; // 经典写法 // 不满足则等待(释放锁并阻塞自己) while(als.contains(from) || als.contains(to))&#123; try&#123; wait(); &#125;catch(Exception e)&#123; &#125; &#125; als.add(from); als.add(to); &#125; // 归还资源 synchronized void free( Object from, Object to)&#123; als.remove(from); als.remove(to); notifyAll(); &#125;&#125; 尽量使用notifyAll notify会随机通知等待队列中的某一个线程，而notifyAll会通知等待队列中的所有线程。 所以使用notify的风险就是有些线程可能永远不会被唤醒，所以除非经过深思熟虑，不然尽量避免使用notify。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——如何解决死锁]]></title>
    <url>%2F2019%2F08%2F08%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[现实世界 前面我们使用Account.class来作为转账的锁，即当发生一个转账操作的时候，所有的用户操作都会被阻塞，这效率简直太低下。 现实世界里，账户转账操作是支持并发的，而且绝对是真正的并行，银行所有的窗口都可以做转账操作。只要我们能仿照现实世界做转账操作，串行的问题就解决了。 我们试想在古代，没有信息化，账户的存在形式真的就是一个账本，而且每个账户都有一个账本，这些账本都统一存放在文件架上。银行柜员在给我们做转账时，要去文件架上把转出账本和转入账本都拿到手，然后做转账。这个柜员在拿账本的时候可能遇到以下三种情况： 文件架上恰好有转出账本和转入账本，那就同时拿走； 如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来； 转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。 而编程世界解决这个问题就是使用两把锁去控制两个转账账户。 12345678910111213141516class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; // 锁定转出账户 synchronized(this) &#123; // 锁定转入账户 synchronized(target) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125;&#125; 这个时候仿佛问题已经解决了，但是随之而来又是一个新的问题。 死锁的产生 试想一下，如果这个时候A账户要转账给B账户，B账户要转账给A账户，然后A转账给B的时候申请到了A的锁，同时B转账给A的时候申请到了B的锁，这个时候线程1申请B的锁不成功(因为B的锁被线程2给拿走了)，线程2申请A的锁不成功(因为A的锁被线程1给拿走了)，这个时候两个线程就会因为获得不到锁而发生阻塞(Java中只要synchronized不成功，线程便会进入阻塞状态)，两个线程互相等待锁，却都不释放锁，那么这个时候就产生了死锁。 如何预防死锁 首先，当死锁产生的时候一般只有杀死进程或者结束应用来解决，所以解决死锁的代价是很大的。对于死锁，最好的办法就是规避死锁。 coffman于1971年提出了死锁产生的四个必要条件 互斥条件：一个资源一次只能有一个线程(或进程)占用 部分分配条件(占有且等待)：即一个线程(或进程)不能一次性获得所有需要的资源 不可抢占条件：一个资源只能由它占有的线程(或进程)来释放，不能通被其他线程(或进程)抢占使用。 循环等待条件：每个线程(或进程)占有若干资源，并且又在等待下一个线程(或进程)所拥有的资源。 反过来讲，我们只需要破坏一个条件就可以避免死锁的产生。对于第一个互斥条件来说，我们无法破坏，因为我们就是需要使用锁的互斥条件来达到并发的目的。剩下三个我们都能破话。 部分分配条件(占有且等待)：我们只需要同时将资源一次性分配给线程 不可抢占条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。 循环等待条件：按序申请资源，即 使资源是有线性顺序的。 破坏部分分配条件(占有且等待) 一次性申请所有资源，对于转账来说，因为涉及到两个资源，所以我们需要一次性申请两个资源AccountA和AccountB，在现实生活中我们可以通过一个账本管理员来负责一个业务员只能同时获取到转账双发的账本，要么都获取不到。 编程中我们也可以定义一个管理员，并且对资源的回收和发放都要是原子操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Allocator &#123; private List&lt;Object&gt; als = new ArrayList&lt;&gt;(); // 一次性申请所有资源 synchronized boolean apply( Object from, Object to)&#123; if(als.contains(from) || als.contains(to))&#123; return false; &#125; else &#123; als.add(from); als.add(to); &#125; return true; &#125; // 归还资源 synchronized void free( Object from, Object to)&#123; als.remove(from); als.remove(to); &#125;&#125;class Account &#123; // actr 应该为单例 private Allocator actr; private int balance; // 转账 void transfer(Account target, int amt)&#123; // 一次性申请转出账户和转入账户，直到成功 while(!actr.apply(this, target)) ； try&#123; // 锁定转出账户 synchronized(this)&#123; // 锁定转入账户 synchronized(target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; finally &#123; actr.free(this, target) &#125; &#125;&#125; 破坏不可抢占条件 破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。 你可能会质疑，“Java 作为排行榜第一的语言，这都解决不了？”你的怀疑很有道理，Java 在语言层次确实没有解决这个问题，不过在 SDK 层面还是解决了的，java.util.concurrent 这个包下面提供的 Lock 是可以轻松解决这个问题的。 破坏循环等待条件 破坏这个条件需要对资源进行排序，这样申请资源申请锁的时候就不会出现循环等待了。 这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。 1234567891011121314151617181920212223class Account &#123; private int id; private int balance; // 转账 void transfer(Account target, int amt)&#123; Account left = this ① Account right = target; ② if (this.id &gt; target.id) &#123; ③ left = target; ④ right = this; ⑤ &#125; ⑥ // 锁定序号小的账户 synchronized(left)&#123; // 锁定序号大的账户 synchronized(right)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125;&#125; 总结 当我们使用细粒度锁来解决问题的时候，需要注意死锁问题。 预防死锁有三个解决方案，在上述中我们使用了两种方式避免死锁，但是显然破坏循环等待条件的做法明显优于破坏部分分配条件，所以在选用避免死锁的方法的时候还要仔细斟酌]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——互斥锁]]></title>
    <url>%2F2019%2F08%2F08%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81%2F</url>
    <content type="text"><![CDATA[如何解决原子性问题 原子性问题的源头就是线程切换，而我们禁用线程切换就能解决，而操作系统进行线程切换是依赖于CPU中断的，所以我们禁用CPU中断就能禁用线程切换。 在早期单核CPU的情况下，统一时刻只有一个线程执行(多线程是利用时间片切换)，所以禁用了线程切换就导致了获得CPU使用权的线程可以不间断的执行，就比如说在32位机器上写入一个long变量分为写入高32位和低32位，那么如果禁用CPU中断，该线程就不会被打断，所以这时候写入高32和低32这两个操作就具有原子性，即要么不被执行要么都被执行。 但是对于现代多核CPU，这时候就有多个线程同一时刻在不同cpu上执行，这个时候如果禁用CPU中断是不能禁止同一时刻只有一个线程执行的。它只能保证这时的执行线程不会被切换，如果这时候同时有两个变量要写入long型变量，由于多线程竞争的问题，在线程A写入高32位的时候线程B也写入高32位，然后线程B写入低32位之后线程A写入低32位，这时候就会出现写入数值出现异常值的bug。 同一时刻只有一个线程执行这个概念非常重要，我们称之为互斥。如果我们对于某一共享变量的操作都是互斥的，无论是单核还是多核CPU都能实现原子性。 简易锁模型 而解决原子性的问题最重要的解决办法就是锁。比如线程A要执行临界区的一段代码，必须先进行加锁，枷锁完成后进入临界区并执行，当线程B要进入的时候由于获得不到锁，那么线程B得不到执行。当线程A执行完成后便释放锁，之后线程B就可以获得锁并且进入临界区执行了。 但是我们常常忽略的两个问题——我们的锁是什么？我们保护的资源又是什么？ 改进后的锁模型 改进后的锁模型则对资源和锁进行了定义，就像现实生活中，自家门对应着自家门的锁，别人家的对应别人的锁。 Java语言提供的锁技术——synchronized Java语言提供的锁技术就是synchronized关键字，它可以应用于方法中也可以是代码块中。 1234567891011121314151617class X &#123; // 修饰非静态方法 synchronized void foo() &#123; // 临界区 &#125; // 修饰静态方法 synchronized static void bar() &#123; // 临界区 &#125; // 修饰代码块 Object obj = new Object()； void baz() &#123; synchronized(obj) &#123; // 临界区 &#125; &#125;&#125; 其中锁的实现是Java编译器帮我们自动实现的，而synchronized并没有指定锁到底是什么，其实这里java是有默认规则的。 具体的默认规则如下： 当synchronized修饰的是静态方法的时候，默认锁住的是当前类的class 123456class X &#123; // 修饰静态方法 synchronized(X.class) static void bar() &#123; // 临界区 &#125;&#125; 当修饰的是非静态方法的时候默认锁着的是当前对象即this 123456class X &#123; // 修饰非静态方法 synchronized(this) void foo() &#123; // 临界区 &#125;&#125; 用synchronized来解决count+=1的问题 SafeCalc 这个类有两个方法：一个是 get() 方法，用来获得 value 的值；另一个是 addOne() 方法，用来给 value 加 1，并且 addOne() 方法我们用 synchronized 修饰。那么我们使用的这两个方法有没有并发问题呢？ 123456789class SafeCalc &#123; long value = 0L; long get() &#123; return value; &#125; synchronized void addOne() &#123; value += 1; &#125;&#125; 由于synchronized的存在，假使有1000个线程去执行addOne方法，因为同一时刻只能有一个线程去执行，所以最后的value肯定是1000。 但是对于get方法就不是了，如果有线程去执行get方法，因为上述代码有了管程中锁机制的happens-before规则(前一个线程加锁后进入临界区对共享资源的修改对于后一个线程解锁后进入是可见的)，这个时候get方法就不是可见的了。所以这时候将get方法也synchronized一下就可以了，因为前面对addOne的操作对于get就可见了。 锁和受保护资源的关系 受保护资源和锁之间的关联关系是 N:1 的关系，如果我们将上述代码改一下。把 value 改成静态变量，把 addOne() 方法改成静态方法，此时 get() 方法和 addOne() 方法是否存在并发问题呢？ 123456789class SafeCalc &#123; static long value = 0L; synchronized long get() &#123; return value; &#125; synchronized static void addOne() &#123; value += 1; &#125;&#125; 这个时候是通过不同的锁来保护不同的资源，那么get方法就会像刚刚那样出现并发问题了。 锁不能是可变对象12345678910111213class SafeCalc &#123; long value = 0L; long get() &#123; synchronized (new Object()) &#123; return value; &#125; &#125; void addOne() &#123; synchronized (new Object()) &#123; value += 1; &#125; &#125;&#125; 如果将锁变为这样，是不允许的，因为锁应该是不可变的。 保护没有关联关系的多个资源 被保护资源和锁应该是N：1的关系，那么保护没有关联关系的多个资源呢？ 12345678910111213141516171819202122232425262728293031323334353637383940class Account &#123; // 锁：保护账户余额 private final Object balLock = new Object(); // 账户余额 private Integer balance; // 锁：保护账户密码 private final Object pwLock = new Object(); // 账户密码 private String password; // 取款 void withdraw(Integer amt) &#123; synchronized(balLock) &#123; if (this.balance &gt; amt)&#123; this.balance -= amt; &#125; &#125; &#125; // 查看余额 Integer getBalance() &#123; synchronized(balLock) &#123; return balance; &#125; &#125; // 更改密码 void updatePassword(String pw)&#123; synchronized(pwLock) &#123; this.password = pw; &#125; &#125; // 查看密码 String getPassword() &#123; synchronized(pwLock) &#123; return password; &#125; &#125;&#125; 很简单，使用不同的锁去保护没有关联关系的不同资源就行了，这里使用两个锁pwlock和ballock来保护密码和余额。 当然，我们也可以用一把互斥锁来保护多个资源，例如我们可以用 this 这一把锁来管理账户类里所有的资源：账户余额和用户密码。具体实现很简单，示例程序中所有的方法都增加同步关键字 synchronized 就可以了。 但是用一把锁有个问题，就是性能太差，会导致取款、查看余额、修改密码、查看密码这四个操作都是串行的。而我们用两把锁，取款和修改密码是可以并行的。用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁。 保护有关联关系的多个资源 如果多个资源是有关联的，比如转账，将A账户的钱转到B账户中，这两个账户的余额就是相关联的。 1234567891011class Account &#123; private int balance; // 转账 void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125;&#125; 如果通过synchronized关键字，你会发现你锁住的仅仅是当前账户的余额，而target的余额就不能保证原子性。比如你同时进行target账户的收款和打钱的操作，那么target就会出现并发问题。 假设有 A、B、C 三个账户，余额都是 200 元，我们用两个线程分别执行两个转账操作：账户 A 转给账户 B 100 元，账户 B 转给账户 C 100 元，最后我们期望的结果应该是账户 A 的余额是 100 元，账户 B 的余额是 200 元， 账户 C 的余额是 300 元。 我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗？我们期望是，但实际上并不是。因为线程 1 锁定的是账户 A 的实例（A.this），而线程 2 锁定的是账户 B 的实例（B.this），所以这两个线程可以同时进入临界区 transfer()。同时进入临界区的结果是什么呢？线程 1 和线程 2 都会读到账户 B 的余额为 200，导致最终账户 B 的余额可能是 300（线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖），可能是 100（线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖），就是不可能是 200。 这时候我们就可以通过增大锁的细粒度来保护资源，我们可以将Account.class作为锁对象，这时候就可以解决并发问题。 问题是解决了，但是使用class作为锁的意思就是当一个账户执行操作的时候，其他账户都不能使用，这样可是会严重影响性能的。 原子性 “原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以解决原子性问题，是要保证中间状态对外不可见。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——Java如何解决可见性和有序性问题]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[什么是Java内存模型 导致可见性的原因是缓存，导致有序性的原因是编译优化，那么解决可见性和有序性的最直接的方法就是禁用缓存和编译优化，但是如果禁用那么就会导致程序的性能下降。 所以合理的方案就是按需禁用缓存和编译优化，而何时禁用这件事情是程序员决定的，这时候就应该请出主角Java内存模型了。 Java内存模型是一个很复杂的概念，站在程序员的角度来看，Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括volatile，synchronized和final三个关键字以及六项Happens-Before规则。 使用volatile的困惑 volatile关键字并不是Java语言的特产，C语言也有，它最原始的意义就是禁用CPU缓存。 例如我们声明一个volatile变量 1volatile int x = 0; 它表达的是：告诉编译器，对这个变量的读写，不能使用CPU缓存，必须从内存中读取或者写入。 例如以下代码,在1.5版本之前打印结果可能为0(因为CPU缓存的原因，线程2读取的是自身缓存的值)，在JDK1.5之后肯定为40，因为在1.5版本之后JDK做了volatile的语意增强，这个增强其实就是一项Happens-Before规则。 1234567891011121314151617181920212223242526272829303132333435363738public class Test &#123; int x = 0; volatile boolean v = false; public void write() &#123; x = 40; v = true; &#125; public void read() &#123; if (v == true) &#123; System.out.println(x); &#125; else &#123; System.out.println("Noxxxxxxxxxxxxxxxxxxx"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test test = new Test(); Thread thread1 = new Thread(() -&gt; &#123; test.write(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; test.read(); &#125;); thread1.start(); thread2.start(); thread1.join(); thread2.join(); &#125;&#125; Happens-Before规则 Happens-Before规则并不是先于发生的意思，而具体意思是指前一个操作的结果对于后一个操作时可见的。 程序的顺序性规则 在一个线程中，前面的操作Happens-Before后面的操作。 volatile变量规则 一个对于volatile变量的写操作Happens-Before于后续对这个变量的读操作。 传递性 如果 A Happens-Before B 且 B Happens-Before C 那么 A Happens-Before C 这条规则和volatile变量规则结合起来看前面的代码，其实就是上面代码示例的结果原理，在线程A中x=40的操作happens-before对于volatile变量v的写操作，然后线程A中对于volatile变量v的写操作happens-before于对线程B的对volatile变量v的读操作，所以x = 40happens-before线程B中的对于volatile变量v的读操作，也就是说x = 40对于线程B的那个操作是可见的，而JDK1.5之后就是通过这个原则来增强volatile语意的。 管程中的锁规则 管程是一种通用的同步原语。在Java中指的就是synchronized，synchronized就是java对管程的一种实现。 管程中的锁是java隐式帮我们实现的，在进入同步块代码的时候Java会帮我们上锁，执行完成会帮我们释放锁，这个是由编译器帮我们实现的，为的是防止程序员忘记释放锁。 123456789// 进入同步代码块加锁synchronized(this) &#123; if(this.x == 40) &#123; this.x = 0; &#125; else &#123; x = 0; &#125;&#125;// 执行完成释放锁 线程的start()规则 主线程启动子线程B，子线程能看到主线程在启动子线程B之前的操作。换言之就是线程A中调用的线程B的start方法happens-before线程B中的任意操作。 123456789Thread B = new Thread(()-&gt;&#123; // 主线程调用 B.start() 之前 // 所有对共享变量的修改，此处皆可见 // 此例中，var==77&#125;);// 此处对共享变量 var 修改var = 77;// 主线程启动子线程B.start(); 线程join规则 主线程等待子线程完成，当子线程完成后，主线程能看到子线程的操作。其实就是，在主线程A中调用了子线程B的join方法，这时候子线程B的任意操作happens-before主线程调用线程B的join方法 123456789101112Thread B = new Thread(()-&gt;&#123; // 此处对共享变量 var 修改 var = 66;&#125;);// 例如此处对共享变量修改，// 则这个修改结果对线程 B 可见// 主线程启动子线程B.start();B.join()// 子线程所有对共享变量的修改// 在主线程调用 B.join() 之后皆可见// 此例中，var==66 线程中断规则 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则 一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。 final final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化 总结 为什么定义Java内存模型？ 现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。 三个基本原则 原子性、可见性、有序性。 Java内存模型涉及的几个关键词 锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习——可见性,原子性,有序性问题]]></title>
    <url>%2F2019%2F08%2F06%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[并发程序幕后的故事 此系列文章为极客时间java并发编程课程的学习笔记。 计算机中由于CPU，内存，I/O设备三者硬件速度之间的差异，而面对三者的差异，计算机体系结构，操作系统，编译程序都为之做出了自己的贡献。 比如CPU增加了缓存机制，操作系统增加了进程，线程，分时复用CPU的理念，编译程序则会优化指令顺序。 而这些，其实就是并发程序bug的根源所在。 根源一：缓存导致的可见性问题 在早期的PC中，一般使用的是单核的CPU，CPU缓存与内存的数据一致性问题很好解决。因为不同线程都是对同一个cpu缓存进行操作，一个线程对于cpu缓存的数据更改另一个线程肯定是可见的，所以如果线程A更改了缓存中的V值，对于线程B再取出V的值就是线程A已经更改的值。 但是现如今多核时代，每个CPU都有自己的缓存，这时候缓存的可见性问题并没有那么简单了。 如下面的代码 123456789101112131415161718192021222324252627282930313233343536373839public class Test &#123; private static long count = 0; private void add10k() &#123; int idx = 0; while (idx++ &lt; 100000) &#123; count += 1; &#125; &#125; public static long calc() throws InterruptedException &#123; final Test test = new Test(); Thread thread1 = new Thread(() -&gt; &#123; test.add10k(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; test.add10k(); &#125;); thread1.start(); thread2.start(); thread1.join(); thread2.join(); return count; &#125; public static void main(String[] args) &#123; try &#123; System.out.println(Test.calc()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面代码表示创建两个线程，这两个线程同时为count做100000次自增，如果按照常理得到的结果应该是200000，但是其实输出的是100000到200000之间的数字。其原因在于在线程A和线程B执行的过程中，两个线程会将count都放入自己的寄存器中然后进行+操作，但是对于放回内存中这样的操作就会出现重叠，例如线程A计算出count为1了放入内存，线程B计算出count为1了放入内存，此时count就会为1而不是我们真正想看到的2。 根源二：线程切换带来的原子性问题 因为CPU执行速度是非常快的，所以在早期的PC时代中人们就发明了多进程的理念，即CPU通过切换时间片来使多个进程看似在同时执行。 在一个时间片内，如果一个进程进行一个IO操作，例如读文件，这个时候该进程可以把自己标记为“休眠状态”并让出CPU的使用权，待文件读入内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得CPU的使用权了。 这里的进程在等待IO时会释放CPU使用权，是为了提高CPU使用率。此外，如果这时有另外一个进程读文件，那么读文件的操作就会排队，磁盘驱动在完成一个进程的读操作之后，会立即进行下一个操作，这样IO的使用率也提升了。而这个就是多进程分时复用，这个操作在操作系统中具有里程碑的意义，Unix就是因为解决这个问题而名噪天下的。 早期的操作系统基于进程来调度CPU，不同进程间是不共享内存空间的，所以要做进程任务切换就要切换内存映射地址，而一个进程创建的所有线程中，他们都是共享内存空间的，所以线程做任务切换的成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。 Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。 将count从内存中取出放入寄存器 在寄存器中进行加操作 从寄存器中取出放入内存中（缓存机制导致可能写入的是 CPU 缓存而不是内存）。 操作系统做任务切换，可以发生在任何一条CPU 指令执行完，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。 如果我们将这条语句作为原子操作那是可以的，而对于线程切换，它的基本单位是cpu指令而不是语句，我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。 源头三：编译优化带来的有序性问题 Java的编译优化是很智能的，为了提高程序的性能，编译器有时候会更改语句执行顺序，按照常理有些语句的顺序变更是不会影响结果的，但是在多线程的情境下就变得复杂起来了。 例如在单例模式的双重检查中 123456789101112public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 假如现有两个线程A，B同时进入getInstance方法他们同时判断instance是否为空，此时为空两个线程同时进入语句，由于synchronized的存在，JVM只会让一个线程进入并且上锁。假设此时A进入B等待锁，那么A获得锁判断instance是否为空，为空则创建对象，然后A释放锁，此时B获得锁并进入语句判断instance不为空跳出语句并return不为空的instance。一切看起来完美，但是我们一直以为的new操作是这样的。 在内存中开辟一个地址空间M 在地址空间M中初始化Singleton对象 将地址赋值给instance变量 但经过了编译优化它是这样的 在内存中开辟一个地址空间M 将地址赋值给instance变量 在地址空间初始化Singleton对象 试想一下，如果在执行2指令的时候进行了线程切换，线程B会判断instance是否为空，此时不为空那么直接返回，但是在返回instance的地址空间并没有Singleton对象，所以之后如果调用instance的变量，方法就会产生空指针异常。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——解释器模式]]></title>
    <url>%2F2019%2F08%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是解释器模式 原文链接解释器模式 解释器模式的定义是一种按照规定语法进行解析的方案，在现在项目中使用的比较少，其定义如下： Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language. 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表达式来解释语言中的句子。 解释器角色： AbstractExpression抽象解释器：具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和NonterminalExpression TerminalExpression终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结表达式，但有多个实例，对应不同的终结符。 NonterminalExpression非终结符表达式：文法中的每条规则对应于一个非终结表达式，非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式 Context环境角色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//抽象表达式/*抽象表达式是生产语法集合(也叫语法树)的关键，每个语法集合完成指定语法解析任务，它是通过递归调用的方式，最终由最小的语法单元进行解析完成*/public abstract class Expression&#123; //每个表达式必须有一个解析任务 public abstract Object interpreter(Context context);&#125;//终结符表达式 主要是处理场景元素和数据的转换 如：a+b+c中的"a""b""c"public class TerminalExpression extends Expression&#123; //通常终结符表达式只有一个，但是有多个对象 public Object interpreter(Context context)&#123; return null; &#125;&#125;//非终结符表达式/* 每个非终结符表达式都代表一个文法规则，并且每个文法规则都只关心自己周边的文法规则结果(注意是结果),因此 这就产生了每个终结符表达式调用自己周边的非终结符表达式，然后最终，最小的文法规则就是终结符表达式，终 结符表达式的概念就是如此，不能在参与比自己更小的文法运算了*/public class NonterminalExpression extends Expression&#123; //每个非终结符表达式都会对其他表达式产生依赖 public NonterminalExpression(Expression... expression)&#123; &#125; public Object interpreter(Context context)&#123; //进行文法处理 return null; &#125;&#125;//场景类public class Client&#123; public static void main(String[] args)&#123; Context context=new Context(); //通常一个语法容器，容纳一个具体的表达式，通常为ListArray，LinkedList，Stack等类型 Stack&lt;Expression&gt; stack=null; for(;;)&#123; //进行语法判断，并产生递归调用 &#125; //产生一个完整的语法树，由各个具体的语法分析进行解析 Expression expression=stack.pop(); //具体元素进入场景 expression.interpreter(context); &#125;&#125; 解释器的优缺点 优点: 解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了 缺点: 解释器模式会引发类膨胀：每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。 解释器模式采用递归调用方法：每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层的剥茧，无论是面向过程的语言还是面向对象的语言，递归都是在必要条件下是使用的，它导致调试非常复杂 效率问题：解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题 解释器模式应用场景 重复发生的问题可以使用解释器模式 一个简单语法需要解释的场景 注意事项 尽量不要再重要的模块中使用解释器模式，否则维护会一个很大的问题。在项目中可以使用shell，jRuby，Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。 常用的解释器模式工具包：Expression4J,MESP(Math Expression String parser),Jep等开源的解析工具包]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——中介者模式]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是中介者模式 中介者模式是一种行为模式，其中最重要的角色就是中介者了，中介者的作用就是封装一系列对象的交互逻辑。比如在一个智能家居系统中有许多设备比如TV，屏幕，摄像头，报警器等等的启动，一般来说系统的启动需要这些设备的相互协调交互，如果这些全部暴露给Client，那么整体逻辑就会变得非常的复杂，先如今通过中介者来包装系统中的一些列对象的交互逻辑。 中介者模式UML图 Mediator是中介者，它用来封装一系列的Colleague对象之间的相互调用。即它需要知道所有的具体的同事类，即以一个集合来管理并接受某个同事对象消息，完成相应的任务。 具体的同事类会有很多，每个同事只知道自己的行为，而不了解其他同事对象的行为，但是他们都依赖中介者对象。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public abstract class Colleague &#123; // 每个同事类中都含有对应的中介者 private Mediator mediator; // 同事对象的名字 public String name; // 构造的时候讲中介者和名字传入初始化 public Colleague(Mediator mediator, String name) &#123; this.mediator = mediator; this.name = name; &#125; // 获取中介者，因为它需要向中介者发送消息 public Mediator GetMediator() &#123; return this.mediator; &#125; // 发送消息 public abstract void SendMessage(int stateChange);&#125;public class Alarm extends Colleague &#123; public Alarm(Mediator mediator, String name) &#123; super(mediator, name); mediator.Register(name, this); &#125; public void SendAlarm(int stateChange) &#123; SendMessage(stateChange); &#125; @Override public void SendMessage(int stateChange) &#123; this.GetMediator().GetMessage(stateChange, this.name); &#125;&#125;public class Curtains extends Colleague &#123; public Curtains(Mediator mediator, String name) &#123; super(mediator, name); mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; this.GetMediator().GetMessage(stateChange, this.name); &#125; public void UpCurtains() &#123; System.out.println("I am holding Up Curtains!"); &#125;&#125;public class CoffeeMachine extends Colleague &#123; public CoffeeMachine(Mediator mediator, String name&#123; super(mediator, name); mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; this.GetMediator().GetMessage(stateChange, this.name); &#125; public void StartCoffee() &#123; System.out.println("It's time to startcoffee!"); &#125; public void FinishCoffee() &#123; System.out.println("After 5 minutes!");System.out.println("Coffee is ok!"); SendMessage(0); &#125;&#125;public class TV extends Colleague &#123; public TV(Mediator mediator, String name) &#123; super(mediator, name); mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; this.GetMediator().GetMessage(stateChange, this.name); &#125; public void StartTv() &#123; System.out.println("It's time to StartTv!"); &#125; public void StopTv() &#123; System.out.println("StopTv!"); &#125;&#125;public abstract class Mediator &#123; // 将同事注册到中介者对象中 public abstract void Register(String colleagueName, Colleague colleague); // 获取同事发送的消息 public abstract void GetMessage(int stateChange, String colleagueName); // 发送消息 public abstract void SendMessage();&#125;public class ConcreteMediator extends Mediator &#123; private HashMap&lt;String, Colleague&gt; colleagueMap; private HashMap&lt;String, String&gt; interMap; public ConcreteMediator() &#123; colleagueMap = new HashMap&lt;String, Colleague&gt;(); interMap = new HashMap&lt;String, String&gt;(); &#125; @Override public void Register(String colleagueName, Colleague colleague) &#123; colleagueMap.put(colleagueName, colleague); if (colleague instanceof Alarm) &#123; interMap.put("Alarm", colleagueName); &#125; else if (colleague instanceof CoffeeMachine) &#123; interMap.put("CoffeeMachine", colleagueName); &#125; else if (colleague instanceof TV) &#123; interMap.put("TV", colleagueName); &#125; else if (colleague instanceof Curtains) &#123; interMap.put("Curtains", colleagueName); &#125; &#125; // 中介者协调各个同事之间的工作 @Override public void GetMessage(int stateChange, String colleagueName) &#123; // 如果我接受到的是Alarm那么。。。 if (colleagueMap.get(colleagueName) instanceof Alarm) &#123; if (stateChange == 0) &#123; ((CoffeeMachine) (colleagueMap.get(interMap.get("CoffeeMachine")))).StartCoffee(); ((TV) (colleagueMap.get(interMap.get("TV")))).StartTv(); &#125; else if (stateChange == 1) &#123; ((TV) (colleagueMap.get(interMap.get("TV")))).StopTv(); &#125; // 如果是咖啡，那么、、、 &#125; else if (colleagueMap.get(colleagueName) instanceof CoffeeMachine) &#123; ((Curtains) (colleagueMap.get(interMap.get("Curtains")))) .UpCurtains(); &#125; else if (colleagueMap.get(colleagueName) instanceof TV) &#123; &#125; else if (colleagueMap.get(colleagueName) instanceof Curtains) &#123; &#125; &#125; @Override public void SendMessage() &#123;&#125;&#125;public class ClientTest &#123; public static void main(String[] args) &#123; Mediator mediator = new ConcreteMediator(); Alarm alarm = new Alarm(mediator, "alarm"); CoffeeMachine coffeeMachine = new CoffeeMachi (mediator,"coffeeMachine"); Curtains curtains = new Curtains(mediator, "curtains"); TV tV = new TV(mediator, "TV"); alarm.SendAlarm(0); coffeeMachine.FinishCoffee(); alarm.SendAlarm(1); &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——状态模式]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是状态模式 一个事物在发展过程中都会产生不同的状态，比如人在成长过程中会有小孩，成人，老人等状态。但是这个状态是依赖聚合于对象本身的，因为状态是随着对象的行为而发生变化的，状态本身就是对象的一部分。 UML图 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223public class RaffleActivity &#123; private State state; private int count; private State canRaffleState = new CanRaffleState(this); private State noRaffleState = new NoRaffleState(this); private State dispenseState = new DispenseState(this); private State dispenseOutState = new DispenseOutState(this); public RaffleActivity(int count) &#123; this.state = this.noRaffleState; this.count = count; &#125; public void deduceMoney() &#123; state.deduceMoney(); &#125; public void raffle() &#123; if (state.raffle()) &#123; state.dispensePrize(); &#125; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public State getCanRaffleState() &#123; return canRaffleState; &#125; public void setCanRaffleState(State canRaffleState) &#123; this.canRaffleState = canRaffleState; &#125; public State getNoRaffleState() &#123; return noRaffleState; &#125; public void setNoRaffleState(State noRaffleState) &#123; this.noRaffleState = noRaffleState; &#125; public State getDispenseState() &#123; return dispenseState; &#125; public void setDispenseState(State dispenseState) &#123; this.dispenseState = dispenseState; &#125; public State getDispenseOutState() &#123; return dispenseOutState; &#125; public void setDispenseOutState(State dispenseOutState) &#123; this.dispenseOutState = dispenseOutState; &#125;&#125;public interface State &#123; void deduceMoney(); boolean raffle(); void dispensePrize();&#125;public class NoRaffleState implements State&#123; private RaffleActivity raffleActivity; public NoRaffleState(RaffleActivity raffleActivity) &#123; this.raffleActivity = raffleActivity; &#125; @Override public void deduceMoney() &#123; System.out.println("扣除50元余额，您可以开始抽奖了。"); raffleActivity.setState(raffleActivity.getCanRaffleState()); &#125; @Override public boolean raffle() &#123; System.out.println("当前不可以抽奖。"); return false; &#125; @Override public void dispensePrize() &#123; System.out.println("不能发放奖品。"); &#125;&#125;public class CanRaffleState implements State &#123; private RaffleActivity raffleActivity; public CanRaffleState(RaffleActivity raffleActivity) &#123; this.raffleActivity = raffleActivity; &#125; @Override public void deduceMoney() &#123; System.out.println("您已抽中奖品。"); &#125; @Override public boolean raffle() &#123; if (raffleActivity.getCount() &lt; 0) &#123; System.out.println("抽奖活动已结束！请下次再来！"); System.exit(0); &#125; Random random = new Random(); int num = random.nextInt(10); if (num == 0) &#123; System.out.println("恭喜您！中奖了！"); raffleActivity.setCount(raffleActivity.getCount() - 1); raffleActivity.setState(raffleActivity.getDispenseState()); return true; &#125; else &#123; System.out.println("很遗憾！未中奖！"); raffleActivity.setState(raffleActivity.getNoRaffleState()); return false; &#125; &#125; @Override public void dispensePrize() &#123; System.out.println("请先抽奖！"); &#125;&#125;public class DispenseState implements State &#123; private RaffleActivity raffleActivity; public DispenseState(RaffleActivity raffleActivity) &#123; this.raffleActivity = raffleActivity; &#125; @Override public void deduceMoney() &#123; System.out.println("您已抽中奖品！"); &#125; @Override public boolean raffle() &#123; System.out.println("您已抽中奖品！"); return false; &#125; @Override public void dispensePrize() &#123; System.out.println("正在发送奖品！请稍等！"); raffleActivity.setState(raffleActivity.getDispenseOutState()); &#125;&#125;public class DispenseOutState implements State &#123; private RaffleActivity raffleActivity; public DispenseOutState(RaffleActivity raffleActivity) &#123; this.raffleActivity = raffleActivity; &#125; @Override public void deduceMoney() &#123; System.out.println("您已抽中奖品"); &#125; @Override public boolean raffle() &#123; System.out.println("您已抽中奖品"); return false; &#125; @Override public void dispensePrize() &#123; System.out.println("奖品已发送完毕！"); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; RaffleActivity raffleActivity = new RaffleActivity(3); for (int i = 0; i &lt; 15; i++) &#123; System.out.println("这是第" + i + "次抽奖"); raffleActivity.deduceMoney(); raffleActivity.raffle(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——备忘录模式]]></title>
    <url>%2F2019%2F08%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是备忘录模式 备忘录是指在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象外部保存状态。而状态保存的地方就是备忘录对象，并且再创建一个备忘录的管理类来管理一系列的状态，在用户操作的时候，用户不与备忘录直接耦合而与备忘录的管理类相耦合。相应的我们就可以做一些操作比如回滚，撤销等。 备忘录的UML图 originator是指需要保存状态的对象，Memento是聚合了状态的备忘录对象，CareTaker是存储了备忘录对象集合的备忘录管理类。 在originator中需要有一个方法是将状态保存到备忘录对象中，并且在备忘录管理类中需要有备忘录对象的增加删除方法。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Originator &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Memento saveToMemento() &#123; return new Memento(this.state); &#125; public void getStateFromMemento(Memento memento) &#123; this.state = memento.getState(); &#125; public void display() &#123; System.out.println("当前状态为:" + this.state); &#125;&#125;public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125;&#125;public class CareTaker &#123; private List&lt;Memento&gt; mementoList = new ArrayList&lt;&gt;(); public void addMemento(Memento memento) &#123; mementoList.add(memento); &#125; public Memento getMemento(int index) &#123; return mementoList.get(index); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState("状态1"); careTaker.addMemento(originator.saveToMemento()); originator.display(); originator.setState("状态2"); careTaker.addMemento(originator.saveToMemento()); originator.display(); originator.setState(careTaker.getMemento(0).getState()); originator.display(); &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——Command模式]]></title>
    <url>%2F2019%2F08%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Command%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是Command模式 所谓命令模式，必然存在三个角色——命令发起者、命令、命令接收者。即命令这个角色使发起者和接收者实现了解耦。试想一下，如果没有中间层命令，那么命令发起者必须聚合接收者，如果有了命令，那么发起者和接受者则通过命令来实现联系。 Command的UML图 Command是一个接口，其中定义了执行和撤销的方法，而ConcreteCommand是实现了Command的具体命令，这个具体命令是Invoker(发起者)和Receiver(接收者)的“桥梁”。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public interface Command &#123; void execute(); void undo();&#125;// 执行命令的接收者public class CommandReceiver &#123; public void on() &#123; System.out.println("on"); &#125; public void off() &#123; System.out.println("off"); &#125;&#125;// 具体的命令角色 拥有命令接受者 并调用接收者的actionpublic class LightOnCommand implements Command &#123; private CommandReceiver commandReceiver; public LightOnCommand(CommandReceiver commandReceiver) &#123; this.commandReceiver = commandReceiver; &#125; @Override public void execute() &#123; commandReceiver.on(); System.out.println("light on"); &#125; @Override public void undo() &#123; commandReceiver.off(); System.out.println("light off"); &#125;&#125;public class LightOffCommand implements Command&#123; private CommandReceiver commandReceiver; public LightOffCommand(CommandReceiver commandReceiver) &#123; this.commandReceiver = commandReceiver; &#125; @Override public void execute() &#123; commandReceiver.off(); System.out.println("light off"); &#125; @Override public void undo() &#123; commandReceiver.on(); System.out.println("light on"); &#125;&#125;// 空命令 也是一种设计模式 是我们少做空判断 加强逻辑public class NoCommand implements Command &#123; @Override public void execute() &#123; &#125; @Override public void undo() &#123; &#125;&#125;// 命令发起者 聚合的是命令的集合或者单个命令public class RemoteControl &#123; private Command[] onCommands = new Command[5]; private Command[] offCommands = new Command[5]; private Command undoCommand = new NoCommand(); public Command[] getOnCommands() &#123; return onCommands; &#125; public void setOnCommands() &#123; onCommands[0] = new LightOnCommand(new CommandReceiver()); &#125; public Command[] getOffCommands() &#123; return offCommands; &#125; public void setOffCommands() &#123; offCommands[0] = new LightOffCommand(new CommandReceiver()); &#125; public void onButton(int n) &#123; undoCommand = this.onCommands[n]; this.onCommands[n].execute(); &#125; public void offButton(int n) &#123; undoCommand = this.offCommands[n]; this.offCommands[n].execute(); &#125; public void undo() &#123; undoCommand.undo(); &#125;&#125;// 客户端调用public class Client &#123; public static void main(String[] args) &#123; RemoteControl remoteControl = new RemoteControl(); remoteControl.setOnCommands(); remoteControl.setOffCommands(); remoteControl.onButton(0); remoteControl.offButton(0); remoteControl.undo(); &#125;&#125; Command模式的优点和不足 实现命令发起者和接受者之间的解耦，命令发起者不需要知道接受者是谁。 容易设计一个命令队列，并使用多线程去操作。 但是提高了系统的复杂度，可能会导致命令的具体类过多。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——JDK动态代理原理]]></title>
    <url>%2F2019%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是动态代理 动态代理就是在运行时生成动态的代理对象，静态代理是通过接口，封装来实现对特定对象的代理，而动态代理则可以在运行时通过反射或者字节码来动态生成代理对象，而不仅仅只针对于特定对象。 动态代理分为两种: JDK动态代理和Cglib动态代理，前者是通过反射实现，后者是通过字节码实现，这篇博客主要讲解JDK动态代理的基本原理。 我们知道，在静态代理中，我们的代理类需要实现和被代理对象相同的接口并且聚合该代理对象，在实现重写接口方法的时候调用本身聚合的对象的实现方法从而来解决代理问题。 在JDK动态代理中，其实思想和静态代理差不多，最重要的区别只是JDK动态代理通过反射来实现静态代理，是静态模式动态化。 使用例子123456789101112131415161718192021222324252627282930313233343536373839public interface Hello &#123; void sayHello();&#125;public class HelloImpl implements Hello &#123; @Override public void sayHello() &#123; System.out.println("Hello World"); &#125;&#125;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("Invoking sayHello"); Object result = method.invoke(target, args); return result; &#125;&#125;public class MyDynamicProxy &#123; public static void main(String[] args) &#123; HelloImpl hello = new HelloImpl(); MyInvocationHandler handler = new MyInvocationHandler(hello); Hello proxyHello = (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(),hello.getClass().getInterfaces(),handler); proxyHello.sayHello(); &#125;&#125; 源码浅析 我们要阅读源码首先要知道整个流程大概干了什么。 我们先从使用中来猜测，我们实现了自己的InvocationHandler，这个Handler中有一个target字段，这个target指的就是被代理对象(即目标类),在被重写的invoke方法中我们通过method和args来调用target的与之对应的方法，并且在整个invoke方法中我们对它做了一些增加(即代理方法)。 我们还可以发现，我们的HelloImpl被代理类需要实现一个接口，这也是JDK动态代理的要求，毕竟它是通过接口来实现的。 在客户端主方法中我们new了一个HelloImpl对象然后将这个对象传入自己实现的InvocationHandler中，最后通过Proxy类中的newProxyInstance方法来获取代理对象，我们可以发现代理对象也是实现了Hello接口的，这和我们静态代理的实现方法是一样的！ 我们再来看一下newProxyInstance方法中的三个参数。 首先第一个是ClassLoader这个就是指当前加载该类的类加载器，第二个是该类实现的接口，第三个就是handler。 最容易理解的就是handler，因为我们具体代理逻辑是写在handler中的，所以肯定要传。而interfaces是因为整个JDK动态代理需要接口的支持，我们暂且不管，这个需要后面有个整体观念。而第一个类加载器是为什么，具体用来做什么？ 其实JDK动态代理就是通过传入handler和接口来通过反射来编写代理类的.java文件，然后通过编译器进行编译，最后通过类加载器load进内存。这样三个参数的作用就明了了 动态代理做主要的就是那个newProxyInstance我们首先来看一下这个类具体做了什么。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@CallerSensitive public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException&#123; Objects.requireNonNull(h); // 获取克隆的接口集 final Class&lt;?&gt;[] intfs = interfaces.clone(); // 做一些校验 final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; // 生成class // 其中包括获取生成.java 编译 类加载过程 /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; // 校验 if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; // 获取class的构造器，这里params是InvocationHandler，所以在上面的代码会给我们生成，拥有InvocationHandler对象的代理类，并且有相应的构造方法。 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; // 判断权限 如果是private 那么更改为public if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; // 通过构造器new出代理对象 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 我们再来看一下getProxyClass0方法。 12345678910111213141516// 这个方法传入类加载器和接口// 注意这里没有InvocationHandler，其实也可以理解，InvocationHandler只是个接口，对于代理对象的handler字段可以写死为InvacationHandlerprivate static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; // 如果接口数量大于多少 抛出异常 if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // 这里值 先从缓冲中取，如果没有那么从ProxyClassFactory中制造 // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces);&#125; 我们来看一下ProxyClassFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123; // 类的前缀 // prefix for all proxy class names private static final String proxyClassNamePrefix = "$Proxy"; // 唯一的值 // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; // 获取接口class interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; /* * Verify that the Class object actually represents an * interface. */ // 验证是否是接口 if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; // 拼接包名逻辑 String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ // 生成代理类的字节码 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; // 将字节码加载进JVM return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125; 我们来看一下生成的字节码文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1、所有JDK动态代理 都是Proxy的子类 且自己是final类// 2、实现了你所需要代理得接口// 3、代理类整体看起来都是非常简单的 我们发现不管调用哪个方法，最终都是交给了InvocationHandler.invoke()方法 这也就是为什么需要我们提供这个接口的实现类的原因吧public final class $Proxy0 extends Proxy implements Helloworld &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; // 通过反射给Method赋值 这里我们得出结论 // Object的三个方法equals/toString/hashCode最终都是会被代理的 // m3是我们HelloService自己的业务方法 static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m3 = Class.forName("com.proxy.Helloworld").getMethod("sayHello"); m2 = Class.forName("java.lang.Object").getMethod("toString"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125; // 构造函数 // 传入了InvocationHandler public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void sayHello() throws &#123; try &#123; // 调用了handler的invoke方法 // 而具体的代理逻辑都在handler的invoke方法中实现 // handler中持有被代理对象 并且会在他自己的invoke中实现代理逻辑 super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——桥接模式]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[桥接模式简介(Bridge) 桥接模式是指将抽象和实现放入两个不同层次，使它们能任意改变。比如我们设计一个手机的类，其中有翻盖手机，直板手机，触屏手机。。然后每个手机又有不同的牌子，比如vivo，小米，华为。。。试想，如果我们通过面向对象继承来实现的话，我们需要创造n*n个类比如vivo翻盖，vivo直板，小米触屏。。。这样就会产生类爆炸，而且当我们想扩展比如一个旋转手机，那么我们还需要去创造不同品牌的手机先然后再创建xxx旋转手机的类，即当我们需要增加样式的时候，我们需要增加所有品牌的手机，这样就违反了单一职责原则。 而桥接模式基于类的最小设计原则，桥接模式是一种结构型模式，它通过聚合和继承来将两个变化的层次分离开来，从而保持类的可扩展性。 UML 其中Abstraction和RefinedAbstraction就是抽象层，而右边的Implementor就是实现层，在桥接模式中，抽象层就充当桥的部分将客户端和实现相连。在抽象层中聚合了实现，比如说我们可以将手机作为一个抽象Abstraction然后我们去实现不同类型的手机，比如说直板，触屏等，然后这个抽象类中聚合了一个品牌brand的接口,如果需要实现不同品牌类型的手机，只需要去实现brand接口然后将它聚合到抽象层中就行了。 这样，手机就可以这样设计了 这样，桥接模式来代替继承可以有效地减少类的个数，而且易于扩展维护，有助于系统的分层设计，但是桥接模式需要辨别出两个变化的部分——抽象和实现，所以使用范围有一定的局限性。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——享元模式]]></title>
    <url>%2F2019%2F07%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是享元模式 池技术是享元模式运用的一个经典了，享元模式是使用户共享相似对象的一种设计模式，比如在数据库连接池中，里面会放置很多已经创建好的连接对象，如果要使用相似的对象可以直接在池中取，这样就节省了大量对象的创建。所以，享元模式一般运用在系统底层来提高系统性能，像String常量池，数据库连接池，缓冲池中都有使用。 UML 这里最重要的就是FlyWeightFactory，这里面一般会存放一个map用来存储需要共享的元对象，当我们需要创建新对象的时候，会先检查池中是否已经有相似对象，如果有直接从池中取。 外部状态和内部状态 内部状态指的是共享对象的一些不可改变的状态，它们是固定的，比如我们需要共享一些棋子，对于棋子来说，其颜色黑白两色是它的内部状态是共享出去的，而且不会变。而棋子的内部状态来说可以使棋子的位置，这是一直会发生变化的，而且它不是共享出去的，是由使用者决定的。 享元模式在Integer中的应用 在Integer的静态方法valueOf中我们创造一个Integer对象会先从预先定义好的缓冲池中去取。 如果范围是-128~127会直接从缓冲池中取出对象，不然再创建新对象，这样就能减少对象的频繁创建。 我们可以看到缓冲池中会预先给我们存放元对象于数组中(在静态块中执行) 123456789101112131415161718192021222324252627282930313233private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——门面模式]]></title>
    <url>%2F2019%2F07%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是门面模式(Facade) 门面模式也叫外观模式，是一种结构型设计模式。门面模式屏蔽了系统方法调用的复杂性，呈现给客户端的是一个抽象简单的接口，降低了客户端使用系统的复杂度。让客户端和系统之间解耦，还能使我们更好地划分层次结构。而且在我们重新开发新系统，我们可以使用门面模式来复用旧系统中需要调用的一系列方法，并合并成一个接口来呈现给新系统api。 使用场景 例如，我们需要设计一个家庭影院，其中启动家庭影院可能会有那么几步： 启动荧幕 启动投影机 关闭房间等 打开爆米花等等 试想，如果我们提供给用户的是上述四个启动接口，对于用户来说实在是太不友好，所以我们可以设计一个接口包含四个对象然后在接口中实现一键启动，这样对于用户来说就非常方便了]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter——浅析Widget原理]]></title>
    <url>%2F2019%2F07%2F26%2FFlutter%E2%80%94%E2%80%94%E6%B5%85%E6%9E%90Widget%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Widget渲染过程 在进行App开发的时候，我们往往会关注的一个问题是：如何结构化地组织视图数据，提供渲染引擎，最终完成界面显示。 通常情况下，不同UI框架都会以不同方式去处理这一个问题，但无一例外都会用到视图树(View Tree)的概念，而Flutter将视图树的概念进行了扩展，把视图树的组织和渲染抽象为三部分，即Widget，Element和RenderObject。 Widget 很多人理解为Widget为一个组件其实并不是完全正确的，Widget只是一个数据配置信息，它是组件实现的基本逻辑单位，它里面存储了有关视图渲染的配置信息，比如布局，渲染属性，事件相应信息等等。 当视图渲染信息发生变化的时候，Flutter会选择重建Widget树的方式进行数据更新。 但，你可想到的是——当Widget树层次很深的时候，只要视图渲染信息发生变化的时候会涉及到大量的Widget的销毁和重建，这样会对垃圾回收造成一定的压力。但是Widget它只是一个数据配置对象，它是一个轻量级的数据结构，不涉及实际渲染位图，重建的成本很低。 另外，由于Widget的不可变性，可以以较低成本进行渲染节点复用，因此在一个真实的渲染树中可能存在不同的Widget对应同一个渲染节点的情况，这无疑又降低了重建UI的成本。 Element Element是Widget的一个实例化对象，它是配置信息到最终模型数据成型的桥梁。 Flutter渲染过程，可以分为这三步： 首先通过Widget树生成对应的Element树 然后，创建相应的RenderObject并关联到Element.renderObject属性上 最后，构建RenderObject树，来完成最终的渲染 可以看到其实Widget和Element都不负责视图的渲染，最终干活的只是RenderObject。Widget和Element只是负责发号施令，但是既然都是发号施令，为什么不直接通过Widget去控制RenderObject的渲染呢？其实本来三者就可以结合在一起，分为两者是为了数据信息和处理信息的解耦，而分为三者也是为了解耦。 因为Widget具有不可变性，每次改变都需要重建，如果Widget直接关联RenderObject，那么就意味着Widget的重建必然会导致RenderObject的重建，而RenderObject是负责渲染过程的，所以RenderObject的重建会非常影响性能，Element就是为了解决这个问题的，为了解决Widget和RenderObject的耦合问题，Element充当了中间的抽象层，它会和Widget中的数据进行同步，只将需要修改的部分同步到真实的RenderObject树中，最大程度降低对真实渲染视图的修改，提高渲染效率，而不是销毁整个渲染视图树。 这，就是Element存在的意义。 RenderObject RenderObject主要负责实现视图渲染的对象。 渲染对象树在Flutter的展示过程分为四个阶段——布局，绘制，合成和渲染。其中，布局和绘制在RenderObject中完成，Flutter采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把他们绘制到不同图层。绘制完毕后，合成和渲染的工作则交给Skia搞定。 我们可以先了解一下图像的绘制原理，图像绘制需要三大主角——CPU，GPU，显示器 CPU负责图像数据计算，GPU负责图像数据渲染，显示器负责最终图像显示。 整个过程就是CPU将计算好的模型数据交给GPU，GPU完成渲染之后放入帧缓冲区，随后视频控制器根据垂直同步信号(vsync)以每秒60次的速度，从帧缓冲区读取帧数据交给显示器完成图像显示 在图中CPU线程所做的事情其实就是RenderObject需要做的事情，我们上文所说渲染对象树在Flutter的展示过程分为布局，绘制，合成和渲染。其中合成和渲染其实就是上图中的GPU线程合成数据交给Skia然后Skia交个自身图像渲染引擎OpenGL来完成渲染。前面的布局和绘制则是RenderObject完成的。 上文我们可以知道Widget负责存储控件信息如位置，大小，渲染属性，事件回应信息等，其实位置和大小就是布局，而渲染属性和等等其他信息其实就是绘制这一层了，RenderObject通过Element抽象层来连接到Widget中的数据，然后对Widget数的数据创建渲染对象树，然后创建真正的渲染模型对象数据交给GPU线程去完成真正的视图渲染。 RenderObjectWidget 在Flutter中有两个Widget，StatelessWidget和StatefulWidget，这两个Widget都是继承了Widget，但其实它们只是用来组装空间的容器并不负责组件最后的布局和绘制。在Flutter中，布局和绘制实际上是在Widget的另一个子类RenderObjectWidget内完成的。 我们来看一下RenderObjectWidget的源码 12345678910111213141516abstract class RenderObjectWidget extends Widget &#123; const RenderObjectWidget(&#123; Key key &#125;) : super(key: key); @override RenderObjectElement createElement(); @protected RenderObject createRenderObject(BuildContext context); @protected void updateRenderObject(BuildContext context, covariant RenderObject renderObject) &#123; &#125; @protected void didUnmountRenderObject(covariant RenderObject renderObject) &#123; &#125;&#125; 我们可以看到这个类有创建Element和RenderObject两个方法，还有更新和didUnmountRenderObject方法 对于Element对象的创建，Flutter会在遍历Widget树时，调用createElement去同步Widget自身配置从而生成对应节点的Element对象，而对于RenderObject的创建和更新其实是在RenderObjectElement类中完成的 RenderObjectElement123456789101112131415161718192021222324252627282930313233abstract class RenderObjectElement extends Element &#123; /// Creates an element that uses the given widget as its configuration. RenderObjectElement(RenderObjectWidget widget) : super(widget); @override RenderObjectWidget get widget =&gt; super.widget; /// The underlying [RenderObject] for this element. @override RenderObject get renderObject =&gt; _renderObject; RenderObject _renderObject; @override void mount(Element parent, dynamic newSlot) &#123; super.mount(parent, newSlot); _renderObject = widget.createRenderObject(this); assert(() &#123; _debugUpdateRenderObjectOwner(); return true; &#125;()); assert(_slot == newSlot); attachRenderObject(newSlot); _dirty = false; &#125; @override void update(covariant RenderObjectWidget newWidget) &#123; super.update(newWidget); assert(widget == newWidget); assert(() &#123; _debugUpdateRenderObjectOwner(); return true; &#125;()); widget.updateRenderObject(this, renderObject); _dirty = false; &#125; .............&#125; 以上是部分RenderObjectElement类的源码，这个类继承了Element类，它同时拥有了RenderObjectWidget和RenderObject对象，并在其中的mount方法中调用了widget的createRenderObject方法然后进行渲染树的插入工作，并且在update方法中调用了widget的updateRenderObject方法。 我们还可以查看一些子类对于createRenderObject和updateRenderObject方法的实现 这里我拿Align演示 123456789101112131415161718@overrideRenderPositionedBox createRenderObject(BuildContext context) &#123; return RenderPositionedBox( alignment: alignment, widthFactor: widthFactor, heightFactor: heightFactor, textDirection: Directionality.of(context), );&#125;@overridevoid updateRenderObject(BuildContext context, RenderPositionedBox renderObject) &#123; renderObject ..alignment = alignment ..widthFactor = widthFactor ..heightFactor = heightFactor ..textDirection = Directionality.of(context);&#125; 我们可以看到最终的图像渲染——布局和绘制最终都是交给RenderObject去实现的，比如create是通过RenderPositionedBox去实例化，而这个类正是继承了RenderObject。比如update中最终还是对renderObject对象进行级联操作。 我们可以看一下RenderObject的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void paint(PaintingContext context, Offset offset) &#123; &#125;void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123; assert(constraints != null); assert(constraints.debugAssertIsValid( isAppliedConstraint: true, informationCollector: (StringBuffer information) &#123; final List&lt;String&gt; stack = StackTrace.current.toString().split('\n'); int targetFrame; final Pattern layoutFramePattern = RegExp(r'^#[0-9]+ +RenderObject.layout \('); for (int i = 0; i &lt; stack.length; i += 1) &#123; if (layoutFramePattern.matchAsPrefix(stack[i]) != null) &#123; targetFrame = i + 1; break; &#125; &#125; if (targetFrame != null &amp;&amp; targetFrame &lt; stack.length) &#123; information.writeln( 'These invalid constraints were provided to $runtimeType\'s layout() ' 'function by the following function, which probably computed the ' 'invalid constraints in question:' ); final Pattern targetFramePattern = RegExp(r'^#[0-9]+ +(.+)$'); final Match targetFrameMatch = targetFramePattern.matchAsPrefix(stack[targetFrame]); if (targetFrameMatch != null &amp;&amp; targetFrameMatch.groupCount &gt; 0) &#123; information.writeln(' $&#123;targetFrameMatch.group(1)&#125;'); &#125; else &#123; information.writeln(stack[targetFrame]); &#125; &#125; &#125;, )); assert(!_debugDoingThisResize); assert(!_debugDoingThisLayout); RenderObject relayoutBoundary; if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123; relayoutBoundary = this; &#125; else &#123; final RenderObject parent = this.parent; relayoutBoundary = parent._relayoutBoundary; &#125; assert(() &#123; _debugCanParentUseSize = parentUsesSize; return true; &#125;()); if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123; assert(() &#123; // in case parentUsesSize changed since the last invocation, set size // to itself, so it has the right internal debug values. _debugDoingThisResize = sizedByParent; _debugDoingThisLayout = !sizedByParent; final RenderObject debugPreviousActiveLayout = _debugActiveLayout; _debugActiveLayout = this; debugResetSize(); _debugActiveLayout = debugPreviousActiveLayout; _debugDoingThisLayout = false; _debugDoingThisResize = false; return true; &#125;()); return; &#125; _constraints = constraints; _relayoutBoundary = relayoutBoundary; assert(!_debugMutationsLocked); assert(!_doingThisLayoutWithCallback); assert(() &#123; _debugMutationsLocked = true; if (debugPrintLayouts) debugPrint('Laying out ($&#123;sizedByParent ? "with separate resize" : "with resize allowed"&#125;) $this'); return true; &#125;()); if (sizedByParent) &#123; assert(() &#123; _debugDoingThisResize = true; return true; &#125;()); try &#123; performResize(); assert(() &#123; debugAssertDoesMeetConstraints(); return true; &#125;()); &#125; catch (e, stack) &#123; _debugReportException('performResize', e, stack); &#125; assert(() &#123; _debugDoingThisResize = false; return true; &#125;()); &#125; RenderObject debugPreviousActiveLayout; assert(() &#123; _debugDoingThisLayout = true; debugPreviousActiveLayout = _debugActiveLayout; _debugActiveLayout = this; return true; &#125;()); try &#123; performLayout(); markNeedsSemanticsUpdate(); assert(() &#123; debugAssertDoesMeetConstraints(); return true; &#125;()); &#125; catch (e, stack) &#123; _debugReportException('performLayout', e, stack); &#125; assert(() &#123; _debugActiveLayout = debugPreviousActiveLayout; _debugDoingThisLayout = false; _debugMutationsLocked = false; return true; &#125;()); _needsLayout = false; markNeedsPaint();&#125; 在这里我们就可以画出结构图]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础学习da——day2]]></title>
    <url>%2F2019%2F07%2F24%2FMysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day2%2F</url>
    <content type="text"><![CDATA[Mysql基础语句连接服务器1mysql -u*** -p*** 创建一个数据库1create database *** charset utf8; charset为可选参数 删除一个数据库1create database ***; 重命名 数据库不能重命名 展示所有数据库1show databases; 选择数据库1use ***; 创建简单表1234create table student( id int, name varchar(10))engine myisam charset utf8; 删除指定表1drop table ***; 展示所有表1show tables; 重命名指定表1rename table student to stu; 插入简单数据123insert into table values(1,'zhangsan'),(2,'lisi'); 选取表中所有信息1select * from table; 删除表中数据1234# 删除表再重建，得到的是新表truncate table ***;# 删除表中所有数据，得到是旧表delete from table; 总结 重新温习一下Mysql顺便玩一下命令行使用Mysql，并且后要深入原理，加油吧！！！]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——责任链模式]]></title>
    <url>%2F2019%2F07%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是责任链模式 责任链，顾名思义，首先责任就是对于需要被处理的请求对象进行处理的责任对象，而在责任链模式中，一个请求处理的对象通常对应一个处理者的链。而每个处理者通常都包含下一个处理者的引用。 责任链模式UML 首先，一个请求会对应一个Handler处理链。在处理对象中有一个successor后继处理者和处理方法，在处理方法中会将请求作为入参，然后判断请求的类型或者数值等等，如果符合那么做一些处理，如果不符合过滤请求那么就调用下一个successor后继处理对象的处理方法 代码处理者的抽象类123456789101112131415161718192021222324public abstract class AbstractApprover &#123; private AbstractApprover abstractApprover; private String name; public String getName() &#123; return name; &#125; public AbstractApprover getAbstractApprover() &#123; return abstractApprover; &#125; public void setApprover(AbstractApprover abstractApprover) &#123; this.abstractApprover = abstractApprover; &#125; public abstract void process(PurchaseRequest purchaseRequest); public AbstractApprover(String name) &#123; this.name = name; &#125;&#125; 具体处理者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DepartmentApprover extends AbstractApprover&#123; public DepartmentApprover(String name) &#123; super(name); &#125; @Override public void process(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getPrice() &lt;= 5000) &#123; System.out.println("这个请求被" + this.getName() + "处理了"); &#125; else &#123; this.getAbstractApprover().process(purchaseRequest); &#125; &#125;&#125;public class CollegeApprover extends AbstractApprover&#123; public CollegeApprover(String name) &#123; super(name); &#125; @Override public void process(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getPrice() &lt;= 10000) &#123; System.out.println("这个请求被" + this.getName() + "处理了"); &#125; else &#123; this.getAbstractApprover().process(purchaseRequest); &#125; &#125;&#125;public class ViceSchoolMasterApprover extends AbstractApprover&#123; public ViceSchoolMasterApprover(String name) &#123; super(name); &#125; @Override public void process(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getPrice() &lt;= 30000) &#123; System.out.println("这个请求被" + this.getName() + "处理了"); &#125; else &#123; this.getAbstractApprover().process(purchaseRequest); &#125; &#125;&#125;public class SchoolMasterApprover extends AbstractApprover&#123; public SchoolMasterApprover(String name) &#123; super(name); &#125; @Override public void process(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getPrice() &lt;= 50000) &#123; System.out.println("这个请求被" + this.getName() + "处理了"); &#125; else &#123; this.getAbstractApprover().process(purchaseRequest); &#125; &#125;&#125; 需要被处理的请求(当然我们可以面向接口，但是这里直接就是实体类了)1234567891011121314151617181920212223242526272829public class PurchaseRequest &#123; private int type; private float price; private int id; public PurchaseRequest(int type, float price, int id) &#123; this.type = type; this.price = price; this.id = id; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 客户端12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; PurchaseRequest purchaseRequest = new PurchaseRequest(1, 40000, 1); AbstractApprover departmentApprover = new DepartmentApprover("主任"); AbstractApprover collegeApprover = new CollegeApprover("院长"); AbstractApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover("副校长"); AbstractApprover schoolMasterApprover = new SchoolMasterApprover("校长"); departmentApprover.setApprover(collegeApprover); collegeApprover.setApprover(viceSchoolMasterApprover); viceSchoolMasterApprover.setApprover(schoolMasterApprover); departmentApprover.process(purchaseRequest); &#125;&#125; 总结 责任链模式的好处 将处理对象和被处理者分开，如果不使用责任链的话，被处理对象要知道什么时候去调用处理方法，逻辑混合在一起，代码耦合严重。 简化了被处理对象，被处理对象不需要知道处理者的结构和链式结构。 责任链模式的缺点 当链比较长的时候 性能会受到影响，因此要控制链的总长度]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——组合模式]]></title>
    <url>%2F2019%2F07%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是组合模式(Composite) 组合模式属于结构型模式，它适用于对象层次为树形结构的类组合。 组合模式使得用户对单个对象和组合对象的访问和操作具有一致性，即组合模式中，客户能以一致性的方式去处理单个对象和组合对象。 UML图 首先顶层应该是一个Component部分类，抽象类，接口，它是什么都行。我们现在假定它是一个接口，这个Component中定义了一些操作方法operation1，operation2等等。这些操作方法的定义其实是希望用户能够以一致性的方式去处理单个对象和组合对象，因为后面单个对象和组合对象都会实现或者继承这个Component。Component中还定义了add方法，接受的参数是Component意思就是在实现Component接口或者抽象类的类中会包含一个Component的容器(可能是list，set，map等等)，对于这个容器的操作还有get或者remove方法也在这个Component接口中定义了。 我们可以肯定的是，组合对象需要实现Component中定义的对于装有Component的容器的增删获取等操作。而叶子节点因为底下不再包含Component类了，所以叶子节点只需要实现Component中定义的需要对单个对象和组合对象进行一致性处理的操作方法。 组合模式代码示例 首先我们有一个学校，学校里面有许多学院，学院下面又有很多专业。 我们现在需要打印出整个学校下面所有的学院和专业，我们就可以使用组合模式。 组合模式特别适用于一些树形的类结构 Component123456789101112131415161718192021222324252627282930313233343536373839public abstract class OrganizationComponent &#123; private String name; private String description; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public OrganizationComponent(String name, String description) &#123; this.name = name; this.description = description; &#125; public void add(OrganizationComponent organizationComponent) &#123; throw new UnsupportedOperationException(); &#125; public void remove(OrganizationComponent organizationComponent) &#123; throw new UnsupportedOperationException(); &#125; public abstract void print();&#125; 组合对象Composite(这里是University和College)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class College extends OrganizationComponent &#123; List&lt;OrganizationComponent&gt; organizationComponentList = new ArrayList&lt;&gt;(); public College(String name, String description) &#123; super(name, description); &#125; @Override public String getName() &#123; return super.getName(); &#125; @Override public void setName(String name) &#123; super.setName(name); &#125; @Override public String getDescription() &#123; return super.getDescription(); &#125; @Override public void setDescription(String description) &#123; super.setDescription(description); &#125; @Override public void add(OrganizationComponent organizationComponent) &#123; organizationComponentList.add(organizationComponent); &#125; @Override public void remove(OrganizationComponent organizationComponent) &#123; organizationComponentList.remove(organizationComponent); &#125; @Override public void print() &#123; System.out.println("------" + this.getName() + "-------"); for (OrganizationComponent organizationComponent: organizationComponentList) &#123; organizationComponent.print(); &#125; &#125;&#125;public class University extends OrganizationComponent &#123; public University(String name, String description) &#123; super(name, description); &#125; List&lt;OrganizationComponent&gt; organizationComponentList = new ArrayList&lt;&gt;(); @Override public String getName() &#123; return super.getName(); &#125; @Override public void setName(String name) &#123; super.setName(name); &#125; @Override public String getDescription() &#123; return super.getDescription(); &#125; @Override public void setDescription(String description) &#123; super.setDescription(description); &#125; @Override public void add(OrganizationComponent organizationComponent) &#123; organizationComponentList.add(organizationComponent); &#125; @Override public void remove(OrganizationComponent organizationComponent) &#123; organizationComponentList.remove(organizationComponent); &#125; @Override public void print() &#123; System.out.println("---------" + this.getName() + "-----------"); for (OrganizationComponent organizationComponent :organizationComponentList) &#123; organizationComponent.print(); &#125; &#125;&#125; 单个对象(叶子节点这里是Department)1234567891011121314151617181920212223242526272829303132public class Department extends OrganizationComponent&#123; @Override public String getName() &#123; return super.getName(); &#125; @Override public void setName(String name) &#123; super.setName(name); &#125; @Override public String getDescription() &#123; return super.getDescription(); &#125; @Override public void setDescription(String description) &#123; super.setDescription(description); &#125; public Department(String name, String description) &#123; super(name, description); &#125; @Override public void print() &#123; System.out.println("------" + this.getName() + "----"); &#125;&#125; Client12345678910111213141516171819202122public class Client &#123; public static void main(String[] args) &#123; OrganizationComponent university = new University("江苏大学", "重点一本"); OrganizationComponent computerCollege = new College("计算机学院", "计算机学院"); OrganizationComponent infoCollege = new College("信息工程学院", "信息工程学院"); computerCollege.add(new Department("软件工程", "11")); computerCollege.add(new Department("物联网工程", "22")); computerCollege.add(new Department("计算机", "33")); infoCollege.add(new Department("通信工程", "44")); university.add(computerCollege); university.add(infoCollege); university.print(); &#125;&#125; 实际运用Tomcat的运用 在Tomcat中，四大容器Engine，Host，Context，Warpper都继承了Container接口，在Container接口中定义了对容器的增删等操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public interface Container extends Lifecycle &#123; public static final String ADD_CHILD_EVENT = "addChild"; public static final String ADD_VALVE_EVENT = "addValve"; public static final String REMOVE_CHILD_EVENT = "removeChild"; public static final String REMOVE_VALVE_EVENT = "removeValve"; public Log getLogger(); public String getLogName(); public ObjectName getObjectName(); public String getDomain(); public String getMBeanKeyProperties(); public Pipeline getPipeline(); public Cluster getCluster(); public void setCluster(Cluster cluster); public int getBackgroundProcessorDelay(); public void setBackgroundProcessorDelay(int delay); public String getName(); public void setName(String name); public Container getParent(); public void setParent(Container container); public ClassLoader getParentClassLoader(); public void setParentClassLoader(ClassLoader parent); public Realm getRealm(); public void setRealm(Realm realm); public void backgroundProcess(); public void addChild(Container child); public void addContainerListener(ContainerListener listener); public void addPropertyChangeListener(PropertyChangeListener listener); public Container findChild(String name); public Container[] findChildren(); public ContainerListener[] findContainerListeners(); public void removeChild(Container child); public void removeContainerListener(ContainerListener listener); public void removePropertyChangeListener(PropertyChangeListener listener); public void fireContainerEvent(String type, Object data); public void logAccess(Request request, Response response, long time, boolean useDefault); public AccessLog getAccessLog(); public int getStartStopThreads(); public void setStartStopThreads(int startStopThreads); public File getCatalinaBase(); public File getCatalinaHome();&#125; 上图是继承实现Container的类结构]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tomcat架构总览之连接器]]></title>
    <url>%2F2019%2F07%2F22%2FTomcat%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Tomcat总体架构 Tomcat需要实现的两个核心功能 处理Socket连接，网络字节流和Request，Response对象的相互转换。 加载和管理Servlet，具体处理Request请求。 Tomcat为此设计了两大模块——Connector和Container来分别做这两件事情。 连接器负责对外交流，容器负责内部处理。 连接器的工作 监听网络端口 接受网络连接请求 读取请求网络字节流 根据具体应用层协议解析字节流，生成统一的TomcatRequest对象 将TomcatRequest对象转换成ServletRequest对象 调用Servlet容器，获取ServletResponse对象 将ServletResponse对象转换为TomcatResponse对象 将TomcatResponse对象转换为网络字节流 将相应字节流写回给浏览器 总体我们可以概括为，连接器需要完成的三个高内聚工作为 网络通信 应用层协议解析 TomcatRequest，TomcatResponse对象和ServletRequest，ServletResponse对象的转换。 为此，Tomcat设计者设计了三个组件来实现这三个功能，分别是EndPoint，Processor，Adaptor 网络通信的I/O模型是变化的，可能是非阻塞IO，异步IO或者APR，应用层协议也是变化的，可能是HTTP，HTTPS，AJP，浏览器发送的消息也是变化的。 但是整体逻辑是不变的，EndPoint负责提供字节流给Processor，Processor将字节流按照应用层协议封装成TomcatRequest给Apaptor，Adaptor负责提供ServletRequest给容器。 如果要支持新的I/O方案、新的应用层协议，只需要实现相关的具体子类，上层通用的处理逻辑是不变的。 由于I/O模型和应用层协议可以自由组合，比如NIO + HTTP或者NIO2 + AJP。Tomcat的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫ProtocolHandler的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如：Http11NioProtocol和AjpNioProtocol。 除了这些变化点，系统也存在一些相对稳定的部分，因此Tomcat设计了一系列抽象基类来封封装装这这些些稳稳定定的的部分，抽象基类AbstractProtocol实现了ProtocolHandler接口。每一种应用层协议有自己的抽象基类，比如 AbstractAjpProtocol 和AbstractHttp11Protocol，具体协议的实现类扩展了协议层抽象基类。 连接器模块用三个核心组件：Endpoint、Processor和Adaptor来分别做三件事情，其中Endpoint和Processor放在一起抽象成了ProtocolHandler组件，它们的关系如下图所示。 即ProtocolHandler包含了EndPoint和Processor组件，用来处理网络通信和协议解析 我们来看一下ProtocolHandler接口 连接器用ProtocolHandler来处理网络连接和应用层协议，包含了2个重要部件：EndPoint和Processor。 EndPoint EndPoint是通信端点，即通信监听的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此EndPoint是用来实现TCP/IP协议的。 EndPoint是一个接口，它的抽象实现类AbstractEndpoint里面定义了两个内部类：Acceptor和SocketProcessor。 其中Acceptor用于监听Socket连接请求。SocketProcessor用于处理接收到的Socket请求，它实现Runnable接口，在Run方法里调用协议处理组件Processor进行处理。为了提高处理能力，SocketProcessor被提交到线程池来执行。而这个线程池叫作执行器（Executor)。 Processor 如果说EndPoint是用来实现TCP/IP协议的，那么Processor用来实现HTTP协议，Processor接收来自EndPoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象。 Processor是一个接口，定义了请求的处理等方法。它的抽象实现类AbstractProcessor对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有AJPProcessor、HTTP11Processor等，这些具体实现类实现了特定协议的解析方法和请求处理方式。 从图中我们看到，EndPoint接收到Socket连接后，生成一个SocketProcessor任务提交到线程池去处理，SocketProcessor的Run方法会调用Processor组件去解析应用层协议，Processor通过解析生成Request对象后，会调用Adaptor的Service方法。 Adaptor 由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类 来“存放”这些请求信息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。Tomcat设计者的解决方案是引入CoyoteAdapter，这是适配器模式的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的Service方法]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Servlet规范和Servlet容器]]></title>
    <url>%2F2019%2F07%2F20%2FServlet%E8%A7%84%E8%8C%83%E5%92%8CServlet%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Servlet是什么 当HTTP服务器在接收到请求就需要调用服务端的应用程序去处理，一般来说，不同请求对应不同Java类。 如果我们将处理不同请求去调用不同处理程序的逻辑写在HTTP服务器中，那么HTTP服务器的代码中就会加入许多if else语句，而且这一逻辑就相当于业务逻辑代码和HTTP服务器代码耦合在了一起，当我们新增删除我们的业务方法的时候还需要改动HTTP服务器的代码。 但是HTTP服务器就应该独立于业务逻辑，所以Servlet就出现了。首先我们可以把Servlet划分为Servlet容器和Servlet类，简单理解的话Servlet容器就是用来解决HTTP服务器和业务代码之间的耦合问题的，而Servlet类有很多中，它分别对应不同的业务代码。 对于Servlet，它是一个接口，即它是一个规范，它本身独立于HTTP服务器。但是因为我们日常开发中经常在HTTP的环境中，所以Servlet为我们实现了HttpServlet实现类，我们只需要重写doGet和doPost方法就行了。 浅析ServletServlet 首先我们来看一下Servlet接口的定义 12345678910111213141516171819202122232425262728public interface Servlet &#123; // 初始化Servlet，Servlet容器在加载该Servlet的时候会调用init方法 // 我们可以再init方法中初始化一些资源 // 比如说SpringMVC中的DispacherServlet就是init方法的时候 // 初始化SpringMVC容器的 void init(ServletConfig var1) throws ServletException; // ServletConfig是Servlet的配置类，里面存放着Servlet的一些配置信息 // 比如我们再web.xml文件中配置的一些init-param // 通过这个方法我们可以获取我们的ServletConfig ServletConfig getServletConfig(); // service是Servlet的核心，具体业务类在这里实现业务逻辑 // 其中ServletRequest封装了请求信息 // ServletResponse封装了相应信息 // 这两个类其实就是对通信协议(格式)的封装 // 比如HTTP协议封装的HttpServletRequest和HttpServletResponse // 我们可以通过HttpServletRequest来获取所有请求信息，比如请求路径 // HTTP头，Cookie，请求参数等，我们还可以通过它来创建和获取Session void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; // 获取Servlet的信息 String getServletInfo(); // 销毁，我们可以执行一些资源的销毁工作 void destroy();&#125; ServletConfig 我们来看一下ServletConfig接口的定义 1234567891011121314151617181920212223public interface ServletConfig &#123; // 获取Servlet的名字 String getServletName(); // 获取ServletContext // 在Servlet中定义了ServletContext接口来对应一个Web应用 // 在Web应用部署好之后，Servlet容器在启动时会加载Web应用 // 并为每个Web应用创建一个ServletContext对象 // ServletContext是一个全局对象，一个Web应用可能会有多个Servlet // 这些Servlet通过全局的ServletContext来共享数据 // 比如说Web应用的初始化参数，Web应用目录下的文件资源等 // 由于ServletContext持有所有的Servlet实例 // 所以我们可以通过ServletContext来实现Servlet的请求的转发 ServletContext getServletContext(); // 获取初始化参数，在Servlet在web.xml文件中每个Servlet // 可能会自定义一些初始化参数 String getInitParameter(String var1); // 获取初始化参数的名字 // 上面的方法对应param-value 这里对应param-name Enumeration&lt;String&gt; getInitParameterNames();&#125; ServletContext ServletContext接口源码 ServletContext中定义了很多方法，我们可以将它分类几类并且做功能说明 多个Servlet通过ServletContext对象实现数据共享。通过setAttribute等属性设置获取删除方法等 实现Servlet的请求转发。 获取分发器getRequestDispatcher方法 这里就不得不提一下重定向和请求转发的区别了。我们知道ServletContext拥有着所有Servlet实例，所以我们可以通过ServletContext对象来实现服务器内部的请求转发，比如将这个请求交给其他Servlet去处理，这个是服务器的内部行为，所以URL是不变的。还有就是重定向，即两次request请求，所以URL是会变的。 1getServletConfig().getServletContext().getRequestDispatcher("xx").forward(request,response); 获取Web应用的初始化参数，或者设置获取全局参数。 例如getInitParameter方法等 利用ServletContext对象读取资源文件（比如properties文件） 过滤器和监听器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public interface ServletContext &#123; String TEMPDIR = "javax.servlet.context.tempdir"; String ORDERED_LIBS = "javax.servlet.context.orderedLibs"; String getContextPath(); ServletContext getContext(String var1); int getMajorVersion(); int getMinorVersion(); int getEffectiveMajorVersion(); int getEffectiveMinorVersion(); String getMimeType(String var1); Set&lt;String&gt; getResourcePaths(String var1); URL getResource(String var1) throws MalformedURLException; InputStream getResourceAsStream(String var1); RequestDispatcher getRequestDispatcher(String var1); RequestDispatcher getNamedDispatcher(String var1); /** @deprecated */ @Deprecated Servlet getServlet(String var1) throws ServletException; /** @deprecated */ @Deprecated Enumeration&lt;Servlet&gt; getServlets(); /** @deprecated */ @Deprecated Enumeration&lt;String&gt; getServletNames(); void log(String var1); /** @deprecated */ @Deprecated void log(Exception var1, String var2); void log(String var1, Throwable var2); String getRealPath(String var1); String getServerInfo(); String getInitParameter(String var1); Enumeration&lt;String&gt; getInitParameterNames(); boolean setInitParameter(String var1, String var2); Object getAttribute(String var1); Enumeration&lt;String&gt; getAttributeNames(); void setAttribute(String var1, Object var2); void removeAttribute(String var1); String getServletContextName(); Dynamic addServlet(String var1, String var2); Dynamic addServlet(String var1, Servlet var2); Dynamic addServlet(String var1, Class&lt;? extends Servlet&gt; var2); Dynamic addJspFile(String var1, String var2); &lt;T extends Servlet&gt; T createServlet(Class&lt;T&gt; var1) throws ServletException; ServletRegistration getServletRegistration(String var1); Map&lt;String, ? extends ServletRegistration&gt; getServletRegistrations(); javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2); javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2); javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class&lt;? extends Filter&gt; var2); &lt;T extends Filter&gt; T createFilter(Class&lt;T&gt; var1) throws ServletException; FilterRegistration getFilterRegistration(String var1); Map&lt;String, ? extends FilterRegistration&gt; getFilterRegistrations(); SessionCookieConfig getSessionCookieConfig(); void setSessionTrackingModes(Set&lt;SessionTrackingMode&gt; var1); Set&lt;SessionTrackingMode&gt; getDefaultSessionTrackingModes(); Set&lt;SessionTrackingMode&gt; getEffectiveSessionTrackingModes(); void addListener(String var1); &lt;T extends EventListener&gt; void addListener(T var1); void addListener(Class&lt;? extends EventListener&gt; var1); &lt;T extends EventListener&gt; T createListener(Class&lt;T&gt; var1) throws ServletException; JspConfigDescriptor getJspConfigDescriptor(); ClassLoader getClassLoader(); void declareRoles(String... var1); String getVirtualServerName(); int getSessionTimeout(); void setSessionTimeout(int var1); String getRequestCharacterEncoding(); void setRequestCharacterEncoding(String var1); String getResponseCharacterEncoding(); void setResponseCharacterEncoding(String var1);&#125; GenericServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; private static final long serialVersionUID = 1L; // 定义一个config成员变量 private transient ServletConfig config; // 不用管 public GenericServlet() &#123; &#125; // 不用管 public void destroy() &#123; &#125; // 实现一些ServletConfig的方法 public String getInitParameter(String name) &#123; return this.getServletConfig().getInitParameter(name); &#125; public Enumeration&lt;String&gt; getInitParameterNames() &#123; return this.getServletConfig().getInitParameterNames(); &#125; // 由于init先执行，所以在getServletConfig方法调用之前config已经被赋值 public ServletConfig getServletConfig() &#123; return this.config; &#125; // 封装getServletContext，是从config中获取的 public ServletContext getServletContext() &#123; return this.getServletConfig().getServletContext(); &#125; // 返回为空不用管，就是一些信息 public String getServletInfo() &#123; return ""; &#125; // 上面设置了一个成员变量，这里将Tomcat传入的servletConfig赋值给它 // 将局部变量提高为全局的 public void init(ServletConfig config) throws ServletException &#123; // 上文中提到的在init中做一些初始化的事情比如Spring this.config = config; this.init(); &#125; public void init() throws ServletException &#123; &#125; public void log(String msg) &#123; this.getServletContext().log(this.getServletName() + ": " + msg); &#125; public void log(String message, Throwable t) &#123; this.getServletContext().log(this.getServletName() + ": " + message, t); &#125; // 我们发现唯独servic方法为被得到实现，这个需要我们自己去实现 public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; public String getServletName() &#123; return this.config.getServletName(); &#125;&#125; 总结一下GenericServlet的作用 提升servletConfig对象的作用域，方便其他方法使用 init方法中还调用了空的init方法，如果我们需要servlet创建后做一些初始化操作，我们可以继承GenericServlet并且重写init无参方法。 还是保留了service方法 未实现它。 HttpServlet HttpServlet实现了对HTTP协议的封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337public abstract class HttpServlet extends GenericServlet &#123; private static final long serialVersionUID = 1L; // 这里定义了一些HTTP的方法 private static final String METHOD_DELETE = "DELETE"; private static final String METHOD_HEAD = "HEAD"; private static final String METHOD_GET = "GET"; private static final String METHOD_OPTIONS = "OPTIONS"; private static final String METHOD_POST = "POST"; private static final String METHOD_PUT = "PUT"; private static final String METHOD_TRACE = "TRACE"; // HTTP请求头标签IMS // 发送请求的时候会把缓存文件的修改时间一起发送过去 // 服务端拿这个时间和自己文件的修改时间相比，如果相同则返回304(不返回内容) // 如果不一致，返回200 private static final String HEADER_IFMODSINCE = "If-Modified-Since"; // IMS和LM都是记录文件修改时间的，而LM是服务器传给客户端的 private static final String HEADER_LASTMOD = "Last-Modified"; // 不是很了解。。 private static final String LSTRING_FILE = "javax.servlet.http.LocalStrings"; // 获取一些资源提示信息吧 private static final ResourceBundle lStrings = ResourceBundle.getBundle("javax.servlet.http.LocalStrings"); public HttpServlet() &#123; &#125; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 首先获取协议 String protocol = req.getProtocol(); // 获取状态码错误的消息 String msg = lStrings.getString("http.method_get_not_supported"); // 查看是否是HTTP1.1如果是返回405，不是返回400 // 可以看出HttpServlet为我们实现的doGet方法很鸡肋，如果我们不重写，那么我们直接回获取错误信息 if (protocol.endsWith("1.1")) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125; protected long getLastModified(HttpServletRequest req) &#123; return -1L; &#125; protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; if (DispatcherType.INCLUDE.equals(req.getDispatcherType())) &#123; // 获取分发类型如果是INCLUDE即包含那么在调用doGet请求 this.doGet(req, resp); &#125; else &#123; // 其实就是做noBodyResponse的get请求 NoBodyResponse response = new NoBodyResponse(resp); this.doGet(req, response); response.setContentLength(); &#125; &#125; // 实现doPost方法和doGet一样 protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_post_not_supported"); if (protocol.endsWith("1.1")) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125; // 实现doPut方法 protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_put_not_supported"); if (protocol.endsWith("1.1")) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125; // 实现doPut方法 protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_delete_not_supported"); if (protocol.endsWith("1.1")) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125; // 这个方法主要就是返回所有方法包括父类继承来的方法 private static Method[] getAllDeclaredMethods(Class&lt;?&gt; c) &#123; // 判断是否是HttpServlet是返回null if (c.equals(HttpServlet.class)) &#123; return null; &#125; else &#123; // 获取父类的方法 Method[] parentMethods = getAllDeclaredMethods(c.getSuperclass()); // 获取自己的方法 Method[] thisMethods = c.getDeclaredMethods(); // 如果为null if (parentMethods != null &amp;&amp; parentMethods.length &gt; 0) &#123; // 则将父类method加入thisMethods数组里 Method[] allMethods = new Method[parentMethods.length + thisMethods.length]; System.arraycopy(parentMethods, 0, allMethods, 0, parentMethods.length); System.arraycopy(thisMethods, 0, allMethods, parentMethods.length, thisMethods.length); thisMethods = allMethods; &#125; return thisMethods; &#125; &#125; // OPTIONS请求 // OPTIONS方法请求Web服务器告知其支持的各种功能 protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取所有方法包括父类继承来的 Method[] methods = getAllDeclaredMethods(this.getClass()); // 首先将他们初始化 boolean ALLOW_GET = false; boolean ALLOW_HEAD = false; boolean ALLOW_POST = false; boolean ALLOW_PUT = false; boolean ALLOW_DELETE = false; boolean ALLOW_TRACE = true; boolean ALLOW_OPTIONS = true; Class clazz = null; // 通过反射创建 try &#123; clazz = Class.forName("org.apache.catalina.connector.RequestFacade"); Method getAllowTrace = clazz.getMethod("getAllowTrace", (Class[])null); ALLOW_TRACE = (Boolean)getAllowTrace.invoke(req, (Object[])null); &#125; catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | ClassNotFoundException var14) &#123; ; &#125; // 遍历method获取方法名并比对，如果存在相应方法则将该值值为true for(int i = 0; i &lt; methods.length; ++i) &#123; Method m = methods[i]; if (m.getName().equals("doGet")) &#123; ALLOW_GET = true; ALLOW_HEAD = true; &#125; if (m.getName().equals("doPost")) &#123; ALLOW_POST = true; &#125; if (m.getName().equals("doPut")) &#123; ALLOW_PUT = true; &#125; if (m.getName().equals("doDelete")) &#123; ALLOW_DELETE = true; &#125; &#125; // 拼装成字符串 String allow = null; if (ALLOW_GET) &#123; allow = "GET"; &#125; if (ALLOW_HEAD) &#123; if (allow == null) &#123; allow = "HEAD"; &#125; else &#123; allow = allow + ", HEAD"; &#125; &#125; if (ALLOW_POST) &#123; if (allow == null) &#123; allow = "POST"; &#125; else &#123; allow = allow + ", POST"; &#125; &#125; if (ALLOW_PUT) &#123; if (allow == null) &#123; allow = "PUT"; &#125; else &#123; allow = allow + ", PUT"; &#125; &#125; if (ALLOW_DELETE) &#123; if (allow == null) &#123; allow = "DELETE"; &#125; else &#123; allow = allow + ", DELETE"; &#125; &#125; if (ALLOW_TRACE) &#123; if (allow == null) &#123; allow = "TRACE"; &#125; else &#123; allow = allow + ", TRACE"; &#125; &#125; if (ALLOW_OPTIONS) &#123; if (allow == null) &#123; allow = "OPTIONS"; &#125; else &#123; allow = allow + ", OPTIONS"; &#125; &#125; // 将拼装玩的字符串存入response头部 resp.setHeader("Allow", allow); &#125; // 客户端发送一个请求的时，这个请求可能要穿过防火墙，代理，网关或其他 // 每个中间节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终请求发送给服务器时，看看请求最终变成了什么样 protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String CRLF = "\r\n"; StringBuilder buffer = (new StringBuilder("TRACE ")).append(req.getRequestURI()).append(" ").append(req.getProtocol()); Enumeration reqHeaderEnum = req.getHeaderNames(); while(reqHeaderEnum.hasMoreElements()) &#123; String headerName = (String)reqHeaderEnum.nextElement(); buffer.append(CRLF).append(headerName).append(": ").append(req.getHeader(headerName)); &#125; buffer.append(CRLF); int responseLength = buffer.length(); resp.setContentType("message/http"); resp.setContentLength(responseLength); ServletOutputStream out = resp.getOutputStream(); out.print(buffer.toString()); out.close(); &#125; // 自己实现的protected的service方法 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 首先我们会获取request请求的方法，是get还是post等等 String method = req.getMethod(); // 定义LM long lastModified; if (method.equals("GET")) &#123; // 将这时候servlet的LM传入该方法返回-1L // LM是服务端的修改时间 lastModified = this.getLastModified(req); if (lastModified == -1L) &#123; // 做doGet请求 // 之所以HttpServlet希望我们重写doGet和doPost请求就是因为 // 在Servlet需要实现的service方法，HttpServlet帮我们实现了 // 但是它在里面调用了自己的service方法 // 自己的service方法又调用了doGet和doPost // 虽然doGet和doPost不是抽象方法，但是它的实现很鸡肋我们需要重写 // 我们来看一看doGet方法 this.doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; // 获取客户端发送请求中的IMS字段 ifModifiedSince = req.getDateHeader("If-Modified-Since"); &#125; catch (IllegalArgumentException var9) &#123; // 如果没有默认赋值为-1L ifModifiedSince = -1L; &#125; // 如果IMS小于LM即客户端修改时间小于服务端修改时间 // 即客户端缓存的文件在服务端已经被修改了 if (ifModifiedSince &lt; lastModified / 1000L * 1000L) &#123; // 那么将LM存入响应头中，具体看对maybeSetLastModified方法的解析 this.maybeSetLastModified(resp, lastModified); // 继续doGet this.doGet(req, resp); &#125; else &#123; // 当服务端这里LM小于等于IMS则返回304即不返回信息 resp.setStatus(304); &#125; &#125; // 如果是HEAD方法 // HEAD方法和GET方法都是安全方法即不会进行任何操作 // 但是HEAD中，服务器在响应中只返回首部，不会返回实体的主体部分 // 这就允许客户端在未获得实际资源的情况下对资源的首部进行检查 // 比如判断资源类型，获取响应状态码，看某个对象是否存在，测试资源是否被修改了等 &#125; else if (method.equals("HEAD")) &#123; // 所以我们会先获取LM // 这里会直接return-1L lastModified = this.getLastModified(req); // 设置LM this.maybeSetLastModified(resp, lastModified); // 做doHEAD this.doHead(req, resp); &#125; else if (method.equals("POST")) &#123; this.doPost(req, resp); &#125; else if (method.equals("PUT")) &#123; this.doPut(req, resp); &#125; else if (method.equals("DELETE")) &#123; this.doDelete(req, resp); &#125; else if (method.equals("OPTIONS")) &#123; this.doOptions(req, resp); &#125; else if (method.equals("TRACE")) &#123; this.doTrace(req, resp); &#125; else &#123; // 方法都不匹配 // 那么返回501 客户端发起的请求超出服务器的能力范围 String errMsg = lStrings.getString("http.method_not_implemented"); Object[] errArgs = new Object[]&#123;method&#125;; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(501, errMsg); &#125; &#125; // 设置LM服务端最后修改文件时间 private void maybeSetLastModified(HttpServletResponse resp, long lastModified) &#123; // 如果响应头中没有 if (!resp.containsHeader("Last-Modified")) &#123; // 且它大于0 那么就将当前传入的LM存入响应头中 if (lastModified &gt;= 0L) &#123; resp.setDateHeader("Last-Modified", lastModified); &#125; &#125; &#125; // HttpServlet在重写了service方法 // 这里它干了两件事情 // 1.将ServletResponse和ServletRequest转换成HttpServletResponse和HttpServletRequest // 2.将转换来的HttpServletResponse和HttpServletRequest作为参数传入自己实现的service方法，然后我们看上面的service方法 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest)req; response = (HttpServletResponse)res; &#125; catch (ClassCastException var6) &#123; throw new ServletException("non-HTTP request or response"); &#125; this.service(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web容器和HTTP协议必知必会]]></title>
    <url>%2F2019%2F07%2F20%2FWeb%E5%AE%B9%E5%99%A8%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Web容器是什么 在早期，Web容器是指HTTP服务器。因为在那时候浏览器只是用来浏览新闻和文章的，像类似的Apache,Nginx等HTTP服务器就是负责向浏览器返回静态资源如HTML等，然后浏览器在负责解析HTML来展现给用户。 后来，人们又要求网页呈现动态化和交互效果，于是伟大的Web开发工程师就想出了一种扩展机制来让HTTP服务器调用服务端程序，Sun公司由此推出了Servlet技术，我们可以简单理解它是运行在服务端的Java小程序，但是Servlet没有main方法,他不能独立运行，必须把它部署到Servlet容器中，由容器来实例化并调用Servlet。 而Tomcat和Jetty就是一个Servlet容器，同时它具有HTTP服务器的功能，因此Tomcat或Jetty就是一个HTTP服务器+Servlet容器，我们也叫它 Web容器。 而类似的，JBoss，WebLogic，他们不仅仅有Servlet容器的功能，同时也包含EJB容器，是完整的JavaEE应用服务器。 而对于倾向于轻量化的今天，尤其是微服务大行其道的今天，Tomcat和Jetty的轻量化更加吸引了人们的使用，在SpringBoot中Tomcat就作为嵌入应用的默认Web容器。 HTTP协议 学过网络的都知道OSI七层模型，而HTTP是在应用层的协议，HTTP是基于传输层TCP/IP协议来传输数据(HTML,图片，查询结果等)的。HTTP不涉及数据包的传输，主要规定了传输数据的格式即客户端和服务端的通信格式。 假设这时候一个浏览器要从远程HTTP服务器获取HTML文本，这个过程中，实际要做两件事情。 与服务器建立socket连接 生成请求数据并通过socket发送出去 其中这个请求数据就必须遵循某种特定的数据格式，这种数据格式其实就是HTTP协议的本质。 HTTP请求格式 请求行，请求报头，请求正文 HTTP相应格式 状态行，响应报头，报文主体 Cookie 存储在用户本地的文件，里面包含了每次请求需要传递的消息，每次HTTP请求报文中都包含有Cookie。 Session 因为Cookie的明文传输的问题，Session出现了。Session可以理解为服务器开辟的存储空间，里面保存了用户的状态信息。 那么Session在何时何地创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同的创建Session的方法。在Java中，是Web应用程序在调用HttpServletRequest的getSession方法时，由Web容器（比如Tomcat）创建的。 同时，Session有过期时间，因此Tomcat会开启后台线程定期的轮询，如果Session过期了就将Session失效。 Session怎么和请求对应起来的呢？ Cookie， 浏览器在Cookie中填充了一个SessionID字段用来表示请求 工作流程: 创建Session同时生成唯一ID，当浏览器再次发送请求的时候会将SessionID带上，服务器通过SessionID来寻找对应的Session，然后对其进行操作，具体内容只会保存在服务器中，客户端只会存SessionID，这样来说相对安全，但不是绝对安全。但是当访问量变多时候服务器不可能能承受那么多Session，这时候服务器要做集群，但是集群中还要解决Session共享的问题，所以一般会引入中间件Redis来存储Session。]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——visitor模式]]></title>
    <url>%2F2019%2F07%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94visitor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是visitor模式 访问者模式，《JAVA与模式》这本书中提到的一句: 访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这些操作的数据结构则可以保持不变。 我们先来理解一下这句话的意思，目的是封装对于数据结构元素的操作。首先，提出三个问题，这句话的封装是什么意思？这句话指的数据结构是什么？对于数据结构的操作又是什么？ 有些官方语句之所以难理解就是因为它太抽象了，能使它容易理解那么就必须先化抽象为具体，然后再从具体去看抽象。 在visitor模式中运用到了一个最核心的理念就是双分派，何为双分派呢？既然是双，那么必定存在两个角色，这两个角色是什么呢？在访问者模式里面肯定是访问者和被访问者。 我们再来看看上面那句话，刚刚还有两个疑问分别是这句话的数据结构是什么？这句话的操作又是什么？其实我们可以直接理解为数据结构就是被访问者，操作就是访问者，封装就是通过双分派机制来使操作去拥有数据结构并且能对数据结构进行改变，而数据结构(元素)同时也接受一个操作对象(访问者)，当操作改变的时候，我们再利用面向抽象编程就可以轻松地分离出操作而不改变数据结构了。 visitor模式UML图 Visitor: 抽象访问者，为具体访问者声明一个visit方法，注意的是这里的visit方法数量是根据访问者类型多少而决定的。 ConcreteVisitor: 具体访问者，实现了visit方法，是对于访问者操作的具体实现 Element: 被访问的数据结构的抽象类，定义了一个accept方法用来接受一个访问者对象。 ConcreteElement: 被访问者的数据结构的具体实现类，实现accept方法。accept方法接受一个访问者，让后这里面会调用访问者的具体visit方法，然后再将自己作为对象传入这个访问者的具体visit方法中，在这个visit方法中就会调用一些对于对象进行操作的方法。 ObjectStructure: 这个类其实对于整个设计模式中关联性不是很强，可以忽略，它的作用就是将上述的Element放入一个集合中，可能我们会对这个集合进行遍历然后再进行操作等。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——Decoration模式]]></title>
    <url>%2F2019%2F07%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Decoration%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是装饰模式 参考自java中什么是装饰者模式? 看了老半天Decoration模式还是没看懂，后面看具体实现再去看UML图的时候突然恍然大悟。 首先，我们要先确定这个设计模式中有什么角色，有什么作用。 第一当然需要被装饰的类了，比如说有一个Component抽象类，然后又有一个ConcreateComponent实现类，这个具体的Component类就是具体我们需要装饰的类。 既然是装饰模式，当然需要装饰的类了，和其他设计模式一样，我们面向抽象编程，首先这个装饰的类我们先定义一个抽象的类AbstractDecoration，它继承了Component抽象类，这时候它就可以去重写Component类中需要被包装增强的方法了，并且它还拥有一个Component字段，我们只需要将Component(需要被包装的类)放入它的构造方法中，然后这个包装类重写被包装类的某个需要被包装的方法。 之后我们可以新增一些具体实现的包装类，比如MusicDecoration类，我们需要在包装方法前调用听音乐，我们这个MusicDecoration就可以新增一个listenMusic方法，并且在重写方法前添上这个方法的调用在调用字段的需要被包装方法前。 12345678// 重写打电话的方法@Overridepublic void call() &#123; // 在打电话之前听音乐 listenMusic(); // 因为super.call就是调用当前字段的call方法 super.call();&#125; 当我们需要在包装方法后面添加一个吃饭的方法，我们可以新增一个具体实现类EatDecoration类并且重写call方法。 12345678 // 重写打电话的方法@Overridepublic void call() &#123; // 因为super.call就是调用当前字段的call方法 super.call(); // 在调用完call之后新添加一个eat eat();&#125; 这时候我们就可以这样创建一个对象，并且调用。 12Phone phone = new EatDecoration(new MusicDecoration(new ConcreateComponent()));phone.call();]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式——Builder模式]]></title>
    <url>%2F2019%2F07%2F17%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是Builder模式 今天看了Builder设计模式，发现Builder模式和模板方法模式都差不多，不同的是——模板方法模式中对于方法的调用顺序是在原本抽象父类里面定义的，而建造者模式是在另一个Director类中定义的。 实现代码Builder类 123456public abstract class Builder&#123; public abstract void makeTitle(String title); public abstract void makeString(String str); public abstract void makeItems(String[] items); public abstract void close();&#125; 这个类主要是定义一些抽象方法提供一些子类Builder去实现。 比如这里的TextBuilder和AnotherBuilder等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class TextBuilder extends Builder&#123; private StringBuffer stringBuffer = new StringBuffer(); @Override public void makeTitle(String title)&#123; buffer.append("======\n"); buffer.append("[" + title + "]\n"); buffer.append("\n"); &#125; @Override public void makeString(String str)&#123; buffer.append(".." + str + "..\n"); buffer.append("\n"); &#125; @Override public void makeItems(String[] items)&#123; for(int i = 0; i &lt; items.length; i++)&#123; buffer.append("----" + items[i] + "----\n"); &#125; buffer.append("\n"); &#125; @Override public void close()&#123; buffer.append("================\n"); &#125; public String getResult() &#123; return buffer.toString(); &#125;&#125;public class AnotherBuilder extends Builder&#123; private StringBuffer stringBuffer = new StringBuffer(); @Override public void makeTitle(String title)&#123; buffer.append("&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n"); buffer.append("&#123;" + title + "&#125;\n"); buffer.append("\n"); &#125; @Override public void makeString(String str)&#123; buffer.append(str); &#125; @Override public void makeItems(String[] items)&#123; for(int i = 0; i &lt; items.length; i++)&#123; buffer.append("+++++" + items[i] + "++++\n"); &#125; buffer.append("\n"); &#125; @Override public void close()&#123; buffer.append("0000000000000\n"); &#125; public String getResult() &#123; return buffer.toString(); &#125;&#125; 前面两个子类分别不同实现了Builder抽象类，这时候我们创建一个Director类去拥有一个Builder实例，并且在Director中创建一个方法去控制Builder中实现的一些方法的顺序。 1234567891011121314151617181920public class Director&#123; private Builder builder; public Director(Builder builder)&#123; this.builder = builder; &#125; public void construct() &#123; builder.makeTitle("Title"); builder.makeString("String"); builder.makeItems(new String[]&#123; "xxx", "xxxx" &#125;); builder.makeString("endString"); builder.makeItems(new String[]&#123; "endxxx", "endxxx" &#125;); builder.close(); &#125;&#125; 总结 所谓建造者模式，就是变相的模板方法模式。其中我们的Builder是一个抽象类，其中定义了建造者的一些建造方法，这些方法都是一些细节的，比如说建造一个大楼，首先打地基可能就是Builder中需要定义实现的一个方法。然后一些实体类去实现这个抽象方法。之后我们定义了一个Director类，这个类拥有了一个Builder字段，然后有一个方法中调用了这个builder实体字段的某些建造方法比如打地基什么的，这个调用建造方法的方法可能还调用了其他建造方法，总之这个方法作为一个集大成者，将一些细节拼装起来，最后可能就建造了一座雄伟的大厦。 当我们需要构造一个非常复杂的对象的时候，我们可以使用Builder模式，我们可以将它拆解成一些细小的东西最后拼装起来，这有点像Flutter中的组件开发。 Builder模式和模板方法模式，我认为Builder模式更加松耦合。在模板方法模式中，定义方法的顺序或者执行的一些细节是在被实现的抽象父类中的，这个方法里面可能调用了许多抽象方法(当然不只是抽象，主要就是后面会被实现的)，模板方法模式在Servlet中的doGet，doPost中运用到了。而Builder模式是开辟了一个新的类，这个类拥有这个需要被实现方法的类，并且在新类中的方法中调用了需要被实现方法的类的方法。可以说，这里正好阐释了has有时候往往由于is。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java是解释执行吗]]></title>
    <url>%2F2019%2F07%2F15%2FJava%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%90%97%2F</url>
    <content type="text"><![CDATA[解释型语言 所谓解释型语言就是解释器对代码进行逐条解释，解释成本地机器代码然后直接运行 编译型语言 所谓编译型语言就是在程序运行之前，将代码提前编译成本地机器代码。 JIT编译技术 以前不是很懂JIT和解释型语言的区别，一直以为JIT就是解释型语言。其实JIT是在程序运行时将代码逐条编译成本地机器代码，看似和解释型语言的定义没啥区别，但是JIT最重要的是加了个缓存。根据程序的局部性原理，代码会被多次循环调用，JIT所做的就是将逐条解释编译成的机器代码存入缓存中，当再次对相同语句进行编译的时候直接从缓存中调用。因为局部性原理，所以性能不会有什么损失。 Java是解释执行吗 以前一直以为Java是编译型语言，因为从.java文件到.class文件需要一个编译的过程。 看了许多回答，其实大家对解释型语言和编译型语言都有着不同的见解。我觉得对于语言类型的定义并不重要，了解语言的本质才是精髓。 上文提到编译型语言，当编译型语言的程序生成了目标文件，这个目标文件是本地机器能直接运行的文件，它是针对cpu而言的，因为硬件本身的差异，编译型语言的程序当需要在另外一种cpu上面运行的时候，这个程序必须要重新编译。 这里我就直接定义为编译型语言就是在运行之前将程序直接编译成本机机器码的语言，如C，C++等。 而对于py，java这些语言来说，可能也存在着一些编译的过程，就比如说Java中需要先将.java文件编译成.class文件，而对于本地机器，它是无法运行.class文件的，所以我们称之为解释语言。对于.java到.class的编译，它的目的就是将代码编译成统一平台(JVM)上能看得懂的代码，它是一种中间代码，不是本地机器代码，之所以java代码能Write once, run anywhere就是因为JVM这个中间层的存在，因为jvm屏蔽了操作系统和硬件的细节，它会将.class文件转换为本地机器可以执行的本地代码。 我们通常会把Java分为编译期和运行时，上述就是编译期。而运行时的时候，JVM会通过类加载器(Class-Loader)加载字节码，解释或者编译执行。 注意这里是解释或者编译执行，在主流Java版本Java8中它就是解释和编译混合的一种模式。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter实例——搜索条的实现]]></title>
    <url>%2F2019%2F06%2F27%2FFlutter%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%9D%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[SearchDelegate 在Flutter中实现搜索框可以使用SearchDelegate来实现，我们需要将自己要实现搜索框的类继承于它，并且实现相关的方法。 buildSuggestions这个方法监听这query，query是用户键入的内容，这个方法一般返回一个ListView，然后将建议的列表放置其中，当列表中某一项被点击的时候应该通过回调showResults方法来显示结果。 buildResults用来构建搜索结果被提交后的显示结果 buildLeading查询条的左边头放置的部件，通常返回一个返回按钮并且触发close事件 buildActions查询条右边放置的组件，返回一个widget数组，通常里面存放着清除按钮，搜索按钮等 SearchDelegate源码及详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980abstract class SearchDelegate&lt;T&gt; &#123; // 建议显示在搜索页的正文中，而用户在搜索字段中键入一个查询。每当[Query]的内容发生变化时，都会调用委托方法。建议应该基于当前[Query]字符串。如果查询String为空，则根据PASS查询或当前上下文显示建议的查询是很好的做法。通常，此方法将返回一个[listview]，其中包含每个建议中的一个列表。当[listtile.ontab]被调用时，[query]应该用相应的建议来更新，结果页面应该通过调用[showResults]来显示。 Widget buildSuggestions(BuildContext context); // 用户从搜索页面提交搜索后显示的结果。可使用[Query]的当前值来确定用户搜索的内容。此方法可多次应用于同一查询。如果您的[构建结果]方法在计算上开销很大，您可能希望缓存一个或多个查询的搜索结果。通常，此方法返回带有搜索结果的[listview]。当用户点击特定的搜索结果时，[close]应该被调用，并将选定的结果作为参数。这将关闭搜索页面并将结果传回[SHOWSEARCH]的初始调用方。 Widget buildResults(BuildContext context); // 在[appbar]中当前查询之前显示的一个小部件。通常是一个配置了一个[backtton图标]的[偶像按钮]，该按钮退出带有[Close]的搜索。还可以使用由[过渡动画]驱动的[动画图标]，当搜索覆盖逐渐消失时，[动画图标]从汉堡包菜单到Back按钮。如果不显示小部件，则返回NULL。 Widget buildLeading(BuildContext context); // 在[appbar]中的搜索查询之后显示的小部件。如果[查询]不是空的，这通常应该包含到清除查询的按钮，并再次显示建议(通过[显示建议]) List&lt;Widget&gt; buildActions(BuildContext context); // 用于设置主题 默认为白色主题 ThemeData appBarTheme(BuildContext context) &#123; assert(context != null); final ThemeData theme = Theme.of(context); assert(theme != null); return theme.copyWith( primaryColor: Colors.white, primaryIconTheme: theme.primaryIconTheme.copyWith(color: Colors.grey), primaryColorBrightness: Brightness.light, primaryTextTheme: theme.textTheme, ); &#125; // 显示在[appbar]中的当前查询字符串。用户通过键盘操作此字符串。如果用户点击[buildSuggestions]提供的建议，则应通过setter将该string更新为该建议。 String get query =&gt; _queryTextController.text; set query(String value) &#123; assert(query != null); _queryTextController.text = value; &#125; // 从[BuildSuggestions]返回的建议转换到[BuildResults]返回的[查询]结果如果用户点击[BuildSuggestions]提供的建议，屏幕应典型地过渡到显示所建议查询的搜索结果的页面。同样的，使用[showSuggestions]可再次显示搜索建议。 void showResults(BuildContext context) &#123; _focusNode.unfocus(); _currentBody = _SearchBody.results; &#125; // 从显示[buildResults]返回的结果到显示/显示[BuildSuggestions]返回的建议。调用此方法还会将输入焦点放回[appbar]的搜索字段中。如果目前显示了结果，则可以使用此方法返回以显示搜索建议。 void showSuggestions(BuildContext context) &#123; FocusScope.of(context).requestFocus(_focusNode); _currentBody = _SearchBody.suggestions; &#125; // 关闭搜索页面并返回到底层路由。Result为为底层路由返回的值 void close(BuildContext context, T result) &#123; _currentBody = null; _focusNode.unfocus(); Navigator.of(context) ..popUntil((Route&lt;dynamic&gt; route) =&gt; route == _route) ..pop(result); &#125; // [animation]在搜索页面淡入或淡出时触发。此动画通常用于为[buildleading]或[buildactions]返回的[iconbutton]s设置动画。它还可以用于设置搜索页面下方路线中包含的[iconbutton]的动画。 Animation&lt;double&gt; get transitionAnimation =&gt; _proxyAnimation; // 是否选中 final FocusNode _focusNode = FocusNode(); // 输入框的控制器 final TextEditingController _queryTextController = TextEditingController(); // 设置过度动画 final ProxyAnimation _proxyAnimation = ProxyAnimation(kAlwaysDismissedAnimation); final ValueNotifier&lt;_SearchBody&gt; _currentBodyNotifier = ValueNotifier&lt;_SearchBody&gt;(null); _SearchBody get _currentBody =&gt; _currentBodyNotifier.value; set _currentBody(_SearchBody value) &#123; _currentBodyNotifier.value = value; &#125; _SearchPageRoute&lt;T&gt; _route;&#125; 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'search bar', theme: ThemeData(primarySwatch: Colors.cyan), home: SearchBarDemo(), ); &#125;&#125;class SearchBarDemo extends StatefulWidget &#123; @override _SearchBarDemoState createState() =&gt; _SearchBarDemoState();&#125;class _SearchBarDemoState extends State&lt;SearchBarDemo&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, title: Text('search bar demo'), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.search), onPressed: () &#123; showSearch(context: context, delegate: SearchBarDelegate()); &#125;, ) ], ), ); &#125;&#125;class SearchBarDelegate extends SearchDelegate&lt;String&gt; &#123; @override List&lt;Widget&gt; buildActions(BuildContext context) &#123; return [ IconButton( icon: Icon(Icons.clear), onPressed: () =&gt; query = '', ) ]; &#125; @override Widget buildLeading(BuildContext context) &#123; return IconButton( icon: AnimatedIcon( icon: AnimatedIcons.menu_arrow, progress: transitionAnimation, ), onPressed: () =&gt; close(context, null), ); &#125; @override Widget buildResults(BuildContext context) &#123; return Center( child: Container( width: 100.0, height: 100.0, child: Card( elevation: 50.0, color: Colors.green, child: Text( '$query', style: TextStyle(color: Colors.red), ), ), ), ); &#125; @override Widget buildSuggestions(BuildContext context) &#123; final suggestionList = query.isEmpty ? recentSuggest : searchList.where((input) =&gt; input.startsWith(query)).toList(); return ListView.builder( itemCount: suggestionList.length, itemBuilder: (context, index) =&gt; ListTile( onTap: () &#123; showResults(context); &#125;, title: RichText( text: TextSpan( text: suggestionList[index].substring(0, query.length), style: TextStyle( color: Colors.black, fontWeight: FontWeight.bold), children: [ TextSpan( text: suggestionList[index].substring(query.length), style: TextStyle(color: Colors.grey)) ])), )); &#125;&#125;const searchList = [ "jiejie-大长腿", "jiejie-水蛇腰", "gege1-帅气欧巴", "gege2-小鲜肉"];const recentSuggest = [ "推荐-1", "推荐-2"];]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter中的动画(一)]]></title>
    <url>%2F2019%2F06%2F24%2FFlutter%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[动画概述 对于任何UI框架，实现动画的原理都是一样的，通过画面在短时间内的变化形成动画，基本上人眼对30帧以上的动画的感受就是极限了，即在30帧以上人眼是基本区别不了的，在Flutter中，动画的平均帧率是可以达到60FPS的，这和原生基本持平，也是Flutter的一个特点。 主要涉及到的类 在Flutter中，实现动画主要涉及到四个类，分别是Animation,Curved,Tween,Controller。 其中Animation类是用来保存动画的插值和状态的 Curved是用来实现动态的变化方式，比如说一般变化是线性的，你可以通过设置不同Curved来实现不同的函数变化方式。 Tween，在默认情况下，AnimationController对象的值范围是在0.0到1.0之间，我们可以通过设置Tween来设置动画的值的变化范围以达到我们想要的效果。 Controller，用来控制动画的控制器。 Animation Animation对象本身和UI渲染没有关系，它是用来保存动画插值和状态的对象，我们可以查看Animation源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 abstract class Animation&lt;T&gt; extends Listenable implements ValueListenable&lt;T&gt; &#123; const Animation(); @override void addListener(VoidCallback listener); @override void removeListener(VoidCallback listener); void addStatusListener(AnimationStatusListener listener); void removeStatusListener(AnimationStatusListener listener); AnimationStatus get status; @override T get value; bool get isDismissed =&gt; status == AnimationStatus.dismissed; bool get isCompleted =&gt; status == AnimationStatus.completed; @optionalTypeArgs Animation&lt;U&gt; drive&lt;U&gt;(Animatable&lt;U&gt; child) &#123; assert(this is Animation&lt;double&gt;); return child.animate(this as dynamic); &#125; @override String toString() &#123; return '$&#123;describeIdentity(this)&#125;($&#123;toStringDetails()&#125;)'; &#125; String toStringDetails() &#123; assert(status != null); String icon; switch (status) &#123; case AnimationStatus.forward: icon = '\u25B6'; // &gt; break; case AnimationStatus.reverse: icon = '\u25C0'; // &lt; break; case AnimationStatus.completed: icon = '\u23ED'; // &gt;&gt;| break; case AnimationStatus.dismissed: icon = '\u23EE'; // |&lt;&lt; break; &#125; assert(icon != null); return '$icon'; &#125;&#125; Animation对象是一个在一段时间内一次生成一个区间(Tween)之间值的类，这种输出可以是线性的，曲线的(我们可以通过Curved来设置)，这个类中还为我们定义了一些监听器和状态监听器，我们可以通过设置监听器来监听动画发生的一些变化，然后做出一些改变。 addListener()可以给Animation添加帧监听器，在每一帧都会被调用。帧监听器中最常见的行为是改变状态后调用setState()来触发UI重建。 addStatusListener()可以给Animation添加“动画状态改变”监听器；动画开始、结束、正向或反向（见AnimationStatus定义）时会调用StatusListener。 Tween 刚刚提到了Animation是用来生成在Tween之间的值的对象。 我们先来查看一下源码 12345678910111213141516171819202122232425262728293031323334353637class Tween&lt;T extends dynamic&gt; extends Animatable&lt;T&gt; &#123; // Tween的构造函数，接受一个开始的泛型和结束的泛型 // 正如我们先前提到的Tween是一个范围 // 这里的范围可以是数值也可以使某种对象例如Color等 Tween(&#123; this.begin, this.end &#125;); // 泛型的开始 T begin; // 泛型的结束 T end; // 我们需要传入一个进度百分比 // 这个函数就能直接返还给我们当前进度的插值 @protected T lerp(double t) &#123; assert(begin != null); assert(end != null); return begin + (end - begin) * t; &#125; // 该transform封装了lerp函数 // 就是传入的值为0直接返回begin，为1返回end，如果不是那就返回lerp函数返回的值 // 所以要实现自定义lerp，我们需要重写lerp函数而不是transform @override T transform(double t) &#123; if (t == 0.0) return begin; if (t == 1.0) return end; return lerp(t); &#125; @override String toString() =&gt; '$runtimeType($begin \u2192 $end)';&#125; 因为Tween继承Animatable这个抽象类，这个抽象类中有一个方法animate方法，它用来返回一个Animation对象，所以对于Tween类我们通常设置完begin和end之后会调用原本继承于Animatable抽象类的animate方法设置一个Animation对象并赋值给一个Animation对象。 Curve Curve这个类是用来设置动画的变化曲线的，默认情况下是线性变化的。 我们一般使用CurveAnimation这个对象来自定义设置动画曲线，我们可以查看一下它的源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class CurvedAnimation extends Animation&lt;double&gt; with AnimationWithParentMixin&lt;double&gt; &#123; CurvedAnimation(&#123; @required this.parent, @required this.curve, this.reverseCurve, &#125;) : assert(parent != null), assert(curve != null) &#123; _updateCurveDirection(parent.status); parent.addStatusListener(_updateCurveDirection); &#125; // 用来设置父控制器，这里一般传入AnimationController // 用来将自己的curve添加到这个控制器中去。 @override final Animation&lt;double&gt; parent; // 设置自己的curve Curve curve; // 用来设置动画的反转时的曲线，不设置就和原来相等， // 为了保持动画在结束和反转开始的时候动画的连续性 // flutter会为我们将反转曲线的值和结束设置在同一点。 Curve reverseCurve; // 用来设置曲线的方向 // 只有动画结束或者开始的时候我们才能设置 // 以免造成动画的不连续性 AnimationStatus _curveDirection; // 更新curveDirection void _updateCurveDirection(AnimationStatus status) &#123; switch (status) &#123; case AnimationStatus.dismissed: case AnimationStatus.completed: _curveDirection = null; break; case AnimationStatus.forward: _curveDirection ??= AnimationStatus.forward; break; case AnimationStatus.reverse: _curveDirection ??= AnimationStatus.reverse; break; &#125; &#125; bool get _useForwardCurve &#123; return reverseCurve == null || (_curveDirection ?? parent.status) != AnimationStatus.reverse; &#125; @override double get value &#123; final Curve activeCurve = _useForwardCurve ? curve : reverseCurve; final double t = parent.value; if (activeCurve == null) return t; if (t == 0.0 || t == 1.0) &#123; assert(() &#123; final double transformedValue = activeCurve.transform(t); final double roundedTransformedValue = transformedValue.round().toDouble(); if (roundedTransformedValue != t) &#123; throw FlutterError( 'Invalid curve endpoint at $t.\n' 'Curves must map 0.0 to near zero and 1.0 to near one but ' '$&#123;activeCurve.runtimeType&#125; mapped $t to $transformedValue, which ' 'is near $roundedTransformedValue.' ); &#125; return true; &#125;()); return t; &#125; return activeCurve.transform(t); &#125; @override String toString() &#123; if (reverseCurve == null) return '$parent\u27A9$curve'; if (_useForwardCurve) return '$parent\u27A9$curve\u2092\u2099/$reverseCurve'; return '$parent\u27A9$curve/$reverseCurve\u2092\u2099'; &#125;&#125; 对于CurveAnimation我们可以直接使用构造方法来指定父controller和想要实现的curve AnimationController 用来实现动画的控制器，它包含动画的启动forward()、停止stop() 、反向播放 reverse()等方法。AnimationController会在动画的每一帧，就会生成一个新的值。默认情况下，AnimationController在给定的时间段内线性的生成从0.0到1.0（默认区间）的数字。 12345678910111213141516171819AnimationController(&#123; double value, // 接受一个Duration对象，可以设置持续时间 this.duration, this.debugLabel, // 设置动画值最低 this.lowerBound = 0.0, // 设置最高 this.upperBound = 1.0, this.animationBehavior = AnimationBehavior.normal, @required TickerProvider vsync,&#125;) : assert(lowerBound != null), assert(upperBound != null), assert(upperBound &gt;= lowerBound), assert(vsync != null), _direction = _AnimationDirection.forward &#123; _ticker = vsync.createTicker(_tick); _internalSetValue(value ?? lowerBound);&#125; Ticker 当创建一个AnimationController时，需要传递一个vsync参数，它接收一个TickerProvider类型的对象，它的主要职责是创建Ticker，定义如下： 1234abstract class TickerProvider &#123; //通过一个回调创建一个Ticker Ticker createTicker(TickerCallback onTick);&#125; Flutter应用在启动时都会绑定一个SchedulerBinding，通过SchedulerBinding可以给每一次屏幕刷新添加回调，而Ticker就是通过SchedulerBinding来添加屏幕刷新回调，这样一来，每次屏幕刷新都会调用TickerCallback。使用Ticker(而不是Timer)来驱动动画会防止屏幕外动画（动画的UI不在当前屏幕时，如锁屏时）消耗不必要的资源，因为Flutter中屏幕刷新时会通知到绑定的SchedulerBinding，而Ticker是受SchedulerBinding驱动的，由于锁屏后屏幕会停止刷新，所以Ticker就不会再触发。 通过将SingleTickerProviderStateMixin添加到State的定义中，然后将State对象作为vsync的值，这在后面的例子中可以见到。 使用例子 这里我们实现一个Icon通过动画的值来变化大小和颜色的动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class AnimateLove extends StatefulWidget &#123; @override _AnimateLoveState createState() =&gt; _AnimateLoveState();&#125;class _AnimateLoveState extends State&lt;AnimateLove&gt; with TickerProviderStateMixin &#123; // 用来保存动画的插值 Animation&lt;double&gt; _animation; // 动画的控制器 AnimationController _animationController; // 动画实现曲线效果 CurvedAnimation _curvedAnimation; // 用来保存动画的值(这里则是Color) Animation&lt;Color&gt; _colorTween; @override void initState() &#123; super.initState(); // 首先初始化动画控制器 // 这个类需要with一个TickerProviderStateMixin // 这个类提供一个this实现动画的垂直同步 _animationController = AnimationController( // 接受一个Duration，可以设置动画的持续时间 duration: Duration(seconds: 2), // 设置垂直同步 vsync: this ); // 初始化一个动画曲线 // 接受一个parent参数，这个是指定需要实现这个curve曲线的相应的动画控制器 // 接受的curve参数是具体实现了什么curve _curvedAnimation = CurvedAnimation(parent: _animationController, curve: Curves.fastLinearToSlowEaseIn); // Tween用来设置动画的插值 // 并且使用animate方法(参数是用来接受这个范围值的父Animation，通常为CurveAnimation)用来将范围值保存到一个Animation对象中 _colorTween = ColorTween(begin: Colors.red[200], end: Colors.red[800]).animate(_curvedAnimation); // 这里也是设置一个动画保存值，这里是double _animation = Tween(begin: 0.0, end: 100.0).animate(_curvedAnimation) // 添加监听器，变化的时候重新设置UI渲染 ..addListener(()&#123; setState(() &#123;&#125;); // 增加状态监听器，这里接受一个带status状态参数的一个方法 &#125;)..addStatusListener((status)&#123; // 这里实现的主要功能就是判断动画是否结束，结束就方向播放动画 if(status == AnimationStatus.completed) &#123; _animationController.reverse(); &#125; else if (status == AnimationStatus.dismissed) &#123; _animationController.forward(); &#125; &#125;); // 初始化设置动画向前开始 _animationController.forward(); &#125; @override void dispose() &#123; // 销毁 减少资源浪费 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Center( child: Icon( Icons.favorite, // 将数值赋给size size: _animation.value, // 将color赋值给color color: _colorTween.value, ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——表单组件]]></title>
    <url>%2F2019%2F06%2F19%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[TextField 在Flutter中TextField是最重要的一个表单组件，它是定义输入框，密码框以及textarea。 其中有几个重要的属性 maxLines 最大行数接受一个int，当这个设置为1时，就是我们平常的文本框了，你可以把它设置成更大，然后让它变成一个textarea。 onChanged 接受一个函数，函数中传入一个当前文本框值的参数，通过这个我们可以在文本框值改变的时候设置我们的值。 decoration 设置文本框的样式，接受一个InputDecoration对象，这个对象中的属性用来设置当前文本框的样式属性，比如说hintText类似于html的placeholder，labelText设置标签的文本，labelStyle设置标签文本文字样式(跟TextStyle用法一样), border设置文本框边框，我们可以传入一个OutlineInputBorder等。 obscureText 是否设置为密码框，默认为false，设置为true的时候就是密码框。 controller 接受一个TextEditController，我们可以在组件初始化的时候创建一个关于当前文本框的TextEditController，然后我们通过addListener函数来监听当前文本框的变化，它的作用比onChanged还要大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const TextField(&#123; Key key, this.controller, this.focusNode, this.decoration = const InputDecoration(), TextInputType keyboardType, this.textInputAction, this.textCapitalization = TextCapitalization.none, this.style, this.strutStyle, this.textAlign = TextAlign.start, this.textDirection, this.autofocus = false, this.obscureText = false, this.autocorrect = true, this.maxLines = 1, this.minLines, this.expands = false, this.maxLength, this.maxLengthEnforced = true, this.onChanged, this.onEditingComplete, this.onSubmitted, this.inputFormatters, this.enabled, this.cursorWidth = 2.0, this.cursorRadius, this.cursorColor, this.keyboardAppearance, this.scrollPadding = const EdgeInsets.all(20.0), this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection, this.onTap, this.buildCounter, this.scrollPhysics, &#125;) : assert(textAlign != null), assert(autofocus != null), assert(obscureText != null), assert(autocorrect != null), assert(maxLengthEnforced != null), assert(scrollPadding != null), assert(dragStartBehavior != null), assert(maxLines == null || maxLines &gt; 0), assert(minLines == null || minLines &gt; 0), assert( (maxLines == null) || (minLines == null) || (maxLines &gt;= minLines), 'minLines can\'t be greater than maxLines', ), assert(expands != null), assert( !expands || (maxLines == null &amp;&amp; minLines == null), 'minLines and maxLines must be null when expands is true.', ), assert(maxLength == null || maxLength == TextField.noMaxLength || maxLength &gt; 0), keyboardType = keyboardType ?? (maxLines == 1 ? TextInputType.text : TextInputType.multiline), super(key: key); Checkbox,CheckboxListTile多选框组件Checkbox常见属性 value 当前多选框的值，设置成true或者false。 onChanged 在多选框的值被改变的时候调用的函数 activeColor 选中的背景颜色 checkColor 选中的√的颜色 CheckboxListTile checkboxListTile是类似于ListTile的多选框，其中也可以像ListTile中定义title，subtitle等。 value 当前多选框的值，设置成true或者false onChanged 改变的时候接受的函数 title， subtitle 标题 secondary 在前面设置图片或者图片 selected 选中的时候是否文字颜色跟着改变 Radio，RadioListTile Radio和checkbox差不多，主要就是一个groupValue。 radio中有一个value是定义当前单选按钮的value，还有一个是groupValue是定义当前单选按钮对应的组的值。其他属性和checkbox差不多，同理RadioListTile也和checkboxListTile也差不多。 Demo代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Form App', debugShowCheckedModeBanner: false, theme: ThemeData(primarySwatch: Colors.green), home: Scaffold( resizeToAvoidBottomPadding: false, appBar: AppBar( title: Text('Form'), ), body: MyForm(), ), ); &#125;&#125;class MyForm extends StatefulWidget &#123; @override _MyFormState createState() =&gt; _MyFormState();&#125;class _MyFormState extends State&lt;MyForm&gt; &#123; TextEditingController _usernameController = TextEditingController(); TextEditingController _passwordController = TextEditingController(); TextEditingController _informationController = TextEditingController(); bool _checkBool = false; bool _switchBool = false; int _groupValue = 0; @override void initState() &#123; super.initState(); _usernameController.addListener(() &#123; print(_usernameController.text); &#125;); _passwordController.addListener(() &#123; print(_usernameController.text); &#125;); _informationController.addListener(() &#123; print(_usernameController.text); &#125;); &#125; @override Widget build(BuildContext context) &#123; return Center( child: Container( margin: EdgeInsets.only(left: 20.0, right: 20.0), padding: EdgeInsets.all(20.0), height: 750.0, width: 550.0, child: Card( color: Colors.green[200], shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(50.0), ), child: Padding( padding: EdgeInsets.only(left: 20.0, right: 20.0), child: Column( mainAxisAlignment: MainAxisAlignment.start, children: &lt;Widget&gt;[ SizedBox( height: 20.0, ), Container( child: Text('Login', textScaleFactor: 2.5, textAlign: TextAlign.center), ), TextField( controller: this._usernameController, maxLines: 1, onChanged: (username) &#123; print(username); &#125;, decoration: InputDecoration( hintText: 'username', labelText: 'username', icon: Icon(Icons.person)), ), TextField( controller: this._passwordController, maxLines: 1, onChanged: (password) =&gt; debugPrint(password), decoration: InputDecoration( hintText: 'code', labelText: 'code', icon: Icon(Icons.message), ), obscureText: true, ), SizedBox( height: 30.0, ), TextField( controller: this._informationController, maxLines: 1, onChanged: (content) &#123; debugPrint(content); &#125;, decoration: InputDecoration( hintText: 'please input your information here', border: OutlineInputBorder( borderSide: BorderSide( color: Colors.purple, width: 1.5, style: BorderStyle.solid))), ), Row( children: &lt;Widget&gt;[ Text('remember'), Checkbox(value: this._checkBool, onChanged: (value) &#123; setState(() &#123; this._checkBool = value; print(value); &#125;); &#125;, checkColor: Colors.indigo,), Text('remember'), Expanded( child: Switch(value: this._switchBool, onChanged: (value)&#123; setState(() &#123; this._switchBool = value; &#125;); &#125;,activeColor: Colors.indigo,), ), ], ), CheckboxListTile( title: Text('checktile'), subtitle: Text('this is CheckBoxListTile'), secondary: Icon(Icons.album), value: this._checkBool, onChanged: ((value)&#123; setState(() &#123; this._checkBool = value; &#125;); &#125;), selected: true, ), Row( children: &lt;Widget&gt;[ Text('male'), Radio(value: 0, groupValue: this._groupValue, onChanged: (value)&#123; setState(() &#123; this._groupValue = value; &#125;); &#125;, activeColor: Colors.red,), Text('female'), Radio(value: 1, groupValue: this._groupValue, onChanged: (value)&#123; setState(() &#123; this._groupValue = value; &#125;); &#125;) ], ), RadioListTile(value: 0, groupValue: this._groupValue, onChanged: (value)&#123; setState(() &#123; this._groupValue = value; &#125;); &#125;, title: Text('female'), subtitle: Text('this is female radio')), RadioListTile(value: 1, groupValue: this._groupValue, onChanged: (value)&#123; setState(() &#123; this._groupValue = value; &#125;); &#125;, title: Text('female'), subtitle: Text('this is female radio'),), Container( height: 50.0, width: 150.0, child: RaisedButton( shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(50.0), ), color: Colors.blue, onPressed: () &#123; if (_usernameController.text == 'francisqiang' &amp;&amp; _passwordController.text == '123456' &amp;&amp; _informationController.text != '') &#123; print('success'); &#125; else &#123; print('fail'); &#125; &#125;, child: Text( 'Sign In', textScaleFactor: 2.0, style: TextStyle( color: Colors.cyanAccent, fontWeight: FontWeight.bold), ), ), ) ], ), )), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——侧边栏Drawer]]></title>
    <url>%2F2019%2F06%2F17%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%E4%BE%A7%E8%BE%B9%E6%A0%8FDrawer%2F</url>
    <content type="text"><![CDATA[Drawer 在Flutter中的Scaffold中有一个drawe属性，这个属性是定义页面的左边滑动抽屉的。如果我们没有在AppBar中设置自己的leading属性(控制左边的按钮)，Flutter会默认给我配置它自己的按钮。 我们可以首先查看一下Drawer中的构造函数源代码。 1234567const Drawer(&#123; Key key, this.elevation = 16.0, this.child, this.semanticLabel,&#125;) : assert(elevation != null &amp;&amp; elevation &gt;= 0.0), super(key: key); elevation 控制z轴阴影效果，接受一个double。 child 子元素，里面通常存放一个Container再嵌套一个ListView。 semanticLabel 语意标签，目前还不知道做什么的。 DrawerHearder源代码 123456789const DrawerHeader(&#123; Key key, this.decoration, this.margin = const EdgeInsets.only(bottom: 8.0), this.padding = const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0), this.duration = const Duration(milliseconds: 250), this.curve = Curves.fastOutSlowIn, @required this.child, &#125;) : super(key: key); 其中decoration用来设置容器的样式装饰，比如形状，颜色等。margin和padding是用来设置边距的，后面的duration和curve是动画内容，现在我还弄清楚怎么用。 UserAccountsDrawerHeader 如果我们想快速构建个人信息页面的话我们可以直接使用UserAccountDrawerHeader，这个类替我们封装了DrawerHeader，我们可以查看它的源代码。 12345678910const UserAccountsDrawerHeader(&#123; Key key, this.decoration, this.margin = const EdgeInsets.only(bottom: 8.0), this.currentAccountPicture, this.otherAccountsPictures, @required this.accountName, @required this.accountEmail, this.onDetailsPressed, &#125;) : super(key: key); 我们查看它的build方法就可以知道其中它使用了Drawer 123456789101112131415161718192021222324252627282930313233343536373839@overrideWidget build(BuildContext context) &#123; assert(debugCheckHasMaterial(context)); assert(debugCheckHasMaterialLocalizations(context)); return Semantics( container: true, label: MaterialLocalizations.of(context).signedInLabel, child: DrawerHeader( decoration: widget.decoration ?? BoxDecoration( color: Theme.of(context).primaryColor, ), margin: widget.margin, padding: const EdgeInsetsDirectional.only(top: 16.0, start: 16.0), child: SafeArea( bottom: false, child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Expanded( child: Padding( padding: const EdgeInsetsDirectional.only(end: 16.0), child: _AccountPictures( currentAccountPicture: widget.currentAccountPicture, otherAccountsPictures: widget.otherAccountsPictures, ), ), ), _AccountDetails( accountName: widget.accountName, accountEmail: widget.accountEmail, isOpen: _isOpen, onTap: widget.onDetailsPressed == null ? null : _handleDetailsPressed, ), ], ), ), ), );&#125; 我们先来看一下UserAccountDrawer中的属性 decoration 盒子装饰属性 margin 边距 currentAccountPricture 当前用户的头像 otherAccountPicture 其他用户的头像，放在当前头像的右边。 accountName，accountEmail 用户的名字和邮箱。 Drawer的代码示例12345678910111213141516171819202122232425262728293031323334353637383940Drawer( elevation: 200.0, child: Container( alignment: Alignment.center, child: ListView( padding: EdgeInsets.zero, children: &lt;Widget&gt;[ UserAccountsDrawerHeader( accountName: Text('FrancisQiang', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 30.0),), accountEmail: Text('2487049041@qq.com'), currentAccountPicture: CircleAvatar( backgroundImage: NetworkImage('https://francisqiang.github.io/images/avatar.gif'), ), decoration: BoxDecoration( image: DecorationImage( image: NetworkImage('https://francisqiang.github.io/2019/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Trie/10.jpg'), fit: BoxFit.cover, colorFilter: ColorFilter.mode( Colors.purple.withOpacity(0.3), BlendMode.srcOver ) ), ), ), ListTile( title: Text('Message', textAlign: TextAlign.right,), trailing: Icon(Icons.message, color: Colors.blueAccent, size: 25.0,), ), ListTile( title: Text('Favorite', textAlign: TextAlign.right,), trailing: Icon(Icons.favorite, color: Colors.red, size: 25.0,), ), ListTile( title: Text('Setting', textAlign: TextAlign.right,), trailing: Icon(Icons.settings,color: Colors.black87, size: 25.0,), ), ], ) ), ),]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter中的底部导航和顶部导航]]></title>
    <url>%2F2019%2F06%2F14%2FFlutter%E4%B8%AD%E7%9A%84%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E5%92%8C%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[BottomNavigatorBar Flutter中实现底部导航需要在Scaffold脚手架中赋值bottomNavigationBar参数，这个参数接受一个Widget，一般我们直接赋值BottomNavigationBar对象。 其中有几个参数比较重要 currentIndex 当前item元素的索引 onTap 当点击的时候触发的函数 items 存放路由导航的的按钮(小部件)。 需要注意的是整个脚手架需要放置在动态组件中。 代码示例123456789101112131415161718192021222324252627282930313233343536373839class MyScaffold extends StatefulWidget &#123; @override _MyScaffoldState createState() =&gt; _MyScaffoldState();&#125;class _MyScaffoldState extends State&lt;MyScaffold&gt; &#123; int _currentIndex = 0; // 定义导航切换的路由 List&lt;Widget&gt; _tabsWidget = [TabControllerPage(), MyMessage(), MySetting()]; @override Widget build(BuildContext context) &#123; return DefaultTabController( length: 2, child: Scaffold( appBar: AppBar( centerTitle: true, title: Text('Tab Demo'), leading: IconButton(icon: Icon(Icons.favorite), onPressed: () &#123;&#125;), ), bottomNavigationBar: BottomNavigationBar( currentIndex: this._currentIndex, // 触发重构页面 onTap: (index) =&gt; setState(() =&gt; this._currentIndex = index), items: [ BottomNavigationBarItem( icon: Icon(Icons.home), title: Text('home')), BottomNavigationBarItem( icon: Icon(Icons.message), title: Text('message')), BottomNavigationBarItem( icon: Icon(Icons.settings), title: Text('settings')) ], ), body: _tabsWidget[this._currentIndex], ), ); &#125;&#125; TabBar TabBar是用来实现顶部滑动导航的。我们可以放置在脚手架中appBar中的bottom中。 但最需要注意的是我们需要在脚手架外层嵌套一个DefaultTabController，我们必须要定义这个组件中的length属性，这是用来定义导航条的数目的。然后我们再bottom中定义一个TabBar，里面的tabs属性接受一个Widget数组，数组中存放导航条，然后我们可以在Scaffold中的body里面添加TabBarView，TabBarView里面有children属性，是用来存放导航的主页面的，所以我们这里DefaultTabController中的length属性和bottom中tabs中数组的长度还有这个children数组的长度，三者必须一样。 其实这里就是在你想要实现顶部导航页面外层嵌套DefaultTabController并且定义长度，然后再里面定义TabBar和TabBarView，这个DefaultTabController用来对TabBar和TabBarView进行”连接”和监听。 常规顶部导航代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class MyScaffold extends StatefulWidget &#123; @override _MyScaffoldState createState() =&gt; _MyScaffoldState();&#125;class _MyScaffoldState extends State&lt;MyScaffold&gt; &#123; @override Widget build(BuildContext context) &#123; return DefaultTabController( length: 2, child: Scaffold( appBar: AppBar( centerTitle: true, title: Text('Tab Demo'), leading: IconButton(icon: Icon(Icons.favorite), onPressed: () &#123;&#125;), bottom: TabBar( isScrollable: true, tabs: &lt;Widget&gt;[ Tab( text: 'hot', ), Tab( text: 'recommend', ) ], ), ), body: TabBarView( children: &lt;Widget&gt;[ ListView( children: &lt;Widget&gt;[ ListTile( title: Text('111111'), ), ListTile( title: Text('222222'), ), ListTile( title: Text('333333'), ), ], ), ListView( children: &lt;Widget&gt;[ ListTile( title: Text('111111'), ), ListTile( title: Text('222222'), ), ListTile( title: Text('333333'), ), ], ), ], ), ), ); &#125;&#125; 如果我们页面里面已经有底层导航了，这时候我们就不同在appBar中的bottom属性中存放导航条了。 比如你现在有三个底部导航路由，然后你在总的Scaffold中的appBar中添加顶部导航栏，这样就会使你的底部三个页面都存在这个顶部导航栏。 如果你在另一个页面再次使用Scaffold构建子页面 你可以做在appBar的title中定义TabBar，appBar的title属性接受一个Widget，你可以将TabBar赋值给它。或者你可以在新建的脚手架中不使用appBar属性。 自定义TabBar 我们需要在一个动态组件中创建一个TabController 然后这个组件需要with(类似多继承)一个SingleTickerProviderStateMixin(用来设置TabController中的vsync垂直同步属性的)。然后我们这时候不需要使用DefaultTabController来嵌套组件了，我们只需要在TabBar和TabBarView组件中定义他们的Controller属性为我们的controller，当然我们需要在init组件的时候创建controller。 使用自定义的好处就是我们可以监听controller的状态从而定制一些个性化的操作。 自定义TabController代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import 'package:flutter/material.dart';class AppBardemoPage extends StatefulWidget &#123; AppBardemoPage(&#123;Key key&#125;) : super(key: key); _AppBardemoPageState createState() =&gt; _AppBardemoPageState();&#125;class _AppBardemoPageState extends State&lt;AppBardemoPage&gt; with SingleTickerProviderStateMixin &#123; TabController _tabController; @override void dispose() &#123; _tabController.dispose(); super.dispose(); &#125; void initState() &#123; super.initState(); _tabController = new TabController(vsync: this, length: 3); // 我们这时候可以添加监听器来实现自定义 _tabController.addLinstener(()&#123; // 获取控制器的一些值来改变一些UI组件 print(_tabController.index); &#125;); &#125; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('顶部 tab 切换'), bottom: new TabBar( tabs: &lt;Widget&gt;[ new Tab( icon: new Icon(Icons.directions_bike),), new Tab( icon: new Icon(Icons.directions_boat),), new Tab( icon: new Icon(Icons.directions_bus),), ], controller: _tabController,),), body: new TabBarView( controller: _tabController, children: &lt;Widget&gt;[ new Center(child: new Text('自行车')), new Center(child: new Text('船')), new Center(child: new Text('巴士')), ],),); &#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter路由和路由传值]]></title>
    <url>%2F2019%2F06%2F12%2FFlutter%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[基本路由 在Flutter中路由跳转是通过Navigator这个类进行操作的，它是一种堆栈的结构，主要有两个操作一个是push就是入栈操作，他会把当前页面放入栈顶并显示。还有一个就是pop，它会把当前页面进行出栈操作，并显示操作之后最上层的页面。 使用的时候我们需要先将需要跳转的页面文件进行导入，然后使用Navigator.push(context,MaterialPageRoute()),进行跳转。 1234567891011121314RaisedButton( child: Text("跳转到搜索页面"), onPressed: ()&#123; Navigator.of(context).push(MaterialPageRoute( builder: (BuildContext context)&#123; return SearchPage(); &#125; ) );&#125;,color: Theme.of(context).accentColor,textTheme: ButtonTextTheme.primary) 当pop的时候 123456789RaisedButton( child: Text("跳转到搜索页面"), onPressed: ()&#123; Navigator.of(context).pop();&#125;,color: Theme.of(context).accentColor,textTheme: ButtonTextTheme.primary) 当然Navigator.of(context).push(xxx),Navigator.of(context).pop(xxx)也可以直接使用Navigator.push(context,xxx)或者Navigator.pop(context),其实原理都差不多只是后者封装了前者。 1234@optionalTypeArgsstatic Future&lt;T&gt; push&lt;T extends Object&gt;(BuildContext context, Route&lt;T&gt; route) &#123; return Navigator.of(context).push(route);&#125; 基本路由传参 基本路由传参其实就是在需要传参的页面中的构造器加入需要传参的字段，然后通过构造器中的相应参数去传参。 123Navigator.push(context, MaterialPageRoute(builder: (context)&#123; return MyParam(title: '哈哈哈哈',);&#125;)); 构造器 12345678910111213141516171819202122232425262728293031323334class MyParam extends StatelessWidget &#123;final String title;MyParam(&#123;Key key, this.title&#125;):super(key: key);@overrideWidget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Test'), ), body: Center( child: Container( height: 300.0, width: 200.0, decoration: BoxDecoration( color: Colors.amber ), child: Column( children: &lt;Widget&gt;[ Text('$title'), RaisedButton( child: Text('返回'), onPressed: ()&#123; Navigator.pop(context); &#125;, ) ], ) ), ), ); &#125;&#125; 当我们需要返回数据的时候(pop操作) 我们可以使用pop里面的result参数 1234@optionalTypeArgsstatic bool pop&lt;T extends Object&gt;(BuildContext context, [ T result ]) &#123; return Navigator.of(context).pop&lt;T&gt;(result);&#125; 注意我们push方法返回的是一个Future，我们可以直接使用.then方法接受参数 123456789Navigator.push&lt;String&gt;(context, new MaterialPageRoute(builder: (BuildContext context)&#123; return new ThirdPage(title:"请输入昵称");&#125;)).then( (String result)&#123; //处理代码&#125;); 命名路由 命名路由有点类似于Vue中的路由，我们需要将使用到的路由注册到MaterialApp中的routes参数中，这个routes参数是一个map 12345678910111213class MyApp extends StatelessWidget &#123;@overrideWidget build(BuildContext context) &#123;return MaterialApp( // home:Tabs(), initialRoute: '/', routes: &#123; '/':(contxt)=&gt;Tabs(), '/search':(contxt) =&gt;SearchPage(), '/form': (context) =&gt; FormPage(), &#125;, ); &#125;&#125; initalRoute就是初始路由。 然后我们就可以使用Navigator.pushNamed(context,routeName)这个方法进行跳转页面了。 命名路由传参 命名路由传参主要借助于MaterialApp的onGeneratorRoute属性，这里面接受一个RouteFactory，其实返回的就是Route。 我们首先要删除routes属性(必须要，不然无法使用)。然后我们自己定义一个route的map。 1234567891011121314151617181920212223242526272829303132333435363738class MyApp extends StatelessWidget &#123; // 我们需要在routes里面做些小变动，(context)需要变成(context,&#123;arguments&#125;) // 然后通过构造方法进行传参 final routes=&#123; '/':(context)=&gt;Tabs(), '/form':(context)=&gt;FormPage(), '/product':(context)=&gt;ProductPage(), '/productinfo':(context,&#123;arguments&#125;)=&gt;ProductInfoPage(arguments:arguments), '/search':(context,&#123;arguments&#125;)=&gt;SearchPage(arguments:arguments), &#125;; @override Widget build(BuildContext context) &#123; return MaterialApp( // home:Tabs(), initialRoute: '/', //初始化的时候加载的路由 onGenerateRoute: (RouteSettings settings) &#123; // 统一处理 final String name = settings.name; final Function pageContentBuilder = routes[name]; if (pageContentBuilder != null) &#123; if (settings.arguments != null) &#123; final Route route = MaterialPageRoute( builder: (context) =&gt; pageContentBuilder(context, arguments: settings.arguments)); return route; &#125;else&#123; final Route route = MaterialPageRoute( builder: (context) =&gt; pageContentBuilder(context)); return route; &#125; &#125; &#125; ); &#125;&#125; 当然，我们的Navigator也需要变动 1234//路由跳转Navigator.pushNamed(context, '/search',arguments: &#123; "id":123&#125;); 这里我们需要增加argument参数(这是原本方法自带的参数)]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——Stack，Card]]></title>
    <url>%2F2019%2F06%2F10%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Stack%EF%BC%8CCard%2F</url>
    <content type="text"><![CDATA[Stack Stack也是一个布局组件，它用于有子组件堆叠的场景，而且当我们使用Positioned组进行辅助的时候我们可以是层叠效果变得非常灵活。 alignment它接受一个AlignmentDirectional对象，它用于控制non-positioned组件在Stack组件中的位置。默认为topStart(左上角) overflow它接受一个Overflow对象，用于控制溢出部分的显示效果 textDirection用于控制子组件排列方向，接受一个TextDirection对象有ltr，rtl这些值。 fit用于控制如何设置non-positioned节点尺寸，默认为loose。接受一个StackFit对象，里面有loose，expand，passthrough三个枚举常量。 children放置子元素组件。其中可以放置positioned组件Positioned组件中有left，right，top，bottom，width，height等属性，上下左右用来控制在Stack的位置的，这个组件不受alignment属性的影响。 源码 123456789101112131415161718192021Stack(&#123; Key key, this.alignment = AlignmentDirectional.topStart, this.textDirection, this.fit = StackFit.loose, this.overflow = Overflow.clip, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) : super(key: key, children: children);const Positioned(&#123; Key key, this.left, this.top, this.right, this.bottom, this.width, this.height, @required Widget child,&#125;) : assert(left == null || right == null || width == null), assert(top == null || bottom == null || height == null), super(key: key, child: child); Card 这是一个容器组件，就是卡片的样子 源代码 12345678910111213const Card(&#123; Key key, this.color, this.elevation, this.shape, this.borderOnForeground = true, this.margin, this.clipBehavior, this.child, this.semanticContainer = true, &#125;) : assert(elevation == null || elevation &gt;= 0.0), assert(borderOnForeground != null), super(key: key); color接受一个Color对象，用来设置卡片的颜色。 elevation控制z轴的高度，就是阴影效果，接受一个double值。 shape控制卡片的形状，接受一个shapeBorder对象，我们可以将RoundedRectangleBorder对象赋值给它，这是事项圆角卡片的对象。 borderOnForeground接受一个布尔值，默认为true，当设置为true的时候，边框渲染会在子元素前面，false就相反。 margin用于控制外边距，接受一个EdgeInsetsGeometry对象。 semanticContainer接受一个bool，将此标志设置为true将尝试将所有子语义合并到此节点中。将此标志设置为false会强制所有子语义节点显式。这是文档里面的解释，我不太理解，但是官方说当你子元素是多种类型的时候最好设置为false，其默认也是false。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——Row，Column]]></title>
    <url>%2F2019%2F06%2F09%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Row%EF%BC%8CColumn%2F</url>
    <content type="text"><![CDATA[Row Row组件是一种很常见的布局组件，顾名思义就是水平一行的组件。它将里面的子组件排成一行，如果其子组件超出一行的范围，那么会报错。 mainAxisAlignmentRow组件分为两个方向，分别是主轴和副轴。mainAxisAlignment是控制子组件在主轴方向上的排列方式的。它接受一个MainAxisAlignment对象。 center 设置主轴中心 end 放在主轴末尾 spaceAround 将主轴方向上的空白区域均分，使children之间的空白区域相等，但是首尾child的空白区域为1/2 spaceBetween 和spaceAround差不多，但是首尾children没有空隙 spaceEvenly 是children空白区域相等包括首尾部分。 mainAxisSize它接受一个MainAxisAlignment对象，它决定了主轴方向上占有空间的值，默认是max。max是最大化主轴方向的可用空间，min则相反。 crossAxisAlignment它接受一个CrossAxisAlignment对象，控制的是在副轴上子元素排列的方式，其中有end，start，center等。 verticalDirection它接受一个VerticalDirection对象，定义了children的摆放顺序(我也不是很了解)。 Row的构造函数源码 1234567891011121314151617181920 Row(&#123; Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) : super( children: children, key: key, direction: Axis.horizontal, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline,); Column 了解了Row组件之后Column组件就非常简单了，字面理解Column组件就是控制纵向的布局组件，其属性和Row非常类似，我们可以直接看构造方法的源代码 1234567891011121314151617181920 Column(&#123; Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) : super( children: children, key: key, direction: Axis.vertical, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline,);]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——ListView和GridView]]></title>
    <url>%2F2019%2F06%2F08%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94ListView%E5%92%8CGridView%2F</url>
    <content type="text"><![CDATA[ListView组件 ListView是可滚动的列表组件，使用的范围非常广。 静态构建ListView我们直接使用ListView标准构造函数就可以构建了(只适合列表元素已经确定并且数目比较少的时候)。里面最重要的一个属性就是children，里面接受一个Widget数组，我们可以将需要的放置的组件放入数组里面。 动态构造ListViewListView的标准构造函数会将所有item一次性创建，而ListView.builder会创建滚动到屏幕上显示的item。 ListView.builder其实是dart里面的一种可命名构造函数(直接理解为一种构造函数就好了)。还有这两种ListView.separatedListView.custom。 我们直接来看builder命名构造函数的属性 首先我们看一下源码 1234567891011121314151617181920212223242526272829303132333435363738 ListView.builder(&#123; Key key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, bool shrinkWrap = false, EdgeInsetsGeometry padding, this.itemExtent, @required IndexedWidgetBuilder itemBuilder, int itemCount, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double cacheExtent, int semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start,&#125;) : childrenDelegate = SliverChildBuilderDelegate( itemBuilder, childCount: itemCount, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes, ), super( key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, shrinkWrap: shrinkWrap, padding: padding, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount ?? itemCount, dragStartBehavior: dragStartBehavior, ); 构造函数后面的childrenDelegate和super是初始化列表，先只作了解。 itemBuilder 这个属性是required的，他需要一个IndexedWidgetBuilder对象,我们查看源码发现他是一个方法，参数是上下文对象BuildContext和index。 1typedef IndexedWidgetBuilder = Widget Function(BuildContext context, int index); 所以这里面我们可以直接传进去一个方法，参数是上下文和index，需要返回一个Widget，我们这里直接可以使用匿名函数加上胖箭头表达式。 itemCount 这个属性是指定item(元素)的个数 scrollDirection 指定能滑动方向，接受一个Axis，其中可以设置horizontal或者vertical，默认为vertical(垂直方向)。 itemExtent 接受double类型参数，指定每个元素在滑动方向所占的高度值。 padding 设置内边距 GridView组件 我们首先看一下GridView常用的count命名构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445 GridView.count(&#123; Key key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, bool shrinkWrap = false, EdgeInsetsGeometry padding, @required int crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double cacheExtent, List&lt;Widget&gt; children = const &lt;Widget&gt;[], int semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start,&#125;) : gridDelegate = SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: crossAxisCount, mainAxisSpacing: mainAxisSpacing, crossAxisSpacing: crossAxisSpacing, childAspectRatio: childAspectRatio, ), childrenDelegate = SliverChildListDelegate( children, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes, ), super( key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, shrinkWrap: shrinkWrap, padding: padding, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount ?? children.length, dragStartBehavior: dragStartBehavior, ); 其中有很多属性是和ListView的一样的 reverse 接受bool，是否沿反方向滚动 controller 控制child滚动时候的位置 shrinkWrap 滚动方向的滚动视图内容是否应该由正在查看的内容所决定。 primary 是否是与父节点的PrimaryScrollController所关联的主滚动视图。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——Image]]></title>
    <url>%2F2019%2F06%2F06%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Image%2F</url>
    <content type="text"><![CDATA[Image Image就是图片组件，其中分为很多中，比如说network(url 获取图片)，asset(本地获取图片)，还有File，Memory。这里我学习了network和asset的。 必须属性这里必须属性和Text组件的字符串内容差不多，我们需要加入图片地址，asset需要放入本地地址，network需要放入网络地址。不过在new Image.asset之前，我们需要在yaml文件中注册asset资源 123flutter: assets: - images/avatar.gif width,height宽高设置，需要double alignment排列位置，接受Alignment对象。控制的是图片在图片组件中的位置。 fit图片充满格式，接受BoxFit对象，可以使用其中已经预定义了一些常量fill(充满)，cover(覆盖)等。 repeat重复，接受ImageRepeat对象，控制的是如果图片没有占满图片组件，那么就重复。 color与混合模式一起使用，在图片上增加一个颜色层，然后使用混合模式混合，如果不加混合模式，图片就会被颜色给覆盖掉。 ColorBlendMode接受一个BlendMode，图片混合模式，该对象已经定义好几种混合类型，BlendMode.darken,BlendMode.clear等。 代码示例123456789Image.asset("images/avatar.gif", width: 200.0, height: 400.0, color: Colors.pink, colorBlendMode: BlendMode.colorBurn, fit: BoxFit.scaleDown, alignment: Alignment.bottomCenter, repeat: ImageRepeat.repeat, )]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——Container]]></title>
    <url>%2F2019%2F06%2F06%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Container%2F</url>
    <content type="text"><![CDATA[Container组件 Container组件是一个非常重要的组件有点类似于html中的div。 alignment这个是设置子组件的布局的，注意是子组件，它接受一个Alignment对象，我们可以使用Alignment(x, y)来构造它，或者我们也可以使用它已经定义好的几个常量来构造它 padding这个是设置内边距的，接受一个EdgeInsetsGeometry, 我们可以将它的子类EdgeInsets对象赋值给它，我们可以使用const EdgeInsets.all(double value)，const EdgeInsets.only等方式声明 margin它是设置Container的外边距，接受参数和padding一样 height，width它们是设置宽和高的，里面接受一个double decoration绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在decoration中进行颜色的设置。 其中它接受一个Decoration，我们可以使用它的子类BoxDecoration来赋值给它。 在BoxDecoration中也有许多参数 color 设置颜色的 image 设置背景图片，可以添加一个DecorationImage对象 border 设置边，接受一个BoxBorder，我们可以使用Border.all(width: 1.5, style: BorderStyle.solid, color: Colors.deepPurple),这样的发情时来构造它。 borderRadius 设置边角的，可以增加弧度，接受一个BorderRadius对象，我们可以使用BorderRadius.all来构造 gradient 设置颜色渐变效果，接受一个Gradient对象 child接受一个孩子，孩子里面可以放置子组件 代码示例12345678910111213141516171819202122Container( alignment: Alignment.bottomCenter, padding: const EdgeInsets.all(20.0), margin: const EdgeInsets.all(100.0), height: 500.0, width: 200.0, decoration: BoxDecoration( border: Border.all(width: 1.5, style: BorderStyle.solid, color: Colors.deepPurple), borderRadius: BorderRadius.circular(1.0), gradient: LinearGradient(colors: [ Colors.deepPurple, Colors.deepOrange, Colors.pink, Colors.greenAccent ]) ), child: Image.network('https://francisqiang.github.io/images/avatar.gif', fit: BoxFit.fitWidth, color: Colors.deepOrangeAccent, colorBlendMode: BlendMode.darken, ), ),]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter组件——Text]]></title>
    <url>%2F2019%2F06%2F06%2FFlutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Text%2F</url>
    <content type="text"><![CDATA[默认属性Text中有个默认必须的属性就是字符串了，你需要在一开始设置字符串的内容 textAlign这个属性主要就是设置字符串的对齐方式的，他接受一个TextAlign对象，这个对象里面有几个常见的枚举比如说left，center，start等。 maxLinesmaxLines指的是Text的最大行数，如果超过剩余字符串内容则会被隐藏 overflowoverflow定义了超出字符串部分内容的显示样式(不太精确，先这么理解)，其中它接受TextOverFlow对象，这个对象设置了几个枚举类型，其中有clip，fade，ellipsis，visible效果，其中ellipsis是用的比较多的 textScaleFactor这个属性是设置字体大小的，它是根据比例设置，接受的是一个double，如果你设置2.0就是两倍大小，当你设置这个属性的时候就不要设置fontSize了，会有冲突 StyleText中最重要的就是style属性了，style属性主要设置字体的样式，它接受一个TextStyle对象并且这个对象中还有很多属性，下面是几个常见属性。 color属性 主要是字体的颜色，里面接受一个Color对象，我们可以使用Colors.dark的形式，因为Colors里面已经内置了很多Color常量，或者使用Color.fromARGB(a, r, g, b) fontSize属性 字体大小不用多说，接受一个double fontWeight属性 字体粗度，里面接受一个FontWeight对象，比如FontWeight.w800等 decoration属性 用于下划线类型的装饰，接受一个TextDecoration对象，里面有下划线，上划线等等样式，你还可以设置combine里面接受一个数组，可以把样式都添加进去。 decorationStyle属性 装饰的样式，比如将下划线变成波浪线等等。接受一个TextDecorationStyle对象，里面有solid，double，dashed，wavy，dotted类型的。 decorationColor属性 装饰的颜色，可以设置下划线的颜色，接受一个Color对象 backgroundColor属性 这个属性就是设置字体的背景的颜色，接受一个Color对象 代码示例1234567891011121314151617181920212223class MyText extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Text('This is my first page', textAlign: TextAlign.justify, maxLines: 1, overflow: TextOverflow.ellipsis, textScaleFactor: 1.5, style: TextStyle( color: Colors.red, fontSize: 30.0, fontWeight: FontWeight.w800, decoration: TextDecoration.combine([ TextDecoration.lineThrough, TextDecoration.underline ]), decorationStyle: TextDecorationStyle.wavy, decorationColor: Colors.lightGreenAccent, backgroundColor: Colors.red ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性——lambda范围和内置功能接口]]></title>
    <url>%2F2019%2F06%2F05%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94lambda%E8%8C%83%E5%9B%B4%E5%92%8C%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[lambda scopes 在lambda表达式中我们可以访问外部变量，这个功能和匿名内部类一样，但是对于匿名内部类，我们只能访问final变量，lambda表达式中都可以访问，但是它只是隐式地将变量变成了final 首先我们能通过lambda表达式来访问外部变量。 123456789@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from); public static void main(String[] args) &#123; int num = 1; Converter&lt;Integer, String&gt; converter = (from -&gt; String.valueOf(from + num)); System.out.println(converter.convert(2)); // 输出3 &#125;&#125; 但是我们不能再改变lambda表达式中调用的外部变量了，因为一旦被lambda表达式调用，这个变量就被隐式地声明成了final变量。 12345678910@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from); public static void main(String[] args) &#123; int num = 1; Converter&lt;Integer, String&gt; converter = (from -&gt; String.valueOf(from + num)); System.out.println(converter.convert(2)); num = 3; &#125;&#125; 这个时候就会报错 从lambda 表达式引用的本地变量必须是最终变量或实际上的最终变量。 还有一个容易混淆的点就是这样的写法 1234567public static void main(String[] args) &#123; int num = 1; Converter&lt;Integer, String&gt; converter = String::valueOf; System.out.println(converter.convert(2 + num)); num = 2; System.out.println(num);&#125; 即使是对象也是一样 1234567891011@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from); public static void main(String[] args) &#123; StringBuilder stringBuilder = new StringBuilder("123"); Converter&lt;StringBuilder, String&gt; converter = (stringBuilder1) -&gt; stringBuilder1.toString(); System.out.println(converter.convert(stringBuilder)); stringBuilder.append("234"); System.out.println(stringBuilder); &#125;&#125; 这个时候其实我们只是将num作为函数参数传进去了，在lambda表达式中并没有显示声明调用这个变量。 在lambda表达式中我们还可以访问静态和类中的字段 12345678910111213141516class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125; 还记得上次声明的Formula接口么，其中定义了一个sqrt的默认方法，在lambda中我们是不能调用默认方法的。 1Formula formula = (a) -&gt; sqrt(a * 100); //这样编译不通过 Built-in Functional InterfacesPredicate 这是断言，判断的意思。先上代码 12345678910Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test("foo"); // truepredicate.negate().test("foo"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); 其中test方法就是Predicate接口中的唯一抽象方法，我们lambda表达式中就是实现了它。 negate方法是取反的意思，其中还有and(), or()这两个默认方法对应语，或。 可以直接看源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate, * otherwise &#123;@code false&#125; */ boolean test(T t); /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is &#123;@code false&#125;, then the &#123;@code other&#125; * predicate is not evaluated. * * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * &#123;@code other&#125; predicate will not be evaluated. * * @param other a predicate that will be logically-ANDed with this * predicate * @return a composed predicate that represents the short-circuiting logical * AND of this predicate and the &#123;@code other&#125; predicate * @throws NullPointerException if other is null */ default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; /** * Returns a predicate that represents the logical negation of this * predicate. * * @return a predicate that represents the logical negation of this * predicate */ default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is &#123;@code true&#125;, then the &#123;@code other&#125; * predicate is not evaluated. * * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * &#123;@code other&#125; predicate will not be evaluated. * * @param other a predicate that will be logically-ORed with this * predicate * @return a composed predicate that represents the short-circuiting logical * OR of this predicate and the &#123;@code other&#125; predicate * @throws NullPointerException if other is null */ default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; /** * Returns a predicate that tests if two arguments are equal according * to &#123;@link Objects#equals(Object, Object)&#125;. * * @param &lt;T&gt; the type of arguments to the predicate * @param targetRef the object reference with which to compare for equality, * which may be &#123;@code null&#125; * @return a predicate that tests if two arguments are equal according * to &#123;@link Objects#equals(Object, Object)&#125; */ static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;&#125; Function Function从字面理解就是函数的意思，这也是Java支持函数式编程的一个很重要的函数式接口。我们先看源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the &#123;@code before&#125; * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of input to the &#123;@code before&#125; function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the &#123;@code before&#125; * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; /** * Returns a composed function that first applies this function to * its input, and then applies the &#123;@code after&#125; function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of output of the &#123;@code after&#125; function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the &#123;@code after&#125; function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; /** * Returns a function that always returns its input argument. * * @param &lt;T&gt; the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 其中apply()是我们需要实现的一个函数，为什么这里说是函数不是方法呢？我们现在用函数式的思想去思考这个问题，其实这个方法就是我们给定一个参数然后我们返回一个结果，具体这个函数是怎么实现我们先不管。这就是函数式思想(先考虑参数和结果，然后再去考虑实现行为)。 这是作者给的实例代码 12345// 这里是实现apply方法Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply("123"); // "123" 这里多出来了个andThen方法，我们来具体看一看 123456789default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; //判空 Objects.requireNonNull(after); // 我们传入的是一个Function // 该语句是先调用当前Function的apply方法 // 然后将该方法的返回值作为after(传入的Function)的apply方法中的参数 // 最终返回的是after的apply方法的返回值 return (T t) -&gt; after.apply(apply(t));&#125; 里面还有一个compose方法,其实和andThen方法正好相反 12345default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); // 先调用传入的befor的apply方法，然后将返回值作为当前Function的apply的参数 return (V v) -&gt; apply(before.apply(v));&#125; Supplier 这个函数很简单，就相当于无参函数，我们不需要设置给定参数，只关注结果 具体源码也很简单 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person Comsumer 我们先来看一下源码 123456789101112131415161718192021222324252627@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed &#123;@code Consumer&#125; that performs, in sequence, this * operation followed by the &#123;@code after&#125; operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the &#123;@code after&#125; operation will not be performed. * * @param after the operation to perform after this operation * @return a composed &#123;@code Consumer&#125; that performs in sequence this * operation followed by the &#123;@code after&#125; operation * @throws NullPointerException if &#123;@code after&#125; is null */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 上面有一个accept()是我们需要实现的抽象方法，其实就是我们给定一个参数但是我们没有返回值，然后这个andThen()就是传入一个Consumer先调用原来的Consumer的accept方法然后再调用传入的accept() Comparators123456789// 这里是实现了compare方法Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person("John", "Doe");Person p2 = new Person("Alice", "Wonderland");comparator.compare(p1, p2); // &gt; 0// reversed方法是默认方法comparator.reversed().compare(p1, p2); // &lt; 0]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性——接口中的static，default方法]]></title>
    <url>%2F2019%2F06%2F04%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84static%EF%BC%8Cdefault%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[default方法 这些天在看ES6的语法，包括我以前学了一段时间的dart，这两门语言中都涉及到函数式编程，想想我对Java中的函数式编程还是不太了解，最近开始学习Java8的一些新特性，反正语言都差不多，一起学习好了。 在java8中新增了default方法，这个方法可以定义在接口中，其实就是在接口中定义了默认方法，这些默认方法可以在接口中就已经实现。 我看的是github上的Java8——tutorial,原文是英文的，其实理解起来不难。 12345678910111213141516171819public interface Formula &#123; double calculate(int a); default double sqrt(int a)&#123; return Math.sqrt(a); &#125; static void main(String[] args) &#123; Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return a; &#125; &#125;; System.out.println(formula.calculate(5)); // 未实现也可以直接使用 System.out.println(formula.sqrt(5)); &#125;&#125; static方法 上面就已经定义了静态方法在接口中，在以往版本是不可以的。我们可以直接通过接口(不需要实现)来调用静态方法，但注意的是实现接口的类或者子接口(是继承不是实现)不会继承接口中的静态方法。 Lambda expressions 因为是跟着教程走的，涉及到的知识和教程的差不多，你们可以直接去原网站看。 我们可以使用lambda表达式改造上面的静态方法 12345static void main(String[] args) &#123; Formula formula = (a) -&gt; a; System.out.println(formula.calculate(5)); System.out.println(formula.sqrt(5));&#125; 能使用lambda表达式来实现的接口必须只能有一个抽象方法，然后我们写的那个lambda表达式会和原来类型中的抽象方法进行匹配。 这是原文(大概意思就是上面的话): How does lambda expressions fit into Java’s type system? Each lambda corresponds to a given type, specified by an interface. A so called functional interface must contain exactly one abstract method declaration. Each lambda expression of that type will be matched to this abstract method. Since default methods are not abstract you’re free to add default methods to your functional interface. 然后我们可以在只有一个抽象方法的接口上面声明一个注解@FunctionalInterface来指明这个接口是一个函数接口，当我们尝试添加第二个抽象方法的时候编译器会报错。 We can use arbitrary interfaces as lambda expressions as long as the interface only contains one abstract method. To ensure that your interface meet the requirements, you should add the @FunctionalInterface annotation. The compiler is aware of this annotation and throws a compiler error as soon as you try to add a second abstract method declaration to the interface. Method and Constructor References 方法和构造方法引用，Java 8允许您通过::关键字传递方法或构造函数的引用。 例子： 1234567@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert("123");System.out.println(converted); // 123 我们可以使用::来化简代码 12Converter&lt;String, Integer&gt; converter = Integer::valueof// 可以这么理解本来我们可以将这个实现写成一个lambda表达式，这个表达式其实就是一个函数，我们现在只是要一个函数，然后我们通过方法引用吧方法赋值给它。这个方法必须参数返回值要相同 当然我们还可以使用某个实例化的对象的方法 12345678class Something &#123; String startsWith(String s) &#123; return String.valueOf(s.charAt(0)); &#125;&#125;Something something = new Something();Converter&lt;String, String&gt; converter = something::startsWith; 通过::引用构造器 12345678910111213141516171819class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125;interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125;//我们通过构造器引用实现接口PersonFactory&lt;Person&gt; pf = Person::new;Person person = PersonFactory.create("11", "22");]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的赋值和参数传递]]></title>
    <url>%2F2019%2F06%2F04%2FJava%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[Java中的=赋值 一直以来我对于这些都有些模糊，今天来写一篇博客总结一下。 在Java中，=赋值对于基本类型可以简单理解为就是直接传值 12345int a = 1;int b = a;b = 2;System.out.println(a); // 1System.out.println(b); // 2 我们可以看出我们把a赋值给b然后对b进行改变的时候a的值还是不会变。 所以在基本数据类型中，我们可以简单理解为=为传值。 而在对象中的=就不是赋值那么简单了，对于对象的=其实赋值的是对象的地址而不是内容，比如a = a1 ，假设这两个变量是对象，那么我们是将a1的地址赋值给a，那么a的地址就是a1的地址，即他们两共享同一地址，所以如果我们对a进行了操作，其实就是通过地址同时操作a1。 12345StringBuilder s1 = new StringBuilder("123");StringBuilder s2 = s1;s2.append("456");System.out.println(s1); // 123456System.out.println(s2); // 123456 所以我们可以理解对于对象的=赋值的是对象的地址，除非我们再次new一个对象，将这个new的对象的地址重新赋值给s2。 123456789StringBuilder s1 = new StringBuilder("123");StringBuilder s2 = s1;s2.append("456");System.out.println(s1);System.out.println(s2);s2 = new StringBuilder("123");s2.append("789");System.out.println(s1); // 123456 不变System.out.println(s2); // 123789 我们可以看出当我们给s2重新赋值一个地址的时候这个时候的s2就与s1无关了，因为他们已经不是共享同一个地址了。 Java中的方法参数传递 我觉得方法参数传递和=赋值差不多。 1234567891011121314151617181920212223 public class Test &#123; public static void function1(StringBuilder stringBuilder) &#123; stringBuilder.append("我改变了"); &#125; public static void function2(StringBuilder stringBuilder) &#123; stringBuilder = new StringBuilder("我重新赋值地址了"); &#125; public static void main(String[] args) &#123; StringBuilder stringBuilder = new StringBuilder("初始化"); System.out.println(stringBuilder); //初始化 Test.function1(stringBuilder); System.out.println(stringBuilder); //初始化我改变李 Test.function2(stringBuilder); System.out.println(stringBuilder); //初始化我改变了 // 这里我们看出function2对stringBuilder对象没有任何改变，是因为 // 我们传入function2的stringBuilder是一个地址，然后我们又重新将 // 新的地址赋值给stringBuilder，所以指向了不同的地址 自然就不会有关联了&#125; 总之记住一个就是Java中的参数传递就是按值传递，当我们传入的是一个对象的时候我们传入的是地址，我们传入一个基本类型的时候传入的是一个值，我们也可以简单理解为地址就是对象的值。 其实也可以这么理解，基本类型的值在栈中，即栈中的的值，然后对象的地址在栈中，这个地址指向堆中的内容，我们可以简单理解为传值就是传入栈中的内容。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构——Trie]]></title>
    <url>%2F2019%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Trie%2F</url>
    <content type="text"><![CDATA[什么是Trie Trie是字典树，前缀树。Trie的思想就是使用空间换时间，它是一种专门致力于字符串查询的树，因为它的子节点是所有包含的字符，所以它是一个多叉树(使用空间大)，当我们对一个字符串进行查询的时候它的时间复杂度是O(字符串长度)，所以当个字符串集合非常大的时候是不影响Trie的性能的。 这是Trie的基本结构，里面存放了see，dog，pain，pand 在Trie中添加单词 因为Trie是专门对字符串进行操作的，这里我们选择对Trie中添加一个单词。 主要思路就是:我们对需要添加的单词进行for循环取出每个字符，然后我们同时在树中进行遍历，比如我们取出第一个字符是a，那我们就在根节点的next(这里是一个map存放着所有的子节点)中查找是否有a这样的节点，如果没有我们就创建，如果有我们进入这个结点继续后面的操作，比如下一个字符是p。。。 java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Trie &#123;//定义每个结点private class Node &#123; private boolean word; //该结点存放子节点的map private TreeMap&lt;Character, Node&gt; next = new TreeMap&lt;&gt;(); public Node(boolean word) &#123; this.word = word; &#125; public Node() &#123; this(false); &#125;&#125;private Node root;private int size;public int getSize() &#123; return size;&#125;public Trie() &#123; root = new Node(); size = 0;&#125;public void add (String word) &#123; //将根结点作为当前节点 Node currentNode = root; for (int i = 0; i &lt; word.length(); i++) &#123; //获取该位置的字符 char c = word.charAt(i); //判断是否有该字符的节点，没有则创建 //有则继续遍历 if (currentNode.next.get(c) == null) &#123; currentNode.next.put(c, new Node()); &#125; currentNode = currentNode.next.get(c); &#125; //如果遍历到最后不是个单词那么将它标志位单词 if (!currentNode.word)&#123; currentNode.word = true; size++; &#125;&#125; 在Trie中查找单词 基本思路： 对于查找其实就是遍历这个单词字符串然后在Trie中进行遍历，如果符合则继续遍历，不符合就直接return false。如果遍历到最后，我们就查看最后那个节点的单词标志是不是true如果是那么就return true。 java代码: 1234567891011121314 public boolean contains (String word) &#123; Node currentNode = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); //如果一个不符合直接false if (currentNode.next.get(c) == null) &#123; return false; &#125; //符合继续遍历 currentNode = currentNode.next.get(c); &#125; //判断最后节点是不是单词 return currentNode.word;&#125; 在Trie中进行前缀查询 基本思路： 对于前缀查询其实跟查找差不多，只是我们不需要判断最后一个节点是不是单词了，因为这里只是判断前缀。 java代码 123456789101112 public boolean prefix (String word) &#123; Node currentNode = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (currentNode.next.get(c) == null) &#123; return false; &#125; currentNode = currentNode.next.get(c); &#125; //遍历到最后直接true return true;&#125; 在Trie进行模式匹配 其实是一个LeetCode题目 解题思路： 主要就是要解决这个.的匹配问题，这里我们使用递归。当我们搜索一个字符串是否存在的时候(包括.的字符串)，我们首先定义一个递归函数，参数为当前查找的node，字符串，当前字符的索引，返回是boolean。 我们递归函数的最根本条件就是当index等于这个查询的字符串的长度的时候我们就返回当前节点是否是单词的标志。 但我们进行查找的时候我们现在root的node中执行该函数，然后我们字符索引是0，获取到第一个字符，我们首先要判断这个字符是不是等于.,如果不等于，我们判断当前节点的next中是否有当前字符的node如果没有直接返回false，如果有那继续递归到当前节点的next.get(当前字符)的节点，索引是index + 1。 如果是. 那么我们就对这个node.next的key进行遍历，并且在遍历中调用递归函数，写法跟上面差不多 具体代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class WordDictionary &#123;private class Node &#123; private boolean word; private TreeMap&lt;Character, Node&gt; next = new TreeMap&lt;&gt;(); public Node(boolean word) &#123; this.word = word; &#125; public Node() &#123; this(false); &#125;&#125;private Node root;/** * Initialize your data structure here. */public WordDictionary() &#123; root = new Node();&#125;/** * Adds a word into the data structure. */public void addWord(String word) &#123; Node currentNode = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (currentNode.next.get(c) == null) &#123; currentNode.next.put(c, new Node()); &#125; currentNode = currentNode.next.get(c); &#125; currentNode.word = true;&#125;/** * Returns if the word is in the data structure. A word could contain the dot character '.' to * represent any one letter. */public boolean search(String word) &#123; return match(root, word, 0);&#125;private boolean match(Node node, String word, int index) &#123; if (index == word.length()) &#123; return node.word; &#125; char c = word.charAt(index); if (c != '.') &#123; if (node.next.get(c) == null) &#123; return false; &#125; return match(node.next.get(c), word, index + 1); &#125; else &#123; // 遍历key for (char nextChar:node.next.keySet()) &#123; // 每个key都进行递归，匹配上了交给下一个节点 if (match(node.next.get(nextChar), word, index + 1)) &#123; return true; &#125; &#125; //如果整个for循环结束都没有成功那就是都没匹配上 直接false return false; &#125; &#125;&#125; LeetCode中的键值映射题目 解题思路： 其实前面查找都差不多，主要就是我们对这个进行前缀查找之后到了最后那个节点的时候我们需要对后面所有单词的value进行相加最终返回。 我们这里可以使用递归，比如我们已经进行前缀查询并且到了前缀查找字符的最后一个字符，我们书写一个sum递归函数，目的是计算符合这个前缀的单词的value的总和，其实就是获取都前缀最后节点的字数所形成的所有单词的value和。 这个递归函数的参数只有一个Node，这个node就是前缀遍历到最后的节点。然后我们的根本条件就是node的next的size为0的时候也就是最后没有字符(结尾)的时候直接返回该结点的value，然后我们定义一个result，每次result都对当前节点的value进行+=操作，然后我们对next的key进行遍历，在遍历中进行递归调用，递归到node为当前node.next.get(遍历到的key) 具体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MapSum &#123;private class Node &#123; private int value; private TreeMap&lt;Character, Node&gt; next = new TreeMap&lt;&gt;(); public Node(boolean word) &#123; this.value = 0; &#125; public Node() &#123; this(false); &#125;&#125;private Node root;/** * Initialize your data structure here. */public MapSum() &#123; root = new Node();&#125;public void insert(String key, int val) &#123; Node currentNode = root; for (int i = 0; i &lt; key.length(); i++) &#123; char c = key.charAt(i); if (currentNode.next.get(c) == null) &#123; currentNode.next.put(c, new Node()); &#125; currentNode = currentNode.next.get(c); &#125; currentNode.value = val;&#125;public int sum(String prefix) &#123; Node currentNode = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if (currentNode.next.get(c) == null) &#123; return 0; &#125; currentNode = currentNode.next.get(c); &#125; return sum(currentNode);&#125;private int sum(Node node) &#123; if (node.next.size() == 0) &#123; return node.value; &#125; int result = node.value; for (char c: node.next.keySet()) &#123; result += sum(node.next.get(c)); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——Prototype模式]]></title>
    <url>%2F2019%2F06%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Prototype%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是Prototype模式 Prototype模式(原型模式)指的就是使用对象去制造新的对象，不像单例模式只制造出一个对象，原型模式制造的对象是多个的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。 实现Prototype模式 原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件： 实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class Shape implements Cloneable&#123; abstract void draw(); @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;public class Circle extends Shape &#123; @Override void draw() &#123; System.out.println("this is Circle"); &#125;&#125;public class Rectangle extends Shape &#123; @Override void draw() &#123; System.out.println("this is rectangle"); &#125;&#125;public class ShapeMap &#123; private Map&lt;String, Shape&gt; map = new HashMap&lt;&gt;(); public void register(String string, Shape shape)&#123; map.put(string, shape); &#125; public Shape get(String string) throws CloneNotSupportedException &#123; Shape shape = map.get(string); //这里是核心我们获取到这个对象之后使用clone方法 return (Shape) shape.clone(); &#125;&#125;public class Main &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; ShapeMap shapeMap = new ShapeMap(); Shape circle = new Circle(); Shape rectangle = new Rectangle(); shapeMap.register("circle", circle); shapeMap.register("rectangle", rectangle); Shape circleClone = shapeMap.get("circle"); Shape rectangleClone = shapeMap.get("rectangle"); circleClone.draw(); rectangleClone.draw(); &#125;&#125; 最后输出打印 this is Circle this is rectangle]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6学习——day02]]></title>
    <url>%2F2019%2F06%2F02%2FES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day02%2F</url>
    <content type="text"><![CDATA[函数扩展参数默认值 这个参数默认值有些像Java里面注解的默认值，跟dart语言中的默认值有着神似之处，要不然怎么说dart和js很像呢。 先上代码吧 123456789101112&#123; function test(x, y = 'world')&#123; console.log(x, y); &#125; test('hello'); //打印出来 hello world,当然也可以对y赋值进行更改 let x = 'test'; function test2(x, y = x)&#123; console.log(x, y); &#125; test2('kill'); //输出kill kill 可见x的值为kill&#125; rest参数 rest参数就是… , 应用场景就是在参数数量可变或者不可预知的时候使用的，这时候…后面的形参会被变成数组传进函数，跟java的…差不多，只是java里面是这样的(java8新特性) 123456public void test(int... arr)&#123; for(int i: arr)&#123; //打印出参数i System.out.println(i); &#125;&#125; js代码是这样的 1234567891011121314&#123; //rest参数 function test3(...arg) &#123; //将输入的参数都转为数组 for (let v of arg)&#123; console.log('rest',v);//a b c &#125; &#125; test3('a','b','c'); //将数组转成离散的值 console.log(...[1,2,4]);//1 2 4 console.log('a',...[1,2,4]);//a 1 2 4&#125; 尾调用 其实就是某个函数的最后一步再调用另一个函数，使用递归函数就经常会有尾递归的情况 12345678910&#123; //尾调用：函数的最后一句话是不是函数 function tail(x) &#123; console.log('tail',x); &#125; function fx(x) &#123; return tail(x); &#125; fx(123);//tail 123&#125; 箭头函数 一个革命性的新特性，向着函数式编程挺进。在java里面有lambda表达式(-&gt;)，dart中跟js一样是=&gt;，就叫它胖箭头吧。。。 123456&#123; //这里的arrow其实就是一个函数 let arrow = v =&gt; v * 2; console.log(arrow(3)); // 6 let arrow2 = () =&gt; 2;&#125; this绑定 这是一个概念性的问题，在没有箭头函数的函数里面，this就是代表调用这个函数的对象，所以当一个函数中调用另一个函数的时候this可能会发生变化。但是在箭头函数中，this是代表调用这个(箭头函数的函数)的对象，所以箭头函数会是this不变化，不是绝对的具体看情况。 对象扩展 这里的对象是指Object 简洁表达式 123456789101112131415161718192021 let o = 1; let k = 2; let es5 = &#123; o: o, K: k &#125;; let es6 = &#123; o, k &#125;; let es5_mrthod=&#123; hello:function () &#123; console.log('hello'); &#125; &#125;; let es6_method=&#123; hello()&#123; console.log('hello'); &#125;&#125;; 属性表达式123456789//属性表达式let a='b';let es5_obj=&#123; a: 'c'&#125;;let es6_obj=&#123; [a]:'c' //这里的a是变量，即b&#125;;console.log(es5_obj,es6_obj); 新增APIObject.is()12console.log('字符串',Object.is('abc','abc'));//true 相当于===console.log('数组',Object.is([],[]),[]===[]);//false false 引用地址不同 Object.assign()Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 语法：Object.assign(target, …sources); 返回拷贝后的对象 12345678const object1 = &#123; a: 1, b: 2, c: 3&#125;;const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);console.log(object2.c, object2.d);// expected output: 3 5 Object.entries()1234let test=&#123;k:123,o:456&#125;;for (let [key,value] of Object.entries(test))&#123; console.log(key,value);&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6学习——day01]]></title>
    <url>%2F2019%2F06%2F01%2FES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day01%2F</url>
    <content type="text"><![CDATA[反思 前段时间学习的mysql到现在还停留在day1阶段，现在就突然学es6。其实我是这么想的 因为这段时间在帮老师弄前端项目，用的JQuery。我想着这东西比较老，然后想用vue逐渐替换掉(做一次尝试吧)，学完vue发现还需要es6的基础，所以看了一下es6语法，并不是很难而且为我写js提供了更好地方法。那就学吧。。。 let 和 const 其实学习es6并不打算一个代码一个代码敲过来，可能眼高手低吧。我先学着反正也要项目中使用es6，那我项目中使用多练练吧。 在let 和 const之前我们都使用的是var声明变量。这里无非就是作用域的不同，let的作用域是块作用域简单来说就是大括号括起来的部分，而var是函数作用域，如果在全局声明那就全局的。然后let 不准重复声明，又因为es6强制开启了严格模式，所以变量不准在未声明之前引用，不然会报引用错误。 而const就是常量，常量是不准重新赋值且声明时必须赋值。有个特殊一点的就是对象常量，对象常量里面的字段都是可以修改的，也许你认为这违反了常量，其实不是(有点像C++里面的常量指针)，在es6中常量对象意味着这个对象引用的地址是不改变的(因为对象是引用类型，所以值其实是地址)，但是里面的内容是可以改变的。这在我学习vuex全局变量的时候看到别人使用const定义全局的变量就很不解，原来是因为他们定义的是全局对象变量。 解构赋值 什么是解构赋值，它有很多分类，数组解构赋值(左右都是数组),对象解构赋值(左右都是对象),字符串解构赋值(左数组，右字符串)，布尔解构赋值，函数参数解构赋值(数组解构赋值在函数上的引用)，数值解构赋值 数组解构赋值和对象解构赋值使用的比较多。 数组解构赋值例子，在要对数组成员进行变量赋值的时候，尽量使用解构赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//这个打印出来的ab就是1和2&#123; let a,b,rest [a, b] = [1, 2] console.log(a) console.log(b)&#125;&#123; let a,b,rest [a, b, ...rest] = [1, 2, 3, 4, 5] console.log(a, b, rest); //打印结果ab还是1 2 但是rest是[3, 4, 5]数组&#125;&#123; //默认值 let a,b [a, b = 3] = [1] console.log(a, b) //结果是a为1 b为3 //如果b为赋值那么就是undefined&#125;//将两个变量交换&#123; let a = 1 let b = 2 [a, b] = [b, a]&#125;//获取函数返回值&#123; function f() &#123; return [1, 2] &#125; let a,b [a, b] = f() //ab则为12&#125;//选择型获取&#123; function f () &#123; return [1, 2, 3, 4, 5, 6] &#125; let a,b [a, , , b] = f() //这时候 a为1 b为6&#125; 对象解构赋值例子 123456789101112131415161718192021222324252627&#123; //对象解构赋值 let a,b (&#123;a, b&#125; = &#123;a:1, b:2&#125;) console.log(a, b) //a为1b为2&#125;&#123; let o = &#123;p: 42, q: true&#125; let &#123;p, q&#125; = o console.log(p, q) //这里的p为42 ，q为true&#125;//使用场景&#123; let jsonData = &#123; title: 'abc', test: [&#123; title: 'test', desc: 'description' &#125;] &#125; let &#123;title: esTitle, test: [&#123;title: testTitle&#125;]&#125; = jsonData console.log(esTitle, testTitle) //这时候esTitle获取到的就是bc testTitle获取到的就是test&#125; 数组扩展 其实就是对数组的api进行扩展了。 Array.of()方法 12345&#123; let arr = Array.of(3, 4, 5, 5, 3) console.log('arr', arr) //[3, 4, 5, 5, 3] console.log('arr',Array.of()) //[]&#125; Array.from()方法 1234567let p=document.querySelectorAll('p');let pArr=Array.from(p); //将上面的集合转义成数组pArr.forEach(function (item) &#123; console.log(item.textContent);&#125;);//mapconsole.log(Array.from([1,3,5],function (item) &#123;return item + 2;&#125;));//3 5 7 填充数组 12console.log('fill-7',[1,'a',undefined].fill(7));//[7,7,7]console.log('fill,pos',['a','b','c','d','e'].fill(7,1,3));//["a", 7, 7, "d", "e"] 1和3表示起始和截至位置，不包括位置3 获取索引和值 1234567891011for (let index of ['1','c','ks'].keys())&#123; console.log('keys',index);//0 1 2&#125;for (let value of ['1','c','ks'].values())&#123; console.log('values',value);//1 c ks&#125;for (let [index,value] of ['1','c','ks'].entries())&#123; console.log(index,value);&#125;//替换console.log([1,2,3,4,5].copyWithin(0,3,4));//[4,2,3,4,5] （从0开始替换，从3开始读取，也就是第一个读取的数是4，4是截至位置，也就是在位置4之前，因此只取4） 查找和判断包含 12345678console.log([1,2,3,4,5,6].find(function (item) &#123; return item&gt;3;//4，只找第一个&#125;));console.log([1,2,3,4,5,6].findIndex(function (item) &#123; return item&gt;3;//3&#125;));console.log('number',[1,2,NaN].includes(1));//trueconsole.log('number',[1,2,NaN].includes(NaN));//true]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——模板方法模式]]></title>
    <url>%2F2019%2F05%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是模板方法模式 Template Method模式，我的理解就是它是一种抽象类实现方法的一种升级版的设计模式。所谓模板就是将某一种工序流程方法抽象成一个统一的模板，比如说我有一个绘画的模板，我们可以选择任何一种画笔，比如我使用红笔画这个模板画出来的就是红色的，我用蜡笔那就蜡笔画出来的画。 模板方法的实现 比如这时候我们有一个流程，流程中需要调用几个工序，这几个工序的顺序是不变的，但是具体的工序是会变化的。这时候我们就可以使用模板方法模式了。 首先，我们先定义一个抽象类，这个抽象类里面有具体的模板方法和几个工序方法，工序方法是抽象方法(这个就需要子类去实现具体方法)，模板方法里需要调用这几个方法比如说先是工序1然后是工序2最后是工序4。 当我们需要具体实现的时候，我们需要加一个类继承于这个抽象类并且实现它的抽象方法。 代码实现 这里我就直接使用vs在md文件里手敲了，比较简单但最重要的是思想。 首先是抽象类AbstractProcess 1234567891011public abstract class AbstractProcess &#123; abstract void workOrder1(); abstract void workOrder2(); abstract void workOrder4(); void processTemplate()&#123; workOrder1(); workOrder2(); workOrder4(); &#125;&#125; 然后是实现类代码 123456789101112131415public class MakePencilProcess extends AbstractProcess&#123; public MakePencilProcess()&#123;&#125; @Override void workOrder1()&#123; System.out.println("This is make pencil first"); &#125; @Override void workOrder2()&#123; System.out.println("This is make pencil second"); &#125; @Override void workOrder4()&#123; System.out.println("This is make pencil third"); &#125;&#125; 最后是客户端类 1234567public class Main&#123; public static void main(String[] args)&#123; //里氏替换原则，更加灵活 AbstractProcess abstractProcess = new MakePencilProcess(); abstractProcess.processTemplate(); &#125;&#125; 后记 这两天在看vue，突然有好多要学的现在有点不知所措，期末，练车，数据结构，设计模式，Java项目，大创，前端项目，vue，六级考试，操作系统实验。。。感觉自己野心有点太大了，慢慢来吧，不能太急。 这几天突然意识到自己缺少了很多生活的记忆，尤其是前几天肝项目的时候，让我回忆那几天生活里干了啥我已经记不清了，我觉得我不能成为那样的呆子，那不是我，那也是我以前不想成为的人。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——适配器模式]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 简单来说，适配器就是用来填补实际情况和需求两者之间地差异。比如说我们需要5V电压，但是国内只给的是220V电压，那我们现在就需要一个适配器帮我们将电压转换。 通过继承方式实现适配器模式 Adapter模式，比如我们有一个原本的类A，A中有一个a方法，这时候我们有一个B类需要A中的a方法，但是它不能直接调用(因为某个原因不匹配，但是B确实需要a方法)，这时候我们可以通过一个C适配器类来包装A类的a方法，我们需要做的就是让C继承A类拥有A类的a方法，然后我们再让C实现B接口(B是一个接口),B类有一个方法时b方法(b方法可以理解为将来需要将a封装或者使用a方法的方法),这时候C适配器就重写了B接口的b方法，当我们B接口需要使用b方法的时候我们new一个C适配器类就行了(拿C实现B接口)。 示例代码： 我们有一个Banner类，Banner类中有showWithParen，showWithAster方法，这两个方法分别是在使用括号括住字符串和使用两个*包住字符串。然后我们有一个Print接口，这个接口有weakPrint和strongPrint方法，其实这两个方法需要使用showWithParen，showWithAster方法，所以我们可以添加一个适配器，让这个适配器作为Print的实现类，我们在适配器中继承Banner并调用Banner中的showWithParen，showWithAster方法，然后在封装这两个方法成为Print接口需要使用的方法就行了。 Banner类 12345678910111213141516171819202122232425public class Banner &#123; private String string; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public Banner()&#123;&#125; public Banner(String string)&#123; this.string = string; &#125; public void showWithParen()&#123; System.out.println("(" + string + ")"); &#125; public void showWithAster()&#123; System.out.println("*" + string + "*"); &#125;&#125; Print接口 1234public interface Print &#123; void weakPrint(); void strongPrint();&#125; PrintBanner适配器类 1234567891011121314151617public class PrintBanner extends Banner implements Print&#123; public PrintBanner(String string)&#123; super(string); &#125; @Override public void weakPrint() &#123; showWithParen(); System.out.println("weak"); &#125; @Override public void strongPrint() &#123; showWithAster(); System.out.println("strong"); &#125;&#125; 客户端类 12345678public class Main &#123; public static void main(String[] args) &#123; Print print = new PrintBanner("12345"); print.weakPrint(); print.strongPrint(); &#125;&#125; 使用委托方式实现适配器模式 其实使用委托的方法就是改动一下适配器类，使适配器不是继承原来的类而是拥有原来的类，将是一个变为有一个在面向对象里会有很多好处。这貌似是Java编程思想里看到的，，，我也忘了。 这时候我们需要改动一下适配器类 12345678910111213141516171819 public class PrintBanner implements Print&#123; private Banner banner; public PrintBanner(String string)&#123; this.banner = new Banner(string); &#125; @Override public void weakPrint() &#123; banner.showWithParen(); System.out.println("weak"); &#125; @Override public void strongPrint() &#123; banner.showWithAster(); System.out.println("strong"); &#125;&#125;]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——迭代器模式]]></title>
    <url>%2F2019%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是迭代器模式 当我们进行数组遍历的时候需要for循环i一直到arr.length，当我们使用迭代器模式的时候我们只需要生成当前数组的具体迭代器(实现迭代器接口),然后通过这个迭代器遍历就行。 迭代器UML图及角色介绍 Aggregate接口 Aggregate是所有需要通过迭代器遍历的集合的接口。所有需要通过迭代器遍历集合的都需要实现这个Aggregate接口，Aggregate本身有聚集集合的意思，这里我们就叫它有迭代器实现的集合接口吧。 其中相关Aggregate接口的代码如下: 1234public interface Aggregate &#123; //这里实现了一个迭代器，需要实现迭代器的集合都必须实现这个方法，这个方法的目的是返回该集合的具体迭代器。 Interator iterator();&#125; ConcreteAggregate实现类 ConcreteAggregate实现了Aggregate接口，可以说是具体的实现类，比如说这个类是一个CardList(里面存放了card元素)，里面会有相关的card字段以及获取某个元素，获取长度等等有关集合数组的操作。最重要的是它需要实现iterator方法。 其中相关ConcreteAggregate实现类的代码如下: 123public Iterator iteratot()&#123; return new ConcreteIterator(this);&#125; Iterator接口 Iterator和Aggregate接口的关系就是，Aggregate接口中有产生Iterator的iterator方法，也就是Aggregate接口的具体实现类ConcreteAggregate产生出Iterator具体实现类ConcreteIterator。 其中Iterator中有两个方法，分别是hasNext(),next()。hasNext的作用是判断迭代器是否还有下一个元素，如果有返回true否则false。next()的作用是返回当前集合迭代到的元素并将指针移向一下个元素(注意这里是两个作用)。 所以有了迭代器我们遍历一个集合是这样的 1234567//用于产生cardList的迭代器//这个方法这里还是不可以用的，为了现在介绍迭代器迭代代码，如果要实现必须要有一个具体ConcreteIterator实现类Iteratot iterator = cardList.iterator();while(it.hasNext())&#123; Card card = (Card)iterator.next(); //.......进行相关操作&#125; 具体Iterator接口的实现代码如下: 1234public interface Iterator&#123; boolean hasNext(); Object next();&#125; ConcreteIterator实现类 ConcreteIterator实现了Iterator接口，比如我们这里实现的是CardList的Iterator，我们可以这样写 12345678910111213141516public class CardListIterator implements Iterator&#123; private CardList cardList; private int index; public CardListIterator(CardList catdList)&#123; this.cardList = cardList; this.index = 0; &#125; public boolean hasNext()&#123; return index &lt; cardList.getLength(); &#125; public Object next()&#123; Card card = CardList.get(index); index ++ ; return card; &#125;&#125; 迭代器模式的作用 为什么要考虑引入Iterator模式呢？直接for循环不就好了，其实迭代器模式有一个好处就是分离，将遍历和实现分开来，在我们调用如下代码的时候 1234while(it.hasNext())&#123; Card card = (Card)iterator.next(); //.......进行相关操作&#125; 这个遍历并没有依赖于cardList，所以当我们这个cardList切换了数据结构的时候我们不需要将原来代码的for循环再依次改动了，我们只需要修改这个相关的iterator的具体实现类其中的hasNext()方法和next()方法就行了。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础学习——day1]]></title>
    <url>%2F2019%2F05%2F23%2FMysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day1%2F</url>
    <content type="text"><![CDATA[Mysql的数据类型整型 TINYINT SMALLINT MEDIUMINT INT BIGINT 这五个从小往大，可以对对应字段设置有无符号位。 浮点型 FLOAT 单精度 DOUBLE 双精度 日期类型 YEAR TIME DATE DATETIME TIMESTAMP DATE范围： 1000/1/1~9999/12/31 DATETIME范围： 1000/1/1/0:00:00~9999/12/31/23:59:59 TIMESTAMP范围： 1970/1/1~2037/12/31 TIME范围： -8385959~8385959 YEAR范围： 可存储俩位或者四位 默认四位，可以是1970~2069 字符类型 CHAR VARCHAR TINYTEXT TEXT MEDIUMTEXT LONGTEXT ENUM SET Mysql的约束五种约束NOT NULL（非空约束） PRIMARY KEY (主键约束) UNIQUE KEY （唯一约束） DEFAULT (默认约束) FOREIGN KEY (外键约束) 外键约束的条件 父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。 数据表的存储引擎只能为InnoDB。 外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。 外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。 外键约束的参照操作 CASCADE:从父表删除或更新且自动删除或更新子表中匹配的行。 SET NULL:从父表删除或更新行，并设置子表中的外键列为NULL。 RESTRICT:拒绝对父表的删除或更新操作。 NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。 CASCADE的删除案例：（子表中外键列添加ON DELETE CASCADE，父表进行删除时，子表也进行相应删除）]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——观察者模式]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式的定义 观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 在观察者模式中有如下角色： Subject： 抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject： 具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer： 抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver： 具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 简单实现观察者模式 这里我们简单实现一下观察者模式，首先我们定义一个被观察者的接口Subject，然后我们再定义一个观察者的接口Observer 其中Subject中有三个方法，attach()用来增加用户的，detach()用来移除用户的，notify()用来提醒订阅的用户的。 其中Observer中有个update()方法，这是notify()里会调用用来提醒所有订阅用户消息的 具体代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public interface Observer &#123;void update(String message);&#125;public interface Subject &#123;void attach(Observer observer);void detach(Observer observer);void notify(String message);&#125;//User实现观察者接口，并实现update方法public class User implements Observer&#123;private String name;public User(String name)&#123; this.name = name;&#125;@Overridepublic void update(String message) &#123; System.out.println("User" + name + "receive the update message:" + message);&#125;&#125;//具体被观察者实现类public class ConcreteSubject implements Subject&#123;//里面存放观察者的列表private ArrayList&lt;Observer&gt; observerArrayList = new ArrayList&lt;&gt;();//增加观察者@Overridepublic void attach(Observer observer) &#123; observerArrayList.add(observer);&#125;// 移除@Overridepublic void detach(Observer observer) &#123; observerArrayList.remove(observer);&#125;//当要通知的时候遍历观察者列表调用他们的update方法@Overridepublic void notify(String message) &#123; for (Observer observer : observerArrayList) &#123; observer.update(message); &#125;&#125;&#125; 测试方法和结果 1234567891011121314151617public static void main(String[] args) &#123; ConcreteSubject concreteSubject = new ConcreteSubject(); User first = new User("first"); User second = new User("second"); User third = new User("third"); concreteSubject.attach(first); concreteSubject.attach(second); concreteSubject.attach(third); concreteSubject.notify("第一次更新"); concreteSubject.detach(second); concreteSubject.notify("第二次更新");&#125; 观察者模式和发布订阅模式 在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 我们再刚刚实现的观察者模式中，观察者和被观察者是要互相知道对方的存在的(上述代码只实现了被观察者增加观察者，当然也可以在观察者里面关联被观察者)，不然无法增加和删除观察者列表中的用户。 但是发布订阅则是通过一个消息中间者来实现，他们之间通过消息代理，可以说更加松耦合。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F05%2F23%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是线段树 按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。 当然时间复杂度的减少，空间也就会有相应的损失，当我们要通过线段树存储一个线性结构，空间的开销就会增大。比如我们存储的线性结构的大小正好是2的整数幂，那么我们所有的叶子节点都会是单个区间的值，这个叶子节点的数量就是n，我们知道对于一个满二叉树来说，叶子节点的数量就是上层所有节点的和，那么这时候我们需要开辟的空间就是2n。但是当我们存储的大小不是2的整数幂的时候，这时候单个区间节点就不全在叶子节点上，假设我们为了使线段树尽量满足满二叉树的结构，那么在倒数第二层的单个区间的值也需要两个左右孩子节点(虽然他们是空，但还是需要空间的)，那么这时候我们就需要开辟2n*2(4n)的空间。 线段树的实现 对于线段树的实现，我们需要使用递归调用。 具体思路如下: 不考虑动态规划的情况，我们需要将整个区间一分为二，这个 middleIndex 就是(left + right) / 2,然后我们再依次递归到最后的叶子节点，当我们需要划分的left = right的时候也就是区间为1的时候(即一个区间的值)我们返回，然后我们通过后序遍历的思想将两个左右子节点的值相融合赋值给父节点。 具体实现代码: 1234567891011121314151617181920 private void buildSegmentTree(int treeIndex, int left, int right)&#123; if (left == right)&#123; tree[treeIndex] = data[left]; return; &#125; //获取左右孩子的节点索引 int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); //获取中间索引 int middleIndex = left + (right - left) / 2; //int middleIndex = (left + right) / 2; //为了防止整型溢出 buildSegmentTree(leftChildIndex, left, middleIndex); buildSegmentTree(rightChildIndex, middleIndex + 1, right); tree[treeIndex] = merger.merger(tree[leftChildIndex], tree[rightChildIndex]);&#125; 线段树的搜索 基本思路: 其实还是递归的思想，我们需要获取某个区间的值，即我们创建一个query方法，其中参数有treeIndex(遍历的根节点的index)，left(在什么区间查询的左边界index),right(在什么区间查询的右边界index),queryLeft(需要查询的左边界index),queryRight(需要查询的右边界的index)。 最根本的条件就是当我们所查询的左右边界值分别和我们需要查询的左右边界值相等，那么我们直接返回这个tree[treeIndex]。 我们使用递归转换为小问题的思路就是通过left right，queryLeft queryRight的关系，我们设置一个middleIndex(这个middleIndex也是根据left,right得来的)，我们通过queryLeft和middle比较，如果queryLeft比当前所查询区间的的middle要大的话，那么我们就去查询右子树，如果queryRight比middle要小的话我们就去查询左子树，因为我们查询的一个区间基本可能实现一个大区间的子集中，那么为了精确，我们就需要在大区间的左右孩子树中查找结果然后我们再将左右结果融合在一起然后返回。 代码实现: 123456789101112131415161718192021222324 private E query(int treeIndex, int left, int right , int queryLeft, int queryRight)&#123; //当left == queryLeft &amp;&amp; right == queryRight时就说明是我们需要查询的区间直接返回 if (left == queryLeft &amp;&amp; right == queryRight)&#123; return tree[treeIndex]; &#125; int middle = left + (right - left) / 2; int childLeftIndex = leftChild(treeIndex); int childRightIndex = rightChild(treeIndex); //缩小查询范围 if (queryLeft &gt;= middle + 1)&#123; return query(childRightIndex, middle + 1, right, queryLeft, queryRight); &#125; if (queryRight &lt;= middle)&#123; return query(childLeftIndex, left, middle, queryLeft, queryRight); &#125; //我们查询的区间必定是某个大区间的左右孩子树查询结果的融合 E leftResult = query(childLeftIndex, left, middle, queryLeft, queryRight); E rightResult = query(childRightIndex, middle + 1, right, queryLeft, queryRight); return merger.merger(leftResult, rightResult);&#125; 线段树查询的LeetCode题目 题目描述: 解题思路: 题目要求需要我们获得一个数组中某个区间段的值，并且这个sumRange函数会不断被调用，那么我们就可以使用线段树的查询操作(使merge融合改成相加就行了) 具体代码: 123456789101112131415161718class NumArray&#123; private SegmentTree&lt;Integer&gt; segmentTree; public NumArray(int[] nums) &#123; Integer[] integers = new Integer[nums.length]; if (nums.length &gt; 0)&#123; for (int i = 0 ; i &lt; nums.length ; i ++)&#123; integers[i] = nums[i]; &#125; //λ表达式，直接实现接口 segmentTree = new SegmentTree&lt;&gt;(integers, (a, b) -&gt; a + b); &#125; &#125; public int sumRange(int i, int j) &#123; return segmentTree.query(i, j); &#125;&#125; 线段树的修改基本实现 这里我们主要实现对线段树的某个单区间的修改操作，对于单个线段树的修改操作势必会牵连到其父节点的修改，这里我们还是可以使用后序遍历的思想再更新完子节点之后将父节点更新。 相关代码: 12345678910111213141516171819202122 private void set(int treeIndex, int left, int right, int index, E e)&#123; //最根本条件就是我们查询的区间左右相等 //这时候我们直接对该结点更新就行 if (left == right)&#123; tree[treeIndex] = e; return; &#125; //后面也是拿index和left，right比较 //通过index和left，right的关系将问题变小 int middleIndex = left + (right - left) / 2; int childLeftIndex = leftChild(treeIndex); int childRightIndex = rightChild(treeIndex); if (index &lt;= middleIndex)&#123; set(childLeftIndex, left, middleIndex, index, e); &#125;else if (index &gt;= middleIndex + 1)&#123; set(childRightIndex, middleIndex, right, index, e); &#125; //通过后序遍历的思想将父节点更新 tree[treeIndex] = merger.merger(tree[childLeftIndex], tree[childRightIndex]);&#125; 相关的LeetCode题目 这里其实就是增加一个update方法，题目又增加了修改单个结点的值，那么我们将更新方法加入原来实现的代码中。 123public void update(int i, int val) &#123; segmentTree.update(i, val);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2F2019%2F05%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[应用背景继承一定好用吗？ 当我们做到一个项目类似于设计鸭子，鸭子呢有游泳和嘎嘎叫的能力，另外他们都有display显示外貌的方法。现在比如有两个鸭子，绿头鸭和红头鸭。绿头鸭的头是绿色的，可以游泳，叫声是ll声，红头鸭的头是红色的，可以游泳，叫声是rr声。 如果我们要设计这两个鸭子类其实可以直接使用继承来实现，我们可以先设计一个Duck基类，类中有display方法，该方法是抽象的(所以类也是抽象的)，因为每个鸭子的外貌不一样。还有swim(),quack()方法，其中定义了基类默认的，比如说会游泳会嘎嘎叫等，之后绿头鸭红头鸭就需要实现display方法和重写swim(),quack()方法就行了。 但是这时候，客户增加需求说要增加会飞行的鸭子。也许我们可以在父类里增加fly(),但是这对原先的子类都会有改动，如果绿头鸭不会飞我们还需要重新覆盖fly()方法，如果我们也像display方法变成抽象的，那么重写的代码太多，代码太冗余。 继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应 超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式 使用组合更加灵活可扩展 上面设计的鸭子类主要就是灵活性太差，其实我们可以使用分离的技巧，我们先来看鸭子这个类，它的方法中有变的和不变的，当我们增加需求或者改动需求的时候是只涉及变的的。 比如我们现在将叫声和飞行分离出来变成一个行为，然后我们分别实现这两个行为接口QuackBehavior,FlyBehavior,这两个接口里各有方法quack和fly方法，当我们的叫声和飞行方法有变动的时候我们只需要实现要改变的方法的接口就行。比如我们现在需要有一个火箭飞行的行为那么我们创建一个RocketFlyBehavior实现FlyBehavior接口然后重写方法就行了。 那么具体怎么使用呢？我们可以直接在Duck基类里增加两个接口字段QuackBehavior和FlyBehavior就行，然后我们基类的fly和quack方法中直接调用接口字段的fly方法和quack方法就行了，如果这时候我们需要给一个鸭子更换功能，我们直接调用接口字段的set方法就行了。 代码示例Duck抽象类123456789101112131415161718192021222324252627282930313233343536/** * @author Lin * @date 2019-05-21 20:07 **/public abstract class AbstractDuck &#123; protected FlyBehavior mFlyBehavior; protected QuackBehavior mQuackBehavior; public AbstractDuck()&#123; &#125; public void fly()&#123; mFlyBehavior.fly(); &#125; public void quack()&#123; mQuackBehavior.quack(); &#125; public void setQuackBehavior(QuackBehavior qb) &#123; mQuackBehavior = qb; &#125; public void setFlyBehavior(FlyBehavior fb) &#123; mFlyBehavior = fb; &#125; public abstract void display(); public void swim() &#123; System.out.println("~~im swim~~"); &#125;&#125; 两个实现类123456789101112131415public class GreenHeadDuck extends AbstractDuck &#123; public GreenHeadDuck() &#123; mFlyBehavior = new GoodFlyBehavior(); mQuackBehavior = new GeGeQuackBehavior(); &#125; @Override public void display() &#123; System.out.println("**GreenHead**"); &#125; @Override public void fly() &#123; System.out.println("~~no fly~~"); &#125;&#125; 123456789101112public class RedHeadDuck extends AbstractDuck &#123; public RedHeadDuck() &#123; mFlyBehavior = new GoodFlyBehavior(); mQuackBehavior = new GeGeQuackBehavior(); &#125; @Override public void display() &#123; System.out.println("**RedHead**"); &#125;&#125; 测试类123456789101112131415161718192021222324252627/** * @author Lin * @date 2019-05-21 20:58 **/public class Main &#123; public static void main(String[] args) &#123; AbstractDuck greenHeadDuck = new GreenHeadDuck(); AbstractDuck redHeadDuck = new RedHeadDuck(); //默认调用 greenHeadDuck.display(); greenHeadDuck.fly(); greenHeadDuck.quack(); greenHeadDuck.swim(); //将红头鸭的飞行方法改成不能飞 redHeadDuck.setFlyBehavior(new BadFlyBehavior()); redHeadDuck.display(); redHeadDuck.fly(); redHeadDuck.quack(); redHeadDuck.swim(); //当我们增加行为的时候增加相应接口然后实现相应接口并将接口加入基类字段并实现set方法和相应方法调用接口里面的方法就行了 &#125;&#125; 总结 策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。 原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优先队列和堆]]></title>
    <url>%2F2019%2F05%2F19%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%2F</url>
    <content type="text"><![CDATA[什么是优先队列 普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院挂急诊的优先级大于普通排队就诊的，比如在游戏中自动打怪设置，当地图中出现级别高的野怪先打级别高的等等。 如果我们实现优先队列使用普通的线性结构，那么当我们入队的时候时间复杂度就是O(1)，但出队的时候我们的时间复杂度就是O(n)，因为出队的时候是优先级最高的出队，所以我们需要遍历整个队列寻找优先级最高的元素。 如果我们实现优先队列使用的顺序线性结构，那么我们出队的时间复杂度就是O(1)，因为原本队列就是依靠优先级排列的，这时候我们出队只需要取出第一个元素就行了。但是，当我们进行入队操作的时候我们就需要维持队列的顺序性，这时候入队就是O(n)的时间复杂度了。 相较于前面两种实现方法，使用堆来实现优先队列的入队操作和出队操作都是O(logn)的时间复杂度，这是非常快的。 什么是堆 堆其实就是按照层由上到下，由左到右的树结构，其中可以分为最大堆和最小堆(根元素为最大的元素就是最大堆) 当我们使用数组实现堆的时候，这时候父子节点的索引值存在着一种数学关系。 当索引从0开始的时候，父亲节点的索引就是子节点的索引-1再除以2(取整的性质，所以左右孩子都一样)，相应的，左孩子就是父亲节点索引乘2+1，右孩子则是左孩子+1。 通过这个关系我们就可以很轻松的使用数组存储二叉堆。 最大堆的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * @author Lin * @date 2019-05-19 17:03 **/public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; array; public MaxHeap(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public MaxHeap()&#123; array = new Array&lt;&gt;(); &#125; public int size()&#123; return array.getSize(); &#125; public boolean isEmpty()&#123; return array.isEmpty(); &#125; /** * 返回index索引的父亲节点的索引 * @param index 索引 * @return 父亲节点的索引 */ private int parent(int index)&#123; if (index == 0)&#123; throw new IllegalArgumentException("index-0 doesn't have parent"); &#125; return (index - 1) / 2; &#125; /** * 获取节点左孩子的索引 * @param index 节点索引 * @return 左孩子索引 */ private int leftChild(int index)&#123; return index * 2 + 1; &#125; /** * 获取右孩子索引 * @param index 费节点的索引 * @return 右孩子的索引 */ private int rightChild(int index)&#123; return index * 2 + 2; &#125; public void add(E e)&#123; array.addLast(e); siftUp(array.getSize() - 1); &#125; /** * 堆中元素上浮 * @param index 指定上浮元素 */ private void siftUp(int index) &#123; //当父元素比指定元素小的时候交换，如果交换则继续去比较 while(index &gt; 0 &amp;&amp; array.get(parent(index)).compareTo(array.get(index)) &lt; 0)&#123; array.swap(index, parent(index)); index = parent(index); &#125; &#125; public E getMax()&#123; if (array.getSize() == 0)&#123; throw new IllegalArgumentException("The heap is empty"); &#125; return array.getFirst(); &#125; public E extractMax()&#123; E temp = getMax(); //将堆顶元素和堆的最后一个元素交换位置 array.swap(0, array.getSize() - 1); //删除最后一个元素(原来的堆顶元素) array.removeLast(); siftDown(0); return temp; &#125; /** * 堆中元素的下沉 * @param index 需要下沉的索引 */ private void siftDown(int index) &#123; //判断index合法性 if (index &lt; 0 || index &gt; array.getSize())&#123; throw new IllegalArgumentException("Index is illegal"); &#125; //遍历堆，条件是左孩子存在 while (leftChild(index) &lt; array.getSize())&#123; int j = leftChild(index); //如果右孩子存在则比较左右孩子，将大的索引赋值给j if (j + 1 &lt; array.getSize() &amp;&amp; array.get(j).compareTo(array.get(j + 1)) &lt; 0)&#123; j ++; &#125; if (array.get(index).compareTo(array.get(j)) &gt;= 0)&#123; //如果需要下沉的节点已经比左右孩子最大的大了直接break break; &#125;else &#123; array.swap(index, j); index = j; &#125; &#125; &#125;&#125; 最大堆的入队和出队的操作 在上述代码中，其他操作都是最基本的，但是对于插入和移除元素就会稍微复杂了。 当我们插入元素的时候，我们需要在数组最后插入元素，但是插入元素的大小不一定性决定着我们需要重新排列这个二叉堆使它还满足最大堆的特性。所以我们只需要和插入元素的父亲节点比较，如果我们插入的节点大于父亲节点了则交换，然后再和交换后的父亲节点比较，一直到根节点或者子节点小于父亲节点了。 当我们移除元素的时候，其实就是移除堆中的顶层元素，这时候如果直接移除的话，那么堆就会变成两个堆，这样整合成一个堆的话太复杂，这时候我们可以将堆底元素和堆顶元素交换，然后再删除堆底元素(原来堆顶元素),然后我们通过现在堆顶元素和它的左右孩子最大的作比较，如果小于最大的那么就交换，然后再次和左右孩子做比较直到自己没有左右孩子为止。 使用堆来实现优先队列123456789101112131415161718192021222324252627282930313233343536373839/** * @author Lin * @date 2019-05-19 20:48 **/ //优先队列中的元素必须是可比较的 //其他的方法直接复用堆中的方法就行了public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue()&#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public void enqueue(E e) &#123; maxHeap.add(e); &#125; @Override public E dequeue() &#123; return maxHeap.extractMax(); &#125; @Override public int getSize() &#123; return maxHeap.size(); &#125; @Override public E getFront() &#123; return maxHeap.getMax(); &#125; @Override public boolean isEmpty() &#123; return maxHeap.isEmpty(); &#125;&#125; 关于LeetCode中优先队列的问题 分析: 我们需要获取频率出现最高的元素，我们需要将频率和元素(key)存入一个map中，然后遍历这个数组，当map不存在相应key的数组中的元素，则将value设置为1，如果存在value++。 然后我们遍历这个map中的key，将key存入优先队列中(容量为k)，当k的容量存满了并且还需要添加元素到优先队列的时候就判断优先队列优先度最高的元素和插入元素的优先度，如果插入元素的优先度高于现在队列中最高的，那么就将元素插入到队列中，知道整个map遍历完。 代码实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; //定义一个Frequency类 //存放key和频率 private class Frequency&#123; public int k, freq; public Frequency(int k, int freq)&#123; this.k = k; this.freq = freq; &#125; &#125; //实现比较器 private class FrequencyCompartor implements Comparator&lt;Frequency&gt;&#123; @Override public int compare(Frequency o1, Frequency o2) &#123; return o1.freq - o2.freq; &#125; &#125; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(20); //遍历数组并且将频率信息存入map中 for (Integer integer : nums)&#123; if (!map.containsKey(integer))&#123; map.put(integer, 1); &#125;else &#123; map.put(integer, map.get(integer) + 1); &#125; &#125; PriorityQueue&lt;Frequency&gt; priorityQueue = new PriorityQueue&lt;&gt;(new FrequencyCompartor()); //遍历map的key，并且将频率最高的放入优先队列中 for (int key: map.keySet()) &#123; if (priorityQueue.size() &lt; k)&#123; priorityQueue.add(new Frequency(key, map.get(key))); &#125;else if (map.get(key) &gt; priorityQueue.peek().freq)&#123; priorityQueue.poll(); priorityQueue.add(new Frequency(key, map.get(key))); &#125; &#125; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); while (!priorityQueue.isEmpty())&#123; linkedList.add(priorityQueue.poll().k); &#125; return linkedList; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集合与映射]]></title>
    <url>%2F2019%2F05%2F13%2F%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是集合(Set) 简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。 定义Set接口123456789101112131415161718192021222324252627282930313233 public interface Set&lt;E&gt; &#123; /** * 增加元素 * @param e 元素 */ void add(E e); /** * 是否包含 * @param e 元素 * @return 布尔 */ boolean contains(E e); /** * 移除元素 * @param e 元素 */ void remove(E e); /** * 获取集合大小 * @return size大小 */ int getSize(); /** * set是否为空 * @return boolean */ boolean isEmpty();&#125; 使用二分搜索树实现集合 对于二分搜索树有一个很重要的特性就是它是根据元素的大小来放入元素到树中的，所以二分搜索树基本是不存在相同元素的，我们就可以通过二分搜索树底层实现集合 这是上一篇博客写的二分搜索树的相关代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276/** * @author Lin * @date 2019-05-05 20:50 **/public class BinarySearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node&#123; private E e; private Node left,right; private Node(E e)&#123; this.e=e; left=null; right=null; &#125; &#125; private Node root; private int size; public BinarySearchTree()&#123; root = null; size = 0; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size==0; &#125; public void add(E e)&#123; root = add(root,e); &#125; private Node add(Node node,E e)&#123; if (node == null)&#123; size ++; return new Node(e); &#125;else if (e.compareTo(node.e) &lt; 0)&#123; node.left = add(node.left,e); &#125;else if (e.compareTo(node.e) &gt; 0)&#123; node.right = add(node.right,e); &#125; return node; &#125; public boolean contains(E e)&#123; return contains(root,e); &#125; private boolean contains(Node node,E e)&#123; if (root==null)&#123; return false; &#125; if (e.equals(node.e))&#123; return true; &#125;else if (e.compareTo(node.e)&lt;0)&#123; return contains(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; return contains(node.right,e); &#125; return false; &#125; public E minimum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return minimum(root).e; &#125; private Node minimum(Node node) &#123; if (node.left==null)&#123; return node; &#125; return minimum(node.left); &#125; public E maximum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return maximum(root).e; &#125; private Node maximum(Node node)&#123; if (node.right==null)&#123; return node; &#125; return maximum(node.right); &#125; public E removeMin()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMin(root).e; &#125; private Node removeMin(Node node)&#123; if (node.left==null)&#123; Node rightNode=node.right; node.right=null; size--; return rightNode; &#125; node.left=removeMin(node.left); return node; &#125; public E removeMax()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMax(root).e; &#125; private Node removeMax(Node node)&#123; if (node.right==null)&#123; Node leftNode=node.left; node.left=null; size--; return leftNode; &#125; node.right=removeMax(node.right); return node; &#125; public void remove(E e)&#123; root=remove(root,e); &#125; private Node remove(Node node,E e)&#123; if (node==null)&#123; return null; &#125; if (e.compareTo(node.e)&lt;0)&#123; node.left=remove(node.left,e); return node; &#125; else if (e.compareTo(node.e)&gt;0) &#123; node.right=remove(node.right,e); return node; &#125; //如果相等就要删除 else &#123; //首先判断这个树是不是只有一边的孩子 //如果只有左边有孩子或者只有右边有孩子 if (node.right==null)&#123; size--; return node.left; &#125;else if (node.left==null)&#123; size--; return node.right; &#125; //如果左右都有孩子 //寻找该节点的后继节点 //后继结点就是离该结点最近的节点（数值最近而且是大于该节点） //那么这个结点的后继结点就是该节点右孩子的最小结点 Node successorNode=minimum(node.right); //我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子 successorNode.right=removeMin(node.right); successorNode.left=node.left; node.left=node.right=null; return successorNode; &#125; &#125; public void preOrder()&#123; preOrder(root); &#125; private void preOrder(Node node)&#123; if (node!=null)&#123; System.out.println(node.e); preOrder(node.left); preOrder(node.right); &#125; &#125; /** * 非递归实现前序遍历 */ public void perOrderWithoutRecurrence()&#123; Stack&lt;Node&gt; stack=new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; Node currentNode=stack.pop(); System.out.println(currentNode.e); if (currentNode.right!=null)&#123; stack.push(currentNode.right); &#125; if (currentNode.left!=null)&#123; stack.push(currentNode.left); &#125; &#125; &#125; /** * 层序遍历(广度优先遍历) */ public void levelOrder()&#123; if (root!=null)&#123; Queue&lt;Node&gt; queue=new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; Node currentNode=queue.remove(); System.out.println(currentNode.e); if (currentNode.left!=null)&#123; queue.add(currentNode.left); &#125; if (currentNode.right!=null)&#123; queue.add(currentNode.right); &#125; &#125; &#125; &#125; public void inOrder()&#123; inOrder(root); &#125; private void inOrder(Node node)&#123; if (node!=null)&#123; inOrder(node.left); System.out.println(node.e); inOrder(node.right); &#125; &#125; public void postOrder()&#123; postOrder(root); &#125; private void postOrder(Node node)&#123; if (node!=null)&#123; postOrder(node.left); postOrder(node.right); System.out.println(node.e); &#125; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); generateBSTString(root, 0, res); return res.toString(); &#125; /** * 生成以node为根节点，深度为depth的描述二叉树的字符串 * @param node * @param depth * @param res */ private void generateBSTString(Node node, int depth, StringBuilder res)&#123; if(node == null)&#123; res.append(generateDepthString(depth) + "null\n"); return; &#125; res.append(generateDepthString(depth) + node.e + "\n"); generateBSTString(node.left, depth + 1, res); generateBSTString(node.right, depth + 1, res); &#125; private String generateDepthString(int depth)&#123; StringBuilder res = new StringBuilder(); for(int i = 0 ; i &lt; depth ; i ++)&#123; res.append("--"); &#125; return res.toString(); &#125;&#125; 这时候我们就可以使用二分搜索树来实现集合了，很简单，直接封装一个二分搜索树然后调用方法就行了。 12345678910111213141516171819202122232425262728293031323334353637/** * @author Lin * @date 2019-05-05 21:08 **/public class BinarySearchTreeSet&lt;E extends Comparable&lt;E&gt;&gt; implements Set&lt;E&gt;&#123; private BinarySearchTree&lt;E&gt; binarySearchTree; public BinarySearchTreeSet()&#123; this.binarySearchTree = new BinarySearchTree&lt;&gt;(); &#125; @Override public void add(E e) &#123; binarySearchTree.add(e); &#125; @Override public void remove(E e) &#123; binarySearchTree.remove(e); &#125; @Override public boolean contains(E e) &#123; return binarySearchTree.contains(e); &#125; @Override public int getSize() &#123; return binarySearchTree.size(); &#125; @Override public boolean isEmpty() &#123; return binarySearchTree.isEmpty(); &#125;&#125; 使用链表来实现集合 链表中有一个contains方法，我们可以在调用add方法的时候使用contains方法判断原来集合中是否已经存在该元素了，如果已经存在那么就添加失败。其他的也是直接调用方法。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author Lin * @date 2019-05-12 10:01 **/public class LinkedListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private LinkedList&lt;E&gt; linkedList; public LinkedListSet()&#123; this.linkedList = new LinkedList&lt;&gt;(); &#125; @Override public void add(E e) &#123; //判断是否已经存在该元素 if (!linkedList.contains(e))&#123; linkedList.addFirst(e); &#125; &#125; @Override public boolean contains(E e) &#123; return linkedList.contains(e); &#125; @Override public void remove(E e) &#123; linkedList.remove(e); &#125; @Override public int getSize() &#123; return linkedList.getSize(); &#125; @Override public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125;&#125; 二分搜索树和链表实现集合的比较 在上面实现链表集合的时候我们很容易就会发现，链表集合的增加操作的时候需要先判断整个链表中是否存在该元素，那么这样就需要O(n)的时间复杂度了，在删除，查找元素的时候都是和普通链表一样O(n)的时间复杂度。可以说链表实现的集合的效率并不是很高。 那么我们再来看一看二分搜索树实现的集合的时间复杂度。当我们添加元素的时候我们是依靠二分搜索树的特性来添加的 比如我们需要添加一个元素的时候，我们就需要先判断大小，然后根据树的特性一层一层遍历，这个时候我们就会发现，我们的时间复杂度是和这个二分搜索树的高度呈线性关系的。 然后我们通过运算就可以得出一个平衡二叉树h层一共有2的h次方-1个元素，我们就很容易得出时间复杂度为log2(n+1)，忽略常数，那么就是logn。 而logn和n的差距在基数很大的时候差距特别明显 所以说二分搜索树实现的集合会比链表实现的集合快很多。当然这也是考虑树的最好情况。当树不为平衡二叉树的时候，最坏情况也会是O(n)。 如上图右边，我们看到当树成一边排列的时候，它的时间复杂度就是O(n)。 LeetCode上解决关于集合的题目 题目是这样的： 对于这道题，我们可以遍历这个words数组，然后得到其中的某个元素再次遍历字符串的每个字母，然后通过原先定义的摩尔斯密码表数组和字符相对应，之后我们就可以获取到这个单词的摩尔斯密码，我们循环完一次之后，我们就把得到的摩尔斯密码拼接成字符串然后存入到set中，最终循环完成之后我们只要返回set的size就行了。 实现代码: 123456789101112131415161718192021222324252627 /** * @author Lin * @date 2019-05-12 13:39 **/public class Solution &#123; public int uniqueMorseRepresentations(String[] words) &#123; //预先定义摩尔斯密码表 String[] codes = &#123;".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."&#125;; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (String word : words) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0 ; i &lt; word.length() ; i ++)&#123; //拼接字符串 stringBuilder.append(codes[word.charAt(i) - 'a']); &#125; //存入set中 set.add(stringBuilder.toString()); &#125; return set.size(); &#125;&#125; 什么是映射(Map,字典) 映射，在定义域中每一个值在值域都有一个值与他对应 存储(键，值)数据对的数据结构（Key，Value） 根据键(Key)，寻找值(Value) 定义Map接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @author Lin * @date 2019-05-13 20:07 **/public interface Map&lt;K, V&gt; &#123; /** * 添加元素 * @param k key * @param v value */ void add(K k, V v); /** * 删除元素 * @param k key * @return key对应的value */ V remove(K k); /** * 设置相应key的value * @param k key * @param v value */ void set(K k, V v); /** * 获取某个key对应的value * @param k key * @return value */ V get(K k); /** * 判断是否包含 * @param k key * @return 是否包含 */ boolean contains(K k); /** * 获取映射的大小 * @return 映射大小 */ int getSize(); /** * 判断映射是否为空 * @return 是否为空 */ boolean isEmpty();&#125; 链表实现Map 使用链表实现Map其实只需要将私有类Node里面的字段e更改为key和value就行。当然BinarySearchTree也是如此 实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * @author Lin * @date 2019-05-13 20:17 **/public class LinkedListMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private class Node&#123; private K key; private V value; private Node next; public Node(K key, V value, Node next)&#123; this.key = key; this.value = value; this.next = next; &#125; public Node(K key, V value)&#123; this.key = key; this.value = value; &#125; public Node()&#123; this.key = null; this.value = null; this.next = null; &#125; @Override public String toString()&#123; return key.toString() + " : " + value.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedListMap()&#123; dummyHead = new Node(); size = 0; &#125; private Node getNode(K key)&#123; Node currentNode = dummyHead.next; while (currentNode != null)&#123; if (currentNode.key.equals(key))&#123; return currentNode; &#125;else &#123; currentNode = currentNode.next; &#125; &#125; return null; &#125; @Override public void add(K k, V v) &#123; //首先判断是否已经存在该key的映射 Node node = getNode(k); if (node == null)&#123; dummyHead.next = new Node(k, v, dummyHead.next); size ++ ; &#125;else &#123; //如果存在则更新 node.value = v; &#125; &#125; @Override public V remove(K k) &#123; Node preNode = dummyHead; while (preNode.next != null)&#123; if (preNode.next.key.equals(k))&#123; Node delNode = preNode.next; preNode.next = preNode.next.next; delNode.next = null; size --; break; &#125;else &#123; preNode = preNode.next; &#125; &#125; return null; &#125; @Override public void set(K k, V v) &#123; //首先判断是否存在该key的映射，如果不存在则抛出异常 Node node = getNode(k); if(node == null)&#123; throw new IllegalArgumentException(k + " doesn't exist!"); &#125;else &#123; node.value = v; &#125; &#125; @Override public V get(K k) &#123; Node node = getNode(k); return node == null ? null : node.value; &#125; @Override public boolean contains(K k) &#123; return getNode(k) != null; &#125; @Override public int getSize() &#123; return this.size; &#125; @Override public boolean isEmpty() &#123; return this.size == 0; &#125;&#125; 二分搜索树实现映射(Map) 对于BinarySearchTree来说实现Map也是利用它原先的方法 代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196/** * @author Lin * @date 2019-05-13 20:51 **/public class BinarySearchTreeMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; private class Node&#123; public K key; public V value; public Node left, right; public Node(K key, V value)&#123; this.key = key; this.value = value; left = null; right = null; &#125; public Node()&#123; left = null; right = null; this.value = null; this.key = null; &#125; &#125; private int size; private Node root; public BinarySearchTreeMap()&#123; root = null; size = 0; &#125; //辅助方法，在删除，修改映射的value时候会用到 //获取相应key对应的Node(递归) private Node getNode(Node node, K key)&#123; //如果递归到节点为null直接返回null if (node == null)&#123; return null; &#125;else if (key.compareTo(node.key) &lt; 0)&#123; //小于的时候继续递归该结点的左子树 return getNode(node.left, key); &#125;else if (key.compareTo(node.key) &gt; 0)&#123; //大于的时候继续递归该结点的右子树 return getNode(node.right, key); &#125;else &#123; //不然就是相等，则直接返回该结点 return node; &#125; &#125; @Override public void add(K key, V value)&#123; root = add(root, key, value); &#125; private Node add(Node node, K key, V value)&#123; //递归到最底层，直接添加节点 if (node == null)&#123; size ++; return new Node(key, value); &#125;else if (key.compareTo(node.key) &lt; 0)&#123; //小于的时候直接递归该结点的左子树 node.left = add(node.left, key, value); &#125;else if (key.compareTo(node.key) &gt; 0)&#123; node.right = add(node.right, key, value); &#125; return node; &#125; /** * 返回以node为根的二分搜索树的最小值所在的节点 * @param node * @return */ private Node minimum(Node node)&#123; if(node.left == null)&#123; return node; &#125; return minimum(node.left); &#125; /** * 删除掉以node为根的二分搜索树中的最小节点 * 返回删除节点后新的二分搜索树的根 * @param node * @return */ private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; /** * 从二分搜索树中删除键为key的节点 * @param key * @return */ @Override public V remove(K key)&#123; Node node = getNode(root, key); if(node != null)&#123; root = remove(root, key); return node.value; &#125; return null; &#125; private Node remove(Node node, K key)&#123; if( node == null )&#123; return null; &#125; if( key.compareTo(node.key) &lt; 0 )&#123; node.left = remove(node.left , key); return node; &#125; else if(key.compareTo(node.key) &gt; 0 )&#123; node.right = remove(node.right, key); return node; &#125; else&#123; // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; @Override public void set(K key, V newValue)&#123; Node node = getNode(root, key); if(node == null)&#123; throw new IllegalArgumentException(key + " doesn't exist!"); &#125; node.value = newValue; &#125; @Override public V get(K k) &#123; Node node = getNode(root, k); return node == null ? null : node.value; &#125; @Override public boolean contains(K k) &#123; return getNode(root, k) != null; &#125; @Override public int getSize() &#123; return this.size; &#125; @Override public boolean isEmpty() &#123; return this.size == 0; &#125;&#125; 链表Map和二分搜索树Map比较 测试代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestMap &#123; private static double testMap(Map&lt;String, Integer&gt; map, String filename)&#123; long startTime = System.nanoTime(); System.out.println(filename); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(filename, words)) &#123; System.out.println("Total words: " + words.size()); for (String word : words)&#123; if(map.contains(word))&#123; map.set(word, map.get(word) + 1); &#125;else&#123; map.add(word, 1); &#125; &#125; System.out.println("Total different words: " + map.getSize()); System.out.println("Frequency of PRIDE: " + map.get("pride")); System.out.println("Frequency of PREJUDICE: " + map.get("prejudice")); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0; &#125; public static void main(String[] args) &#123; String filename = "I:\\data_structure\\src\\pride-and-prejudice.txt"; Map&lt;String, Integer&gt; bstMap = new BinarySearchTreeMap&lt;&gt;(); double time1 = testMap(bstMap, filename); System.out.println("BST Map: " + time1 + " s"); System.out.println(); Map&lt;String, Integer&gt; linkedListMap = new LinkedListMap&lt;&gt;(); double time2 = testMap(linkedListMap, filename); System.out.println("Linked List Map: " + time2 + " s"); &#125;&#125; 两者时间差异: 可以看出，二分搜索树实现的Map的时间性能是远高于链表实现的Map的。 因为对于链表实现修改某一映射对应的value值的时间复杂度是O(n),我们需要一个一个去遍历知道找到key符合的元素。 而对于二分搜索树实现的Map来说，它修改一个value的时间复杂度是跟二叉树的高度相关的，也就是说它的时间复杂度是O(logn)级别的，所以当数据量大的时候，二分搜索树的优势非常明显。当然我们还需要考虑最坏的情况，那就是这个二分搜索树变成了类似于链表的树，那这时候时间复杂度就是O(n)了。 但是有个细节需要注意的是，链表实现的Map的key是无序的，上文中的set也是无序的。但是二分搜索树实现的set和map都是有序的(这也是它这么快的一部分原因)。 使用Map来实现Set 我们可以发现，其实Set就是一个没有value的的Map。所以，当我们底层实现了一个映射，集合我们就可以理解成Map&lt;K, V&gt;中value为null的情况，对于不管是k，它所对应的的value都为null。 所以当我们在Map中只考虑K的时候，整个Map数据结构就变成了K的集合。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合RabbitMQ以及四种交换模式]]></title>
    <url>%2F2019%2F05%2F09%2FSpringBoot%E6%95%B4%E5%90%88RabbitMQ%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是消息队列 在google的时候发现知乎一个很好的回答，很生动形象。 作者：ScienJus 原文链接 个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。使用场景的话，举个例子：假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：校验用户名等信息，如果没问题会在数据库中添加一个用户记录如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他发送给用户一个包含操作指南的系统通知等等……但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了。 我理解的消息队列就是当你的一个接口访问量大或者需要进行的操作很多，就比如注册这些功能(里面有发邮件，插入数据各种操作)，但是用户只需要知道是否注册成功，他们需要马上收到注册结果(提高用户体验性)，所以当用户的信息插入到数据库中我们就可以直接返回结果，至于后面的操作可以放入消息队列异步慢慢处理。 SpringBoot整合RabbitMQ maven配置 首先当然是maven配置了，springboot中为我们提供了amqp的start,amqp是一个消息队列的协议，RabbitMQ实现了这个协议。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; springboot配置文件的配置 1234567891011121314151617181920rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest virtual-host: / listener: simple: concurrency: 10 max-concurrency: 10 prefetch: 1 auto-startup: true default-requeue-rejected: true template: retry: enabled: true initial-interval: 1000ms max-attempts: 3 max-interval: 10000ms multiplier: 1.0 除了host，port什么的其他都可以不写，springboot已经默认帮我们配置好了。 RabbitMQ的配置类 1234567891011@Configurationpublic class RabbitConfig &#123; public static final String QUEUE = "queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; &#125; 消息发送者(提供者) 12345public void send(Object message)&#123; logger.info("send"); //标注需要发送的某个队列 amqpTemplate.convertAndSend(RabbitConfig.QUEUE,message);&#125; 消息接收者(消费者) 123456//@RabbitListener注解需要标注刚刚我们的队列名//其作用就是监听那个队列是否有消息，有消息则接收@RabbitListener(queues = RabbitConfig.QUEUE)public void receive(String message)&#123; logger.info("receive:"+message);&#125; RabbitMQ的四种模式 RabbitMQ分为四种模式 * Direct模式 * Topic模式 * Fanout模式 * Headers模式 Direct模式(直接交换模式) 刚刚我们的配置类，接受者和发送者实现的就是Direct模式，其流程就是发送者指定一个Queue来发送消息给那个队列，然后消费者一直监听那个队列，有消息则接收 Topic模式 首先是Topic的配置类，这里定义两个Queue，并且生成一个TopicExchange(Topic交换机)。 然后我们通过Binding来将A和B的消息队列绑定到我们刚刚生成的TopicExchange和指定routingKey中 123456789101112131415161718192021222324@Beanpublic Queue topicQueueA()&#123; return new Queue(TOPIC_QUEUE_A, true);&#125;@Beanpublic Queue topicQueueB()&#123; return new Queue(TOPIC_QUEUE_B, true);&#125; @Beanpublic TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE);&#125;@Beanpublic Binding topicBindingA()&#123; return BindingBuilder.bind(topicQueueA()).to(topicExchange()).with("topic.keyA");&#125;@Beanpublic Binding topicBindingB()&#123; return BindingBuilder.bind(topicQueueB()).to(topicExchange()).with("topic.#");&#125; 然后是我们的消息发送者 123456789public void topicSend(Object message)&#123; logger.info("topic send"); //我们指定某个routingkey发送到这个交换机上 //然后这个topic交换机会将我们的routingKey审核 //如果这个key和某个队列绑定的key匹配那么这个消息就会发送到这个队列里 //在队列绑定routingKey的时候可以使用#,*这些通配符,所以就会出现我发送一个消息，两个队列都收到了，我发送两个消息都是一个队列收到等情况，如图所示。 amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, "topic.keyA", message); amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, "topic.keyB", message);&#125; 最后是我们的消息消费者(接收者) 12345678910//接收很简单，只要指定队列就行@RabbitListener(queues = RabbitConfig.TOPIC_QUEUE_A)public void topicReceiveA(String message)&#123; logger.info("receive:" + message);&#125;@RabbitListener(queues = RabbitConfig.TOPIC_QUEUE_B)public void topicReceiveB(String message)&#123; logger.info("receive:" + message);&#125; Fanout模式 首先是Fanout的配置类,跟上面的topic查不到，我们先配置一个FanoutExchange类，然后通过Binding将队列绑定到那个Exchange中，我们可以绑定多个队列到Exchange中。 123456789101112131415161718192021222324@Beanpublic Queue fanoutQueueA()&#123; return new Queue(FANOUT_QUEUE_A, true);&#125;@Beanpublic Queue fanoutQueueB()&#123; return new Queue(FANOUT_QUEUE_B, true);&#125;@Beanpublic FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE);&#125;@Beanpublic Binding fanoutBindingA()&#123; return BindingBuilder.bind(fanoutQueueA()).to(fanoutExchange());&#125;@Beanpublic Binding fanoutBindingB()&#123; return BindingBuilder.bind(fanoutQueueB()).to(fanoutExchange());&#125; 然后就是我们的发送者 12345//我们只要将消息发送给交换机就好public void fanoutSend(Object message)&#123; logger.info("fanout send"); amqpTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, "", message);&#125; 最后是我们的消费者,这时候我们会发现这个Fanout模式就是类似于广播模式，我们将所有需要的队列都绑定上Fanout的Exchange中，然后我们发送者只需要将消息发送给Exchange，然后我们的消费者在所有的Queue中都能接收到消息。 123456789@RabbitListener(queues = RabbitConfig.FANOUT_QUEUE_A)public void fanoutReceiveA(String message)&#123; logger.info("fanoutA receive:"+message);&#125;@RabbitListener(queues = RabbitConfig.FANOUT_QUEUE_B)public void fanoutReceiveB(String message)&#123; logger.info("fanoutB receive:"+message);&#125; Headers模式 首先是我们的配置类，这个Header跟上面几种有些不一样 12345678910111213141516171819@Beanpublic Queue headersQueue()&#123; return new Queue(HEADERS_QUEUE);&#125;@Beanpublic HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE);&#125;//前面两个和上述三种都差不多，这里的Binding有些不一样@Beanpublic Binding headersBinding()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(5); map.put("HeadersAKey","HeadersAValue"); map.put("HeadersBKey","HeadersBValue"); //我们需要创建一个map存入键值对，然后绑定队列到交换机上，并且有个要求就是where什么什么加入map需要匹配，我们先看消息发送者 return BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match();&#125; 然后是我们的发送者 123456789101112public void headersSend(String message)&#123; logger.info("headers send"); //这里的发送者的发送方法需要的是一个交换机名称，还有一个就是Message对象 //这个Message对象存入了真正消息的字符数组和消息的配置类，这里的消息配置类就是MessageProperties //我们需要对这个MessageProperties设置头，这个头就是键值对，就是我们配置类设置的map //我们发送消息给队列，这个消息的头被设置为我配置类书写的那两个map才行，因为我设置了whereAll.match，所以我发送消息给交换机，这个交换机会帮我去匹配请求头和我设置的符合的Queue并把消息存入那个队列中 MessageProperties messageProperties = new MessageProperties(); messageProperties.setHeader("HeadersAKey","HeadersAValue"); messageProperties.setHeader("HeadersBKey","HeadersBValue"); Message headersMessage = new Message(message.getBytes(),messageProperties); amqpTemplate.convertAndSend(RabbitConfig.HEADERS_EXCHANGE, "", headersMessage);&#125; 最后是我们的接收者 12345//这个时候我们接收的就是字符数组了，因为我们再发送者的方法中是将消息变成byte[]再作为参数进行入队的@RabbitListener(queues = RabbitConfig.HEADERS_QUEUE)public void headersReceive(byte[] message)&#123; logger.info("headers receive:"+new String(message));&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分搜索树的遍历]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二分搜索树的遍历 其实这里就是二叉树的遍历，只是因为二分搜索树因为是依靠它的特定规则而排列的，所以再经过不同方法遍历之后，它的顺序会有很多特点。 我们是依靠根节点顺序来命名的，记住！是根结点。 前序遍历就是先遍历根结点，然后遍历左结点，最后遍历右结点。 中序遍历就是先遍历左结点，然后遍历根结点，最后遍历右结点。 后序遍历就是先遍历左结点，然后遍历右结点，最后遍历根结点。 最后要注意，这个提示可能不是适合所有人，对于我来说，我书写一个二叉树的前中后序遍历的时候都告诫自己要等待一个结点能遍历的时候才能遍历，什么意思呢？就是要遍历一个结点的时候需要把它的子节点先遍历了（子节点优先遍历），其实这个前中后序遍历另一个名字就是深度优先遍历，跟这个有关。 慕课网中有另一种快速书写三种遍历方式遍历后的顺序结果的方法，如图: 它是在每个结点上画上三个点，然后不管什么遍历方式都从根节点到左节点到右节点的方式遍历(比较图中)，每个结点其实都会经过三次，当中序遍历就去中间的点作为顺序参照，前序遍历就取左边的点作为顺序参照，后序遍历就取右边的点作为顺序参照。 如果中序和后序的图看不懂，那么就将前序遍历那些顺序线放入中序和后序的图中，然后根据那个顺序线依次找蓝色的点，最后这些点连接成的就是遍历顺序了。 深度优先遍历的递归代码实现 前面说了，前中后序遍历都可以称为深度优先遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142//前序遍历public void preOrder()&#123; preOrder(root);&#125;//前序遍历private void preOrder(Node node)&#123; if (node!=null)&#123; //先打印根节点 System.out.println(node.e); //然后遍历左节点 preOrder(node.left); //遍历右结点 preOrder(node.right); &#125;&#125; public void inOrder()&#123; inOrder(root);&#125;private void inOrder(Node node)&#123; if (node!=null)&#123; //优先遍历左节点 inOrder(node.left); System.out.println(node.e); inOrder(node.right); &#125;&#125;public void postOrder()&#123; postOrder(root);&#125;private void postOrder(Node node)&#123; if (node!=null)&#123; //先遍历左节点 postOrder(node.left); //然后遍历右结点 postOrder(node.right); //最后遍历根结点 System.out.println(node.e); &#125;&#125; 使用递归实现深度优先遍历很简单，只需要记住顺序就行了。 非递归实现前序遍历 其实非递归实现前序遍历就是模拟系统方法栈，这时候我们不通过递归，我们就要自己使用栈来实现前序遍历。 比如说我们需要将一个树前序遍历，这时候我们先将根结点放入我们new的一个栈中，然后我们把栈中这个结点元素取出来，对它进行打印(或者其他操作)，然后我们将它的右孩子，左孩子依次放入栈中(因为栈是先进后出)。然后我们再次取出栈中的一个元素，这时候我们取的是根结点的左孩子，然后我们对这个节点进行打印，然后把这个结点的右左孩子依次放入栈中，继续进行出栈操作。。。 代码实现： 12345678910111213141516171819 /** * 非递归实现前序遍历 */public void perOrderWithoutRecurrence()&#123; Stack&lt;Node&gt; stack=new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; //栈中元素不为空那么就出栈操作 Node currentNode=stack.pop(); System.out.println(currentNode.e); //依次将右左孩子放入栈中 if (currentNode.right!=null)&#123; stack.push(currentNode.right); &#125; if (currentNode.left!=null)&#123; stack.push(currentNode.left); &#125; &#125;&#125; 二叉树的层序遍历 层序遍历又是广度优先遍历，它是将树一层一层地进行遍历的。 比如上图，我们广度优先遍历（层序遍历）的顺序就是28,16,30,13,22,29,42. 我们如何实现呢？其实我们这时候需要一个队列，这个队列里将根结点放入，然后把根结点取出来进行操作（同时也要将队列里的根节点删除，后面的结点被取出来的时候也要删除），然后把根节点的左孩子，右孩子依次进行入队，这时候我们再取出队列里的第一个元素（根节点的左孩子结点），然后我们对它进行操作并删除队列里它的元素，然后将他的左右孩子依次入队，之后我们再取出来队列的第一个元素（根节点的右孩子），后面依次同上操作，如图所示。 代码实现： 12345678910111213141516171819 /** * 层序遍历(广度优先遍历) */public void levelOrder()&#123; if (root!=null)&#123; Queue&lt;Node&gt; queue=new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; Node currentNode=queue.remove(); System.out.println(currentNode.e); if (currentNode.left!=null)&#123; queue.add(currentNode.left); &#125; if (currentNode.right!=null)&#123; queue.add(currentNode.right); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分搜索树的增删改查]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[什么是二分搜索树 首先我们要先知道二叉树是什么，二叉树其实就是从一个根节点左右两端延伸出左右结点，延伸出的结点再次延伸出结点，然后一直延伸下去，所以树这种数据结构天生满足递归特性。 而二分搜索树就是对二叉树做了一个限制，首先二分搜索树中的元素必须是可比较的（对于Java来说就是必须继承Comparable接口）。为什么需要它可比较呢？就是因为，二分搜索树的排列需要根据数值来排列。 二分搜索树的某个结点的左孩子必须小于原来的节点且某个结点的左子树的所有结点必须比这个结点小。 右边同上。 二分搜索树的基本定义 根据上面的定义，我们很容易就能写出代码 12345678910111213141516171819public class BinarySearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node&#123; private E e; private Node left,right; private Node(E e)&#123; this.e=e; left=null; right=null; &#125; &#125; private Node root; private int size; public BinarySearchTree()&#123; root=null; size=0; &#125;&#125; 二分搜索树的一些方法 首先就是getSize()和isEmpty()方法，很容易，返回size和判断size是否为0就行了 1234567public int size()&#123; return size;&#125;public boolean isEmpty()&#123; return size==0;&#125; 添加元素 添加元素的时候我们只需要在树的叶子节点中添加就行了。 12345678910111213141516171819202122232425262728293031public void add(E e)&#123; //如果根节点为空，那么直接new if(root==null)&#123; root=new Node(e); &#125;else&#123; add(root,e); &#125;&#125;private void add(Node node,E e)&#123; //如果这个结点不等于这个时候才能添加元素 if (!e.equals(node.e))&#123; //如果插入元素小于该结点的元素且该结点的左孩子为空 //那么直接插入左孩子 if (e.compareTo(node.e)&lt;0&amp;&amp;node.left==null)&#123; node.left=new Node(e); size++; &#125; //这个同上 else if (e.compareTo(node.e)&gt;0&amp;&amp;node.right==null)&#123; node.right=new Node(e); size++; &#125; //如果小于，那么就递归调用 else if (e.compareTo(node.e)&lt;0)&#123; add(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; //同上 add(node.right,e); &#125; &#125;&#125; 当然添加方法还有优化的地方 1234567891011121314151617public void add(E e)&#123; add(root,e);&#125;private Node add(Node node,E e)&#123; if (node==null)&#123; //该结点为空，那么直接返回给上一级new出来的元素为e的节点，这里就是添加，只是现在遍历到最后了而已 return new Node(e); &#125;else if (e.compareTo(node.e)&lt;0)&#123; //如果小于，那么该结点的左孩子就是下一层二分搜索树的添加元素后的二分搜索树 node.left=add(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; //如果大于，那么该结点的右孩子就是下一层二分搜索树的添加元素后的二分搜索树 node.right=add(node.right,e); &#125; //最后return被添加过结点的根节点 return node;&#125; 查询元素 这里就是判断二分搜索树是否包含某个元素 1234567891011121314151617181920public boolean contains(E e)&#123; return contains(root,e);&#125;private boolean contains(Node node,E e)&#123; //如果该树的根节点就是空，那么直接false if (root==null)&#123; return false; &#125; //如果查询到了那么返回该结点 if (e.equals(node.e))&#123; return true; &#125;else if (e.compareTo(node.e)&lt;0)&#123; //小于的时候遍历左孩子树 return contains(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; //大于的时候遍历右孩子树 return contains(node.right,e); &#125; return false;&#125; 获取最小元素和最大元素 123456789101112131415161718192021222324252627public E minimum()&#123; //当树的大小为0就不能删除 if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return minimum(root).e;&#125;private Node minimum(Node node) &#123; //当遍历到最后的某个结点的左孩子为null，那么这个结点就是最小元素 if (node.left==null)&#123; return node; &#125; return minimum(node.left);&#125;//同理public E maximum()&#123;if (size==0)&#123; throw new IllegalArgumentException("BST is empty");&#125;return maximum(root).e;&#125;private Node maximum(Node node)&#123;if (node.right==null)&#123; return node;&#125;return maximum(node.right);&#125; 删除元素，其中删除元素是最复杂的，对于删除最小最大元素来说并不复杂，因为只需要往左往右遍历二分搜索树就行了，但是对于任意元素的删除就要考虑多种情况。 删除最小元素 123456789101112131415161718192021public E removeMin()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMin(root).e;&#125;private Node removeMin(Node node)&#123; //如果左孩子为空，那么这个结点就是要删除的结点 if (node.left==null)&#123; //将该结点的右子树放入临时变量 Node rightNode=node.right; //将这个结点的右子树置为null，然后返回刚刚的临时变量rightNode node.right=null; size--; return rightNode; &#125; //不然就一直向左遍历，并且将下一级删除后返回的二分搜索树赋值给上一级的结点 node.left=removeMin(node.left); return node;&#125; 删除最大元素 1234567891011121314151617public E removeMax()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMax(root).e;&#125;private Node removeMax(Node node)&#123; if (node.right==null)&#123; Node leftNode=node.left; node.left=null; size--; return leftNode; &#125; node.right=removeMax(node.right); return node;&#125; 删除某个结点 我们可以通过寻找需要被删除节点的后继或者前驱，并且把它从原来树中删除然后代替被删除节点的位置 这里我只写了通过后继删除某个元素，当然前驱书写方式也是一样的 12345678910111213141516171819202122232425262728293031323334353637383940public void remove(E e)&#123; root=remove(root,e);&#125;private Node remove(Node node,E e)&#123; if (node==null)&#123; return null; &#125; if (e.compareTo(node.e)&lt;0)&#123; node.left=remove(node.left,e); return node; &#125; else if (e.compareTo(node.e)&gt;0) &#123; node.right=remove(node.right,e); return node; &#125; //如果相等就要删除 else &#123; //首先判断这个树是不是只有一边的孩子 //如果只有左边有孩子或者只有右边有孩子 if (node.right==null)&#123; //如果只有左子树 //那么我们将该结点的左子树返回给上一节点的左子树 size--; return node.left; &#125;else if (node.left==null)&#123; size--; return node.right; &#125; //如果左右都有孩子 //寻找该节点的后继节点 //后继结点就是离该结点最近的节点（数值最近而且是大于该节点） //那么这个结点的后继结点就是该节点右孩子的最小结点 Node successorNode=minimum(node.right); //我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子 successorNode.right=removeMin(node.right); successorNode.left=node.left; node.left=node.right=null; return successorNode; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git中.gitignore文件修改后不起作用]]></title>
    <url>%2F2019%2F05%2F05%2FGit%E4%B8%AD-gitignore%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[问题背景 当我使用git上传项目的时候，有些本应该忽略的文件没有被忽略，这时候我修改.gitignore文件再次上传的时候，本该忽略的文件还是在那里 问题原因 这是因为git缓存的原因，如果某些文件已经被纳入版本管理中，就算是在.gitignore文件中声明了忽略文件的路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再add和push。 问题解决 首先清除本地缓存git rm -r –cached . 再次add文件git add . 提交git commit -m “chore:update .gitignore” pushgit push .gitignore书写格式123456# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从源文件到可执行文件]]></title>
    <url>%2F2019%2F05%2F05%2F%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[关于本文 这篇文章是我阅读《程序是怎样跑起来的》这本书第八章后写的读后感，也说不上读后感，就是把原文一些东西整理一下，方便日后阅读记忆。学校图书馆真是一个好地方，原本以为没有什么好的图书，后面去借阅几次发现了很多好书，这本书也是我在图书馆中借阅的。 计算机只能运行本地代码 什么是源文件和源代码，就是使用某种编程语言编写的程序就称为源代码，保存源代码的文件就是源文件。比如说以.c或者.java为扩展名的文件就是源文件。 但是源文件是无法直接运行的，这是因为CPU能直接解析并运行的不是源代码而是本地代码的程序。 本地(native)，对于CPU来说就是母语的意思，任何编程语言编写的源代码最后都要翻译成本地代码，否则CPU就看不懂。 本地代码的内容 比如说Windows中的EXE文件里面就是本地代码。 我们使用文本工具打开exe文件可以看到类似下图的代码 这时候我们将它转变成十六进制 计算机指令也是数值的罗列，这些就是本地代码。 编译器负责转换源代码 能够把C语言等高级语言转换为本地代码的程序成为编译器，相当于现实中的翻译，每个编程语言都需要专用的编译器，C语言的就叫C编译器，这类似于现实中中文翻译成英文需要专业的英文翻译者。 编译器读入代码内容，然后通过一些对照表把源代码对照翻译成本地代码，当然不仅仅是这么简单，其中还有语法解析，句法解析，语义解析等等，最后才能生成本地代码。 根据CPU的不同，本地代码的类型也不同，所以编译器不仅和编程语言相关还和CPU相关，列入x86系列的CPU用的C编译器就和PowerPC这种CPU的C编译器不同。 还有就是编译器也是一种程序，所以也需要运行环境，那么windows用的C编译器和Linux用的C编译器就不同。还有就是交叉编译器，他生产的是和运行环境中的CPU不同的CPU所使用的的本地代码。 仅靠编译时无法得到可执行文件的 C和C++中编译之后生成的是.obj目标文件，这时候还需要链接才能得到可执行的exe文件。 比如说我们书写了一个函数 其中我们调用了MessageBox函数，sprintf函数。但是在我们的源代码中没有这两个函数的相关实现，比如这个文件生成的是sample.obj，那么这个文件就需要和MessageBox，sprintf的目标文件相结合(链接)，才能生成完整的程序。试想一下这个sample是exe文件，那么这个文件就是不完整的，是无法执行的。 运行连接的程序就称为链接器。 启动及库文件 当我们执行上述sample.c文件的编译 链接操作的时候，我们需要指定两个文件。一个是sample.obj生成的目标文件，另一个是C0w32.obj文件，这个文件是记录着同所有程序气死位置相结合的处理内容，程序程序的启动。 后面我们还需要指定库文件，比如说32.lib cw32.lib库文件，这里面存放着sprintf函数的目标文件和MessageBox函数的目标文件(实际上是在 user32.dll文件中，这是动态链接库) 链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件 如果不指定库文件就会发生无法识别sprintf函数和MessageBox函数的错误 DLL文件及导入库 Windows以函数的形式为应用提供了各种功能，这些函数被称为API(Application Programming Interface应用程序接口) 上面讲到的MessageBox()函数并不是C语言的标准库函数，而是Windows提供的API，这些API的目标文件存储在名为DLL(Dynamic Link Library)文件的特殊库文件中，它是程序运行动态结合的文件，上面我们提到MessageBox的目标文件存储在import32.lib文件中，其实这个文件只存储了两个信息——MessageBox()存储在user32.dll文件中，还有就是这个dll文件的文件夹信息。 我们把类似于import32.lib这样的库文件称为导入库。 DLL文件的好处：DLL文件中的函数可以被多个程序共用，因此借助该功能可以节约内存和磁盘。此外，在对函数的内容做修正的时候不需要重新连接(静态链接)。 另一个就是静态链接库，就是sprintf，存储着sprintf()的cw32.lib就是静态链接库。 可执行文件运行时的必要条件 存储在硬盘中的exe文件运行时要读入内存中执行，在exe文件中我们会给变量和函数分配虚拟的内存地址，在程序运行的时候，这些虚拟内存地址会转换为实际内存地址，链接器会在exe文件的开头，追加转换内存地址所需的必要信息，这个信息称为再配置信息。 可以这么理解，再配置信息里存放了变量和函数的相对地址，这个相对地址就是相对于基地址的偏移量，这样各个变量的内存地址就可以用变量组的基地址加上偏移量作为地址，而这些基地址是在程序运行时被计算机分配的。 程序加载时会生成堆和栈 当程序加载到内存中，出再配置信息，变量组，函数组等还会额外生成两个组，那就是堆和栈。栈是用来存储函数内部使用的临时变量以及函数调用时所用的参数的内存区域。堆是用来存储程序运行时的任意数据和对象的内存领域。 内存泄漏 对于栈来说，它会在函数调用的时候自动分配内存，在函数执行完毕后自动释放内存。但是对于堆来说，C语言需要程序员使用malloc申请分配，free()函数来释放，C++中需要使用new来申请分配，delete来释放，Java和C#这些语言户进行自动垃圾回收，如果我们忘记释放内存，那么这个内存空间就会一直被使用，久而久之就会造成内存泄露(memory leak)从而导致内存不足而卡死，就比如一晚上忘关水龙头，水盆中的水装满并溢出一样。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis插入字段并返回主键的小问题]]></title>
    <url>%2F2019%2F05%2F04%2FMybatis%E6%8F%92%E5%85%A5%E5%AD%97%E6%AE%B5%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用背景 这几天在写秒杀项目，其中有一个需求是生成订单并返回订单号（主键）然后再生成秒杀订单将刚刚返回的订单号作为某个字段插入秒杀订单中，也就是秒杀订单表中的order_id。这其中就使用到了插入信息并返回主键。 我使用的是Mybatis逆向工程生成的Mapper文件，其中自动生成的insert方法返回的是影响的行数，我在使用的时候一直返回给我的是1，导致报错。 相关Mapper的编写 其中最关键的就是在insert标签上增加useGeneratedKeys和keyProperty 12345678910 &lt;insert id="insertOrderAndReturnOrderId" useGeneratedKeys="true" keyProperty="id" parameterType="com.lgq.miaosha.domain.OrderInfo"&gt; insert into t_order_info (id, user_id, goods_id, delivey_addr_id, goods_name, goods_count, goods_price, order_channel, status, create_date, pay_date) values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=BIGINT&#125;, #&#123;goodsId,jdbcType=BIGINT&#125;, #&#123;deliveyAddrId,jdbcType=BIGINT&#125;, #&#123;goodsName,jdbcType=VARCHAR&#125;, #&#123;goodsCount,jdbcType=INTEGER&#125;, #&#123;goodsPrice,jdbcType=DECIMAL&#125;, #&#123;orderChannel,jdbcType=TINYINT&#125;, #&#123;status,jdbcType=TINYINT&#125;, #&#123;createDate,jdbcType=TIMESTAMP&#125;, #&#123;payDate,jdbcType=TIMESTAMP&#125;)&lt;/insert&gt; 其中keyProperty=”id”，这个id就是传入对象中的某个属性值，比如说这里就是OrderInfo对象，执行成功之后就会自动将主键的值赋给对象中的id属性。然后原本作为参数的OrderInfo对象中的id就得到了更新，这时候我们再取这个对象的id字段就可以获取到主键的值了。 使用代码12345678910111213141516171819202122232425262728293031323334353637 /** * 生成订单 * @param user 用户 * @param goodsVo 商品 * @return 订单详情 */ @Transactional public OrderInfo createOrder(User user, GoodsVo goodsVo) &#123; //这里主要就是生成OrderInfo对象 OrderInfo orderInfo=new OrderInfo(); orderInfo.setCreateDate(new Date()); orderInfo.setDeliveyAddrId(0L); orderInfo.setGoodsCount(1); orderInfo.setGoodsId(goodsVo.getId()); orderInfo.setGoodsName(goodsVo.getGoodsName()); orderInfo.setGoodsPrice(goodsVo.getMiaoshaPrice()); byte b=1; orderInfo.setOrderChannel(b); b=0; orderInfo.setStatus(b); orderInfo.setUserId(user.getId()); //插入订单 orderInfoMapper.insertOrderAndReturnOrderId(orderInfo); //最关键的一步 //获取到刚刚对象中的id字段就是主键的值了 Long orderId=orderInfo.getId(); MiaoshaOrder miaoshaOrder=new MiaoshaOrder(); miaoshaOrder.setGoodsId(goodsVo.getId()); //这里不是很严谨，意思是将MiaoShaOrder的id设置成和OrderInfo的id一样 miaoshaOrder.setId(orderId); miaoshaOrder.setUserId(user.getId()); //将miaosha_order表中的order_id字段设置为order_id表中的主键 miaoshaOrder.setOrderId(orderId); miaoshaOrderMapper.insert(miaoshaOrder); return orderInfo; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Redis]]></title>
    <url>%2F2019%2F05%2F03%2FSpringBoot%E6%95%B4%E5%90%88Redis%2F</url>
    <content type="text"><![CDATA[项目介绍 最近在写一个秒杀的项目，是跟着慕课网的一个教程学习的。其中用到了redis进行session共享等等功能，现如今做到的步骤是使用redis将用户信息存入redis中，并且同时将用户的唯一token值存入cookie中（cookie的有效期和redis键值的有效期一样），当我们用户跳转到某个页面的时候，先查询cookie中是否存在键值为user的cookie，如果存在就获取到cookieValue（token值），然后通过这个token作为键去查询redis中查找对应token的用户信息。 五一玩了几天，这几天没怎么进食新东西，今天趁着假期学校不熄灯，继续写一篇博客。 引入依赖和配置变量 首先是pom.xml的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;1.4.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 然后我们需要在application.yaml文件中写入redis的配置环境 123redis:host: 119.82.123.134port: 6379 配置类的编写 编写RedisConfig配置类 123456789101112131415161718192021222324 @Configurationpublic class RedisConfig &#123; //这里是引入刚刚yaml文件的配置变量 private @Value("$&#123;redis.host&#125;") String host; private @Value("$&#123;redis.port&#125;") int port; //引入JedisConnection工厂，主要负责的是redis的连接 //其中要设置地址和端口号 @Bean public JedisConnectionFactory redisConnectionFactory() &#123; RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setHostName(host); redisStandaloneConfiguration.setPort(port); return new JedisConnectionFactory(redisStandaloneConfiguration); &#125; //配置redis模板，这个主要是进行一些redis的操作，就像jdbc的模板类一样 @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate=new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); return redisTemplate; &#125;&#125; 相关操作的编写 关于redis的操作有很多，我也学的不是很好，这里面只写了最简单的set和get 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 /** * @author Lin * @date 2019-04-18 23:23 **/@Componentpublic class RedisUtil &#123; //引入刚刚我们设置的redis模板 @Resource RedisTemplate&lt;String,Object&gt; redisTemplate; //这是redis单独印出来的string的模板——因为对于redis的操作大部分都是以String类型为基础的，这里没有用到 @Autowired StringRedisTemplate stringRedisTemplate; /** * 往redis中缓存数据,这里使用T模板更加灵活 * @param key */ public &lt;T&gt; void set(String key,T value)&#123; //将value对象转换为json字符串 String jsonString=beanToString(value); //valueOperations用来set和get 它是由redisTemplate产生的 ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue(); //这里是将value对象转换为jsonString，因为项目中User是一个java对象 valueOperations.set(key,jsonString); &#125; /** * 往redis中缓存数据并加上过期时间 * @param key * @param time 过期时间，秒 */ public &lt;T&gt; void set(String key,T value,long time)&#123; //这个方法跟上面差不多，多加了一个设置过期时间，为的是与项目需求设置redis过期时间和cookie相等 String jsonString=beanToString(value); ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue(); valueOperations.set(key, jsonString, time,TimeUnit.SECONDS); &#125; /** * 从redis1中获取数据 * @param key * @return */ public &lt;T&gt; T get(String key,Class&lt;T&gt; clazz)&#123; ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue(); //这里其实获取的是存在redis中对象的json字符串 Object object=valueOperations.get(key); //如果获取的不为空，那么就像这个json字符串转换为java对象 if (object!=null)&#123; return stringToBean(object.toString(),clazz); &#125; //获取为空就return null return null; &#125; /** * 将对象转换为json * @param value 对象 * @param &lt;T&gt; 泛型 * @return json数据 */ private &lt;T&gt; String beanToString(T value)&#123; if (value==null)&#123; return null; &#125; Class&lt;?&gt; clazz=value.getClass(); //如果value是int类型或者Integer类型的直接返回 if (clazz==int.class||clazz==Integer.class)&#123; return ""+value; &#125;else if(clazz==String.class)&#123; return (String)value; &#125;else if (clazz==long.class||clazz==Long.class)&#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; /** * 将jsonString转换为java的对象 * @param jsonString json字符串 * @param clazz 类 * @param &lt;T&gt; 泛型 * @return java对象 */ @SuppressWarnings("unchecked") private &lt;T&gt; T stringToBean(String jsonString,Class&lt;T&gt; clazz)&#123; if (jsonString==null||jsonString.length()&lt;=0||clazz==null)&#123; return null; &#125; if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(jsonString); &#125;else if(clazz == String.class) &#123; return (T)jsonString; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(jsonString); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(jsonString), clazz); &#125; &#125; &#125; 上述代码使用了阿里巴巴的fastJson作为json和java对象转换的工具，具体的pom依赖为: 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 总结 对于这个SpringBoot整合Redis虽然是跟着视频写的，但是也踩了很多坑，因为版本更新非常快，我使用的SpringBoot和Redis都是最新版的，很多地方配置和代码书写都和视频中和网上绝大数整合教程不相同，我也是查看很多资料才写好这个整合的，对于英文文档不感冒是真的吃亏，所以英语能力一定要提高！！！ 还有就是在整合redis的时候，如果连接的是远程服务器中的redis的话一定要更改服务器上的redis.conf文件，最重要的两点就是将bind后面的地址修改或者直接注释掉bind那一行配置，还有就是将protected-mode更改为no，不然远程电脑连接不上。 当然还有很多细节问题都需要注意，留下这篇文章作为踩坑记录，希望下面敲代码的日子会越来越顺利。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链表和递归]]></title>
    <url>%2F2019%2F04%2F28%2F%E9%93%BE%E8%A1%A8%E5%92%8C%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[从一道leetcode题目开始 题目描述： 看一下题目内容其实很简单就是删除一个链表中值为val的所有节点并且返回被删除完的链表。 上篇文章讲了如何进行链表操作，这时候我们其实就可以通过老方法遍历整个链表，然后通过比较每个节点的值和val的值是否相等，相等则删除，不相等则保留。 示例代码： 12345678910111213141516171819202122232425 class Solution &#123; //这里的ListNode是leetcode给定的，里面包含next和val字段 public ListNode removeElements(ListNode head, int val) &#123; //创建一个虚拟头结点 ListNode virtualNode=new ListNode(0); //虚拟头结点的next节点是头结点 virtualNode.next=head; //将虚拟头结点赋值给currentNode当前节点 ListNode currentNode=virtualNode; while (currentNode.next!=null)&#123; //通过遍历当前节点来删除元素 if (currentNode.next.val==val)&#123; //如果当前头结点的next元素的val值等于给定的val //则将当前节点的next元素直接指向next的next //那么原来next节点就直接被删除了 currentNode.next=currentNode.next.next; &#125;else &#123; //如果不相等则跳到下一个节点，循环知道currentNode的next节点为null currentNode=currentNode.next; &#125; &#125; //返回虚拟头结点的next，这里就是被删除元素的原来的头结点 return virtualNode.next; &#125;&#125; 递归 在考虑递归如何写的时候我们先需要了解递归的宏观语意。 一个递归函数其实本质就是函数调用，只不过它是自己调用自己。 递归函数就是将原来的问题转化为更小的问题，知道最后求出最基本的解。 最基本的解一般是我们通过if条件判断来终结的，如果不添加if判断给递归函数一个终结（最基本的解，例如求阶乘的时候等于1等于0的时候就是最基本的解），那么计算机就会无限产生递归调用，这会导致cpu的方法栈（写栈的时候提过，函数调用就是通过栈来实现的）爆满从而报错。 如何写一个递归函数，我们不要去考虑它的实现细节，最好是通过宏观语意来完成它。 首先我们最能确定的就是它的最基本解，然后我们需要在原本函数里面再次调用该函数并修改参数（目的是将原问题转换为更小的问题）。上图的代码只是最简单的示例，当递归函数稍微再复杂点的时候，我们就需要获取到递归调用函数产生的值并对这个return的值来做些修改最后再返回给上一级调用这个级别的递归函数的函数。 使用递归来实现链表的删除(上述题目) 首先完成一个递归函数我们需要先确定我们怎么把这个递归函数变为更小的函数。 这里，我们将这个删除长度n的链表中元素的问题转换成先判断从第二个节点开始到最后节点中删除符合条件的节点，然后再转换为从第三个节点到最后节点删除符合条件的节点，直到我们的问题变成了删除最后一个空节点中符合条件的元素，当然这个时候空节点里面是不可能有的，所以我们这时候直接返回head，这样最基本解就出来了。 123if(head==null)&#123; return head;&#125; 之后就是转换为更小的问题了。 12345678910111213//将问题转换为小问题ListNode result=removeElements(head.next,val);//每次return都是return给上一级递归的结果//如果当前节点的val值和给定val相等//则直接return给上一级不包含该节点的链表if(head.val==val)&#123; return result;&#125;else&#123; //如果不相等说明不需要删除 //则需要将返回的结果前面加上头结点head在返回head head.next=result; return head;&#125; 完整代码： 12345678910111213 public ListNode removeElements(ListNode head,int val)&#123; //首先考虑最基本的问题 if (head==null)&#123; return null; &#125; ListNode resultNode=removeElements(head.next,val); if (head.val==val)&#123; return resultNode; &#125;else &#123; head.next=resultNode; return head; &#125;&#125; 其实整个问题可以这么理解，我需要删除一个链表中符合元素的节点，那么我把这个问题转化为小问题，将整个链表转换为从2开始到结尾的链表，然后S到从3开始到结尾的链表，最后到从结尾到结尾的节点（null），那么我就是从最后一个节点找需要删除的节点，假设如果最后一个节点是要删除的节点，那么这时候我们只需要将这个节点删除并且返回给上一级调用递归函数。这时候我们返回的null然后上一级接收到的result就是null，然后这个函数继续执行到if(head.val==val)，这时候就判断（第二级递归就是最后两个节点的链表）当前链表中的头结点的val是否满足，满足就跟刚刚一样“删除”该节点，不满足就将这个head的next设置为result，也就是将result的头结点暂时设置为当前head（将当前head设置为头结点并返回给上一级调用的函数），这样无限的返回，最后返回的就是原本链表中需要删除元素后的链表了。 这个时候我们可以将递归写的更简单 1234567public ListNode removeElements(ListNode head,int val)&#123; if(head==null)&#123; return head; &#125; head.next=removeElements(head.next,val); return head.val==val?head.next:head;&#125; 简单实用递归实现链表的创建 首先我们考虑如何通过递归实现该功能，创建一个链表，我们将问题缩小就是从创建节点开始。例如我们现在给定一个数组，然后我们通过这个数组来创建链表。首先这个数组的索引肯定是我们递归实现的条件，比如一个10个元素的数组，我们需要创建十个元素的链表，我们可以将问题变为创建从索引1开始到结束的链表，然后从索引2到结束，最后到从末尾到末尾（创建最后一个元素），所以这时候我们最基本条件就出来了。 123if((index+1)==array.length)&#123; return null;&#125; 这个时候我们就要来实现将问题转换为小问题 其实很简单。 1234ListNode result=createElement(array,index+1);ListNode currentNode=new ListNode(array[index]);currentNode.next=result;return currentNode; 完整代码： 12345678910public static ListNode createListNode(int[] array,int index)&#123; if ((index+1)==array.length)&#123; return new ListNode(array[index]); &#125;else &#123; ListNode result=createListNode(array,index+1); ListNode currentNode=new ListNode(array[index]); currentNode.next=result; return currentNode; &#125;&#125; 杂谈这个星期开始复习的信号系统，对于我这个学物联网的同学，不会什么高数，硬件是真的很烦躁，信号考完了，能不能过就靠老师助攻了。今天写篇博客来缓解一下一个星期没写代码的愧疚，这个递归还真的有点难理解，还需要勤敲勤练。加油吧！！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java实现自定义验证注解]]></title>
    <url>%2F2019%2F04%2F20%2FJava%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注释)。 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。 通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 Annotation 可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在 Annotation 的“name=value” 对中。 例如 Annotation 能被用来为程序元素(类, 方法, 成员变量等) 设置元数据。 基本的Annotation 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。 用于修饰它支持的程序元素。 三个基本的 Annotation: @Override: 限定重写父类方法, 该注释只能用于方法 @Deprecated: 用于表示某个程序元素(类, 方法等)已过时 @SuppressWarnings: 抑制编译器警告。 自定义Annotation 定义新的 Annotation 类型使用 @interface 关键字 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。 其方法名和返回值定义了该成员的名字和类型。 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation 下面是java验证的NotNull注解的源码： 其中所有的成员变量都是以无参方法定义的，default定义了某个成员变量的默认值，这是一个包含成员变量的 Annotation 所以我们也可以称为 元数据 Annotation。 下面是Override注解的源码： 这个注解没有成员变量，所以我们可以称为标记。而且可以注意的是这个注解的注解(元注解) @Retention是SOURCE类型的，编译器会直接丢弃这种策略的注释。也就是我们编译成class文件的时候是看不见@Override注解的，这个我们后面会讲。 提取 Annotation 信息 JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注释的程序元素。 当一个 Annotation 类型被定义为运行时 Annotation 后, 该注释才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取。 程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信息 JDK 的元 Annotation JDK 的元 Annotation 用于修饰其他 Annotation 定义(注解的注解) @Retention注解 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值 RetentionPolicy.CLASS: 编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注释. 这是默认值 RetentionPolicy.RUNTIME:编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释 RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释 @Target注解 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。可以参考本文第一张图片。 @Documented注解 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档 @Inherited注解 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注释 实现自定义验证注解@IsMobile 参考于实现自定义验证注解 @IsMobile是一个验证是否为11位手机号码的验证注解。 API开发中经常会遇到一些对请求数据进行验证的情况，这时候如果使用注解就有两个好处，一是验证逻辑和业务逻辑分离，代码清晰，二是验证逻辑可以轻松复用，只需要在要验证的地方加上注解就可以。 Java提供了一些基本的验证注解，比如@NotNull、@Size，但是更多情况下需要自定义验证逻辑，这时候就可以自己实现一个验证注解，方法很简单，仅需要两个东西： 一个自定义的注解，并且指定验证器 一个验证器的实现 这个时候我们就可以结合刚刚所学的知识就可以根据前面两部来实现验证注解了。 12345678910111213//这个表示该注解能对于类型注解@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)//这个表示在运行时起作用@Retention(RetentionPolicy.RUNTIME)//@Constraint是最关键的，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器@Constraint(validatedBy = IsMobileValidator.class)public @interface IsMobile &#123; boolean required() default true; String message() default "手机号码格式错误"; //groups()和payload()也为@Constraint要求，可默认为空 Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;&#125; @Target @Target指明这个注解要作用在什么地方，可以是对象、域、构造器等，因为要作用在域上，因此这里可以选择FIELD（这里我是直接所有的可以）。参考了NotNull注解 @Retention 指明生命周期，这里选择RUNTIME @Constraint 实现验证器最重要的注解，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器。 message() 验证失败之后返回的消息。此方法为@Constraint要求 groups()和payload() groups()和payload()也为@Constraint要求，可默认为空，详细用途可以查看@Constraint文档 下面是验证器类： 1234567891011121314151617181920212223242526272829303132/** * @author Lin * @date 2019-04-20 10:55 **/public class IsMobileValidator implements ConstraintValidator&lt;IsMobile,String&gt; &#123; //这里实现ConstraintValidator接口需要重写initialize和isValid方法 /** * required指这个数据是否必须 */ private boolean required = false; @Override public void initialize(IsMobile constraintAnnotation) &#123; required=constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //如果是必须的，那么就验证是否为手机号 if (required)&#123; return ValidatorUtil.isMobile(value); &#125;else &#123; //如果非必须，那么空值和手机号都可以通过验证 if (StringUtils.isEmpty(value))&#123; return true; &#125;else &#123; return ValidatorUtil.isMobile(value); &#125; &#125; &#125;&#125; 其细节说明在注释中。 这样我们就实现了一个自定义验证注解，我们只需要在要验证的元素的前面加上@IsMobile就行了。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手写链表]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是链表 链表是一种重要的数据结构，是一种数据的存储方式。链表由多个链表元素组成，每个元素称为节点。链表存储的物理结构可能是连续的，但也可能是无序的。但是链表之间的元素（节点）是有序的逻辑相连。 链表是一种很灵活的数据结构，它不需要指定内存的大小，删除节点不需要要像数组那样讲数据整体向前移动，只需要更改节点的指向。但是链表的结构也决定了它的许多缺点，比如说访问需要遍历元素，不能像数组那样依靠索引，还有就是链表每个元素存的是一个对象，这是一笔非常大的内存开销。 链表从方向可以分为单向链表，双向链表。 从结构上可以分为单链表，环形链表。 Java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207/** * @author Lin * @date 2019-04-17 18:55 **/public class LinkedList&lt;E&gt; &#123; /** * 节点 */ private class Node&#123; /** * 节点里面的元素内容 */ private E e; /** * 指向下一个节点 */ private Node next; public Node(E e,Node next)&#123; this.e=e; this.next=next; &#125; public Node(E e)&#123; this.e=e; this.next=null; &#125; public Node()&#123; this.e=null; this.next=null; &#125; &#125; /** * 虚拟链表头，让add更加有逻辑 */ private Node dummyHead; /** * 链表大小 */ private int size; public LinkedList()&#123; dummyHead=new Node(); size=0; &#125; public int getSize()&#123; return this.size; &#125; public boolean isEmpty()&#123; return this.size==0; &#125; /** * 链表添加头元素 * @param e 元素 */ public void addFirst(E e)&#123; add(0,e); &#125; /** * 指定位置添加元素 * @param index 索引 * @param e 元素 */ public void add(int index,E e)&#123; if (index&lt;0||index&gt;size)&#123; //当index非法排除异常 throw new IllegalArgumentException("the index is not valid"); &#125;else &#123; //获取要插入的元素的前面的元素 Node pre=dummyHead; for (int i = 0 ; i &lt; index ; i ++)&#123; //遍历 pre = pre.next; &#125; //首先调用的是new Node(e,pre.next) //为的是让新节点的next节点指向它要添加位置的前面一个元素的原来的next节点 //再进行赋值操作为了将添加节点前面的节点的next改为该元素 pre.next = new Node(e,pre.next); size ++; &#125; &#125; /** * 在链表末尾加入元素 * @param e 元素 */ public void addLast(E e)&#123; add(size,e); &#125; /** * 获取某个索引的元素 * @param index 索引 * @return 元素 */ public E get(int index)&#123; if (index&lt;0||index&gt;size)&#123; throw new IllegalArgumentException("the index is not valid"); &#125;else&#123; Node currentNode=dummyHead.next; for (int i=0;i&lt;index;i++)&#123; currentNode=currentNode.next; &#125; return currentNode.e; &#125; &#125; public E getFirst()&#123; return get(0); &#125; public E getLast()&#123; return get(size-1); &#125; /** * 修改元素 * @param index 索引 * @param e 更新后的元素 */ public void set(int index,E e)&#123; if (index&lt;0||index&gt;=size)&#123; throw new IllegalArgumentException("the index is not valid"); &#125;else &#123; Node currentNode=dummyHead.next; for (int i=0;i&lt;index;i++)&#123; currentNode=currentNode.next; &#125; currentNode.e=e; &#125; &#125; /** * 是否包含某个元素 * @param e 元素 * @return 布尔 */ public boolean contains(E e)&#123; Node currentNode=dummyHead.next; for (int i=0;i&lt;size-1;i++)&#123; if (currentNode.next!=null)&#123; if ((currentNode.e).equals(e))&#123; return true; &#125; &#125; &#125; return false; &#125; /** * 移除某个索引元素 * @param index * @return */ public E remove(int index)&#123; if (index&lt;0||index&gt;=size)&#123; throw new IllegalArgumentException("the index is not valid"); &#125;else &#123; Node currentNode=dummyHead; for (int i=0;i&lt;index;i++)&#123; currentNode=currentNode.next; &#125; //暂存被删除的节点 Node tempNode=currentNode.next; //将遍历到的节点（被删除节点前面一个）的next指向被删除节点的next节点 currentNode.next=tempNode.next; //将被删除的节点的next指向为null tempNode.next=null; size--; return tempNode.e; &#125; &#125; public E removeLast()&#123; return remove(size-1); &#125; public E removeFirst()&#123; return remove(0); &#125; public void remove(E e)&#123; Node currentNode=dummyHead.next; //遍历到节点的next为空 while (currentNode!=null)&#123; //判断是否与需要判断的元素相等，如果相等则删除 if (currentNode.e.equals(e))&#123; Node tempNode=currentNode.next; currentNode.next=tempNode.next; tempNode.next=null; size--; return; &#125; if (currentNode.next!=null)&#123; currentNode=currentNode.next; &#125; &#125; &#125;&#125; 使用链表实现栈123456789101112131415161718192021222324252627282930313233343536/** * @author Lin * @date 2019-04-17 20:28 **/public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private LinkedList&lt;E&gt; linkedList; public LinkedListStack()&#123; this.linkedList=new LinkedList&lt;&gt;(); &#125; @Override public int getSize() &#123; return linkedList.getSize(); &#125; @Override public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; @Override public void push(E o) &#123; linkedList.addFirst(o); &#125; @Override public E pop() &#123; return linkedList.removeFirst(); &#125; @Override public E peek() &#123; return linkedList.getFirst(); &#125;&#125; 链表和数组实现栈的比较 从复杂度来考虑，数组和链表实现的出栈入栈等操作的复杂度都相同，我们这里来测试一下。测试代码如下： 12345678910111213141516171819202122232425262728293031// 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒private static double testStack(Stack&lt;Integer&gt; stack, int opCount)&#123; long startTime = System.nanoTime(); Random random = new Random(); for(int i = 0 ; i &lt; opCount ; i ++) &#123; stack.push(random.nextInt(Integer.MAX_VALUE)); &#125; for(int i = 0 ; i &lt; opCount ; i ++) &#123; stack.pop(); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0;&#125;public static void main(String[] args) &#123; int opCount = 100000; ArrayStack&lt;Integer&gt; arrayStack = new ArrayStack&lt;&gt;(); double time1 = testStack(arrayStack, opCount); System.out.println("ArrayStack, time: " + time1 + " s"); LinkedListStack&lt;Integer&gt; linkedListStack = new LinkedListStack&lt;&gt;(); double time2 = testStack(linkedListStack, opCount); System.out.println("LinkedListStack, time: " + time2 + " s"); // 其实这个时间比较很复杂，因为LinkedListStack中包含更多的new操作&#125; 结果如下： 其实这个测试结果不会是稳定的，相比较之下，他们的快慢主要和环境有很大关系。 当然，ArrayStack在添加元素时可能会执行扩容操作，这个时间复杂度是O(n)的，在LinkedListStack添加元素的时候虽然没有扩容的操作但是它会执行大量new对象操作，这也是非常占用资源的。总体来说，它们的增添和删除元素的时间复杂度都是O(1),所以可以说它们执行时间的差异并不是很大。 链表实现队列前面一篇文章专门讲到了Queue，队列就是（FIFO）的数据结构，我们主要去实现队列的入队（在队尾添加元素），出队（在队首删除元素）。回想我们前面实现的链表，在队首删除元素容易（时间复杂度是O1的），但是要在队尾添加元素就非常繁琐了，我们需要遍历整个链表，当数据量一大，我们的执行时间就会变得非常大，所以我们为了效率考虑，我们需要添加一个尾节点。 这时候我们怎么实现队列的操作呢？其实很简单，当我们入队的时候只需要将尾节点的next指向当前入队的新的节点，当然我们不得不把所有尾节点的next都置为null，为的是我们的逻辑和效率，浪费一个空间也不是大问题。 而当我们进行出队操作时，我们只需要将原来头结点变为原来头结点的next节点，返回出队节点的时候我们只需要将被删除的头结点的next节点变为null就行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @author Lin * @date 2019-04-18 19:13 **/public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private class Node&#123; private E e; private Node next; public Node(E e)&#123; this.e=e; this.next=null; &#125; &#125; private Node head,tail; //维持链表元素个数 private int size; public LinkedListQueue()&#123; head=null; tail=null; size=0; &#125; /** * 入队只能从尾部 * @param e 元素 */ @Override public void enqueue(E e) &#123; //如果尾节点为空，那么就代表整个链表为空 if (tail==null)&#123; //需要将元素赋值给头节点和尾节点 head=new Node(e); tail=head; size++; &#125;else &#123; //不为空则需要新节点赋值给尾节点的next tail.next=new Node(e); //尾节点变换 tail=tail.next; size++; &#125; &#125; /** * 出队操作，只能从第一个出队 * @return 头节点 */ @Override public E dequeue() &#123; //当链表为空时无法进行出队操作 if (size==0)&#123; throw new IllegalArgumentException("the linkedListQueue is empty!"); &#125;else &#123; Node tempNode=head; //将原来头结点的next变为当前头结点 head=head.next; //将要返回的“头结点”的next置为null tempNode.next=null; size--; return tempNode.e; &#125; &#125; @Override public int getSize() &#123; return this.size; &#125; @Override public E getFront() &#123; return head.e; &#125; @Override public boolean isEmpty() &#123; return this.size==0; &#125;&#125; 三种实现对列的比较前面我们使用了数组队列和循环队列，这时候我们加入我们刚刚实现的链表队列。测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637public class Main &#123; private static double testQueue(Queue&lt;Integer&gt; q, int opCount)&#123; long startTime = System.nanoTime(); Random random = new Random(); for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.enqueue(random.nextInt(Integer.MAX_VALUE)); &#125; for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.dequeue(); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0; &#125; public static void main(String[] args) &#123; int opCount = 100000; ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;(); double time1 = testQueue(arrayQueue, opCount); System.out.println("ArrayQueue, time: " + time1 + " s"); LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;(); double time2 = testQueue(loopQueue, opCount); System.out.println("LoopQueue, time: " + time2 + " s"); LinkedListQueue&lt;Integer&gt; linkedListQueue = new LinkedListQueue&lt;&gt;(); double time3 = testQueue(linkedListQueue, opCount); System.out.println("LinkedListQueue, time: " + time3 + " s"); &#125;&#125; 这个时候我们能得到结果： 通过我们实践和分析，链表实现的队列也是O(1)的时间复杂度。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis初识与安装]]></title>
    <url>%2F2019%2F04%2F16%2Fredis%E5%88%9D%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[什么是Redis redis是一款基于C语言的开源的基于键值的存储服务系统它支持丰富的数据类型，如：string、list、set、zset(sorted set)、hash。 Redis的创始人是意大利人Salvatore Sanfilippo，他的网名是antirez，我们可以通过https://github.com/antirez来访问他的主页。 Redis的优势 Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。以设置和获取一个256字节字符串为例，它的读取速度可高达110000次/s，写速度高达81000次/s。当然这是官方声明的，但是实际应用达到w级是肯定没问题的。 因此redis的性能非常好，而且可以支持多种数据结构和持久化（RDB实现方式和AOF实现方式）。 redis可以支持多种编程语言，在java，php，python都有实现。 redis可谓短小精悍，redis5.0的代码也就只有5w行，除去实现分布式的代码，它仅仅只有23000行代码，但是redis提供的功能非常丰富，比如发布订阅，Lua脚本，事务等。 redis提供主从复制，这为后面实现高并发和高可用打下了基础。 Redis典型应用场景 缓存系统 计数器 消息队列系统 排行榜 社交网络 实时系统 Redis的安装和简单运行 下载 1wget http://download.redis.io/releases/redis-5.0.3.tar.gz 可能会遇到DNS解析的问题，这时候要去更改/etc/resolv.conf 123vim /etc/resolv.confnameserver 8.8.8.8 #google域名服务器nameserver 8.8.4.4 #google域名服务器 解压 1tar xzf redis-5.0.3.tar.gz 创建文件并编译 12cd redis-5.0.3make 进入目录并运行 1src/redis-server 修改问题和警告 这时候启动redis的时候难免会出现警告，首先肯定是关于配置文件的问题，redis建议你启动的时候附带配置文件路径 如: 1src/redis-server redis.conf 我们需要将redis以守护进程的方式启动以避免关闭命令行是redis不退出，我们只需要修改redis.conf文件，设置daemonize为yes就行。 我们运行之后会发现我们无法再进行其他操作了，这时候我们需要启动的时候添加一个&amp; 12src/redis-server redis.conf &amp;` 你可能还会遇到以下问题 WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 大概意思是你的tcp设置为128对于这个环境来说太小了，redis建议你设置为511 1echo 511 &gt; /proc/sys/net/core/somaxconn you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. 解决办法: 1echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect. 按照提示将vm.overcommit_memory = 1加入到/etc/sysctl.conf中并执行命令sysctl vm.overcommit_memory=1就好了 简单的设置值和取值 命令： set key value get key]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手写Queue]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Queue%2F</url>
    <content type="text"><![CDATA[什么是队列 队列是一种先进先出的数据结构（First In First Out）。结合生活实际，这里的队列就是从生活中的排队得来的。比如我们正在排队办理业务，后来的人只能从队列最后一个进入队伍（入队），当前面的的人办理完业务的时候他就离开了队伍（出队）。由此我们可以发现，要实现队列其实最重要的就是出队和入队的操作。所以我们就可以定义我们的Queue接口了。 123456789101112131415161718192021222324252627282930313233343536 /** * @author Lin * @date 2019-04-15 19:19 **/public interface Queue&lt;E&gt; &#123; /** * 入队 * @param e 元素 */ void enqueue(E e); /** * 出队 * @return 出队的元素 */ E dequeue(); /** * 获取大小 * @return 队列大小 */ int getSize(); /** * 获取队头元素 * @return 队头元素 */ E getFront(); /** * 判断是否为空 * @return 布尔 */ boolean isEmpty();&#125; 数组队列 了解队列的特点，我们不难就想到了上次使用数组实现栈，其实队列和栈也差不多，只不过更改了出和入的操作罢了，这里我就不明细讲了，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * @author Lin * @date 2019-04-15 19:19 **/public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt;&#123; private Array&lt;E&gt; array; public ArrayQueue()&#123; array=new Array&lt;&gt;(); &#125; public ArrayQueue(int capacity)&#123; array=new Array&lt;&gt;(capacity); &#125; @Override public void enqueue(E e) &#123; array.addLast(e); &#125; @Override public E dequeue() &#123; return array.removeFirst(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public E getFront() &#123; return array.getFirst(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125;&#125; 循环队列 我们来对上面的数组队列做一个时间复杂度分析 当我们进行入队操作的时候时间复杂度肯定为O(1),这是非常高效的。但是，我们要进行出队的时候就大不相同了，因为我们每次出队，当移除头元素的时候我们就需要将后面的元素挨个往前移动，因为我们这个底层就是依靠动态数组实现的，所以就是调用动态数组删除某个索引元素的方法，那么这个时间复杂度就是O(n),也就是说当我们进行出队操作的时候，队伍量越大我们消耗的时间就越大，这是低效且我们不愿意看到的。在数据结构中，很多时候我们都会使用空间和时间的互换，时间换取空间资源，空间资源换取时间资源，所以我们这里可以使用循环队列来提高出队效率。 循环队列是什么，其实就相当于将队列的头和尾相连接 如图： 我们增加了一个头索引和尾索引来达到虚拟的连接（这个当然不是真实的）。当我们初始化这个队列的时候，头索引和尾索引都是0,当头索引和尾索引相等的时候这个队列为空，首先记着这个（很好理解，就是头和尾中间没有间隔那不就是空了么）。当我们进行入队操作的时候，将元素放入循环队列的尾索引处，放置完成后将尾索引+1（后移一个单位）。当进行出队的时候，我们将头元素删除，并将头索引+1（后移一个单位）。是不是很简单？当然不可能这么简单，因为这个队列是循环的，头和尾是相连的，这里我们就可以利用相连的特性来使用我们刚刚可能出队的时候浪费的空间资源，怎么做？其实就是更改一下我们头索引和为索引相加的位置，我们将他们++操作更改为front=(front+1)%capacity就行，这里的capacity是指整个队列的容量。 还有一个注意点就是当我们整个队列满的时候我们是无法判断队列是否为空的，因为这时候头索引和尾索引也是相等的，这个时候我们就需要牺牲一个存储单元来解决冲突。 下面就直接贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * @author Lin * @date 2019-04-15 19:40 **/public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private E[] array; private int front, tail; public LoopQueue() &#123; this(10); &#125; public LoopQueue(int capacity) &#123; array = (E[])new Object[capacity+1]; //头尾索引置为0 front = 0; tail = 0; &#125; private int getCapacity() &#123; return array.length - 1; &#125; //入队 @Override public void enqueue(E e) &#123; //当使用长度和容量相等的时候进行扩容 if (((tail - front + this.getCapacity()+1) % (this.getCapacity()+1)) == this.getCapacity()) &#123; resize(this.getCapacity() * 2); &#125; //将元素e放入队尾 array[tail]=e; tail++; &#125; //出队 @Override public E dequeue() &#123; //当队列为空抛出异常 if (front==tail)&#123; throw new IllegalArgumentException("The loopQueue has no element"); &#125;else &#123; //将头元素置为null并且将头索引向后移动一个单位 E temp=array[front]; array[front]=null; front=(front+1)%array.length; //当队列只使用了四分之一时将队列缩容 if (this.getSize()==this.getCapacity()/4&amp;&amp;this.getCapacity()/2!=0)&#123; resize(this.getCapacity()/2); &#125; return temp; &#125; &#125; //获取当前队列的实际长度（使用头尾索引计算） @Override public int getSize() &#123; return (tail - front + this.getCapacity()+1) % (this.getCapacity()+1); &#125; @Override public E getFront() &#123; return array[front]; &#125; @Override public boolean isEmpty() &#123; return tail==front; &#125; //扩容 private void resize(int capacity) &#123; E[] newArray = (E[])new Object[capacity+1]; int size = (tail - front + this.getCapacity()+1) % (this.getCapacity()+1); for (int i = 0; i &lt; size; i++) &#123; newArray[i]=array[(front + i) % size]; &#125; array = newArray; front = 0; tail = size ; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("["); for (int i = front; i != tail; i = (i + 1) % array.length) &#123; if ((i + 1) % array.length == tail) &#123; stringBuilder.append(array[i]); &#125; else &#123; stringBuilder.append(array[i]).append(","); &#125; &#125; stringBuilder.append("] tail container:").append(this.getCapacity()); return stringBuilder.toString(); &#125;&#125; //测试 public static void main(String[] args) &#123; LoopQueue&lt;Integer&gt; loopQueue=new LoopQueue&lt;&gt;(); for (int i=0;i&lt;17;i++)&#123; loopQueue.enqueue(i); System.out.println(loopQueue); &#125; loopQueue.dequeue(); loopQueue.dequeue(); loopQueue.dequeue(); System.out.println(loopQueue); &#125; 数组队列和循环队列的比较 大数比较 12345678910111213141516171819202122232425262728293031 private static double testQueue(Queue&lt;Integer&gt; q, int opCount)&#123; long startTime = System.nanoTime(); Random random = new Random(); for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.enqueue(random.nextInt(Integer.MAX_VALUE)); &#125; for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.dequeue(); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0;&#125;public static void main(String[] args) &#123; int opCount = 100000; ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;(); double time1 = testQueue(arrayQueue, opCount); System.out.println("ArrayQueue, time: " + time1 + " s"); LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;(); double time2 = testQueue(loopQueue, opCount); System.out.println("LoopQueue, time: " + time2 + " s");&#125; 运行结果： 可以看出，当数据量大的时候，LoopQueue完胜。 当我们把数据量变为10的时候我们不难发现，LoopQueue还是胜出,并且速度比数组队列快一个量级。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手写Stack]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Stack%2F</url>
    <content type="text"><![CDATA[什么是栈 我觉得栈是一个很简单的概念，栈是一种后进先出的数据结构(Last In And First Out)，大家都见过装羽毛球的筒吧，你会发现当你装完羽毛球之后第一个拿出来的肯定是最后一个放进去的。其实这就是栈，它是一种线性结构，我们学习了数组其实就很容易理解栈了。 为什么呢？我们可以先想一下，对于栈这样的数据结构，我们能对它进行什么样的操作。其实也就是入栈（将一个羽毛球放进去），出栈（将一个羽毛球拿出来），判断栈是否为空（羽毛球筒里面有没有羽毛球），计算栈的大小（计算羽毛球筒里有多少个羽毛球），获取栈顶元素（获取羽毛球筒中最上面的羽毛球）。无非就是这几个操作。所以我们现在可以定义栈的接口了，如下面代码。 123456789101112131415161718192021222324252627282930313233343536/** * @author Lin * @date 2019-04-15 12:34 **/public interface Stack&lt;E&gt; &#123; /** * 获取栈的大小 * @return 大小 */ int getSize(); /** * 判断栈是否为空 * @return 布尔 */ boolean isEmpty(); /** * 将元素放入栈 * @param e 元素 */ void push(E e); /** * 出栈 * @return 出栈的元素 */ E pop(); /** * 获得栈最上面的元素 * @return 元素 */ E peek();&#125; 栈与数组的关系之前我的一篇博客介绍了如何实现动态数组，那个动态数组中我们实现了添加删除元素，计算数组大小，判断数组是否为空，获取数组的元素等方法。其实我们对栈的操作也就是对数组操作的子集，计算大小，判断为空我们可以直接使用数组的方法，添加元素对于栈来说就是在末尾添加元素，删除就是删除末尾元素，而获取元素就是获取最后一个元素。所以我们可以直接定义我们的ArrayStack类了（这个类是实现了刚刚的Stack接口的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @author Lin * @date 2019-04-15 13:18 **/public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; /** * 通过数组实现栈 */ private Array&lt;E&gt; array=new Array&lt;&gt;(); @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; //入栈操作 @Override public void push(E e) &#123; array.addLast(e); &#125; //出栈操作 @Override public E pop() &#123; return array.removeLast(); &#125; //上篇博客中没有getLast和getFirst方法 //这里是我后面添加的，其实实现这个方法很简单，只要固定index就行了 @Override public E peek() &#123; return array.getLast(); &#125; //这里重写toString方法为了后面测试能清楚显示 @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("Stack ["); for (int i = 0; i &lt; this.getSize(); i++) &#123; if (i != this.getSize() - 1) &#123; stringBuilder.append(array.get(i)).append(","); &#125;else &#123; stringBuilder.append(array.get(i)).append("]pop"); &#125; &#125; return stringBuilder.toString(); &#125;&#125; 栈的一些应用场景 word和一些IDE中的撤销功能 将用户的操作放入栈中，当实行撤销操作的时候把用户最近的操作撤销。 程序调用的系统栈 比如我们调用A方法需要调用B方法，调用B方法的时候我们需要调用C方法，这时候我们C方法执行完了之后我们系统是不知道我们下面应该执行什么方法的，所以这时候栈就登场了，当我们执行A方法需要调用B方法的时候我们将这时候跳转执行前的方法和代码行数记录到栈中（这时候我们执行的是A方法的第二行代码调用了B方法，所以我们把A2存入栈中）。同理，我们运行B方法的时候在第二行调用了C方法，我们就把B2存入栈中，之后我们C方法执行完之后系统就看栈中有没有还需要返回的方法，如果有就跳回指定的方法的代码行数，比如C方法执行完，我们栈中有B2，我们就跳回B2执行并且把栈顶元素删除，接着我们B方法执行完了，我们看栈中还有A2，我们就跳转到A2执行代码并且把A方法执行完查看栈中没有元素的时候我们就把整个A方法执行完成了。 关于栈的算法题目在leetcode中有一道使用栈解决的简单题目 题目是这样的： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 思考一下题目，其实就可以和栈结合起来了，我们将给出的串进行遍历获取字符，我们判断字符是否为”{“,”[“,”(“,为这三个我们就把字符存入栈中，如果不是我们就把它和栈素比较是否匹配，如果不匹配那么直接返回false。大致思是这样，具体细节代码注释里有详细解释。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public boolean isValid(String s) &#123; //创建一个stack Stack&lt;Character&gt; stack=new Stack&lt;&gt;(); //声明栈顶元素 Character topCharacter; //循环遍历字符串 for (int i=0;i&lt;s.length();i++)&#123; //获取某个字符 Character character=s.charAt(i); //如果该字符等于'&#123;'或'['或'('的时候存入栈中 if (character=='&#123;'||character=='['||character=='(')&#123; stack.push(character); //直接进入下一层循环 continue; &#125; //如果不是，那么就是与之相对的了 else &#123; //首先判断栈是否为空 //因为如果栈中没有元素且这个字符是右边的括号 //那么这个字符串肯定不符合要求 if (stack.isEmpty())&#123; return false; &#125;else &#123; //获取栈顶元素 topCharacter=stack.pop(); //判断栈顶元素是否和该元素匹配，如不匹配直接false if (character=='&#125;'&amp;&amp;topCharacter!='&#123;')&#123; return false; &#125;else if (character==']'&amp;&amp;topCharacter!='[')&#123; return false; &#125;else if (character==')'&amp;&amp;topCharacter!='(')&#123; return false; &#125; &#125; &#125; &#125; //如果循环都是正确的，那么还要判断栈是否为空 //因为"&#123;","["这种类型的情况都是错误的 //但是前面没有考虑到，所以只要判断后面直接没有元素匹配 //也就是栈是否不为空 return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手做Array]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9AArray%2F</url>
    <content type="text"><![CDATA[学习数据结构 一直以来在学习java web开发，里面很少涉及到数据结构相关的编程，再加上大一没有怎么好好学这门课程，这段时间开始慢慢捡回来，不说如何去精通它，但希望自己从数据结构开始训练自己的基础代码能力，如今用框架用的已经连代码都不会写了。。。 Array代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225/** * @author Lin * @date 2019-04-13 16:52 **/public class Array&lt;E&gt; &#123; /** * 泛型数组 */ private E[] array; /** * 数组大小 */ private int size; /** * 有参构造方法 */ public Array(int capacity) &#123; //强制类型转换 array = (E[]) new Object[capacity]; //size指向0 size = 0; &#125; /** * 默认构造函数 */ public Array() &#123; //默认容量为8 array = (E[]) new Object[8]; size = 0; &#125; /** * 获取数组容量 */ public int getCapacity() &#123; return array.length; &#125; /** * 获取数组元素个数 */ public int getSize() &#123; return size; &#125; /** * 返回数组是否为空 */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 在index处插入一个新的元素 * * @param index 索引 * @param e 插入的元素 */ public void add(int index, E e) &#123; //判断index是否合法 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("index is not valid!"); &#125; //判断此时size和capacity是否相等，如果相等需要动态增加数组容量 if (size == this.getCapacity()) &#123; resize(size * 2); &#125; //将index索引处后面的元素向后移一个 for (int i = size-1; i &gt;= index; i--) &#123; array[i + 1] = array[i]; &#125; array[index] = e; ++size; &#125; /** * 动态扩容 * * @param capacity 新的容量 */ private void resize(int capacity) &#123; //新构建一个数组，将原来数组赋值上去 E[] temp = (E[]) new Object[capacity]; for (int i = 0; i &lt; size; i++) &#123; temp[i] = array[i]; &#125; array = temp; &#125; /** * 在头部添加元素 * * @param e 元素 */ public void addFirst(E e) &#123; //直接调用add方法 add(0, e); &#125; /** * 在尾部添加元素 */ public void addLast(E e) &#123; add(size, e); &#125; /** * 获取索引位置的元素 * * @param index 索引 * @return 该索引处的元素 */ public E get(int index) &#123; return array[index]; &#125; /** * 修改索引位置的元素 * * @param index 索引 * @param e 要设置的元素 */ public void set(int index, E e) &#123; array[index] = e; &#125; /** * 数组中是否包含元素 * * @param e 元素 * @return 布尔 */ public boolean contains(E e) &#123; for (E originalElement : array) &#123; if (originalElement.equals(e)) &#123; return true; &#125; &#125; return false; &#125; /** * 查找数组中第一次出现该元素的索引，不存在则返回-1 * * @param e 元素 * @return 索引 */ public int find(E e) &#123; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; /** * 删除指定索引元素 * * @param index 索引 * @return 删除的元素 */ public E remove(int index) &#123; E removeElement = array[index]; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException("index is not valid!"); &#125; for (int i = index; i &lt; size; i++) &#123; array[i] = array[i + 1]; &#125; --size; //压缩空间 //这里使用懒压缩，如果在size为容量一半的时候就缩减容量为一半，则当这个数组再次增加一个元素的时候，它又会进行扩容。所以这里给予一定的空间 if (size==array.length/4&amp;&amp;array.length/2!=0)&#123; resize(array.length/2); &#125; return removeElement; &#125; /** * 删除第一个 * * @return 删除的元素 */ public E removeFirst() &#123; return remove(0); &#125; /** * 删除最后一个元素 * * @return 删除的元素 */ public E removeLast() &#123; return remove(size-1); &#125; /** * 删除第一个出现的某个元素 * * @param e 需要删除的元素 */ public void removeElement(E e) &#123; remove(find(e)); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, array.length)); res.append('['); for (int i = 0; i &lt; size; i++) &#123; res.append(array[i]); if (i != size - 1) &#123; res.append(", "); &#125; &#125; res.append(']'); return res.toString(); &#125;&#125; 总结 在Java中，数组的容量一旦声明就无法改变，这里我们通过封装实现了动态数组，并且实现了动态数组的增删改查等简单的功能。其中最为重要的是数组怎样实现增加，删除和动态扩容。 增加当数组某个位置需要增加元素的时候，我们先要将该索引处后面的元素从最后一个元素开始把各自向后移动一个位置。 删除当数组某个位置需要删除元素的时候，我们先要将该索引处后面的元素从索引处后面的元素开始依次将各自向前移动一个位置。即为后面元素覆盖前面元素。 动态扩容当数组进行增加的时候，如果数组容量不够时我们需要进行扩容。当数组中进行删除的时候，如果数组使用量已经远小于数组容量的时候我们需要进行压缩，来减少无用的空间。 我们上文代码实现扩容的方式是在数组增加和删除的时候重新构建一个数组并且将原来的数组赋值到新的数组中去。为了避免一直重复的重构容量大小，我们将扩充的容量变为原来容量的两倍(如果每次容量只是加1或者很少那么每次add之后都要执行重构容量，但是重构容量需要重新遍历数组，时间复杂度为O(n),极大地浪费时间，所以我们这里通过牺牲空间来节省时间)。当每次删除元素的时候，我们将判断数组使用量是否等于容量的四分之一，当为true的时候我们我们将容量变为原来一半以节省空间(这里为什么是四分之一和一半呢？其实具体数值并不是固定的，但是我们这里实现的是懒压缩，如果这里的判断条件为一半，当使用量为容量一半的时候我们就之间将容量变为原来一半，那么之后再次进行add方法时我们又需要扩容，从而引起复杂震荡，这是得不偿失的)。 上文Array代码基本是模仿JDK的ArrayList来实现的，在ArrayList中也是通过上述方法来实现的。 如实现动态扩容: 12345678910111213141516171819/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里使用了移位，为了使运算更加快速 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //这里设置的是最小容量和最大容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从对称加密到数字证书]]></title>
    <url>%2F2019%2F04%2F11%2F%E4%BB%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%88%B0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[对称加密​ 简单来说，对称加密是解决通信之间的安全问题的最初手段。如下图中张大胖同学通过网络结识了远在美国的Bill同学，两个人聊得水深火热，但是有一天张大胖开始变得疑神疑鬼，因为他们聊得内容越来越隐私。张大胖就跟Bill说我总感觉不安全，我感觉有个人通过截取我们的消息在偷窥我们讲话，Bill听了也连忙说，对！我们的消息都是明文传输，中间被人截获就直接被读出来了。那怎么办？加密呗！ ​ 说着，张大胖就提议，不是有个对称加密嘛？我们用那个进行对消息的加密，我们首先沟通好我们的私钥，保持一致性，我给你发消息的时候我通过私钥加密，你收到消息的时候你再通过私钥进行解密，这样即使被中间人截获他也看不懂啦！Bill连忙夸赞张大胖同学说：”dei dei dei这个办法好呀！”。 ​ 就如下图中一样，张大胖和Bill就通过对称加密来进行通信，看似安全了，但是真的安全了吗？ ​ 可是，当张大胖和Bill开始协商秘钥的时候，问题又出现了！Bill说既然网络是不安全的，万一现在正好有人再偷窥我们协商秘钥，我们协商好之后通过网络传输，这个秘钥就是明文传输的呀！那么，我们的秘钥不就暴露了吗？张大胖听了Bill的一席话，幡然醒悟。“对呀！这个可怎么办？而且当两个人进行通信的时候就要一个秘钥，一个人如果需要同一百个，一万个好友进行通信的时候那么就要有一百个，一万个秘钥，这！这哪能记得住呀？“。Bill这时候说道：“不行不行！这个通信方式也不安全！我们得再想一个。” 非对称加密​ 张大胖和Bill得知这种办法也不行的时候就一直提心吊胆地通信着，都不敢涉及隐私了，这个偷窥者听得也没劲了。直到后来，Bill听说了一种叫RSA非对称加密的算法，他一下子来了灵感。 &nbsp; RSA算法意思是一个人同时拥有公钥和私钥，这个公钥是公开的，别人都可以知道，但是这个私钥是自己保存的，千万不能让别人知道。而且，当文本经过某个人的公钥加密的时候，只有通过这个人的私钥才能进行解密，所以当Bill向张大胖同学发消息的时候，他就使用张大胖的公钥对消息进行加密，当张大胖收到消息的时候他就使用自己的私钥进行解密。流程如下图： 非对称加密+对称加密​ 这样，非对称加密就一下子解决了对称加密的两个缺点（秘钥泛滥和秘钥被网络截取），但是它也带来了一个很致命的缺点，那就是——效率问题，对同样大小的文本对称加密的速度是非对称加密速度的几百倍（我曾经拿RSA算法对一个50kb的文件进行加密，电脑直接叫唤着我不行了，我不行了）。大家知道通信是很讲究速度效率的，这个非对称加密虽然安全但是速度太慢了，这叫人怎么能忍呢？ ​ 这么愚蠢的问题当然不会困惑张大胖和Bill很久，他们想出来了一个二者结合的方法！当张大胖和Bill要进行通信的时候，他们就先使用非对称加密沟通好对称加密的秘钥（也就是在这个非对称加密的通道里传输秘钥）这样秘钥就不会被截获了，就算截获也是密文，偷窥者没办法呀。然后双方就使用刚刚非对称加密通信产生的对称加密的秘钥来进行加密解密，这样一来安全问题和效率问题就得到了很好的解决啦！ 中间人劫持​ 现在张大胖和Bill就很欢快地聊起来了，但是问题就这么简单地结束了吗？当然没有！张大胖把自己和Bill的聊天情况告诉了他女朋友，女朋友一听就发现了一个问题，她说：“Bill给别人，给你发公钥的时候也是通过网络传输的呀！那么这时候有个中间人把这个公钥给劫持了，再把自己的公钥换掉Bill的公钥发给你，你收到的就是中间人的公钥呀！那么你通过中间人的公钥进行消息加密发给Bill，这时候中间人再次劫持消息，通过他的私钥进行解密就直接能获得消息的内容了，然后他再把解密完的消息或者自己编造一个假消息然后使用Bill的公钥进行加密发给Bill，这样就神不知鬼不觉的解密了你们的消息并且还能冒充身份和造假消息！！！张大胖一听，后背就开始发凉，难道自己和Bill发的生活照都被中间人截取了吗？？？这可怎么防呀？ 数字签名和数字证书​ 但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？这真的是一个很头痛的问题呀！可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。这让张大胖想到了一个现实中的问题——签名。像我们签合同，协议都是通过签名来确定这个本人，那么我们可以把它移植到网络上！怎么移植呢？ ​ RSA算法给我们提供了一个很好的办法，因为它不仅可以通过公钥加密私钥解密，它还可以私钥加密公钥解密。这样我们发送公钥的时候可以通过某个消息摘要算法，首先这个消息摘要算法必须有两个特性——不可逆性和可变性。不可逆好理解，就是无法通过密文解出明文，这个可变性就是指当消息发生一点点变化的时候，它形成的密文就会发生翻天覆地的变化，这样就可以防止别人修改。这时候我们通过消息摘要算法来对公钥进行加密形成摘要，然后我们通过自己的私钥对这个摘要进行加密形成摘要密文，这个摘要密文就是我们的数字签名。这样，我们发公钥的时候就发送原本的消息附加上我们的数字签名，这样对方收到这个消息的时候就使用收到的公钥对这个数字签名进行解密（得到其实就是公钥的摘要），然后再通过同样的消息摘要算法对收到的公钥进行加密，如果对公要的加密密文和数字签名解密出来的东西是一样的，那么久说明这个公钥没有被修改过！ ​ 可能有点难理解，我们这么想，如果中间人对这个公钥进行了修改或者替换。比如张大胖和Bill在通信，张大胖把自己的公钥和数字签名发给了Bill，中间人截获这个消息，假如他替换了公钥（替换成自己的了），那么他也不能改动数字签名，使数字签名通过这个公钥来形成中间人公钥的信息摘要，因为这个数字签名就是密文，他不知道如何下手，所以如果只改公钥，那么这样肯定会被Bill发现。但是，作为一个狠角色，要干就要干狠一点，不能改公钥，不能改数字签名，老子干脆就把它全改了，全用自己的！ ​ 所以问题又来了，这时候我们就要请来大人物了——认证中心（CA），我们需要有一个具有公信力的中间商，当我们把自己的公钥和个人信息形成消息摘要的时候，我们使用CA的私钥进行加密形成数字签名。 ​ 然后我们发送消息的时候我们把我们的公钥和个人信息再连带着使用CA的私钥加密过的数字签名发送给对方，这些东西合起来就有另一个名字——数字证书。 ​ 如图所示，当Bill吧这个数字证书发给张大胖的时候，我就用同样的消息摘要算法对原本消息进行摘要，然后使用CA的公钥对数字签名进行解密获取摘要，然后对比我前后获取的摘要，如果一致那么就说明这个东西没有被篡改。你想想，如果中间人截获了这个证书，他把证书全改成自己的，但是张大胖使用的是CA的公钥解密摘要，然而中间人不知道CA的私钥，那么他这么做就露馅了！这时候张大胖就安全地拿到了Bill的公钥，后续的加密工作就可以顺利地进行了。当然，网络本就是不安全的，想必大家也想到了，当Bill获取CA的公钥的时候，这个中间人也可以发起攻击，直接篡改CA公钥，那么这样安全问题就无限的循环下去无法解决了！当然这些CA本身也有证书来证明自己的身份，并且CA的信用是像树一样分级的，高层的CA给底层的CA做信用背书，而操作系统／浏览器中会内置一些顶层的CA的证书，相当于你自动信任了他们。这些顶层的CA证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。 HTTPS​ 这样，https也非常好理解了，看图就知道了。 ​ 本博文参考于刘欣的《码农翻身》，特别感谢此书，也推荐大家阅读。 后记​ 好久没写博客了，因为这学期以来就有一大堆事情要解决处理，有时候学习完，就一直没时间写总结。总感觉自己像头狮子一样，想一口气吃成大胖子，什么都要学，什么都学不精，学了之后不总结，学了就忘。当然有好奇心也是好事，但是我可不想无法精通一门东西，昨天看这本《码农翻身》，书中提到了不要让碎片化信息侵蚀你深度思考的能力，确实如此，我们现在学习知识都是以一种常识的心态去学，我们只是记住了这个常识，死记硬背，并没有深度思考其中的原因和逻辑，所以我们无法精通一门技术，我想，这大概是我现阶段学习最大的问题吧。]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的散列集]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E4%B8%AD%E7%9A%84%E6%95%A3%E5%88%97%E9%9B%86%2F</url>
    <content type="text"><![CDATA[哈希&nbsp;&nbsp;Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 &nbsp;&nbsp;所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 &nbsp;&nbsp;两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。 &nbsp;&nbsp;常见的Hash函数有以下几个： 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 &nbsp;&nbsp;上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种： 开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 线性探查：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。 二次探查：di=12，-12，22，-22，…，k2，-k2 ( k&lt;=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 HashMap 的数据结构&nbsp;&nbsp;在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。上面我们提到过，常用的哈希函数的冲突解决办法中有一种方法叫做链地址法，其实就是将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。 &nbsp;&nbsp;我们可以从上图看到，左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，反过来我们也正是通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是哈希算法，即本文的主角hash()函数（当然，还包括indexOf()函数）。 假设现有 persons.put(“1”,”jack”);persons.put(“2”,”john”); 同时计算到的hash值都为123，那么jack先放在第一列的第一个位置Node-jack，persons.put(“2”,”john”);执行时会将Node-jack的next(Node) = Node(john)，Jack的下个节点将指向Node(john)。 那么取的时候呢，persons.get(“2”)，这个时候取得的hash值是123，即table[123]，这时table[123]其实是Node-jack，Key值不相等，取Node-jack的next下个Node，即Node-John，这时Key值相等了，然后返回对应的person.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOP在Spring中的应用]]></title>
    <url>%2F2019%2F02%2F02%2FAOP%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[AOP(面向切面编程)&nbsp;&nbsp;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 &nbsp;&nbsp;AOP是OOP的扩展和延伸，并不能取代OOP，AOP为OOP不能解决的问题提供了很好的方式。 &nbsp;&nbsp;例如，我们现在需要在持久层的某个save方法前面加一个权限校验的方法。 按照正常的想法，我们会在dao类上添加一个check权限的方法然后在调用save方法之前调用check方法，但是问题来了，当出现成千上百的保存方法的时候，我们就需要在成百上千的类中添加check校验方法，这样就很麻烦 使用纵向继承的方式，我们可以编写一个BaseDao类，这个类中我们编写一个check校验方法，当我们某各类需要加入权限校验方法的时候，我们只需要继承BaseDao类并调用BaseDao类中的check方法就行了。但是，使用继承的方式虽然说比上面的方法好一些，但是也并不尽人意，比如当我们这个权限校验方法不需要的时候，我们必须删除这些extends和子类调用BaseDao的check方法。AOP为我们解决这类问题提供了很好的方案。 AOP(横向抽取)，其实AOP的原理就是使用了Java中的代理模式,具体可以参考这篇文章。这时候我们在把save方法抽取出来，我们使用Proxy模式增强save方法。 AOP的好处和Spring AOP底层实现&nbsp;&nbsp;对程序进行曾倩，不修改源码的情况下，AOP可以进行权限校验，日志记录，性能监控，事务控制等功能。 &nbsp;&nbsp;Spring AOP底层使用动态代理模式，在被代理类实现某种接口的时候使用JDK动态代理，在被代理类没有实现某个接口的时候使用cglib动态代理。 AOP相关术语&nbsp;&nbsp;首先我们先列出需要实现AOP的代码类123456public class UserDao&#123; public void save()&#123;&#125; public void find()&#123;&#125; public void update()&#123;&#125; public void delete()&#123;&#125;&#125; &nbsp;&nbsp;我们对照上面代码看 JoinPoint：连接点，可以被拦截到的点。这里四个crud方法都是可以进行方法增强的，所以这四个方法都可以被称为JoinPoint PointCut：切入点，真正被拦截的点，如果这四个方法中我们只对save方法进行了增强，那么save方法就是PointCut。 Advice：通知增强，假如我们现在对save方法进行权限校验，那么这个check方法就称为通知或者增强，而且这是方法层面的增强 Introduction：引介，类方面的增强 Target：被增强的对象，如果现在我们对UserDao这个类增强，那么UserDao就是Target Waving：织入，它是一个过程，指的是我们将通知（Advice）应用到目标（Target）过程，将全县校验的方法的代码应用到UserDao的save方法上的过程。 Proxy：代理对象，一个类被AOP织入增强之后就产生了一个结果代理类 Aspect：切面，是切入点和通知的结合。 Spring AOP的入门开发AOP的配置123456789&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(表达式)&quot; id=&quot;切入点的id可以随便取，下面要对应&quot;/&gt;&lt;!--这里配置切面类--&gt;&lt;!--前提是切面类需要交给Spring管理--&gt;&lt;aop:aspect ref=&quot;某个切面类&quot;&gt; &lt;!--这里配置通知增强方法，这里是前置增强--&gt; &lt;aop:before method=&quot;切面类里面的增强方法&quot; pointcut-ref=&quot;切入点的id&quot;/&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型 前置通知 目标方法执行前进行操作(权限校验..) 1&lt;aop:before method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot;&gt; 后置通知 目标方法执行之后进行操作(日志..),可以获得被增强方法返回值 12&lt;aop:after-returning method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot; returning=&quot;returning对应的名字&quot;&gt;&lt;!--后置增强方法里面传入 Object 与returning对应的名字--&gt; 环绕通知 目标方法执行之后之前进行操作，可以控制方法是否执行 1&lt;aop:round method=&quot;around&quot; pointcut-ref=&quot;切入点&quot;&gt; 1234567891011//环绕增强方法实例//返回值必须是Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123;&#125;public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;环绕前&quot;); //执行切入点的方法 Object obj =joinPoint.proceed(); System.out.println(&quot;环绕后&quot;); return obj;&#125; 异常抛出通知 抛出异常的时候进行的操作(事物回滚),可以获取异常信息1&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;切入点&quot; throwing=&quot;给异常取个名字&quot;&gt; 1234//增强方法public void afterThrowing(Throwable 异常的名字)&#123; System.out.println(异常名字.getMessage());&#125; 最终通知 类似于finally，不管有没有异常都会执行的操作1&lt;aop:after method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot;&gt; 切入点表达式 基于execution的函数完成 语法 [访问修饰符] 方法返回值 包名.类名.方法名(参数) execution( 方法修饰符 方法返回值 方法所属类 匹配方法名 ( 方法中的形参表 ) 方法申明抛出的异常 ) public void com.lgq.UserDao.save(..) 两个点代表任意参数 public void com.lgq.UserDao.save(*,Integer) “*”：代表一个任意类型的参数 public void com.lgq.UserDao.save(); ()匹配一个无参方法 具体还有 使用注解进行AOP开发 使用注解开发上面的XML配置的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 切面类：注解的切面类 * @author jt *///配置切面@Aspectpublic class MyAspectAnno &#123; // 切入点注解 //后面的方法随便定义，在增强方法中要对应 @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.find(..))&quot;) private void pointcut1()&#123;&#125; @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.save(..))&quot;) private void pointcut2()&#123;&#125; @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.update(..))&quot;) private void pointcut3()&#123;&#125; @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.delete(..))&quot;) private void pointcut4()&#123;&#125; //前值增强 @Before(value=&quot;MyAspectAnno.pointcut2()&quot;) public void before()&#123; System.out.println(&quot;前置增强===========&quot;); &#125; // 后置通知: @AfterReturning(value=&quot;MyAspectAnno.pointcut4()&quot;,returning=&quot;result&quot;) public void afterReturning(Object result)&#123; System.out.println(&quot;后置增强===========&quot;+result); &#125; // 环绕通知: @Around(value=&quot;MyAspectAnno.pointcut3()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;环绕前增强==========&quot;); Object obj = joinPoint.proceed(); System.out.println(&quot;环绕后增强==========&quot;); return obj; &#125; // 异常抛出通知: @AfterThrowing(value=&quot;MyAspectAnno.pointcut1()&quot;,throwing=&quot;e&quot;) public void afterThrowing(Throwable e)&#123; System.out.println(&quot;异常抛出增强=========&quot;+e.getMessage()); &#125; // 最终通知 @After(value=&quot;MyAspectAnno.pointcut1()&quot;) public void after()&#123; System.out.println(&quot;最终增强============&quot;); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的代理模式]]></title>
    <url>%2F2019%2F02%2F01%2FJava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是代理&nbsp;&nbsp;假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子 代理模式的分类 远程代理模式：为不同地理的对象提供局域网代表对象（例子：通过远程代理可以监控各个店铺，使之可以直观的了解店里的情况） 虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建 (类似于新闻网站加载时，图片加载不出来先用一张空的图片代替) 保护代理：控制用户的访问权限 智能引用代理：提供对目标对象提供额外的服务或者减少特定的服务（火车票代售处） 两种实现方式静态代理&nbsp;&nbsp;代理和被代理对象在代理之前是确定的。他们都是实现相同的接口或者继承相同的抽象类。就比如已知一个汽车类并且也只到要有一个汽车的代理类，且它们实现相同接口或者继承相同抽象类。 继承的方式实现静态代理&nbsp;&nbsp;代理者继承被代理者，对所代理的方法进行改造 &nbsp;&nbsp;需求:一个汽车有一个move方法，方法中打印了移动中三个字并有一个行驶时间(通过Thread.sleep方法)，现在我们需要使用代理类算出移动时间并打印消息。 123456789101112131415161718192021222324252627282930313233343536373839404142//提供一个代理类和被代理类需要实现的接口public interface Movable &#123; void move();&#125;//创建一个Car并实现Movable接口public class Car implements Movable&#123; public void move() &#123; try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;移动中。。。&quot;); &#125;&#125;//使用继承方式//代理类继承被代理类，并重写其方法public class CarTimeProxy extends Car&#123; @Override public void move() &#123; long startTime=System.currentTimeMillis(); System.out.println(&quot;开始移动。。。&quot;); super.move(); long endTime=System.currentTimeMillis(); System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;); &#125;&#125;//客户端只需要创建代理类并实行代理类重写被代理类的方法public class Client &#123; public static void main(String[] args) &#123; CarTimeProxy carTimeProxy=new CarTimeProxy(); carTimeProxy.move(); &#125;&#125; 聚合的方式实现静态代理&nbsp;&nbsp;继承同一个接口，且代理对象持有被代理的对象 1234567891011121314151617181920212223242526//使用聚合方式构造代理对象public class CarTimeProxy implements Movable&#123; private Movable movable; public CarTimeProxy(Movable movable) &#123; this.movable = movable; &#125; public void move() &#123; long startTime=System.currentTimeMillis(); System.out.println(&quot;开始移动。。。&quot;); movable.move(); long endTime=System.currentTimeMillis(); System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;); &#125;&#125;//客户端先要构造car，再将car传入代理对象public class Client &#123; public static void main(String[] args) &#123; Car car=new Car(); CarTimeProxy carTimeProxy=new CarTimeProxy(car); carTimeProxy.move(); &#125;&#125; 聚合方式和继承方式哪个好呢？&nbsp;&nbsp;这时我们又新增了一个需求，我们需要给汽车再添加一个日志代理类，并在移动前后打印日志信息。 &nbsp;&nbsp;首先我们使用继承方式，那么我们只需要再创建一个日志代理类并继承于时间代理类就好了，代码如下: 12345678910//日志代理类public class CarTimeAndLogProxy extends CarTimeProxy &#123; @Override public void move() &#123; System.out.println(&quot;开始打印日志&quot;); super.move(); System.out.println(&quot;结束打印日志&quot;); &#125;&#125; &nbsp;&nbsp;但是这时候我们需求又变动了，我们需要先打印时间信息再打印日志信息，这时候继承方式的静态代理就显得很无力了。 &nbsp;&nbsp;所以我们推荐使用聚合式的静态代理，如下： 1234567891011121314151617181920212223//创建日志代理类并实现Movable接口public class CarLogProxy implements Movable &#123; private Movable movable; public CarLogProxy(Movable movable) &#123; this.movable = movable; &#125; public void move() &#123; System.out.println(&quot;开始打印日志&quot;); movable.move(); System.out.println(&quot;结束打印日志&quot;); &#125;&#125; //这时候我们只需要调换一下代理类的顺序就好 public static void main(String[] args) &#123; Car car=new Car(); CarLogProxy carLogProxy=new CarLogProxy(car); CarTimeProxy carTimeProxy=new CarTimeProxy(carLogProxy); carTimeProxy.move(); &#125; 动态代理&nbsp;&nbsp;来自静态代理的思考:静态代理是对特定类产生代理对象，但是就日志打印这个代理功能而言，成千上百的类都会用到日志打印，那么这时候如果我们使用静态代理的话，我们就要创建成千上百的代理类，这样会非常麻烦。 &nbsp;&nbsp;所以出现了动态代理：动态产生代理，实现对不同类和不同方法的代理。 JDK动态代理 创建事务处理器，实现InvocationHandler接口，覆写invoke方法 参数说明： proxy 代理对象 Method 被代理对象的方法 args 方法的参数 1invoke（Object proxy,Method method,Object[] args） 创建被代理的类以及接口 调用Proxy的静态方法，创建代理类（这个类是实现了被代理类的接口的） 参数说明： loader：被代理类的类加载器 interfaces：被代理类实现的接口 1newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) 事务处理器 通过代理调用被代理的方法 &nbsp;&nbsp;代码如下: 12345678910111213141516171819//创建一个Handler实现InvocationHandler//并重写invoke方法和创建Object对象存放被代理的对象(用来)public class TimeHandler implements InvocationHandler &#123; private Object target; public TimeHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long startTime=System.currentTimeMillis(); System.out.println(&quot;开始移动。。。&quot;);; method.invoke(target); long endTime=System.currentTimeMillis(); System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;); return null; &#125;&#125; cglib动态代理&nbsp;&nbsp;JDK只能代理实现了接口的类，cglib针对类来实现代理，对指定目标类产生一个子类，通过方法拦截技术拦截所有调用父类方法地调用。也因为cglib使用了继承的方式，所以它不能对final修饰的类进行代理。 &nbsp;&nbsp;需求:实现对火车类的日志代理 &nbsp;&nbsp;代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CglibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class clazz)&#123; //设置创建子类的类 enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; /** * 拦截所有目标类方法的调用 * obj 目标类的实例 * m 目标方法的反射对象 * args 方法的参数 * proxy代理类的实例 */ @Override public Object intercept(Object obj, Method m, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;日志开始...&quot;); //代理类调用父类的方法 proxy.invokeSuper(obj, args); System.out.println(&quot;日志结束...&quot;); return null; &#125;&#125;public class Train &#123; public void move()&#123; System.out.println(&quot;火车行驶中...&quot;); &#125;&#125;public class Client &#123; /** * @param args */ public static void main(String[] args) &#123; CglibProxy proxy = new CglibProxy(); Train t = (Train)proxy.getProxy(Train.class); t.move(); &#125;&#125; 参考&nbsp;&nbsp;本博文参考于Java的三种代理模式和慕课网的模式的秘密——代理模式课程]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring基于XML和注解的配置]]></title>
    <url>%2F2019%2F02%2F01%2FSpring%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Bean定义基于XML的配置12&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;&lt;/bean&gt; 基于注解的配置 @Component 在类上标注这个注解,且在XML上需要配置 1234567891011&lt;context:component-scan/&gt;&lt;!--类似这样--&gt;&lt;!--负责包扫描配置组件--&gt;&lt;context:component-scan base-package=&quot;com.lgq.cfw&quot;&gt; &lt;!--exclude不扫描有Controller注解的类--&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;!--只扫描控制器。 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; @Controller Web层 @Service Service层 @Repository DAO层 &nbsp;&nbsp;后面三个注解相当于@Component注解的分类，官方推荐使用后面三个，因为Spring会对这三个注解以后做扩展。 Bean名称基于XML的配置12345678910&lt;!--配置id或者name为...--&gt;&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;&lt;/bean&gt;&lt;!--类似这样--&gt;&lt;!--加载druid数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;&lt;/bean&gt; 基于注解的配置 @Component(“dataSource”) 配置一个id为dataSource的bean，这个类在IOC容器中的id就叫dataSource Bean注入基于XML的配置通过配置property属性或者p命名空间,例如 1234&lt;!-- 将所有mapper接口的实现类自动加入到ioc容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.lgq.cfw.dao&quot;/&gt;&lt;/bean&gt; 基于注解的配置 @AutoWired 按类型注入 @Qualifier 按名称注入 @Value 普通属性 @Resource 对象属性 生命过程，Bean作用范围基于XML的配置 生命周期 init-method, destory-method 范围 scope属性 基于注解的配置 @PostConstruct 初始化 相当于init-method @PreDestory 销毁 相当于 destory-method Scope 设置作用范围 适合场景基于XML的配置bean来自第三方 基于注解的配置bean的实现类由用户自己开发]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring中的IOC和DI]]></title>
    <url>%2F2019%2F02%2F01%2FSpring%E4%B8%AD%E7%9A%84IOC%E5%92%8CDI%2F</url>
    <content type="text"><![CDATA[IOC(控制反转)&nbsp;&nbsp;IOC(控制反转)，将对象的创建权反转交给了Spring。具体原理看这里Java中的反射和工厂模式 DI(依赖注入)&nbsp;&nbsp;这个就先得从依赖讲起 依赖 123456789Class A&#123;&#125;Class B&#123; public void xxx(A a)&#123; &#125;&#125; 继承 is a 1234567Class A&#123;&#125;Class B extends A&#123;&#125; 聚合 has a 例子: Spring配置文件,将name依赖于userDao 123&lt;bean id=&quot;userDao&quot; class=&quot;com.lgq.UserDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; useDao实现类 1234567891011public class UserDaoImpl implements UserDao &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类 1234567@Testpublic void test1()&#123; //创建Spring的工厂 ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); UserDao userDao=(UserDaoImpl)applicationContext.getBean(&quot;userDao&quot;); System.out.println(((UserDaoImpl) userDao).getName());&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的反射和工厂模式]]></title>
    <url>%2F2019%2F01%2F29%2FJava%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是反射&nbsp;&nbsp;反射之中包含了一个“反”的概念，所以要想解释反射就必须先从“正”开始解释，一般而言，当用户使用一个类的时候，应该先知道这个类，而后通过这个类产生实例化对象，但是“反”指的是通过对象找到类。 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; //正的方式创建对象 Person person=new Person(); //反的方式,使用Class的forName静态方法 Class&lt;?&gt; clazz1=Class.forName(&quot;com.lgq.Person&quot;); Object object1=clazz1.newInstance(); Person person1=(Person)object1; //反的方式,使用object的getClass方法 203. Class&lt;?&gt; clazz2=person.getClass(); Object object2=clazz2.newInstance(); Person person2=(Person)object2; //反的方式,使用Class的class方法 Class&lt;?&gt; clazz3=Person.class; Object object3=clazz3.newInstance(); Person person3=(Person)object3; &#125;&#125; 反射的作用&nbsp;&nbsp;那么现在可以发现，对于对象的实例化操作，除了使用关键字new之外又多了一个反射机制操作，而且这个操作要比之前使用的new复杂一些，可是有什么用？ &nbsp;&nbsp;对于程序的开发模式之前一直强调：尽量减少耦合，而减少耦合的最好做法是使用接口，但是就算使用了接口也逃不出关键字new，所以实际上new是造成耦合的关键元凶。 简单讲一下工厂模式简单工厂&nbsp;&nbsp;首先我们先来回顾一下以前我们使用过的简单工厂模式1234567891011121314151617181920212223242526272829303132333435363738public interface Fruit&#123; void eat();&#125;public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Apple&quot;); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Orange&quot;); &#125;&#125;public class FruitFactory&#123; public static Fruit createFruit(String fruitType)&#123; if (&quot;Apple&quot;.equals(fruitType))&#123; return new Apple(); &#125; else if (&quot;Orange&quot;.equals(fruitType))&#123; return new Orange(); &#125; else&#123; return null; &#125; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Fruit fruit=FruitFactory.createFruit(&quot;Apple&quot;); fruit.eat(); &#125;&#125; &nbsp;&nbsp;这里简单说一下工厂模式，以前我们new东西都是自己new，就像现实生活中，很久以前没有制作商品的工厂，那我们获取东西就要自己制造。例子：比如刀耕火种的时代，我们需要需要一把斧子，我们没有工厂，我们只能自己造，只能自己new出来。但是到了，封建时期直至现在，有很多作坊或者工厂，当我们需要某种东西的时候，我们只需要告诉工厂我们需要什么，工厂便会给我们造什么，其实这就相当于我们制造东西的权利交给了工厂，我们变成了客户，我们客户只关心产品之间地差异(产品生产出来的结果，我们获取到了什么产品)，而不是生产产品的过程，这个东西由工厂来负责，我们不关心了。 工厂方法模式&nbsp;&nbsp;这里我们再次思考一下，上面的代码我们不是一个制造水果的工厂吗？这时候作为客户的我们又想吃Pear了，那么我们的工厂又得重新编辑它的代码，这样就会非常麻烦(因为耦合),那么我们该怎么办呢？ &nbsp;&nbsp;这里我又想提到工厂模式了，工厂模式里面有个工厂方法，它是用来解决这个简单工厂模式不可拓展性的方法。比如，这时候我们把水果工厂给抽象出来，然后我们去具体实现这个水果工厂，比如说我们实现一个AppleFactory，一个OrangeFactory。这两个工厂作为我们默认的，一开始就有的，到后来我们需要添加水果的产品种类了，我们怎么办呢？比如我们添加一个Pear类，我们使Pear实现Fruit接口，然后创建一个PearFactory实现FruitFactory，然后客户端当创建一个工厂时就创建一个PearFactory，具体看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public interface Fruit&#123; void eat();&#125;public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Apple&quot;); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Orange&quot;); &#125;&#125;//这里创建一个Pear实现Fruit接口public class Pear implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Pear&quot;); &#125;&#125;//使FruitFactory抽象public abstract class FruitFactory&#123; abstract Fruit getInstance();&#125;//创建一个AppleFactory实现FruitFactorypublic class AppleFactory extends FruitFactory &#123; @Override Fruit getInstance() &#123; return new Apple(); &#125;&#125;public class OrangeFactory extends FruitFactory &#123; @Override Fruit getInstance() &#123; return new Orange(); &#125;&#125;//如果要新增产品，需要产品实现Fruit接口并且实现FruitFactory类public class PearFactory extends FruitFactory &#123; @Override Fruit getInstance() &#123; return new Pear(); &#125;&#125;//此时更换新增的需求时我们只需要new一个新的工厂public class Client &#123; public static void main(String[] args) &#123; Fruit fruit=new PearFactory().getInstance(); fruit.eat(); &#125;&#125; 抽象工厂模式&nbsp;&nbsp;说完工厂方法模式，顺便就讲一下抽象工厂模式吧，其实抽象工厂模式是工厂方法模式的一种推广，最明显的一点就是在工厂方法的类关系图中只有一类产品，他们实现了一个统一的接口，而抽象工厂有多个类别的产品，他们分别实现了不同的功能（多个接口）。其次的一点差别就是工厂本身所具有的方法数量不同，这点差异其实也是由第一点所导致的，工厂需要有生产不同类别产品的功能，如果抽象工厂中的产品的功能简化到一个，也便成为了工厂方法。 &nbsp;&nbsp;再来看选择的过程，在工厂方法中，客户关心的只不过是实现同一样功能的不同产品间的差异，这是一个一维选择的过程。 12IFactory factory = new FactoryA(); //选择了工厂即选择了产品IProduct productA = factory.Create(); //工厂只有一个Create方法，只能生产一种产品 &nbsp;&nbsp;而在抽象工厂中，客户首先要考虑的是需要哪一样功能，其次要考虑才是产品间的差异。也就是说这是一个二维选择的过程。 12IFactory factory = new FactoryA(); //选择了某个具体工厂IProduct productA = factory.CreateProductA(); //工厂具有多个Create方法，这里选择了其中的一个 &nbsp;&nbsp;由于产品类别的增加而导致客户在考虑产品间差异的同时还要考虑产品间功能的差异，这种二维选择的过程才是工厂方法与抽象工厂之间的本质区别。 &nbsp;&nbsp;举个肯德基与麦当劳的例子，假设原来只有一家快餐店叫做麦当劳，提供的食物（具体产品）有汉堡、可乐、薯条，它们都可以满足你吃东西（抽象接口）的需求，那么你想吃快餐的时候，唯一的选择就在于吃什么，是一维选择，现在又开了一家快餐店叫做肯德基，同样供应汉堡、可乐和薯条，那么现在你若打算吃快餐，除了考虑吃什么外，还要考虑去哪里吃–肯德基还是麦当劳？这便是二维的选择。通过横向与纵向的选择才能最终锁定你要的产品。 &nbsp;&nbsp;引入系列的概念，相互间具有差异的同一类别的产品称为不同的系列，如肯德基和麦当劳就是两个不同的系列。 &nbsp;&nbsp;这种选择的区别带来的另外一个后果就是产品间的差异（系列间的差异）变为客户的次要选择，而客户主要的精力放在了功能的选择上（类别的选择）。 &nbsp;&nbsp;其实可以这么理解，像工厂方法模式里面出现多个工厂是因为产品品种的变更，每个工厂决定了一个产品品种。而抽象工厂里面不只有一个产品品种，它是一个系列的，也就是所抽象工厂模式里面出现多个工厂是因为系列产品的变更。 反射对于工厂模式的优化&nbsp;&nbsp;我们回顾一下刚刚上面所讲的工厂模式，工厂方法模式解决了简单工厂模式的不可拓展性(其实抽象工厂跟工厂方法差不多，这里就以工厂方法模式举例) &nbsp;&nbsp;不可拓展的问题是得到解决了，我们再想一下，这样是否是真的完美了吗？当我们要创建一个新的品种的时候我们还需要去创建一个新品种的工厂并且实现原来的基类工厂(FruitFactory)，没新增一个我们就要实现一个，这样是不是太麻烦了。这时候，反射给我们提供了很好的解决办法。先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940public interface Fruit&#123; void eat();&#125;public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Apple&quot;); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Orange&quot;); &#125;&#125;//这里创建一个Pear实现Fruit接口public class Pear implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Pear&quot;); &#125;&#125;public class FruitFactory&#123; public static Fruit getInstance(String fruitType) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Fruit fruit=null; //利用反射 Class&lt;?&gt; clazz=Class.forName(fruitType); Object object=clazz.newInstance(); fruit=(Fruit)object; return fruit; &#125;&#125;public class Client &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException &#123; Fruit fruit=FruitFactory.getInstance(&quot;com.lgq.Pear&quot;); fruit.eat(); &#125;&#125; &nbsp;&nbsp;这时候是不是就方便很多了，我们不需要再创建具体类的工厂去实现基类工厂了，我们只需要创建具体类实现基类，然后客户把需求告诉工厂，工厂通过反射创建产品，工厂返回基类就行了。所以最终我们变换的只是那个newInstance方法的参数了，那是一个常量，我们完完全全就可以把它放到配置文件里面。 Spring IOC 和工厂模式&nbsp;&nbsp;放到配置文件里面，这有点像什么呢？对了！Spring的IOC。Spring里面有个bean工厂(BeanFactory),其实它也是利用反射的。我们来看一下Spring配置文件里面有个bean节点 1234567891011121314151617181920212223242526&lt;bean id=&quot;Person&quot; class=&quot;test.Person&quot;&gt; &lt;!-- 第一个bean，是一个Person类，id名字随便取，还要写上类的全名 --&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;小龙&lt;/value&gt; &lt;!-- 这里的名字是通过程序里面的set来赋值的，如果去掉程序对应的set，就出错了 --&gt; &lt;/property&gt; &lt;property name=&quot;age&quot;&gt; &lt;value&gt;23&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;grade&quot;&gt; &lt;!-- 这里有点特别，这个grade变量是一个对象，和一般的变量要区别对待 --&gt; &lt;ref local=&quot;Grade&quot;/&gt; &lt;!-- 这里指向了本配置文件里面一个名字叫Grade(即id=Grade)的bean --&gt; &lt;/property&gt; &lt;/bean&gt;&lt;bean id=&quot;Grade&quot; class=&quot;test.Grade&quot;&gt;&lt;!-- 同上 --&gt; &lt;property name=&quot;math&quot;&gt; &lt;value&gt;99&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;english&quot;&gt; &lt;value&gt;59&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &nbsp;&nbsp;我们是如何获取的12345678910 //加载Spring配置文件BeanFactory f = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //从BeanFactory获取对象，通过bean节点的id值，相当于map里面的key class值是valueObject o = f.getBean(&quot;Person&quot;);Person person = (Person)o; Grade grade=(Grade)f.getBean(&quot;Grade&quot;); //这时候Spring就为你自动装配了person和grade，且将property里面的值赋过去了 //我们此时可以调用person的get方法 System.out.println(person.getName()); //.......等等 &nbsp;&nbsp;其实这里面就用到了反射，这个BeanFactory获取到了Spring的配置文件，就会通过某种方法去解析xml文件(好像是SAX，具体还没看)，解析了xml文件后，BeanFactory就会获取bean节点的class值，使用这个class值通过反射去创建这个对象并放到容器中去，如果用户需要那么他直接调用getBean方法告诉他我要获取的bean的id值就行了。其实这就是Spring最基本的原理。 反射的一些高级应用&nbsp;&nbsp;Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method &nbsp;&nbsp;其中class代表的是 类对象，Constructor是类的构造器对象，Field是类的属性对象，Method是类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组成部分。 得到构造器的方法 1234567891011//获得使用特殊的参数类型的公共构造函数， Constructor getConstructor(Class[] params)//获得类的所有公共构造函数Constructor[] getConstructors() //获得使用特定参数类型的构造函数(与接入级别无关) Constructor getDeclaredConstructor(Class[] params)//获得类的所有构造函数(与接入级别无关)Constructor[] getDeclaredConstructors() 获得字段信息(属性) 1234567891011//获得命名的公共字段 Field getField(String name)//获得类的所有公共字段 Field[] getFields()//获得类声明的命名的字段 Field getDeclaredField(String name)//获得类声明的所有字段Field[] getDeclaredFields() 获得方法信息 1234567891011//使用特定的参数类型，获得命名的公共方法 Method getMethod(String name, Class[] params) //获得类的所有公共方法 Method[] getMethods()//使用特写的参数类型，获得类声明的命名的方法Method getDeclaredMethod(String name, Class[] params) //获得类声明的所有方法Method[] getDeclaredMethods()]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC——数据格式化与数据校验]]></title>
    <url>%2F2019%2F01%2F28%2FSpringMVC%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据格式化 对属性对象的输入/输出进行格式化（告诉后端前端页面是以什么格式书写属性的），如果请求的数据格式不是后端标识的格式则后端不能识别，将会报400请求错误，因为服务器无法解析请求(看不懂请求)，从其本质上讲属于”类型转换”范畴。 Spring 在格式化模块中定义了一个实现ConversionService接口的FormattingConversionService实现类，该类扩展了GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能 FormattingConversionService 拥有一个 FormattingConversionServiceFactroyBean 工厂类，后者用于在 Spring 上下文中构造前者 FormattingConversionServiceFactroyBean 内部已经注册了 : NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解 JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解 装配了 FormattingConversionServiceFactroyBean 后，就可以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了。mvc:annotation-driven/ 默认创建的ConversionService 实例即为FormattingConversionServiceFactroyBean 日期格式化&nbsp;&nbsp; @DateTimeFormat注解可对Date,Calendar,java.long.Long时间类型进行标注 pattern 属性：类型为字符串。指定解析/格式化字段数据的模式，如：”yyyy-MM-dd hh:mm:ss” iso 属性：类型为 DateTimeFormat.ISO。指定解析/格式化字段数据的ISO模式，包括四种：ISO.NONE（不使用） – 默认、ISO.DATE(yyyy-MM-dd) 、ISO.TIME(hh:mm:ss.SSSZ)、ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ) style 属性：字符串类型。通过样式指定日期时间的格式，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式：S：短日期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整日期/时间格式、-：忽略日期或时间格式 数值格式化&nbsp;&nbsp; @NumberFormat 可对类似数字类型的属性进行标注，它拥有两个互斥的属性： style：类型为 NumberFormat.Style。用于指定样式类型，包括三种：Style.NUMBER（正常数字类型）、Style.CURRENCY（货币类型）、 Style.PERCENT（百分数类型） pattern：类型为 String，自定义样式，如patter=”#,###”； 例子： 123456789@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)private Date birth;@NumberFormat(pattern=&quot;#,###,###.#&quot;)private Float salary;public Integer getId() &#123; return id;&#125; 数据校验(JSR303) JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 JSR 303 通过在 Bean 属性上标注类似于@NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证 JSR303注解： 使用 直接将注解加到Java bean中的某个要校验的属性上就行，但是也要在目标方法那个bean 类型前面加上@Valid注解,注意：需要校验数据的bean对象总是和其绑定结果对象或错误对象成对出现，他们之间不允许放入其他入参(他们要连在一起) 数据绑定流程 Spring MVC 通过反射机制对目标处理方法进行解析，将请求消息绑定到处理方法的入参中。数据绑定的核心部件是DataBinder，运行机制如下： &nbsp;&nbsp;所以说当进行数据格式化和数据校验时，最后如果是错误的，错误结果会存到BindingResult对象里面，它其实是个Errors对象，因为它继承了Errors 代码例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445 //COntroller层@RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.POST) //要检验的bean必须和BindingResult(Errors)绑定到一起，中间不能有其他入参public String save(@Valid Employee employee, Errors result, Map&lt;String, Object&gt; map)&#123; System.out.println(&quot;save: &quot; + employee); if(result.getErrorCount() &gt; 0)&#123; System.out.println(&quot;出错了!&quot;); for(FieldError error:result.getFieldErrors())&#123; System.out.println(error.getField() + &quot;:&quot; + error.getDefaultMessage()); &#125; //若验证出错, 则转向定制的页面 map.put(&quot;departments&quot;, departmentDao.getDepartments()); return &quot;input&quot;; &#125; employeeDao.save(employee); return &quot;redirect:/emps&quot;;&#125; //bean里面的属性@NotEmptyprivate String lastName;@Emailprivate String email;//1 male, 0 femaleprivate Integer gender;private Department department;@Past@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)private Date birth;@NumberFormat(pattern=&quot;#,###,###.#&quot;)private Float salary;public Integer getId() &#123; return id;&#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC的数据转换]]></title>
    <url>%2F2019%2F01%2F28%2FSpringMVC%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据转换&nbsp;&nbsp;Spring MVC 上下文中内建了很多转换器,可完成大多数Java类型的转换工作。 &nbsp;&nbsp;自定义类型转换器，ConversionService是Spring类型转换体系的核心接口。可以利用 ConversionServiceFactoryBean 在 Spring 的 IOC容器中定义一个 ConversionService. Spring 将自动识别出IOC 容器中的 ConversionService，并在 Bean 属性配置及Spring MVC 处理方法入参绑定等场合使用它进行数据的转换 &nbsp;&nbsp;可通过ConversionServiceFactoryBean 的 converters 属性注册自定义的类型转换器 123456789&lt;!-- 配置 ConversionService --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;employeeConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; Spring 支持的转换器Spring 定义了 3 种类型的转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到ConversionServiceFactroyBean 中： Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象 ConverterFactory：将相同系列多个 “同质” Converter 封装在一起。如果希望将一种类型的对象转换为另一种类型及其子类的对象（例如将 String 转换为 Number 及 Number 子类（Integer、Long、Double 等）对象）可使用该转换器工厂类 GenericConverter：会根据源类对象及目标类对象所在的宿主类中的上下文信息进行类型转换 123456789101112131415161718192021222324@Componentpublic class EmployeeConverter implements Converter&lt;String, Employee&gt; &#123; @Override public Employee convert(String source) &#123; if(source != null)&#123; String [] vals = source.split(&quot;-&quot;); //GG-gg@atguigu.com-0-105 if(vals != null &amp;&amp; vals.length == 4)&#123; String lastName = vals[0]; String email = vals[1]; Integer gender = Integer.parseInt(vals[2]); Department department = new Department(); department.setId(Integer.parseInt(vals[3])); Employee employee = new Employee(null, lastName, email, gender, department); System.out.println(source + &quot;--convert--&quot; + employee); return employee; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC——处理模型数据]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[ModelAndView 当控制器方法的返回值如果为ModelAndView，那么它既包含视图信息，也包含模型数据信息,其实如果返回String的话，他最终也会被SpringMVc转换成ModelAndView对象。 添加模型数据的方法 ModelAndView addObject(String attributeName,Object attributeValue) ModelAndView addAllObject(Map&lt;String,?&gt; modelMap) 设置视图 void setView(View view) void setViewName(String viewName) 例子: 1234567891011121314151617181920@Controller@RequestMapping(&quot;/user&quot;)public class TestController &#123; /** * 利用ModelAndView来转发数据,给前端视图 * @return modelAndView */ @RequestMapping(&quot;/testModelAndView&quot;) public ModelAndView testModelAndView() &#123; //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); //设置返回视图信息 modelAndView.setViewName(&quot;success&quot;); //添加模型数据 modelAndView.addObject(&quot;message&quot;, &quot;Hello World&quot;); return modelAndView; &#125; &#125; Map和Model Spring MVC 在内部使用了一个org.springframework.ui.Model 接口存储模型数据 Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。 如果方法的入参为Map或Model类型，Spring MVC 会将隐含模型的引用传递给这些入参。在方法体中，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据 @SessionAttributes注解 若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个 @SessionAttributes,Spring MVC 将在模型中对应的属性暂存到 HttpSession 中 该注解只能放在类的上面. 而不能修饰方法。 @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中 @SessionAttributes(types=User.class) 会将隐含模型中所有类型为 User.class 的属性添加到会话中。 @SessionAttributes(value={“user1”, “user2”}) 会将名字为user1和user2的属性添加到session对话中 @SessionAttributes(types={User.class, Dept.class})会将User类型和Dept类型的对象添加到会话中 @SessionAttributes(value={“user1”, “user2”}, types={Dept.class}) 会将名字为user1，user2还有类型为Dept的对象添加到session会话中 ModelAttribute的使用场景 比如当我们要修改一个user对象的属性，但是其中ID属性的值我们不能修改，这时我们可以先从数据库中拿到这个user对象，然后再把用户发送过来的修改请求赋值给这个user对象，(前端只对除ID属性以外的属性赋值修改了)这时我们拿到的就是ID没有被修改的user对象了 例子: 1234567891011121314151617181920 //被ModelAttribute修饰的方法会在每个目标方法执行之前被SpringMVC调用@ModelAttributepublic void getUser(@RequestParam(value=&quot;id&quot;,required=false) Integer id, Map&lt;String, Object&gt; map)&#123; System.out.println(&quot;modelAttribute method&quot;); if(id != null)&#123; //模拟从数据库中获取对象 User user = new User(1, &quot;Tom&quot;, &quot;123456&quot;, &quot;tom@atguigu.com&quot;, 12); System.out.println(&quot;从数据库中获取一个对象: &quot; + user); map.put(&quot;user&quot;, user); &#125;&#125;@RequestMapping(&quot;/testModelAttribute&quot;)public String testModelAttribute(User user)&#123; System.out.println(&quot;修改: &quot; + user); return SUCCESS;&#125; 运行流程： ModelAttribute修饰的方法先从数据库中获取要修改的user对象，并把这个对象放入Map中，键为user SpringMVC从map中取出键为user的对象，并将用户输入的修改的值赋给这个对象的相应属性 SpringMVC将这个被赋值好的对象传到目标方法的入参中 放入map的对象的键值要和目标方法第一个字母小写的String值要相同 SpringMVC 确定目标方法 POJO 类型入参的过程 调用 @ModelAttribute 注解修饰的方法. 实际上把 @ModelAttribute 方法中 Map 中的数据放在了 implicitModel 中. 确定一个 key: 若目标方法的 POJO 类型的参数木有使用 @ModelAttribute 作为修饰, 则 key 为 POJO 类名第一个字母小写 若使用了 @ModelAttribute 来修饰, 则 key 为 @ModelAttribute 注解的 value 属性值. 在 implicitModel 中查找 key 对应的对象, 若存在, 则作为入参传入 若在 @ModelAttribute 标记的方法中在 Map 中保存过, 且 key 和 1 确定的 key 一致, 则会获取到. 若 implicitModel 中不存在 key 对应的对象, 则检查当前的 Handler 是否使用 @SessionAttributes 注解修饰, 若使用了该注解, 且 @SessionAttributes 注解的 value 属性值中包含了 key, 则会从HttpSession 中来获取 key 所对应的 value 值, 若存在则直接传入到目标方法的入参中. 若不存在则将抛出异常. 若 Handler 没有标识 @SessionAttributes 注解或 @SessionAttributes 注解的 value 值中不包含 key, 则 会通过反射来创建 POJO 类型的参数, 传入为目标方法的参数 SpringMVC 会把 key 和 POJO 类型的对象保存到 implicitModel 中, 进而会保存到 request 中. ModelAttribute修饰方法的入参 ModelAttribute修饰的POJO类型入参有个value值，SpringMVC会通过value值为key在implicitModel中查找对应的属性，若存在，则把这个属性直接赋值给目标方法入参(POJO对象)。 若不存在，则SpringMVC会以value为key，POJO入参为value存入Request中]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中POJO对象和Servlet API作为入参]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E4%B8%ADPOJO%E5%AF%B9%E8%B1%A1%E5%92%8CServlet-API%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82%2F</url>
    <content type="text"><![CDATA[使用POJO对象绑定请求参数值 Spring MVC 会按请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel 等 例子： Controller层代码12345@RequestMapping(value = &quot;testPOJO&quot;,method = RequestMethod.POST)public String testPOJO(User user)&#123; System.out.println(user.toString()); return TEST;&#125; jsp页面代码1234567891011&lt;form action=&quot;testPOJO&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt; &lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;address.province&quot; placeholder=&quot;省份&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;address.city&quot; placeholder=&quot;城市&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;TestPOJO&quot;&gt;&lt;/form&gt; 使用Servlet API作为入参 例子:1234567891011121314151617181920 /** * 可以使用 Serlvet 原生的 API 作为目标方法的参数 具体支持以下类型 * * HttpServletRequest * HttpServletResponse * HttpSession * java.security.Principal * Locale InputStream * OutputStream * Reader * Writer * @throws IOException */ @RequestMapping(&quot;/testServletAPI&quot;) public void testServletAPI(HttpServletRequest request, HttpServletResponse response, Writer out) throws IOException &#123; System.out.println(&quot;testServletAPI, &quot; + request + &quot;, &quot; + response); out.write(&quot;hello springmvc&quot;);// return SUCCESS; &#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的RequestParam注解]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E4%B8%AD%E7%9A%84RequestParam%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[请求处理方法签名 Spring MVC 通过分析处理方法的签名，将HTTP 请求信息绑定到处理方法的相应入参中 Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名。 必要时可以对方法及方法入参标注相应的注解（@PathVariable、@RequestParam、@RequestHeader 等）、Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理 使用@RequestParam绑定请求参数值 在处理方法入参使用 @RequestParam 可以把请求参数传递给请求方法 value:参数名 required:是否必须。默认为true，表示请求参数中必须包含对应的参数，若不存在，将抛出异常,网页中会报400请求错误。但是，当required设置为false时，方法参数为int型这种基本类型参数时，访问URL时不加参数值会报500服务器错误，解决方法是给RequestParam加一个defaultValue值。因为，如果参数是非必需的，则会赋值为null，所以参数应该是一个object对象，它才能接受这个null值。 1234567//这里RequestParam的value值id其实指的是传过来的参数，即url上带的参数//当RequestParam不写的时候其实跟写了这个注解加上required=false是一样的，但是为了阅读方便，一般都加上@RequestMapping(value = &quot;/testRequestParam&quot;,method = RequestMethod.GET)public String testRequestParam(@RequestParam(value = &quot;id&quot;,required = false) int id)&#123; System.out.println(&quot;参数为:&quot;+id); return TEST;&#125; 相类似的RequestHeader和CookieValue注解1234567891011121314151617181920/** * 了解: * * @CookieValue: 映射一个 Cookie 值. 属性同 @RequestParam */@RequestMapping(&quot;/testCookieValue&quot;)public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123; System.out.println(&quot;testCookieValue: sessionId: &quot; + sessionId); return SUCCESS;&#125;/** * 了解: 映射请求头信息 用法同 @RequestParam */@RequestMapping(&quot;/testRequestHeader&quot;)public String testRequestHeader( @RequestHeader(value = &quot;Accept-Language&quot;) String al) &#123; System.out.println(&quot;testRequestHeader, Accept-Language: &quot; + al); return SUCCESS;&#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的RequestMapping注解]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E4%B8%AD%E7%9A%84RequestMapping%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[使用@RequestMapping注解映射请求 Spring MVC使用 @RequestMapping 注解为控制器指定可以处理哪些URL请求 这个注解在控制器的类定义和方法定义处都可标注，类定义处提供初步的请求映射信息，相对于WEB应用的根目录，方法处提供进一步的细分信息，若类定义处未标注 @RequestMapping ，则方法处标记的URL相对于WEB应用的根目录 DispatcherServlet 截获请求后，就通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理方法。 映射请求参数、请求方法或请求头 @RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求 @RequestMapping 的 value、method、params 及 heads 分别表示请求 URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可让请求映射更加精确化。 params 和 headers支持简单的表达式： – param1: 表示请求必须包含名为 param1 的请求参数 – !param1: 表示请求不能包含名为 param1 的请求参数 – param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1 – {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2 的两个请求参数，且 param1 参数的值必须为 value1 例子 123456@RequestMapping(value = &quot;testParamsAndHeaders&quot;, params = &#123; &quot;username&quot;, &quot;age!=10&quot; &#125;, headers = &#123; &quot;Accept-Language=en-US,zh;q=0.8&quot; &#125;)public String testParamsAndHeaders() &#123; System.out.println(&quot;testParamsAndHeaders&quot;); return SUCCESS;&#125; 支持ant风格的资源地址 Ant 风格资源地址支持 3 种匹配符： – ?：匹配文件名中的一个字符 – *：匹配文件名中的任意字符 – ： 匹配多层路径 例子： “/testAntPath/*/abc” 等等 @PathVariable 映射URl绑定占位符 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过 @PathVariable(“xxx“) 绑定到操作方法的入参中。 例子： 12345678910/** * @PathVariable 可以来映射 URL 中的占位符到目标方法的参数中. * @param id * @return */@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)public String testPathVariable(@PathVariable(&quot;id&quot;) Integer id) &#123; System.out.println(&quot;testPathVariable: &quot; + id); return SUCCESS;&#125; REST风格的URL REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。 表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。 状态转化（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Rest 风格的 URL. 以 CRUD 为例: * 新增: /order POST * 修改: /order/1 PUT update?id=1 * 获取:/order/1 GET get?id=1 * 删除: /order/1 DELETE delete?id=1 * 如何发送 PUT 请求和 DELETE 请求呢 ? 1. 需要配置 HiddenHttpMethodFilter 2. 需要发送 POST 请求 * 3. 需要在发送 POST 请求时携带一个 name=&quot;_method&quot; 的隐藏域, 值为 DELETE 或 PUT * * 在 SpringMVC 的目标方法中如何得到 id 呢? 使用 @PathVariable 注解 * */@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.PUT)public String testRestPut(@PathVariable Integer id) &#123; System.out.println(&quot;testRest Put: &quot; + id); return SUCCESS;&#125;@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String testRestDelete(@PathVariable Integer id) &#123; System.out.println(&quot;testRest Delete: &quot; + id); return SUCCESS;&#125;@RequestMapping(value = &quot;/testRest&quot;, method = RequestMethod.POST)public String testRest() &#123; System.out.println(&quot;testRest POST&quot;); return SUCCESS;&#125;@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.GET)public String testRest(@PathVariable Integer id) &#123; System.out.println(&quot;testRest GET: &quot; + id); return SUCCESS;&#125; //页面代码 &lt;form action=&quot;springmvc/testRest/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;TestRest PUT&quot;/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;form action=&quot;springmvc/testRest/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;TestRest DELETE&quot;/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;form action=&quot;springmvc/testRest&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;TestRest POST&quot;/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;springmvc/testRest/1&quot;&gt;Test Rest Get&lt;/a&gt; //在web.xml中配置filter &lt;!-- 配置 org.springframework.web.filter.HiddenHttpMethodFilter: 可以把 POST 请求转为 DELETE 或 POST 请求 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; HiddenHttpMethodFilter：浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与DELETE 请求。]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中单例模式的饿汉与懒汉]]></title>
    <url>%2F2019%2F01%2F27%2FJava%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%A5%BF%E6%B1%89%E4%B8%8E%E6%87%92%E6%B1%89%2F</url>
    <content type="text"><![CDATA[单例模式&nbsp;&nbsp;有些对象我们只需要一个，如：配置文件、工具类、线程池、缓存、日志对象等。 &nbsp;&nbsp;如果创造出多个实例，就会导致许多问题,比如占用过多资源，不一样的结果等。 饿汉模式 将构造方法私有化，不允许外部直接访问。 1private Singleton()&#123;&#125; 创建 类的唯一实例, 使用private static修饰。 1private static Singleton instance=new Singleton(); 提供一个用于获取实例的方法, 使用public static修饰。 123public static Singleton getInstance()&#123; return instance;&#125; 懒汉模式 将构造方法私有化，不允许外边直接创建对象。 123 private Singleton2()&#123;&#125;``` 2. 声明 类的唯一实例，使用private static修饰。 private static Singleton2 instance; 13. 提供一个用于获取实例的方法，使用public static修饰。 public static Singleton2 getInstance(){ if(instance==null){ instance=new Singleton2(); } return instance; }` 饿汉模式与懒汉模式的区别 饿汉模式 &nbsp;&nbsp;加载类时比较慢，但运行时获取对象的速度比较快，线程安全 懒汉模式 &nbsp;&nbsp;加载类时比较快，但运行时获取对象的速度比较慢，线程不安全]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS中的定位]]></title>
    <url>%2F2019%2F01%2F26%2FCSS%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[position属性&nbsp;&nbsp;通过设置定位将页面中的元素摆放到页面的任意位置，我们使用position属性来设置元素的定位 static&nbsp;&nbsp;默认值，元素没有开启定位 relative&nbsp;&nbsp;开启元素的相对定位 absolute&nbsp;&nbsp;开启元素的绝对定位 fixed&nbsp;&nbsp;开启元素的固定定位 偏移量 left top right bottom 一般情况我们只设置一个水平偏移量和垂直偏移量，用这两个偏移量来确定元素的位置。 相对定位 开启相对定位时如果不设置偏移量，元素不会发生任何变化 相对定位元素相对于其自身原来在文档流中的位置来定位 相对定位的元素不会脱离文档流 box2开启向对定位且向右偏移box3宽度的像素，但是box3没有向上顶，原因就是原来box2还在文档流中 相对定位不会改变元素的性质，块级元素还是块级元素，内联元素还是内联 相对定位的元素会提升一个层级 此时box2开启相对定位，它把box3给覆盖了一些，说明box2比box3高了一个层级 绝对定位 元素设置成绝对定位以后，如果不设置偏移量，元素位置不会发生改变 绝对定位的元素是相对于距离他最近的开启了定位的祖先元素进行定位的，如果所有祖先元素都没有开启定位，则相对于浏览器窗口进行定位 box1为box4的父元素，box1开启定位，box4开启绝对定位，则他的偏移量是根据box1的位置来定的，也就是最近的开启了定位的祖先元素。 绝对定位会完全脱离文档流 绝对定位会改变元素的性质。内联变成块元素，块元素的高度和宽度都被内容撑开，并且不独占一行(脱离文档流的特点，浮动也有) 绝对定位会使元素提升一个层级 固定定位&nbsp;&nbsp;固定定位是一种特殊的绝对定位，他的特点大部分和绝对定位一样，但是不同的是，固定定位的元素永远都是相对于浏览器窗口进行定位的，并且不会随滚动条滚动(用来实现广告窗口，固定导航条等) 层级&nbsp;&nbsp;在一般开启定位之后，开启定位的元素会提升一个层级，也就是它会覆盖上面的元素，如果两个元素都开启了定位，那么后面的元素就会覆盖前面的元素，那么如果我们想前面的元素覆盖上面的元素，我们可以通过设置z-index属性来做到。 &nbsp;&nbsp;z相当于z轴，因为层级已经不是水平方向的了，一般我们给z-index设置整数，整数越大，层级越高。 opacity&nbsp;&nbsp;当元素出现了层级的概念之后，opacity也很好理解了，比如我们设置了box4是覆盖box1的，但是我们想通过box4来看到box1，那么我们可以通过设置opacity属性来设置box4的透明度。 &nbsp;&nbsp;opacity值在0~1之间，0是全透明，1是不透明，0.5就是半透明。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS的盒子模型]]></title>
    <url>%2F2019%2F01%2F25%2FCSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是盒子模型&nbsp;&nbsp;CSS中将每个元素都设置为了一个矩形的盒子来方便页面的布局，所以当这些元素都变成了盒子之后，我们的布局就变成了在页面中摆放盒子 内容(content)&nbsp;&nbsp;元素的所有子元素都是放在父元素的内容区中 &nbsp;&nbsp;内容区有宽度和高度——width，height 内边距(padding)&nbsp;&nbsp;内边距指的是内容区和边框区之间的距离，内边距会影响盒子的大小。 此时box1原本高度宽度只有10px，设置内边距之后整个盒子可见框的大小就发生变化了，而且元素的背景颜色延伸到了内边距。 其中属性有五种 padding 当只设置一个值的时候这个值则是给上右下左都设置了 当设置两个值时，第一个值是上下，第二个值是左右 当设置三个值时，第一个值是上，第二个值是左右，第三个值是下 当设置四个值时，就是上右下左 padding-top padding-right padding-bottom padding-left 边框&nbsp;&nbsp;整个盒子的可见框大小是由内容区、内边距区，边框区决定的 &nbsp;&nbsp;设置边框需要设置三个样式。他们分别是border-width，border-color，border-style border-width设置的是边框的宽度 border-color设置的是边框的颜色 border-style设置的是边框的样式，一般有solid实线，dotted点线，dashed虚线等等 &nbsp;&nbsp;通过使用border直接给边框三个属性赋值，例:border: 1px solid red;&nbsp;三个属性没有顺序要求 外边距外边距的简述和语法规范&nbsp;&nbsp;外边距是盒子和其他盒子之间地距离，外边距不会影响可见框的大小，但是会影响盒子的位置。 &nbsp;&nbsp;外边距也具有四个方向，语法跟padding相类似。 &nbsp;&nbsp;margin值：单独将左右外边距设置为auto，则会将左右外边距设置为最大值 &nbsp;&nbsp;如果同时将左右外边距设置为auto，则他的左右外边距会相同，所以一般我们会通过这种方式使一个子元素在他的父元素中水平居中&nbsp;&nbsp;margin:0 auto &nbsp;&nbsp;外边距可以设置为负值，则元素会向相反方向移动 外边距的重叠和取和现象&nbsp;&nbsp;相邻元素的外边距会取最大值 上面两张图我们可以看见box1和box2之间地margin值重叠在了一起，所以他们之间地margin值取得是最大的那一个 &nbsp;&nbsp;子元素的外边距会传给父元素 上图我们可以知道box1把外边距传给了他的父元素box3 &nbsp;&nbsp;另外一个就是水平外边距不会重叠，他们会取和 内联元素的盒子模型内联元素的width和height&nbsp;&nbsp;内联元素是不支持宽高属性的! 内联元素的padding&nbsp;&nbsp;内联元素支持水平方向的padding &nbsp;&nbsp;内联元素也支持垂直方向的padding但是不会影响布局 内联元素的border&nbsp;&nbsp;支持四个方向的边框，但是垂直的边框不会影响布局 内联元素的margin&nbsp;&nbsp;支持水平方向的外边距，不支持垂直方向上的 盒模型相关的样式display&nbsp;&nbsp;display决定元素的显示方式 none&nbsp;&nbsp;当属性值为none时，这个元素不会在页面中显示且不会占据页面的位置 block&nbsp;&nbsp;元素作为块元素显示 inline&nbsp;&nbsp;元素作为内联元素显示 inline-block&nbsp;&nbsp;作为行内块元素显示，具有块元素和内联元素的特点——能进行宽高的设置，不会进行换行 visibility&nbsp;&nbsp;visibility属性设置元素是否在页面中显示 visible&nbsp;&nbsp;默认值，元素可以正常显示 hidden&nbsp;&nbsp;元素不在页面中显示，但是依然在页面占据着它原来的空间 overflow&nbsp;&nbsp;overflow设置元素如何处理溢出内容 visible&nbsp;&nbsp;默认值，子元素溢出的东西会在父元素以外的地方显示 hidden 溢出内容会被隐藏 scroll 会添加滚动条显示溢出内容不管内容是否溢出都会添加滚动条 auto&nbsp;&nbsp;根据需要自动生成滚动条 文档流概念文档流指的是网页中的一个位置 文档流是网页的基础，是网页的最底层，所有的元素默认都是在文档流中排列 元素在文档流中默认自左向右，自上向下排列（和我们的书写习惯一致） 块元素 块元素在文档流中自上向下排列 块元素在文档流中宽度默认是父元素的100% 块元素在文档流中高度默认被内容撑开 内联元素 内联元素在文档流中自左向右排列，如果一行中不足以容下所有的内联元素，则换到下一行，继续自左至右排列 内联元素在文档流中宽度和高度默认都被内容撑开]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS的浮动]]></title>
    <url>%2F2019%2F01%2F24%2FCSS%E2%80%94%E7%9A%84%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[如何使用&nbsp;&nbsp;使用float属性给元素设置浮动效果 可选值： none &nbsp;&nbsp;默认值,不浮动，元素还在文档流中 left &nbsp;&nbsp;元素向左浮动 right &nbsp;&nbsp;元素向右浮动特点 元素浮动以后会脱离文档流 浮动以后会向父元素的最上方移动 知道遇到父元素的边框或者其他的浮动元素，会停止移动 首先我们看一下当元素在文档流中，比如div元素在页面的布局 此时div是垂直排列的，因为这是块级元素的特点——块级元素在文档流中默认垂直排列 但是如果我们向让他们水平排列怎么办呢？ 可以把块级元素的display属性设置为inline-block（行内块状元素）。 还有一种就是将元素脱离文档流，此时元素就不会受到文档流的约束。 如果浮动元素上边是个块元素，则浮动元素不会覆盖块元素 这里将box1的浮动效果注释掉，可以看到box2和box3元素被box1元素向墙一样堵住了从而不能浮动上去。 浮动元素不会超过他上边的浮动的兄弟元素，最多对齐 我们把box1，box2的宽度调大使一行里面容不下两个浮动元素，我们再设置box3为右浮动，但是此时我们发现box3不会浮动到最上边，它没有超过上边的浮动元素。 浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果 浮动以后元素的特点块元素不会独占一行，宽度和高度都被内容撑开 内联元素内联元素脱离文档流以后会变成块元素]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的私有构造方法和单例模式]]></title>
    <url>%2F2019%2F01%2F09%2FJava%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[私有构造方法&nbsp;&nbsp;这几天在学习Netty写聊天室的时候看见了一个例子，在例子中的代码使用到了Java的单例模式，基础不是太好，所以特意去搜索了解了一下单例模式。 本文参考于 构造方法私有化和单例模式 &nbsp;&nbsp;写单例模式之前先说一下私有构造方法，即在构造方法之前加上private关键字 12345public class Test&#123; private Test()&#123; &#125;&#125; &nbsp;&nbsp;这时我们定义了构造方法的私有化，如果我们在别的类中实例化Test则会报错，因为私有的方法在其他类中是无法看见的 12345public class Test1&#123; public static void main(String[] args)&#123; Test test=new Test(); &#125;&#125; &nbsp;&nbsp;这时候会报错，因为Test1访问不到Test的私有构造方法 如何去解决呢？&nbsp;&nbsp;解决的方法也简单，因为是私有的构造方法，所以我们可以通过在本类里实例化Test，将Test的实例设置为私有静态变量，再构造这个实例的get方法，那么其他类就可以通过这个类的静态方法getInstance()方法获取要获取的类的实例了。 12345678910111213141516171819202122public class Test()&#123; private Test()&#123; &#125; //创建静态对象instance private static Test instance=new Test(); //通过get方法获取instance实例 public static Test getInstance()&#123; return instance; &#125; public void print()&#123; System.out.println(&quot;Hello!&quot;); &#125;&#125;public class Test1&#123; public static void mian()&#123; //通过调用Test的静态方法获取实例 Test test=Test.getInstance(); test.print(); &#125;&#125; &nbsp;&nbsp;代码运行结果就是Hello! 为什么要这么做呢&nbsp;&nbsp;我们先把上面的Test1的代码改一下1234567891011public class Test1&#123; public static void mian()&#123; //通过调用Test的静态方法获取实例 Test test=Test.getInstance(); Test test1=Test.getInstance(); Test test2=Test.getInstance(); Test test3=Test.getInstance(); //后面一些实例调用print方法就不一一列出来了.... test.print(); &#125;&#125; &nbsp;&nbsp;这时候我们实例化了四个Test，我们再回头看看刚刚Test的代码1234567891011121314public class Test()&#123; private Test()&#123; &#125; //创建静态对象instance private static Test instance=new Test(); //通过get方法获取instance实例 public static Test getInstance()&#123; return instance; &#125; public void print()&#123; System.out.println(&quot;Hello!&quot;); &#125;&#125; &nbsp;&nbsp;我们所有实例化都是通过getInstance方法获取的，但是getInstance方法获取的都是一个instance对象，也就是说我们实例化了那么多Test也只是对instance这个对象的引用。所以如果现在不希望一个类产生过多的对象的话，则必须采用单例设计模式，而且，在以后的java学习中，在支持java的类库中，大量采用了这种模式。 如何理解&nbsp;&nbsp;在window中有一个回收站，除了桌面有回收站，每个硬盘都有回收站，实际上每个硬盘上的回收站和桌面的回收站是同一个，也就是说，整个操作系统只有一个回收站实例，各个地方只是引用这个实例而已。 总结单例设计模式核心就是将类的构造方法私有化，之后在类的内部产生实例化对象，并通过类名引用类的静态方法（static）返回实例化对象的引用。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC核心配置文件的解析和应用]]></title>
    <url>%2F2018%2F12%2F14%2FSpringMVC%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用maven导入包&nbsp;&nbsp;这里我使用的是maven导入jar包，以前不知道maven，感觉导入jar包时特别麻烦，现在好了，直接Ctrl+c，Ctrl+v就完事了。 配置SpringMVC的jar包 &nbsp;&nbsp;SpringMVC所需要的jar包叫做 spring-webmvc.jar。这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。这里给出spring-webmvc在pom.xml中的代码，大家也可以自己在maven中央仓库中查找1234567&lt;!-- 依赖Spring MVC--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt;+ 配置Servlet的jar包&nbsp;&nbsp;SpringMVC是以Servlet为基础的，这里当然不能少了Servlet的配置，关于Servlet和SpringMVC的关系在接下来的博客里会有所涉及。这里给出servletz在pom.xml中的代码，大家也可以自己在maven中央仓库中查找12345678 &lt;!--servlet的配置--&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;## 在web.xml中配置dispatcherServletdispatcherServlet是前端控制器设计模式的实现，提供SpringWebMVC的集中访问点，而且负责职责的分派，而且与spring IOC容器无缝集成，从而可以获得Spring的优势。其主要职责是调度工作，本身用于控制流程。1.文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；2.通过HandlerMapping，将请求映射到处理器(返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器)；3.通过handlerAdapter支持多种类型的处理器(handlerExceptionChain中的处理器)；4.通过ViewResolver解析逻辑视图名到具体视图实现；5.本地化解析；6.渲染具体的视图等；7.如果执行过程中遇到异常将交给handlerExceptionResolver来解析；可以说dispatcherServlet是SpringMVC的核心 下面是dispatcherServlet在web.xml中的相关配置 12345678910111213&lt;!-- springmvc的前端控制器，拦截所有请求 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- Map all requests to the DispatcherServlet for handling --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;&lt;!--这里设为拦截所有请求，可以根据自己需求设置--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; dispatcherServlet文件一般默认在WEB-INF目录下面，如果需要更改则通过在servlet的初始参数里面修改contextConfigLocation的值，例如: 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;自己设定的路径&lt;/param-value&gt;&lt;/init-param&gt; 配置dispatcherServlet-servlet.xml&nbsp;&nbsp;如果按照默认的话对应的dispatcherServlet文件会以dispatcherServlet-servlet.xml放在WEB-INF目录下面 首先给出基本的dispatcherServlet的配置代码 1234567891011121314151617&lt;!--SpringMVC的配置文件，包含网站跳转逻辑的控制，配置 --&gt;&lt;context:component-scan base-package=&quot;com.lgq&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--只扫描控制器。 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--配置视图解析器，方便页面返回 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--两个标准配置 --&gt;&lt;!-- 将springmvc不能处理的请求交给tomcat --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 能支持springmvc更高级的一些功能，JSR303校验，快捷的ajax...映射动态请求 --&gt;&lt;mvc:annotation-driven/&gt; &nbsp;&nbsp;以上就是SpringMVC的基本配置，其中一些细节方面的会慢慢在以后的博文里面说明]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中==与equals的区别]]></title>
    <url>%2F2018%2F12%2F11%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD-%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[基本数据类型和引用数据类型 &nbsp;&nbsp;在谈==与equals区别之前，我们先来谈一谈java中堆和栈的区别，还有基本数据类型和引用数据类型的区别。 基本数据类型有什么? &nbsp;&nbsp;八个基本数据类型：byte，short，int，long，float，double，char，boolean 引用数据类型是什么? &nbsp;&nbsp;引用数据类型是：类，接口，数组 &nbsp;&nbsp;具体参考下图 引用数据类型，基本数据类型和堆栈之间的关系 引用类型的变量，其内存分布在堆上或者常量池(字符串变量、基本数据类型常量)，需要通过new等方式来创建。堆内主要存放运行时，需要new来创建的对象。 基本数据类型变量(8种基本数据类型)以及对象的引用变量，其内存分布在栈上，变量出了作用域就会自动释放。 如下图: Java中==和equals()与上述两者的关系 ==操作的是栈内存中的值是否相等 equals比较的是堆内存中的值是否相等。 下面我们通过一些实例来证明： 比较两个基本数据类型 输出结果为: a==b &nbsp;&nbsp;可见==b比较的是栈中的内容,a和b栈中都存放了1所以相等 比较两个字符串 输出结果为: a==b 输出结果为: a.equals(b) &nbsp;&nbsp;在这个例子中，我们看到==和equals的作用是相同的，a==b说明a和b引用了同一个String对象。a.equsls(b)说明a和b指向的对象在堆中存储的内容相同。即a和b指向同一个对象。为什么会这样呢，因为Stirng对象在创建时，会现在String缓冲池中查看是否有相同的对象，如果有，则不创建。 当再新建一个String对象 输出结果为: a.equals(b) a!=b &nbsp;&nbsp;此时字符串a，b为不同的对象。equals比较的是堆中的内容，a和b堆中内容都是123，所以输出a.equals(b)。而又a，b不是同一个对象。所以a，b的栈中存储的地址不一样，而==又是比较栈中内容所以输出a!=b。 总结:&nbsp;&nbsp;==比较的是栈中的内容，即两个对象的地址是否为同一个。equals比较的是堆中内容是否相等，即两个对象的内容是否相同。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F12%2F01%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[我的第一篇博客 建站&nbsp;&nbsp;一开始接触Markdown编辑器有些不适应，但是语法学起来不难，上手很快。可能一开始博文的格式会有些不尽人意，希望大家理解。 &nbsp;&nbsp;前天开始搭的博客，踩了一天的坑。昨天狠下心重新开始建站，长痛不如短痛，果然之前解决不了的评论系统，现在几行代码就完事了,感谢next，感谢开源。 &nbsp;&nbsp;之前博客的评论系统是用的来比力的，因为来比力实在是太慢了，无奈只能摒弃。昨天发现一个很友好的评论系统———valine，速度快了很多，也方便了许多，希望大家在我的文章下面多多留言评论，别让它成为一个死站了，哈哈。 愿身后总有力量&nbsp;&nbsp;昨天收到了学校一个技术小组的录取通知，两个月的任务考核，最后做后端的只有我审核通过了(虽然也就六个人)，算是给自己的肯定吧。希望以后一切顺利。 &nbsp;&nbsp;昨天女朋友开始撒起娇来，说我光顾着学习不理她。她真的好可爱，也好懂事，昨夜想了很久，一时也不知道怎么处理好女朋友和生活学习的关系了，只希望她能一直在我身边。 &nbsp;&nbsp;妈妈昨天给我发了微信，今天早上才想起来回。她说：你是不是光顾着谈恋爱了。哈哈，其实不是的，这两天搭博客，无数次跳坑填坑的，真的忘了回。 &nbsp;&nbsp;但是，这些都是以后会陪伴我的人，给自己一个警醒吧，以后工作学习之余，一定要多陪陪他们。 一条路走到黑就到这吧。以后加油。]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
</search>
