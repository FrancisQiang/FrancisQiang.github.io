<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优先队列和堆]]></title>
    <url>%2F2019%2F05%2F19%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%2F</url>
    <content type="text"><![CDATA[什么是优先队列 普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院挂急诊的优先级大于普通排队就诊的，比如在游戏中自动打怪设置，当地图中出现级别高的野怪先打级别高的等等。 如果我们实现优先队列使用普通的线性结构，那么当我们入队的时候时间复杂度就是O(1)，但出队的时候我们的时间复杂度就是O(n)，因为出队的时候是优先级最高的出队，所以我们需要遍历整个队列寻找优先级最高的元素。 如果我们实现优先队列使用的顺序线性结构，那么我们出队的时间复杂度就是O(1)，因为原本队列就是依靠优先级排列的，这时候我们出队只需要取出第一个元素就行了。但是，当我们进行入队操作的时候我们就需要维持队列的顺序性，这时候入队就是O(n)的时间复杂度了。 相较于前面两种实现方法，使用堆来实现优先队列的入队操作和出队操作都是O(logn)的时间复杂度，这是非常快的。 什么是堆 堆其实就是按照层由上到下，由左到右的树结构，其中可以分为最大堆和最小堆(根元素为最大的元素就是最大堆) 当我们使用数组实现堆的时候，这时候父子节点的索引值存在着一种数学关系。 当索引从0开始的时候，父亲节点的索引就是子节点的索引-1再除以2(取整的性质，所以左右孩子都一样)，相应的，左孩子就是父亲节点索引乘2+1，右孩子则是左孩子+1。 通过这个关系我们就可以很轻松的使用数组存储二叉堆。 最大堆的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * @author Lin * @date 2019-05-19 17:03 **/public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; array; public MaxHeap(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public MaxHeap()&#123; array = new Array&lt;&gt;(); &#125; public int size()&#123; return array.getSize(); &#125; public boolean isEmpty()&#123; return array.isEmpty(); &#125; /** * 返回index索引的父亲节点的索引 * @param index 索引 * @return 父亲节点的索引 */ private int parent(int index)&#123; if (index == 0)&#123; throw new IllegalArgumentException("index-0 doesn't have parent"); &#125; return (index - 1) / 2; &#125; /** * 获取节点左孩子的索引 * @param index 节点索引 * @return 左孩子索引 */ private int leftChild(int index)&#123; return index * 2 + 1; &#125; /** * 获取右孩子索引 * @param index 费节点的索引 * @return 右孩子的索引 */ private int rightChild(int index)&#123; return index * 2 + 2; &#125; public void add(E e)&#123; array.addLast(e); siftUp(array.getSize() - 1); &#125; /** * 堆中元素上浮 * @param index 指定上浮元素 */ private void siftUp(int index) &#123; //当父元素比指定元素小的时候交换，如果交换则继续去比较 while(index &gt; 0 &amp;&amp; array.get(parent(index)).compareTo(array.get(index)) &lt; 0)&#123; array.swap(index, parent(index)); index = parent(index); &#125; &#125; public E getMax()&#123; if (array.getSize() == 0)&#123; throw new IllegalArgumentException("The heap is empty"); &#125; return array.getFirst(); &#125; public E extractMax()&#123; E temp = getMax(); //将堆顶元素和堆的最后一个元素交换位置 array.swap(0, array.getSize() - 1); //删除最后一个元素(原来的堆顶元素) array.removeLast(); siftDown(0); return temp; &#125; /** * 堆中元素的下沉 * @param index 需要下沉的索引 */ private void siftDown(int index) &#123; //判断index合法性 if (index &lt; 0 || index &gt; array.getSize())&#123; throw new IllegalArgumentException("Index is illegal"); &#125; //遍历堆，条件是左孩子存在 while (leftChild(index) &lt; array.getSize())&#123; int j = leftChild(index); //如果右孩子存在则比较左右孩子，将大的索引赋值给j if (j + 1 &lt; array.getSize() &amp;&amp; array.get(j).compareTo(array.get(j + 1)) &lt; 0)&#123; j ++; &#125; if (array.get(index).compareTo(array.get(j)) &gt;= 0)&#123; //如果需要下沉的节点已经比左右孩子最大的大了直接break break; &#125;else &#123; array.swap(index, j); index = j; &#125; &#125; &#125;&#125; 最大堆的入队和出队的操作 在上述代码中，其他操作都是最基本的，但是对于插入和移除元素就会稍微复杂了。 当我们插入元素的时候，我们需要在数组最后插入元素，但是插入元素的大小不一定性决定着我们需要重新排列这个二叉堆使它还满足最大堆的特性。所以我们只需要和插入元素的父亲节点比较，如果我们插入的节点大于父亲节点了则交换，然后再和交换后的父亲节点比较，一直到根节点或者子节点小于父亲节点了。 当我们移除元素的时候，其实就是移除堆中的顶层元素，这时候如果直接移除的话，那么堆就会变成两个堆，这样整合成一个堆的话太复杂，这时候我们可以将堆底元素和堆顶元素交换，然后再删除堆底元素(原来堆顶元素),然后我们通过现在堆顶元素和它的左右孩子最大的作比较，如果小于最大的那么就交换，然后再次和左右孩子做比较直到自己没有左右孩子为止。 使用堆来实现优先队列123456789101112131415161718192021222324252627282930313233343536373839/** * @author Lin * @date 2019-05-19 20:48 **/ //优先队列中的元素必须是可比较的 //其他的方法直接复用堆中的方法就行了public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue()&#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public void enqueue(E e) &#123; maxHeap.add(e); &#125; @Override public E dequeue() &#123; return maxHeap.extractMax(); &#125; @Override public int getSize() &#123; return maxHeap.size(); &#125; @Override public E getFront() &#123; return maxHeap.getMax(); &#125; @Override public boolean isEmpty() &#123; return maxHeap.isEmpty(); &#125;&#125; 关于LeetCode中优先队列的问题 分析: 我们需要获取频率出现最高的元素，我们需要将频率和元素(key)存入一个map中，然后遍历这个数组，当map不存在相应key的数组中的元素，则将value设置为1，如果存在value++。 然后我们遍历这个map中的key，将key存入优先队列中(容量为k)，当k的容量存满了并且还需要添加元素到优先队列的时候就判断优先队列优先度最高的元素和插入元素的优先度，如果插入元素的优先度高于现在队列中最高的，那么就将元素插入到队列中，知道整个map遍历完。 代码实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; //定义一个Frequency类 //存放key和频率 private class Frequency&#123; public int k, freq; public Frequency(int k, int freq)&#123; this.k = k; this.freq = freq; &#125; &#125; //实现比较器 private class FrequencyCompartor implements Comparator&lt;Frequency&gt;&#123; @Override public int compare(Frequency o1, Frequency o2) &#123; return o1.freq - o2.freq; &#125; &#125; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(20); //遍历数组并且将频率信息存入map中 for (Integer integer : nums)&#123; if (!map.containsKey(integer))&#123; map.put(integer, 1); &#125;else &#123; map.put(integer, map.get(integer) + 1); &#125; &#125; PriorityQueue&lt;Frequency&gt; priorityQueue = new PriorityQueue&lt;&gt;(new FrequencyCompartor()); //遍历map的key，并且将频率最高的放入优先队列中 for (int key: map.keySet()) &#123; if (priorityQueue.size() &lt; k)&#123; priorityQueue.add(new Frequency(key, map.get(key))); &#125;else if (map.get(key) &gt; priorityQueue.peek().freq)&#123; priorityQueue.poll(); priorityQueue.add(new Frequency(key, map.get(key))); &#125; &#125; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); while (!priorityQueue.isEmpty())&#123; linkedList.add(priorityQueue.poll().k); &#125; return linkedList; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集合与映射]]></title>
    <url>%2F2019%2F05%2F13%2F%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是集合(Set) 简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。 定义Set接口123456789101112131415161718192021222324252627282930313233 public interface Set&lt;E&gt; &#123; /** * 增加元素 * @param e 元素 */ void add(E e); /** * 是否包含 * @param e 元素 * @return 布尔 */ boolean contains(E e); /** * 移除元素 * @param e 元素 */ void remove(E e); /** * 获取集合大小 * @return size大小 */ int getSize(); /** * set是否为空 * @return boolean */ boolean isEmpty();&#125; 使用二分搜索树实现集合 对于二分搜索树有一个很重要的特性就是它是根据元素的大小来放入元素到树中的，所以二分搜索树基本是不存在相同元素的，我们就可以通过二分搜索树底层实现集合 这是上一篇博客写的二分搜索树的相关代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276/** * @author Lin * @date 2019-05-05 20:50 **/public class BinarySearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node&#123; private E e; private Node left,right; private Node(E e)&#123; this.e=e; left=null; right=null; &#125; &#125; private Node root; private int size; public BinarySearchTree()&#123; root = null; size = 0; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size==0; &#125; public void add(E e)&#123; root = add(root,e); &#125; private Node add(Node node,E e)&#123; if (node == null)&#123; size ++; return new Node(e); &#125;else if (e.compareTo(node.e) &lt; 0)&#123; node.left = add(node.left,e); &#125;else if (e.compareTo(node.e) &gt; 0)&#123; node.right = add(node.right,e); &#125; return node; &#125; public boolean contains(E e)&#123; return contains(root,e); &#125; private boolean contains(Node node,E e)&#123; if (root==null)&#123; return false; &#125; if (e.equals(node.e))&#123; return true; &#125;else if (e.compareTo(node.e)&lt;0)&#123; return contains(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; return contains(node.right,e); &#125; return false; &#125; public E minimum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return minimum(root).e; &#125; private Node minimum(Node node) &#123; if (node.left==null)&#123; return node; &#125; return minimum(node.left); &#125; public E maximum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return maximum(root).e; &#125; private Node maximum(Node node)&#123; if (node.right==null)&#123; return node; &#125; return maximum(node.right); &#125; public E removeMin()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMin(root).e; &#125; private Node removeMin(Node node)&#123; if (node.left==null)&#123; Node rightNode=node.right; node.right=null; size--; return rightNode; &#125; node.left=removeMin(node.left); return node; &#125; public E removeMax()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMax(root).e; &#125; private Node removeMax(Node node)&#123; if (node.right==null)&#123; Node leftNode=node.left; node.left=null; size--; return leftNode; &#125; node.right=removeMax(node.right); return node; &#125; public void remove(E e)&#123; root=remove(root,e); &#125; private Node remove(Node node,E e)&#123; if (node==null)&#123; return null; &#125; if (e.compareTo(node.e)&lt;0)&#123; node.left=remove(node.left,e); return node; &#125; else if (e.compareTo(node.e)&gt;0) &#123; node.right=remove(node.right,e); return node; &#125; //如果相等就要删除 else &#123; //首先判断这个树是不是只有一边的孩子 //如果只有左边有孩子或者只有右边有孩子 if (node.right==null)&#123; size--; return node.left; &#125;else if (node.left==null)&#123; size--; return node.right; &#125; //如果左右都有孩子 //寻找该节点的后继节点 //后继结点就是离该结点最近的节点（数值最近而且是大于该节点） //那么这个结点的后继结点就是该节点右孩子的最小结点 Node successorNode=minimum(node.right); //我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子 successorNode.right=removeMin(node.right); successorNode.left=node.left; node.left=node.right=null; return successorNode; &#125; &#125; public void preOrder()&#123; preOrder(root); &#125; private void preOrder(Node node)&#123; if (node!=null)&#123; System.out.println(node.e); preOrder(node.left); preOrder(node.right); &#125; &#125; /** * 非递归实现前序遍历 */ public void perOrderWithoutRecurrence()&#123; Stack&lt;Node&gt; stack=new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; Node currentNode=stack.pop(); System.out.println(currentNode.e); if (currentNode.right!=null)&#123; stack.push(currentNode.right); &#125; if (currentNode.left!=null)&#123; stack.push(currentNode.left); &#125; &#125; &#125; /** * 层序遍历(广度优先遍历) */ public void levelOrder()&#123; if (root!=null)&#123; Queue&lt;Node&gt; queue=new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; Node currentNode=queue.remove(); System.out.println(currentNode.e); if (currentNode.left!=null)&#123; queue.add(currentNode.left); &#125; if (currentNode.right!=null)&#123; queue.add(currentNode.right); &#125; &#125; &#125; &#125; public void inOrder()&#123; inOrder(root); &#125; private void inOrder(Node node)&#123; if (node!=null)&#123; inOrder(node.left); System.out.println(node.e); inOrder(node.right); &#125; &#125; public void postOrder()&#123; postOrder(root); &#125; private void postOrder(Node node)&#123; if (node!=null)&#123; postOrder(node.left); postOrder(node.right); System.out.println(node.e); &#125; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); generateBSTString(root, 0, res); return res.toString(); &#125; /** * 生成以node为根节点，深度为depth的描述二叉树的字符串 * @param node * @param depth * @param res */ private void generateBSTString(Node node, int depth, StringBuilder res)&#123; if(node == null)&#123; res.append(generateDepthString(depth) + "null\n"); return; &#125; res.append(generateDepthString(depth) + node.e + "\n"); generateBSTString(node.left, depth + 1, res); generateBSTString(node.right, depth + 1, res); &#125; private String generateDepthString(int depth)&#123; StringBuilder res = new StringBuilder(); for(int i = 0 ; i &lt; depth ; i ++)&#123; res.append("--"); &#125; return res.toString(); &#125;&#125; 这时候我们就可以使用二分搜索树来实现集合了，很简单，直接封装一个二分搜索树然后调用方法就行了。 12345678910111213141516171819202122232425262728293031323334353637/** * @author Lin * @date 2019-05-05 21:08 **/public class BinarySearchTreeSet&lt;E extends Comparable&lt;E&gt;&gt; implements Set&lt;E&gt;&#123; private BinarySearchTree&lt;E&gt; binarySearchTree; public BinarySearchTreeSet()&#123; this.binarySearchTree = new BinarySearchTree&lt;&gt;(); &#125; @Override public void add(E e) &#123; binarySearchTree.add(e); &#125; @Override public void remove(E e) &#123; binarySearchTree.remove(e); &#125; @Override public boolean contains(E e) &#123; return binarySearchTree.contains(e); &#125; @Override public int getSize() &#123; return binarySearchTree.size(); &#125; @Override public boolean isEmpty() &#123; return binarySearchTree.isEmpty(); &#125;&#125; 使用链表来实现集合 链表中有一个contains方法，我们可以在调用add方法的时候使用contains方法判断原来集合中是否已经存在该元素了，如果已经存在那么就添加失败。其他的也是直接调用方法。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author Lin * @date 2019-05-12 10:01 **/public class LinkedListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private LinkedList&lt;E&gt; linkedList; public LinkedListSet()&#123; this.linkedList = new LinkedList&lt;&gt;(); &#125; @Override public void add(E e) &#123; //判断是否已经存在该元素 if (!linkedList.contains(e))&#123; linkedList.addFirst(e); &#125; &#125; @Override public boolean contains(E e) &#123; return linkedList.contains(e); &#125; @Override public void remove(E e) &#123; linkedList.remove(e); &#125; @Override public int getSize() &#123; return linkedList.getSize(); &#125; @Override public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125;&#125; 二分搜索树和链表实现集合的比较 在上面实现链表集合的时候我们很容易就会发现，链表集合的增加操作的时候需要先判断整个链表中是否存在该元素，那么这样就需要O(n)的时间复杂度了，在删除，查找元素的时候都是和普通链表一样O(n)的时间复杂度。可以说链表实现的集合的效率并不是很高。 那么我们再来看一看二分搜索树实现的集合的时间复杂度。当我们添加元素的时候我们是依靠二分搜索树的特性来添加的 比如我们需要添加一个元素的时候，我们就需要先判断大小，然后根据树的特性一层一层遍历，这个时候我们就会发现，我们的时间复杂度是和这个二分搜索树的高度呈线性关系的。 然后我们通过运算就可以得出一个平衡二叉树h层一共有2的h次方-1个元素，我们就很容易得出时间复杂度为log2(n+1)，忽略常数，那么就是logn。 而logn和n的差距在基数很大的时候差距特别明显 所以说二分搜索树实现的集合会比链表实现的集合快很多。当然这也是考虑树的最好情况。当树不为平衡二叉树的时候，最坏情况也会是O(n)。 如上图右边，我们看到当树成一边排列的时候，它的时间复杂度就是O(n)。 LeetCode上解决关于集合的题目 题目是这样的： 对于这道题，我们可以遍历这个words数组，然后得到其中的某个元素再次遍历字符串的每个字母，然后通过原先定义的摩尔斯密码表数组和字符相对应，之后我们就可以获取到这个单词的摩尔斯密码，我们循环完一次之后，我们就把得到的摩尔斯密码拼接成字符串然后存入到set中，最终循环完成之后我们只要返回set的size就行了。 实现代码: 123456789101112131415161718192021222324252627 /** * @author Lin * @date 2019-05-12 13:39 **/public class Solution &#123; public int uniqueMorseRepresentations(String[] words) &#123; //预先定义摩尔斯密码表 String[] codes = &#123;".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."&#125;; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (String word : words) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0 ; i &lt; word.length() ; i ++)&#123; //拼接字符串 stringBuilder.append(codes[word.charAt(i) - 'a']); &#125; //存入set中 set.add(stringBuilder.toString()); &#125; return set.size(); &#125;&#125; 什么是映射(Map,字典) 映射，在定义域中每一个值在值域都有一个值与他对应 存储(键，值)数据对的数据结构（Key，Value） 根据键(Key)，寻找值(Value) 定义Map接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @author Lin * @date 2019-05-13 20:07 **/public interface Map&lt;K, V&gt; &#123; /** * 添加元素 * @param k key * @param v value */ void add(K k, V v); /** * 删除元素 * @param k key * @return key对应的value */ V remove(K k); /** * 设置相应key的value * @param k key * @param v value */ void set(K k, V v); /** * 获取某个key对应的value * @param k key * @return value */ V get(K k); /** * 判断是否包含 * @param k key * @return 是否包含 */ boolean contains(K k); /** * 获取映射的大小 * @return 映射大小 */ int getSize(); /** * 判断映射是否为空 * @return 是否为空 */ boolean isEmpty();&#125; 链表实现Map 使用链表实现Map其实只需要将私有类Node里面的字段e更改为key和value就行。当然BinarySearchTree也是如此 实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * @author Lin * @date 2019-05-13 20:17 **/public class LinkedListMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private class Node&#123; private K key; private V value; private Node next; public Node(K key, V value, Node next)&#123; this.key = key; this.value = value; this.next = next; &#125; public Node(K key, V value)&#123; this.key = key; this.value = value; &#125; public Node()&#123; this.key = null; this.value = null; this.next = null; &#125; @Override public String toString()&#123; return key.toString() + " : " + value.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedListMap()&#123; dummyHead = new Node(); size = 0; &#125; private Node getNode(K key)&#123; Node currentNode = dummyHead.next; while (currentNode != null)&#123; if (currentNode.key.equals(key))&#123; return currentNode; &#125;else &#123; currentNode = currentNode.next; &#125; &#125; return null; &#125; @Override public void add(K k, V v) &#123; //首先判断是否已经存在该key的映射 Node node = getNode(k); if (node == null)&#123; dummyHead.next = new Node(k, v, dummyHead.next); size ++ ; &#125;else &#123; //如果存在则更新 node.value = v; &#125; &#125; @Override public V remove(K k) &#123; Node preNode = dummyHead; while (preNode.next != null)&#123; if (preNode.next.key.equals(k))&#123; Node delNode = preNode.next; preNode.next = preNode.next.next; delNode.next = null; size --; break; &#125;else &#123; preNode = preNode.next; &#125; &#125; return null; &#125; @Override public void set(K k, V v) &#123; //首先判断是否存在该key的映射，如果不存在则抛出异常 Node node = getNode(k); if(node == null)&#123; throw new IllegalArgumentException(k + " doesn't exist!"); &#125;else &#123; node.value = v; &#125; &#125; @Override public V get(K k) &#123; Node node = getNode(k); return node == null ? null : node.value; &#125; @Override public boolean contains(K k) &#123; return getNode(k) != null; &#125; @Override public int getSize() &#123; return this.size; &#125; @Override public boolean isEmpty() &#123; return this.size == 0; &#125;&#125; 二分搜索树实现映射(Map) 对于BinarySearchTree来说实现Map也是利用它原先的方法 代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196/** * @author Lin * @date 2019-05-13 20:51 **/public class BinarySearchTreeMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; private class Node&#123; public K key; public V value; public Node left, right; public Node(K key, V value)&#123; this.key = key; this.value = value; left = null; right = null; &#125; public Node()&#123; left = null; right = null; this.value = null; this.key = null; &#125; &#125; private int size; private Node root; public BinarySearchTreeMap()&#123; root = null; size = 0; &#125; //辅助方法，在删除，修改映射的value时候会用到 //获取相应key对应的Node(递归) private Node getNode(Node node, K key)&#123; //如果递归到节点为null直接返回null if (node == null)&#123; return null; &#125;else if (key.compareTo(node.key) &lt; 0)&#123; //小于的时候继续递归该结点的左子树 return getNode(node.left, key); &#125;else if (key.compareTo(node.key) &gt; 0)&#123; //大于的时候继续递归该结点的右子树 return getNode(node.right, key); &#125;else &#123; //不然就是相等，则直接返回该结点 return node; &#125; &#125; @Override public void add(K key, V value)&#123; root = add(root, key, value); &#125; private Node add(Node node, K key, V value)&#123; //递归到最底层，直接添加节点 if (node == null)&#123; size ++; return new Node(key, value); &#125;else if (key.compareTo(node.key) &lt; 0)&#123; //小于的时候直接递归该结点的左子树 node.left = add(node.left, key, value); &#125;else if (key.compareTo(node.key) &gt; 0)&#123; node.right = add(node.right, key, value); &#125; return node; &#125; /** * 返回以node为根的二分搜索树的最小值所在的节点 * @param node * @return */ private Node minimum(Node node)&#123; if(node.left == null)&#123; return node; &#125; return minimum(node.left); &#125; /** * 删除掉以node为根的二分搜索树中的最小节点 * 返回删除节点后新的二分搜索树的根 * @param node * @return */ private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; /** * 从二分搜索树中删除键为key的节点 * @param key * @return */ @Override public V remove(K key)&#123; Node node = getNode(root, key); if(node != null)&#123; root = remove(root, key); return node.value; &#125; return null; &#125; private Node remove(Node node, K key)&#123; if( node == null )&#123; return null; &#125; if( key.compareTo(node.key) &lt; 0 )&#123; node.left = remove(node.left , key); return node; &#125; else if(key.compareTo(node.key) &gt; 0 )&#123; node.right = remove(node.right, key); return node; &#125; else&#123; // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; @Override public void set(K key, V newValue)&#123; Node node = getNode(root, key); if(node == null)&#123; throw new IllegalArgumentException(key + " doesn't exist!"); &#125; node.value = newValue; &#125; @Override public V get(K k) &#123; Node node = getNode(root, k); return node == null ? null : node.value; &#125; @Override public boolean contains(K k) &#123; return getNode(root, k) != null; &#125; @Override public int getSize() &#123; return this.size; &#125; @Override public boolean isEmpty() &#123; return this.size == 0; &#125;&#125; 链表Map和二分搜索树Map比较 测试代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestMap &#123; private static double testMap(Map&lt;String, Integer&gt; map, String filename)&#123; long startTime = System.nanoTime(); System.out.println(filename); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(filename, words)) &#123; System.out.println("Total words: " + words.size()); for (String word : words)&#123; if(map.contains(word))&#123; map.set(word, map.get(word) + 1); &#125;else&#123; map.add(word, 1); &#125; &#125; System.out.println("Total different words: " + map.getSize()); System.out.println("Frequency of PRIDE: " + map.get("pride")); System.out.println("Frequency of PREJUDICE: " + map.get("prejudice")); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0; &#125; public static void main(String[] args) &#123; String filename = "I:\\data_structure\\src\\pride-and-prejudice.txt"; Map&lt;String, Integer&gt; bstMap = new BinarySearchTreeMap&lt;&gt;(); double time1 = testMap(bstMap, filename); System.out.println("BST Map: " + time1 + " s"); System.out.println(); Map&lt;String, Integer&gt; linkedListMap = new LinkedListMap&lt;&gt;(); double time2 = testMap(linkedListMap, filename); System.out.println("Linked List Map: " + time2 + " s"); &#125;&#125; 两者时间差异: 可以看出，二分搜索树实现的Map的时间性能是远高于链表实现的Map的。 因为对于链表实现修改某一映射对应的value值的时间复杂度是O(n),我们需要一个一个去遍历知道找到key符合的元素。 而对于二分搜索树实现的Map来说，它修改一个value的时间复杂度是跟二叉树的高度相关的，也就是说它的时间复杂度是O(logn)级别的，所以当数据量大的时候，二分搜索树的优势非常明显。当然我们还需要考虑最坏的情况，那就是这个二分搜索树变成了类似于链表的树，那这时候时间复杂度就是O(n)了。 但是有个细节需要注意的是，链表实现的Map的key是无序的，上文中的set也是无序的。但是二分搜索树实现的set和map都是有序的(这也是它这么快的一部分原因)。 使用Map来实现Set 我们可以发现，其实Set就是一个没有value的的Map。所以，当我们底层实现了一个映射，集合我们就可以理解成Map&lt;K, V&gt;中value为null的情况，对于不管是k，它所对应的的value都为null。 所以当我们在Map中只考虑K的时候，整个Map数据结构就变成了K的集合。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合RabbitMQ以及四种交换模式]]></title>
    <url>%2F2019%2F05%2F09%2FSpringBoot%E6%95%B4%E5%90%88RabbitMQ%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是消息队列 在google的时候发现知乎一个很好的回答，很生动形象。 作者：ScienJus 原文链接 个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。使用场景的话，举个例子：假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：校验用户名等信息，如果没问题会在数据库中添加一个用户记录如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他发送给用户一个包含操作指南的系统通知等等……但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了。 我理解的消息队列就是当你的一个接口访问量大或者需要进行的操作很多，就比如注册这些功能(里面有发邮件，插入数据各种操作)，但是用户只需要知道是否注册成功，他们需要马上收到注册结果(提高用户体验性)，所以当用户的信息插入到数据库中我们就可以直接返回结果，至于后面的操作可以放入消息队列异步慢慢处理。 SpringBoot整合RabbitMQ maven配置 首先当然是maven配置了，springboot中为我们提供了amqp的start,amqp是一个消息队列的协议，RabbitMQ实现了这个协议。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; springboot配置文件的配置 1234567891011121314151617181920rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest virtual-host: / listener: simple: concurrency: 10 max-concurrency: 10 prefetch: 1 auto-startup: true default-requeue-rejected: true template: retry: enabled: true initial-interval: 1000ms max-attempts: 3 max-interval: 10000ms multiplier: 1.0 除了host，port什么的其他都可以不写，springboot已经默认帮我们配置好了。 RabbitMQ的配置类 1234567891011@Configurationpublic class RabbitConfig &#123; public static final String QUEUE = "queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; &#125; 消息发送者(提供者) 12345public void send(Object message)&#123; logger.info("send"); //标注需要发送的某个队列 amqpTemplate.convertAndSend(RabbitConfig.QUEUE,message);&#125; 消息接收者(消费者) 123456//@RabbitListener注解需要标注刚刚我们的队列名//其作用就是监听那个队列是否有消息，有消息则接收@RabbitListener(queues = RabbitConfig.QUEUE)public void receive(String message)&#123; logger.info("receive:"+message);&#125; RabbitMQ的四种模式 RabbitMQ分为四种模式 * Direct模式 * Topic模式 * Fanout模式 * Headers模式 Direct模式(直接交换模式) 刚刚我们的配置类，接受者和发送者实现的就是Direct模式，其流程就是发送者指定一个Queue来发送消息给那个队列，然后消费者一直监听那个队列，有消息则接收 Topic模式 首先是Topic的配置类，这里定义两个Queue，并且生成一个TopicExchange(Topic交换机)。 然后我们通过Binding来将A和B的消息队列绑定到我们刚刚生成的TopicExchange和指定routingKey中 123456789101112131415161718192021222324@Beanpublic Queue topicQueueA()&#123; return new Queue(TOPIC_QUEUE_A, true);&#125;@Beanpublic Queue topicQueueB()&#123; return new Queue(TOPIC_QUEUE_B, true);&#125; @Beanpublic TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE);&#125;@Beanpublic Binding topicBindingA()&#123; return BindingBuilder.bind(topicQueueA()).to(topicExchange()).with("topic.keyA");&#125;@Beanpublic Binding topicBindingB()&#123; return BindingBuilder.bind(topicQueueB()).to(topicExchange()).with("topic.#");&#125; 然后是我们的消息发送者 123456789public void topicSend(Object message)&#123; logger.info("topic send"); //我们指定某个routingkey发送到这个交换机上 //然后这个topic交换机会将我们的routingKey审核 //如果这个key和某个队列绑定的key匹配那么这个消息就会发送到这个队列里 //在队列绑定routingKey的时候可以使用#,*这些通配符,所以就会出现我发送一个消息，两个队列都收到了，我发送两个消息都是一个队列收到等情况，如图所示。 amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, "topic.keyA", message); amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, "topic.keyB", message);&#125; 最后是我们的消息消费者(接收者) 12345678910//接收很简单，只要指定队列就行@RabbitListener(queues = RabbitConfig.TOPIC_QUEUE_A)public void topicReceiveA(String message)&#123; logger.info("receive:" + message);&#125;@RabbitListener(queues = RabbitConfig.TOPIC_QUEUE_B)public void topicReceiveB(String message)&#123; logger.info("receive:" + message);&#125; Fanout模式 首先是Fanout的配置类,跟上面的topic查不到，我们先配置一个FanoutExchange类，然后通过Binding将队列绑定到那个Exchange中，我们可以绑定多个队列到Exchange中。 123456789101112131415161718192021222324@Beanpublic Queue fanoutQueueA()&#123; return new Queue(FANOUT_QUEUE_A, true);&#125;@Beanpublic Queue fanoutQueueB()&#123; return new Queue(FANOUT_QUEUE_B, true);&#125;@Beanpublic FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE);&#125;@Beanpublic Binding fanoutBindingA()&#123; return BindingBuilder.bind(fanoutQueueA()).to(fanoutExchange());&#125;@Beanpublic Binding fanoutBindingB()&#123; return BindingBuilder.bind(fanoutQueueB()).to(fanoutExchange());&#125; 然后就是我们的发送者 12345//我们只要将消息发送给交换机就好public void fanoutSend(Object message)&#123; logger.info("fanout send"); amqpTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, "", message);&#125; 最后是我们的消费者,这时候我们会发现这个Fanout模式就是类似于广播模式，我们将所有需要的队列都绑定上Fanout的Exchange中，然后我们发送者只需要将消息发送给Exchange，然后我们的消费者在所有的Queue中都能接收到消息。 123456789@RabbitListener(queues = RabbitConfig.FANOUT_QUEUE_A)public void fanoutReceiveA(String message)&#123; logger.info("fanoutA receive:"+message);&#125;@RabbitListener(queues = RabbitConfig.FANOUT_QUEUE_B)public void fanoutReceiveB(String message)&#123; logger.info("fanoutB receive:"+message);&#125; Headers模式 首先是我们的配置类，这个Header跟上面几种有些不一样 12345678910111213141516171819@Beanpublic Queue headersQueue()&#123; return new Queue(HEADERS_QUEUE);&#125;@Beanpublic HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE);&#125;//前面两个和上述三种都差不多，这里的Binding有些不一样@Beanpublic Binding headersBinding()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(5); map.put("HeadersAKey","HeadersAValue"); map.put("HeadersBKey","HeadersBValue"); //我们需要创建一个map存入键值对，然后绑定队列到交换机上，并且有个要求就是where什么什么加入map需要匹配，我们先看消息发送者 return BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match();&#125; 然后是我们的发送者 123456789101112public void headersSend(String message)&#123; logger.info("headers send"); //这里的发送者的发送方法需要的是一个交换机名称，还有一个就是Message对象 //这个Message对象存入了真正消息的字符数组和消息的配置类，这里的消息配置类就是MessageProperties //我们需要对这个MessageProperties设置头，这个头就是键值对，就是我们配置类设置的map //我们发送消息给队列，这个消息的头被设置为我配置类书写的那两个map才行，因为我设置了whereAll.match，所以我发送消息给交换机，这个交换机会帮我去匹配请求头和我设置的符合的Queue并把消息存入那个队列中 MessageProperties messageProperties = new MessageProperties(); messageProperties.setHeader("HeadersAKey","HeadersAValue"); messageProperties.setHeader("HeadersBKey","HeadersBValue"); Message headersMessage = new Message(message.getBytes(),messageProperties); amqpTemplate.convertAndSend(RabbitConfig.HEADERS_EXCHANGE, "", headersMessage);&#125; 最后是我们的接收者 12345//这个时候我们接收的就是字符数组了，因为我们再发送者的方法中是将消息变成byte[]再作为参数进行入队的@RabbitListener(queues = RabbitConfig.HEADERS_QUEUE)public void headersReceive(byte[] message)&#123; logger.info("headers receive:"+new String(message));&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分搜索树的遍历]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二分搜索树的遍历 其实这里就是二叉树的遍历，只是因为二分搜索树因为是依靠它的特定规则而排列的，所以再经过不同方法遍历之后，它的顺序会有很多特点。 我们是依靠根节点顺序来命名的，记住！是根结点。 前序遍历就是先遍历根结点，然后遍历左结点，最后遍历右结点。 中序遍历就是先遍历左结点，然后遍历根结点，最后遍历右结点。 后序遍历就是先遍历左结点，然后遍历右结点，最后遍历根结点。 最后要注意，这个提示可能不是适合所有人，对于我来说，我书写一个二叉树的前中后序遍历的时候都告诫自己要等待一个结点能遍历的时候才能遍历，什么意思呢？就是要遍历一个结点的时候需要把它的子节点先遍历了（子节点优先遍历），其实这个前中后序遍历另一个名字就是深度优先遍历，跟这个有关。 慕课网中有另一种快速书写三种遍历方式遍历后的顺序结果的方法，如图: 它是在每个结点上画上三个点，然后不管什么遍历方式都从根节点到左节点到右节点的方式遍历(比较图中)，每个结点其实都会经过三次，当中序遍历就去中间的点作为顺序参照，前序遍历就取左边的点作为顺序参照，后序遍历就取右边的点作为顺序参照。 如果中序和后序的图看不懂，那么就将前序遍历那些顺序线放入中序和后序的图中，然后根据那个顺序线依次找蓝色的点，最后这些点连接成的就是遍历顺序了。 深度优先遍历的递归代码实现 前面说了，前中后序遍历都可以称为深度优先遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142//前序遍历public void preOrder()&#123; preOrder(root);&#125;//前序遍历private void preOrder(Node node)&#123; if (node!=null)&#123; //先打印根节点 System.out.println(node.e); //然后遍历左节点 preOrder(node.left); //遍历右结点 preOrder(node.right); &#125;&#125; public void inOrder()&#123; inOrder(root);&#125;private void inOrder(Node node)&#123; if (node!=null)&#123; //优先遍历左节点 inOrder(node.left); System.out.println(node.e); inOrder(node.right); &#125;&#125;public void postOrder()&#123; postOrder(root);&#125;private void postOrder(Node node)&#123; if (node!=null)&#123; //先遍历左节点 postOrder(node.left); //然后遍历右结点 postOrder(node.right); //最后遍历根结点 System.out.println(node.e); &#125;&#125; 使用递归实现深度优先遍历很简单，只需要记住顺序就行了。 非递归实现前序遍历 其实非递归实现前序遍历就是模拟系统方法栈，这时候我们不通过递归，我们就要自己使用栈来实现前序遍历。 比如说我们需要将一个树前序遍历，这时候我们先将根结点放入我们new的一个栈中，然后我们把栈中这个结点元素取出来，对它进行打印(或者其他操作)，然后我们将它的右孩子，左孩子依次放入栈中(因为栈是先进后出)。然后我们再次取出栈中的一个元素，这时候我们取的是根结点的左孩子，然后我们对这个节点进行打印，然后把这个结点的右左孩子依次放入栈中，继续进行出栈操作。。。 代码实现： 12345678910111213141516171819 /** * 非递归实现前序遍历 */public void perOrderWithoutRecurrence()&#123; Stack&lt;Node&gt; stack=new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; //栈中元素不为空那么就出栈操作 Node currentNode=stack.pop(); System.out.println(currentNode.e); //依次将右左孩子放入栈中 if (currentNode.right!=null)&#123; stack.push(currentNode.right); &#125; if (currentNode.left!=null)&#123; stack.push(currentNode.left); &#125; &#125;&#125; 二叉树的层序遍历 层序遍历又是广度优先遍历，它是将树一层一层地进行遍历的。 比如上图，我们广度优先遍历（层序遍历）的顺序就是28,16,30,13,22,29,42. 我们如何实现呢？其实我们这时候需要一个队列，这个队列里将根结点放入，然后把根结点取出来进行操作（同时也要将队列里的根节点删除，后面的结点被取出来的时候也要删除），然后把根节点的左孩子，右孩子依次进行入队，这时候我们再取出队列里的第一个元素（根节点的左孩子结点），然后我们对它进行操作并删除队列里它的元素，然后将他的左右孩子依次入队，之后我们再取出来队列的第一个元素（根节点的右孩子），后面依次同上操作，如图所示。 代码实现： 12345678910111213141516171819 /** * 层序遍历(广度优先遍历) */public void levelOrder()&#123; if (root!=null)&#123; Queue&lt;Node&gt; queue=new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; Node currentNode=queue.remove(); System.out.println(currentNode.e); if (currentNode.left!=null)&#123; queue.add(currentNode.left); &#125; if (currentNode.right!=null)&#123; queue.add(currentNode.right); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分搜索树的增删改查]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[什么是二分搜索树 首先我们要先知道二叉树是什么，二叉树其实就是从一个根节点左右两端延伸出左右结点，延伸出的结点再次延伸出结点，然后一直延伸下去，所以树这种数据结构天生满足递归特性。 而二分搜索树就是对二叉树做了一个限制，首先二分搜索树中的元素必须是可比较的（对于Java来说就是必须继承Comparable接口）。为什么需要它可比较呢？就是因为，二分搜索树的排列需要根据数值来排列。 二分搜索树的某个结点的左孩子必须小于原来的节点且某个结点的左子树的所有结点必须比这个结点小。 右边同上。 二分搜索树的基本定义 根据上面的定义，我们很容易就能写出代码 12345678910111213141516171819public class BinarySearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node&#123; private E e; private Node left,right; private Node(E e)&#123; this.e=e; left=null; right=null; &#125; &#125; private Node root; private int size; public BinarySearchTree()&#123; root=null; size=0; &#125;&#125; 二分搜索树的一些方法 首先就是getSize()和isEmpty()方法，很容易，返回size和判断size是否为0就行了 1234567public int size()&#123; return size;&#125;public boolean isEmpty()&#123; return size==0;&#125; 添加元素 添加元素的时候我们只需要在树的叶子节点中添加就行了。 12345678910111213141516171819202122232425262728293031public void add(E e)&#123; //如果根节点为空，那么直接new if(root==null)&#123; root=new Node(e); &#125;else&#123; add(root,e); &#125;&#125;private void add(Node node,E e)&#123; //如果这个结点不等于这个时候才能添加元素 if (!e.equals(node.e))&#123; //如果插入元素小于该结点的元素且该结点的左孩子为空 //那么直接插入左孩子 if (e.compareTo(node.e)&lt;0&amp;&amp;node.left==null)&#123; node.left=new Node(e); size++; &#125; //这个同上 else if (e.compareTo(node.e)&gt;0&amp;&amp;node.right==null)&#123; node.right=new Node(e); size++; &#125; //如果小于，那么就递归调用 else if (e.compareTo(node.e)&lt;0)&#123; add(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; //同上 add(node.right,e); &#125; &#125;&#125; 当然添加方法还有优化的地方 1234567891011121314151617public void add(E e)&#123; add(root,e);&#125;private Node add(Node node,E e)&#123; if (node==null)&#123; //该结点为空，那么直接返回给上一级new出来的元素为e的节点，这里就是添加，只是现在遍历到最后了而已 return new Node(e); &#125;else if (e.compareTo(node.e)&lt;0)&#123; //如果小于，那么该结点的左孩子就是下一层二分搜索树的添加元素后的二分搜索树 node.left=add(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; //如果大于，那么该结点的右孩子就是下一层二分搜索树的添加元素后的二分搜索树 node.right=add(node.right,e); &#125; //最后return被添加过结点的根节点 return node;&#125; 查询元素 这里就是判断二分搜索树是否包含某个元素 1234567891011121314151617181920public boolean contains(E e)&#123; return contains(root,e);&#125;private boolean contains(Node node,E e)&#123; //如果该树的根节点就是空，那么直接false if (root==null)&#123; return false; &#125; //如果查询到了那么返回该结点 if (e.equals(node.e))&#123; return true; &#125;else if (e.compareTo(node.e)&lt;0)&#123; //小于的时候遍历左孩子树 return contains(node.left,e); &#125;else if (e.compareTo(node.e)&gt;0)&#123; //大于的时候遍历右孩子树 return contains(node.right,e); &#125; return false;&#125; 获取最小元素和最大元素 123456789101112131415161718192021222324252627public E minimum()&#123; //当树的大小为0就不能删除 if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return minimum(root).e;&#125;private Node minimum(Node node) &#123; //当遍历到最后的某个结点的左孩子为null，那么这个结点就是最小元素 if (node.left==null)&#123; return node; &#125; return minimum(node.left);&#125;//同理public E maximum()&#123;if (size==0)&#123; throw new IllegalArgumentException("BST is empty");&#125;return maximum(root).e;&#125;private Node maximum(Node node)&#123;if (node.right==null)&#123; return node;&#125;return maximum(node.right);&#125; 删除元素，其中删除元素是最复杂的，对于删除最小最大元素来说并不复杂，因为只需要往左往右遍历二分搜索树就行了，但是对于任意元素的删除就要考虑多种情况。 删除最小元素 123456789101112131415161718192021public E removeMin()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMin(root).e;&#125;private Node removeMin(Node node)&#123; //如果左孩子为空，那么这个结点就是要删除的结点 if (node.left==null)&#123; //将该结点的右子树放入临时变量 Node rightNode=node.right; //将这个结点的右子树置为null，然后返回刚刚的临时变量rightNode node.right=null; size--; return rightNode; &#125; //不然就一直向左遍历，并且将下一级删除后返回的二分搜索树赋值给上一级的结点 node.left=removeMin(node.left); return node;&#125; 删除最大元素 1234567891011121314151617public E removeMax()&#123; if (size==0)&#123; throw new IllegalArgumentException("BST is empty"); &#125; return removeMax(root).e;&#125;private Node removeMax(Node node)&#123; if (node.right==null)&#123; Node leftNode=node.left; node.left=null; size--; return leftNode; &#125; node.right=removeMax(node.right); return node;&#125; 删除某个结点 我们可以通过寻找需要被删除节点的后继或者前驱，并且把它从原来树中删除然后代替被删除节点的位置 这里我只写了通过后继删除某个元素，当然前驱书写方式也是一样的 12345678910111213141516171819202122232425262728293031323334353637383940public void remove(E e)&#123; root=remove(root,e);&#125;private Node remove(Node node,E e)&#123; if (node==null)&#123; return null; &#125; if (e.compareTo(node.e)&lt;0)&#123; node.left=remove(node.left,e); return node; &#125; else if (e.compareTo(node.e)&gt;0) &#123; node.right=remove(node.right,e); return node; &#125; //如果相等就要删除 else &#123; //首先判断这个树是不是只有一边的孩子 //如果只有左边有孩子或者只有右边有孩子 if (node.right==null)&#123; //如果只有左子树 //那么我们将该结点的左子树返回给上一节点的左子树 size--; return node.left; &#125;else if (node.left==null)&#123; size--; return node.right; &#125; //如果左右都有孩子 //寻找该节点的后继节点 //后继结点就是离该结点最近的节点（数值最近而且是大于该节点） //那么这个结点的后继结点就是该节点右孩子的最小结点 Node successorNode=minimum(node.right); //我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子 successorNode.right=removeMin(node.right); successorNode.left=node.left; node.left=node.right=null; return successorNode; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git中.gitignore文件修改后不起作用]]></title>
    <url>%2F2019%2F05%2F05%2FGit%E4%B8%AD-gitignore%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[问题背景 当我使用git上传项目的时候，有些本应该忽略的文件没有被忽略，这时候我修改.gitignore文件再次上传的时候，本该忽略的文件还是在那里 问题原因 这是因为git缓存的原因，如果某些文件已经被纳入版本管理中，就算是在.gitignore文件中声明了忽略文件的路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再add和push。 问题解决 首先清除本地缓存git rm -r –cached . 再次add文件git add . 提交git commit -m “chore:update .gitignore” pushgit push .gitignore书写格式123456# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从源文件到可执行文件]]></title>
    <url>%2F2019%2F05%2F05%2F%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[关于本文 这篇文章是我阅读《程序是怎样跑起来的》这本书第八章后写的读后感，也说不上读后感，就是把原文一些东西整理一下，方便日后阅读记忆。学校图书馆真是一个好地方，原本以为没有什么好的图书，后面去借阅几次发现了很多好书，这本书也是我在图书馆中借阅的。 计算机只能运行本地代码 什么是源文件和源代码，就是使用某种编程语言编写的程序就称为源代码，保存源代码的文件就是源文件。比如说以.c或者.java为扩展名的文件就是源文件。 但是源文件是无法直接运行的，这是因为CPU能直接解析并运行的不是源代码而是本地代码的程序。 本地(native)，对于CPU来说就是母语的意思，任何编程语言编写的源代码最后都要翻译成本地代码，否则CPU就看不懂。 本地代码的内容 比如说Windows中的EXE文件里面就是本地代码。 我们使用文本工具打开exe文件可以看到类似下图的代码 这时候我们将它转变成十六进制 计算机指令也是数值的罗列，这些就是本地代码。 编译器负责转换源代码 能够把C语言等高级语言转换为本地代码的程序成为编译器，相当于现实中的翻译，每个编程语言都需要专用的编译器，C语言的就叫C编译器，这类似于现实中中文翻译成英文需要专业的英文翻译者。 编译器读入代码内容，然后通过一些对照表把源代码对照翻译成本地代码，当然不仅仅是这么简单，其中还有语法解析，句法解析，语义解析等等，最后才能生成本地代码。 根据CPU的不同，本地代码的类型也不同，所以编译器不仅和编程语言相关还和CPU相关，列入x86系列的CPU用的C编译器就和PowerPC这种CPU的C编译器不同。 还有就是编译器也是一种程序，所以也需要运行环境，那么windows用的C编译器和Linux用的C编译器就不同。还有就是交叉编译器，他生产的是和运行环境中的CPU不同的CPU所使用的的本地代码。 仅靠编译时无法得到可执行文件的 C和C++中编译之后生成的是.obj目标文件，这时候还需要链接才能得到可执行的exe文件。 比如说我们书写了一个函数 其中我们调用了MessageBox函数，sprintf函数。但是在我们的源代码中没有这两个函数的相关实现，比如这个文件生成的是sample.obj，那么这个文件就需要和MessageBox，sprintf的目标文件相结合(链接)，才能生成完整的程序。试想一下这个sample是exe文件，那么这个文件就是不完整的，是无法执行的。 运行连接的程序就称为链接器。 启动及库文件 当我们执行上述sample.c文件的编译 链接操作的时候，我们需要指定两个文件。一个是sample.obj生成的目标文件，另一个是C0w32.obj文件，这个文件是记录着同所有程序气死位置相结合的处理内容，程序程序的启动。 后面我们还需要指定库文件，比如说32.lib cw32.lib库文件，这里面存放着sprintf函数的目标文件和MessageBox函数的目标文件(实际上是在 user32.dll文件中，这是动态链接库) 链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件 如果不指定库文件就会发生无法识别sprintf函数和MessageBox函数的错误 DLL文件及导入库 Windows以函数的形式为应用提供了各种功能，这些函数被称为API(Application Programming Interface应用程序接口) 上面讲到的MessageBox()函数并不是C语言的标准库函数，而是Windows提供的API，这些API的目标文件存储在名为DLL(Dynamic Link Library)文件的特殊库文件中，它是程序运行动态结合的文件，上面我们提到MessageBox的目标文件存储在import32.lib文件中，其实这个文件只存储了两个信息——MessageBox()存储在user32.dll文件中，还有就是这个dll文件的文件夹信息。 我们把类似于import32.lib这样的库文件称为导入库。 DLL文件的好处：DLL文件中的函数可以被多个程序共用，因此借助该功能可以节约内存和磁盘。此外，在对函数的内容做修正的时候不需要重新连接(静态链接)。 另一个就是静态链接库，就是sprintf，存储着sprintf()的cw32.lib就是静态链接库。 可执行文件运行时的必要条件 存储在硬盘中的exe文件运行时要读入内存中执行，在exe文件中我们会给变量和函数分配虚拟的内存地址，在程序运行的时候，这些虚拟内存地址会转换为实际内存地址，链接器会在exe文件的开头，追加转换内存地址所需的必要信息，这个信息称为再配置信息。 可以这么理解，再配置信息里存放了变量和函数的相对地址，这个相对地址就是相对于基地址的偏移量，这样各个变量的内存地址就可以用变量组的基地址加上偏移量作为地址，而这些基地址是在程序运行时被计算机分配的。 程序加载时会生成堆和栈 当程序加载到内存中，出再配置信息，变量组，函数组等还会额外生成两个组，那就是堆和栈。栈是用来存储函数内部使用的临时变量以及函数调用时所用的参数的内存区域。堆是用来存储程序运行时的任意数据和对象的内存领域。 内存泄漏 对于栈来说，它会在函数调用的时候自动分配内存，在函数执行完毕后自动释放内存。但是对于堆来说，C语言需要程序员使用malloc申请分配，free()函数来释放，C++中需要使用new来申请分配，delete来释放，Java和C#这些语言户进行自动垃圾回收，如果我们忘记释放内存，那么这个内存空间就会一直被使用，久而久之就会造成内存泄露(memory leak)从而导致内存不足而卡死，就比如一晚上忘关水龙头，水盆中的水装满并溢出一样。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis插入字段并返回主键的小问题]]></title>
    <url>%2F2019%2F05%2F04%2FMybatis%E6%8F%92%E5%85%A5%E5%AD%97%E6%AE%B5%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用背景 这几天在写秒杀项目，其中有一个需求是生成订单并返回订单号（主键）然后再生成秒杀订单将刚刚返回的订单号作为某个字段插入秒杀订单中，也就是秒杀订单表中的order_id。这其中就使用到了插入信息并返回主键。 我使用的是Mybatis逆向工程生成的Mapper文件，其中自动生成的insert方法返回的是影响的行数，我在使用的时候一直返回给我的是1，导致报错。 相关Mapper的编写 其中最关键的就是在insert标签上增加useGeneratedKeys和keyProperty 12345678910 &lt;insert id="insertOrderAndReturnOrderId" useGeneratedKeys="true" keyProperty="id" parameterType="com.lgq.miaosha.domain.OrderInfo"&gt; insert into t_order_info (id, user_id, goods_id, delivey_addr_id, goods_name, goods_count, goods_price, order_channel, status, create_date, pay_date) values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=BIGINT&#125;, #&#123;goodsId,jdbcType=BIGINT&#125;, #&#123;deliveyAddrId,jdbcType=BIGINT&#125;, #&#123;goodsName,jdbcType=VARCHAR&#125;, #&#123;goodsCount,jdbcType=INTEGER&#125;, #&#123;goodsPrice,jdbcType=DECIMAL&#125;, #&#123;orderChannel,jdbcType=TINYINT&#125;, #&#123;status,jdbcType=TINYINT&#125;, #&#123;createDate,jdbcType=TIMESTAMP&#125;, #&#123;payDate,jdbcType=TIMESTAMP&#125;)&lt;/insert&gt; 其中keyProperty=”id”，这个id就是传入对象中的某个属性值，比如说这里就是OrderInfo对象，执行成功之后就会自动将主键的值赋给对象中的id属性。然后原本作为参数的OrderInfo对象中的id就得到了更新，这时候我们再取这个对象的id字段就可以获取到主键的值了。 使用代码12345678910111213141516171819202122232425262728293031323334353637 /** * 生成订单 * @param user 用户 * @param goodsVo 商品 * @return 订单详情 */ @Transactional public OrderInfo createOrder(User user, GoodsVo goodsVo) &#123; //这里主要就是生成OrderInfo对象 OrderInfo orderInfo=new OrderInfo(); orderInfo.setCreateDate(new Date()); orderInfo.setDeliveyAddrId(0L); orderInfo.setGoodsCount(1); orderInfo.setGoodsId(goodsVo.getId()); orderInfo.setGoodsName(goodsVo.getGoodsName()); orderInfo.setGoodsPrice(goodsVo.getMiaoshaPrice()); byte b=1; orderInfo.setOrderChannel(b); b=0; orderInfo.setStatus(b); orderInfo.setUserId(user.getId()); //插入订单 orderInfoMapper.insertOrderAndReturnOrderId(orderInfo); //最关键的一步 //获取到刚刚对象中的id字段就是主键的值了 Long orderId=orderInfo.getId(); MiaoshaOrder miaoshaOrder=new MiaoshaOrder(); miaoshaOrder.setGoodsId(goodsVo.getId()); //这里不是很严谨，意思是将MiaoShaOrder的id设置成和OrderInfo的id一样 miaoshaOrder.setId(orderId); miaoshaOrder.setUserId(user.getId()); //将miaosha_order表中的order_id字段设置为order_id表中的主键 miaoshaOrder.setOrderId(orderId); miaoshaOrderMapper.insert(miaoshaOrder); return orderInfo; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Redis]]></title>
    <url>%2F2019%2F05%2F03%2FSpringBoot%E6%95%B4%E5%90%88Redis%2F</url>
    <content type="text"><![CDATA[项目介绍 最近在写一个秒杀的项目，是跟着慕课网的一个教程学习的。其中用到了redis进行session共享等等功能，现如今做到的步骤是使用redis将用户信息存入redis中，并且同时将用户的唯一token值存入cookie中（cookie的有效期和redis键值的有效期一样），当我们用户跳转到某个页面的时候，先查询cookie中是否存在键值为user的cookie，如果存在就获取到cookieValue（token值），然后通过这个token作为键去查询redis中查找对应token的用户信息。 五一玩了几天，这几天没怎么进食新东西，今天趁着假期学校不熄灯，继续写一篇博客。 引入依赖和配置变量 首先是pom.xml的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;1.4.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 然后我们需要在application.yaml文件中写入redis的配置环境 123redis:host: 119.82.123.134port: 6379 配置类的编写 编写RedisConfig配置类 123456789101112131415161718192021222324 @Configurationpublic class RedisConfig &#123; //这里是引入刚刚yaml文件的配置变量 private @Value("$&#123;redis.host&#125;") String host; private @Value("$&#123;redis.port&#125;") int port; //引入JedisConnection工厂，主要负责的是redis的连接 //其中要设置地址和端口号 @Bean public JedisConnectionFactory redisConnectionFactory() &#123; RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setHostName(host); redisStandaloneConfiguration.setPort(port); return new JedisConnectionFactory(redisStandaloneConfiguration); &#125; //配置redis模板，这个主要是进行一些redis的操作，就像jdbc的模板类一样 @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate=new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); return redisTemplate; &#125;&#125; 相关操作的编写 关于redis的操作有很多，我也学的不是很好，这里面只写了最简单的set和get 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 /** * @author Lin * @date 2019-04-18 23:23 **/@Componentpublic class RedisUtil &#123; //引入刚刚我们设置的redis模板 @Resource RedisTemplate&lt;String,Object&gt; redisTemplate; //这是redis单独印出来的string的模板——因为对于redis的操作大部分都是以String类型为基础的，这里没有用到 @Autowired StringRedisTemplate stringRedisTemplate; /** * 往redis中缓存数据,这里使用T模板更加灵活 * @param key */ public &lt;T&gt; void set(String key,T value)&#123; //将value对象转换为json字符串 String jsonString=beanToString(value); //valueOperations用来set和get 它是由redisTemplate产生的 ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue(); //这里是将value对象转换为jsonString，因为项目中User是一个java对象 valueOperations.set(key,jsonString); &#125; /** * 往redis中缓存数据并加上过期时间 * @param key * @param time 过期时间，秒 */ public &lt;T&gt; void set(String key,T value,long time)&#123; //这个方法跟上面差不多，多加了一个设置过期时间，为的是与项目需求设置redis过期时间和cookie相等 String jsonString=beanToString(value); ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue(); valueOperations.set(key, jsonString, time,TimeUnit.SECONDS); &#125; /** * 从redis1中获取数据 * @param key * @return */ public &lt;T&gt; T get(String key,Class&lt;T&gt; clazz)&#123; ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue(); //这里其实获取的是存在redis中对象的json字符串 Object object=valueOperations.get(key); //如果获取的不为空，那么就像这个json字符串转换为java对象 if (object!=null)&#123; return stringToBean(object.toString(),clazz); &#125; //获取为空就return null return null; &#125; /** * 将对象转换为json * @param value 对象 * @param &lt;T&gt; 泛型 * @return json数据 */ private &lt;T&gt; String beanToString(T value)&#123; if (value==null)&#123; return null; &#125; Class&lt;?&gt; clazz=value.getClass(); //如果value是int类型或者Integer类型的直接返回 if (clazz==int.class||clazz==Integer.class)&#123; return ""+value; &#125;else if(clazz==String.class)&#123; return (String)value; &#125;else if (clazz==long.class||clazz==Long.class)&#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; /** * 将jsonString转换为java的对象 * @param jsonString json字符串 * @param clazz 类 * @param &lt;T&gt; 泛型 * @return java对象 */ @SuppressWarnings("unchecked") private &lt;T&gt; T stringToBean(String jsonString,Class&lt;T&gt; clazz)&#123; if (jsonString==null||jsonString.length()&lt;=0||clazz==null)&#123; return null; &#125; if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(jsonString); &#125;else if(clazz == String.class) &#123; return (T)jsonString; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(jsonString); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(jsonString), clazz); &#125; &#125; &#125; 上述代码使用了阿里巴巴的fastJson作为json和java对象转换的工具，具体的pom依赖为: 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 总结 对于这个SpringBoot整合Redis虽然是跟着视频写的，但是也踩了很多坑，因为版本更新非常快，我使用的SpringBoot和Redis都是最新版的，很多地方配置和代码书写都和视频中和网上绝大数整合教程不相同，我也是查看很多资料才写好这个整合的，对于英文文档不感冒是真的吃亏，所以英语能力一定要提高！！！ 还有就是在整合redis的时候，如果连接的是远程服务器中的redis的话一定要更改服务器上的redis.conf文件，最重要的两点就是将bind后面的地址修改或者直接注释掉bind那一行配置，还有就是将protected-mode更改为no，不然远程电脑连接不上。 当然还有很多细节问题都需要注意，留下这篇文章作为踩坑记录，希望下面敲代码的日子会越来越顺利。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链表和递归]]></title>
    <url>%2F2019%2F04%2F28%2F%E9%93%BE%E8%A1%A8%E5%92%8C%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[从一道leetcode题目开始 题目描述： 看一下题目内容其实很简单就是删除一个链表中值为val的所有节点并且返回被删除完的链表。 上篇文章讲了如何进行链表操作，这时候我们其实就可以通过老方法遍历整个链表，然后通过比较每个节点的值和val的值是否相等，相等则删除，不相等则保留。 示例代码： 12345678910111213141516171819202122232425 class Solution &#123; //这里的ListNode是leetcode给定的，里面包含next和val字段 public ListNode removeElements(ListNode head, int val) &#123; //创建一个虚拟头结点 ListNode virtualNode=new ListNode(0); //虚拟头结点的next节点是头结点 virtualNode.next=head; //将虚拟头结点赋值给currentNode当前节点 ListNode currentNode=virtualNode; while (currentNode.next!=null)&#123; //通过遍历当前节点来删除元素 if (currentNode.next.val==val)&#123; //如果当前头结点的next元素的val值等于给定的val //则将当前节点的next元素直接指向next的next //那么原来next节点就直接被删除了 currentNode.next=currentNode.next.next; &#125;else &#123; //如果不相等则跳到下一个节点，循环知道currentNode的next节点为null currentNode=currentNode.next; &#125; &#125; //返回虚拟头结点的next，这里就是被删除元素的原来的头结点 return virtualNode.next; &#125;&#125; 递归 在考虑递归如何写的时候我们先需要了解递归的宏观语意。 一个递归函数其实本质就是函数调用，只不过它是自己调用自己。 递归函数就是将原来的问题转化为更小的问题，知道最后求出最基本的解。 最基本的解一般是我们通过if条件判断来终结的，如果不添加if判断给递归函数一个终结（最基本的解，例如求阶乘的时候等于1等于0的时候就是最基本的解），那么计算机就会无限产生递归调用，这会导致cpu的方法栈（写栈的时候提过，函数调用就是通过栈来实现的）爆满从而报错。 如何写一个递归函数，我们不要去考虑它的实现细节，最好是通过宏观语意来完成它。 首先我们最能确定的就是它的最基本解，然后我们需要在原本函数里面再次调用该函数并修改参数（目的是将原问题转换为更小的问题）。上图的代码只是最简单的示例，当递归函数稍微再复杂点的时候，我们就需要获取到递归调用函数产生的值并对这个return的值来做些修改最后再返回给上一级调用这个级别的递归函数的函数。 使用递归来实现链表的删除(上述题目) 首先完成一个递归函数我们需要先确定我们怎么把这个递归函数变为更小的函数。 这里，我们将这个删除长度n的链表中元素的问题转换成先判断从第二个节点开始到最后节点中删除符合条件的节点，然后再转换为从第三个节点到最后节点删除符合条件的节点，直到我们的问题变成了删除最后一个空节点中符合条件的元素，当然这个时候空节点里面是不可能有的，所以我们这时候直接返回head，这样最基本解就出来了。 123if(head==null)&#123; return head;&#125; 之后就是转换为更小的问题了。 12345678910111213//将问题转换为小问题ListNode result=removeElements(head.next,val);//每次return都是return给上一级递归的结果//如果当前节点的val值和给定val相等//则直接return给上一级不包含该节点的链表if(head.val==val)&#123; return result;&#125;else&#123; //如果不相等说明不需要删除 //则需要将返回的结果前面加上头结点head在返回head head.next=result; return head;&#125; 完整代码： 12345678910111213 public ListNode removeElements(ListNode head,int val)&#123; //首先考虑最基本的问题 if (head==null)&#123; return null; &#125; ListNode resultNode=removeElements(head.next,val); if (head.val==val)&#123; return resultNode; &#125;else &#123; head.next=resultNode; return head; &#125;&#125; 其实整个问题可以这么理解，我需要删除一个链表中符合元素的节点，那么我把这个问题转化为小问题，将整个链表转换为从2开始到结尾的链表，然后S到从3开始到结尾的链表，最后到从结尾到结尾的节点（null），那么我就是从最后一个节点找需要删除的节点，假设如果最后一个节点是要删除的节点，那么这时候我们只需要将这个节点删除并且返回给上一级调用递归函数。这时候我们返回的null然后上一级接收到的result就是null，然后这个函数继续执行到if(head.val==val)，这时候就判断（第二级递归就是最后两个节点的链表）当前链表中的头结点的val是否满足，满足就跟刚刚一样“删除”该节点，不满足就将这个head的next设置为result，也就是将result的头结点暂时设置为当前head（将当前head设置为头结点并返回给上一级调用的函数），这样无限的返回，最后返回的就是原本链表中需要删除元素后的链表了。 这个时候我们可以将递归写的更简单 1234567public ListNode removeElements(ListNode head,int val)&#123; if(head==null)&#123; return head; &#125; head.next=removeElements(head.next,val); return head.val==val?head.next:head;&#125; 简单实用递归实现链表的创建 首先我们考虑如何通过递归实现该功能，创建一个链表，我们将问题缩小就是从创建节点开始。例如我们现在给定一个数组，然后我们通过这个数组来创建链表。首先这个数组的索引肯定是我们递归实现的条件，比如一个10个元素的数组，我们需要创建十个元素的链表，我们可以将问题变为创建从索引1开始到结束的链表，然后从索引2到结束，最后到从末尾到末尾（创建最后一个元素），所以这时候我们最基本条件就出来了。 123if((index+1)==array.length)&#123; return null;&#125; 这个时候我们就要来实现将问题转换为小问题 其实很简单。 1234ListNode result=createElement(array,index+1);ListNode currentNode=new ListNode(array[index]);currentNode.next=result;return currentNode; 完整代码： 12345678910public static ListNode createListNode(int[] array,int index)&#123; if ((index+1)==array.length)&#123; return new ListNode(array[index]); &#125;else &#123; ListNode result=createListNode(array,index+1); ListNode currentNode=new ListNode(array[index]); currentNode.next=result; return currentNode; &#125;&#125; 杂谈这个星期开始复习的信号系统，对于我这个学物联网的同学，不会什么高数，硬件是真的很烦躁，信号考完了，能不能过就靠老师助攻了。今天写篇博客来缓解一下一个星期没写代码的愧疚，这个递归还真的有点难理解，还需要勤敲勤练。加油吧！！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java实现自定义验证注解]]></title>
    <url>%2F2019%2F04%2F20%2FJava%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注释)。 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。 通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 Annotation 可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在 Annotation 的“name=value” 对中。 例如 Annotation 能被用来为程序元素(类, 方法, 成员变量等) 设置元数据。 基本的Annotation 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。 用于修饰它支持的程序元素。 三个基本的 Annotation: @Override: 限定重写父类方法, 该注释只能用于方法 @Deprecated: 用于表示某个程序元素(类, 方法等)已过时 @SuppressWarnings: 抑制编译器警告。 自定义Annotation 定义新的 Annotation 类型使用 @interface 关键字 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。 其方法名和返回值定义了该成员的名字和类型。 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation 下面是java验证的NotNull注解的源码： 其中所有的成员变量都是以无参方法定义的，default定义了某个成员变量的默认值，这是一个包含成员变量的 Annotation 所以我们也可以称为 元数据 Annotation。 下面是Override注解的源码： 这个注解没有成员变量，所以我们可以称为标记。而且可以注意的是这个注解的注解(元注解) @Retention是SOURCE类型的，编译器会直接丢弃这种策略的注释。也就是我们编译成class文件的时候是看不见@Override注解的，这个我们后面会讲。 提取 Annotation 信息 JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注释的程序元素。 当一个 Annotation 类型被定义为运行时 Annotation 后, 该注释才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取。 程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信息 JDK 的元 Annotation JDK 的元 Annotation 用于修饰其他 Annotation 定义(注解的注解) @Retention注解 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值 RetentionPolicy.CLASS: 编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注释. 这是默认值 RetentionPolicy.RUNTIME:编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释 RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释 @Target注解 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。可以参考本文第一张图片。 @Documented注解 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档 @Inherited注解 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注释 实现自定义验证注解@IsMobile 参考于实现自定义验证注解 @IsMobile是一个验证是否为11位手机号码的验证注解。 API开发中经常会遇到一些对请求数据进行验证的情况，这时候如果使用注解就有两个好处，一是验证逻辑和业务逻辑分离，代码清晰，二是验证逻辑可以轻松复用，只需要在要验证的地方加上注解就可以。 Java提供了一些基本的验证注解，比如@NotNull、@Size，但是更多情况下需要自定义验证逻辑，这时候就可以自己实现一个验证注解，方法很简单，仅需要两个东西： 一个自定义的注解，并且指定验证器 一个验证器的实现 这个时候我们就可以结合刚刚所学的知识就可以根据前面两部来实现验证注解了。 12345678910111213//这个表示该注解能对于类型注解@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)//这个表示在运行时起作用@Retention(RetentionPolicy.RUNTIME)//@Constraint是最关键的，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器@Constraint(validatedBy = IsMobileValidator.class)public @interface IsMobile &#123; boolean required() default true; String message() default "手机号码格式错误"; //groups()和payload()也为@Constraint要求，可默认为空 Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;&#125; @Target @Target指明这个注解要作用在什么地方，可以是对象、域、构造器等，因为要作用在域上，因此这里可以选择FIELD（这里我是直接所有的可以）。参考了NotNull注解 @Retention 指明生命周期，这里选择RUNTIME @Constraint 实现验证器最重要的注解，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器。 message() 验证失败之后返回的消息。此方法为@Constraint要求 groups()和payload() groups()和payload()也为@Constraint要求，可默认为空，详细用途可以查看@Constraint文档 下面是验证器类： 1234567891011121314151617181920212223242526272829303132/** * @author Lin * @date 2019-04-20 10:55 **/public class IsMobileValidator implements ConstraintValidator&lt;IsMobile,String&gt; &#123; //这里实现ConstraintValidator接口需要重写initialize和isValid方法 /** * required指这个数据是否必须 */ private boolean required = false; @Override public void initialize(IsMobile constraintAnnotation) &#123; required=constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //如果是必须的，那么就验证是否为手机号 if (required)&#123; return ValidatorUtil.isMobile(value); &#125;else &#123; //如果非必须，那么空值和手机号都可以通过验证 if (StringUtils.isEmpty(value))&#123; return true; &#125;else &#123; return ValidatorUtil.isMobile(value); &#125; &#125; &#125;&#125; 其细节说明在注释中。 这样我们就实现了一个自定义验证注解，我们只需要在要验证的元素的前面加上@IsMobile就行了。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手写链表]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是链表 链表是一种重要的数据结构，是一种数据的存储方式。链表由多个链表元素组成，每个元素称为节点。链表存储的物理结构可能是连续的，但也可能是无序的。但是链表之间的元素（节点）是有序的逻辑相连。 链表是一种很灵活的数据结构，它不需要指定内存的大小，删除节点不需要要像数组那样讲数据整体向前移动，只需要更改节点的指向。但是链表的结构也决定了它的许多缺点，比如说访问需要遍历元素，不能像数组那样依靠索引，还有就是链表每个元素存的是一个对象，这是一笔非常大的内存开销。 链表从方向可以分为单向链表，双向链表。 从结构上可以分为单链表，环形链表。 Java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207/** * @author Lin * @date 2019-04-17 18:55 **/public class LinkedList&lt;E&gt; &#123; /** * 节点 */ private class Node&#123; /** * 节点里面的元素内容 */ private E e; /** * 指向下一个节点 */ private Node next; public Node(E e,Node next)&#123; this.e=e; this.next=next; &#125; public Node(E e)&#123; this.e=e; this.next=null; &#125; public Node()&#123; this.e=null; this.next=null; &#125; &#125; /** * 虚拟链表头，让add更加有逻辑 */ private Node dummyHead; /** * 链表大小 */ private int size; public LinkedList()&#123; dummyHead=new Node(); size=0; &#125; public int getSize()&#123; return this.size; &#125; public boolean isEmpty()&#123; return this.size==0; &#125; /** * 链表添加头元素 * @param e 元素 */ public void addFirst(E e)&#123; add(0,e); &#125; /** * 指定位置添加元素 * @param index 索引 * @param e 元素 */ public void add(int index,E e)&#123; if (index&lt;0||index&gt;size)&#123; //当index非法排除异常 throw new IllegalArgumentException("the index is not valid"); &#125;else &#123; //获取要插入的元素的前面的元素 Node pre=dummyHead; for (int i = 0 ; i &lt; index ; i ++)&#123; //遍历 pre = pre.next; &#125; //首先调用的是new Node(e,pre.next) //为的是让新节点的next节点指向它要添加位置的前面一个元素的原来的next节点 //再进行赋值操作为了将添加节点前面的节点的next改为该元素 pre.next = new Node(e,pre.next); size ++; &#125; &#125; /** * 在链表末尾加入元素 * @param e 元素 */ public void addLast(E e)&#123; add(size,e); &#125; /** * 获取某个索引的元素 * @param index 索引 * @return 元素 */ public E get(int index)&#123; if (index&lt;0||index&gt;size)&#123; throw new IllegalArgumentException("the index is not valid"); &#125;else&#123; Node currentNode=dummyHead.next; for (int i=0;i&lt;index;i++)&#123; currentNode=currentNode.next; &#125; return currentNode.e; &#125; &#125; public E getFirst()&#123; return get(0); &#125; public E getLast()&#123; return get(size-1); &#125; /** * 修改元素 * @param index 索引 * @param e 更新后的元素 */ public void set(int index,E e)&#123; if (index&lt;0||index&gt;=size)&#123; throw new IllegalArgumentException("the index is not valid"); &#125;else &#123; Node currentNode=dummyHead.next; for (int i=0;i&lt;index;i++)&#123; currentNode=currentNode.next; &#125; currentNode.e=e; &#125; &#125; /** * 是否包含某个元素 * @param e 元素 * @return 布尔 */ public boolean contains(E e)&#123; Node currentNode=dummyHead.next; for (int i=0;i&lt;size-1;i++)&#123; if (currentNode.next!=null)&#123; if ((currentNode.e).equals(e))&#123; return true; &#125; &#125; &#125; return false; &#125; /** * 移除某个索引元素 * @param index * @return */ public E remove(int index)&#123; if (index&lt;0||index&gt;=size)&#123; throw new IllegalArgumentException("the index is not valid"); &#125;else &#123; Node currentNode=dummyHead; for (int i=0;i&lt;index;i++)&#123; currentNode=currentNode.next; &#125; //暂存被删除的节点 Node tempNode=currentNode.next; //将遍历到的节点（被删除节点前面一个）的next指向被删除节点的next节点 currentNode.next=tempNode.next; //将被删除的节点的next指向为null tempNode.next=null; size--; return tempNode.e; &#125; &#125; public E removeLast()&#123; return remove(size-1); &#125; public E removeFirst()&#123; return remove(0); &#125; public void remove(E e)&#123; Node currentNode=dummyHead.next; //遍历到节点的next为空 while (currentNode!=null)&#123; //判断是否与需要判断的元素相等，如果相等则删除 if (currentNode.e.equals(e))&#123; Node tempNode=currentNode.next; currentNode.next=tempNode.next; tempNode.next=null; size--; return; &#125; if (currentNode.next!=null)&#123; currentNode=currentNode.next; &#125; &#125; &#125;&#125; 使用链表实现栈123456789101112131415161718192021222324252627282930313233343536/** * @author Lin * @date 2019-04-17 20:28 **/public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private LinkedList&lt;E&gt; linkedList; public LinkedListStack()&#123; this.linkedList=new LinkedList&lt;&gt;(); &#125; @Override public int getSize() &#123; return linkedList.getSize(); &#125; @Override public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; @Override public void push(E o) &#123; linkedList.addFirst(o); &#125; @Override public E pop() &#123; return linkedList.removeFirst(); &#125; @Override public E peek() &#123; return linkedList.getFirst(); &#125;&#125; 链表和数组实现栈的比较 从复杂度来考虑，数组和链表实现的出栈入栈等操作的复杂度都相同，我们这里来测试一下。测试代码如下： 12345678910111213141516171819202122232425262728293031// 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒private static double testStack(Stack&lt;Integer&gt; stack, int opCount)&#123; long startTime = System.nanoTime(); Random random = new Random(); for(int i = 0 ; i &lt; opCount ; i ++) &#123; stack.push(random.nextInt(Integer.MAX_VALUE)); &#125; for(int i = 0 ; i &lt; opCount ; i ++) &#123; stack.pop(); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0;&#125;public static void main(String[] args) &#123; int opCount = 100000; ArrayStack&lt;Integer&gt; arrayStack = new ArrayStack&lt;&gt;(); double time1 = testStack(arrayStack, opCount); System.out.println("ArrayStack, time: " + time1 + " s"); LinkedListStack&lt;Integer&gt; linkedListStack = new LinkedListStack&lt;&gt;(); double time2 = testStack(linkedListStack, opCount); System.out.println("LinkedListStack, time: " + time2 + " s"); // 其实这个时间比较很复杂，因为LinkedListStack中包含更多的new操作&#125; 结果如下： 其实这个测试结果不会是稳定的，相比较之下，他们的快慢主要和环境有很大关系。 当然，ArrayStack在添加元素时可能会执行扩容操作，这个时间复杂度是O(n)的，在LinkedListStack添加元素的时候虽然没有扩容的操作但是它会执行大量new对象操作，这也是非常占用资源的。总体来说，它们的增添和删除元素的时间复杂度都是O(1),所以可以说它们执行时间的差异并不是很大。 链表实现队列前面一篇文章专门讲到了Queue，队列就是（FIFO）的数据结构，我们主要去实现队列的入队（在队尾添加元素），出队（在队首删除元素）。回想我们前面实现的链表，在队首删除元素容易（时间复杂度是O1的），但是要在队尾添加元素就非常繁琐了，我们需要遍历整个链表，当数据量一大，我们的执行时间就会变得非常大，所以我们为了效率考虑，我们需要添加一个尾节点。 这时候我们怎么实现队列的操作呢？其实很简单，当我们入队的时候只需要将尾节点的next指向当前入队的新的节点，当然我们不得不把所有尾节点的next都置为null，为的是我们的逻辑和效率，浪费一个空间也不是大问题。 而当我们进行出队操作时，我们只需要将原来头结点变为原来头结点的next节点，返回出队节点的时候我们只需要将被删除的头结点的next节点变为null就行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @author Lin * @date 2019-04-18 19:13 **/public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private class Node&#123; private E e; private Node next; public Node(E e)&#123; this.e=e; this.next=null; &#125; &#125; private Node head,tail; //维持链表元素个数 private int size; public LinkedListQueue()&#123; head=null; tail=null; size=0; &#125; /** * 入队只能从尾部 * @param e 元素 */ @Override public void enqueue(E e) &#123; //如果尾节点为空，那么就代表整个链表为空 if (tail==null)&#123; //需要将元素赋值给头节点和尾节点 head=new Node(e); tail=head; size++; &#125;else &#123; //不为空则需要新节点赋值给尾节点的next tail.next=new Node(e); //尾节点变换 tail=tail.next; size++; &#125; &#125; /** * 出队操作，只能从第一个出队 * @return 头节点 */ @Override public E dequeue() &#123; //当链表为空时无法进行出队操作 if (size==0)&#123; throw new IllegalArgumentException("the linkedListQueue is empty!"); &#125;else &#123; Node tempNode=head; //将原来头结点的next变为当前头结点 head=head.next; //将要返回的“头结点”的next置为null tempNode.next=null; size--; return tempNode.e; &#125; &#125; @Override public int getSize() &#123; return this.size; &#125; @Override public E getFront() &#123; return head.e; &#125; @Override public boolean isEmpty() &#123; return this.size==0; &#125;&#125; 三种实现对列的比较前面我们使用了数组队列和循环队列，这时候我们加入我们刚刚实现的链表队列。测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637public class Main &#123; private static double testQueue(Queue&lt;Integer&gt; q, int opCount)&#123; long startTime = System.nanoTime(); Random random = new Random(); for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.enqueue(random.nextInt(Integer.MAX_VALUE)); &#125; for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.dequeue(); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0; &#125; public static void main(String[] args) &#123; int opCount = 100000; ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;(); double time1 = testQueue(arrayQueue, opCount); System.out.println("ArrayQueue, time: " + time1 + " s"); LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;(); double time2 = testQueue(loopQueue, opCount); System.out.println("LoopQueue, time: " + time2 + " s"); LinkedListQueue&lt;Integer&gt; linkedListQueue = new LinkedListQueue&lt;&gt;(); double time3 = testQueue(linkedListQueue, opCount); System.out.println("LinkedListQueue, time: " + time3 + " s"); &#125;&#125; 这个时候我们能得到结果： 通过我们实践和分析，链表实现的队列也是O(1)的时间复杂度。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis初识与安装]]></title>
    <url>%2F2019%2F04%2F16%2Fredis%E5%88%9D%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[什么是Redis redis是一款基于C语言的开源的基于键值的存储服务系统它支持丰富的数据类型，如：string、list、set、zset(sorted set)、hash。 Redis的创始人是意大利人Salvatore Sanfilippo，他的网名是antirez，我们可以通过https://github.com/antirez来访问他的主页。 Redis的优势 Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。以设置和获取一个256字节字符串为例，它的读取速度可高达110000次/s，写速度高达81000次/s。当然这是官方声明的，但是实际应用达到w级是肯定没问题的。 因此redis的性能非常好，而且可以支持多种数据结构和持久化（RDB实现方式和AOF实现方式）。 redis可以支持多种编程语言，在java，php，python都有实现。 redis可谓短小精悍，redis5.0的代码也就只有5w行，除去实现分布式的代码，它仅仅只有23000行代码，但是redis提供的功能非常丰富，比如发布订阅，Lua脚本，事务等。 redis提供主从复制，这为后面实现高并发和高可用打下了基础。 Redis典型应用场景 缓存系统 计数器 消息队列系统 排行榜 社交网络 实时系统 Redis的安装和简单运行 下载 1wget http://download.redis.io/releases/redis-5.0.3.tar.gz 可能会遇到DNS解析的问题，这时候要去更改/etc/resolv.conf 123vim /etc/resolv.confnameserver 8.8.8.8 #google域名服务器nameserver 8.8.4.4 #google域名服务器 解压 1tar xzf redis-5.0.3.tar.gz 创建文件并编译 12cd redis-5.0.3make 进入目录并运行 1src/redis-server 修改问题和警告 这时候启动redis的时候难免会出现警告，首先肯定是关于配置文件的问题，redis建议你启动的时候附带配置文件路径 如: 1src/redis-server redis.conf 我们需要将redis以守护进程的方式启动以避免关闭命令行是redis不退出，我们只需要修改redis.conf文件，设置daemonize为yes就行。 我们运行之后会发现我们无法再进行其他操作了，这时候我们需要启动的时候添加一个&amp; 12src/redis-server redis.conf &amp;` 你可能还会遇到以下问题 WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 大概意思是你的tcp设置为128对于这个环境来说太小了，redis建议你设置为511 1echo 511 &gt; /proc/sys/net/core/somaxconn you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. 解决办法: 1echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect. 按照提示将vm.overcommit_memory = 1加入到/etc/sysctl.conf中并执行命令sysctl vm.overcommit_memory=1就好了 简单的设置值和取值 命令： set key value get key]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手写Queue]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Queue%2F</url>
    <content type="text"><![CDATA[什么是队列 队列是一种先进先出的数据结构（First In First Out）。结合生活实际，这里的队列就是从生活中的排队得来的。比如我们正在排队办理业务，后来的人只能从队列最后一个进入队伍（入队），当前面的的人办理完业务的时候他就离开了队伍（出队）。由此我们可以发现，要实现队列其实最重要的就是出队和入队的操作。所以我们就可以定义我们的Queue接口了。 123456789101112131415161718192021222324252627282930313233343536 /** * @author Lin * @date 2019-04-15 19:19 **/public interface Queue&lt;E&gt; &#123; /** * 入队 * @param e 元素 */ void enqueue(E e); /** * 出队 * @return 出队的元素 */ E dequeue(); /** * 获取大小 * @return 队列大小 */ int getSize(); /** * 获取队头元素 * @return 队头元素 */ E getFront(); /** * 判断是否为空 * @return 布尔 */ boolean isEmpty();&#125; 数组队列 了解队列的特点，我们不难就想到了上次使用数组实现栈，其实队列和栈也差不多，只不过更改了出和入的操作罢了，这里我就不明细讲了，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * @author Lin * @date 2019-04-15 19:19 **/public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt;&#123; private Array&lt;E&gt; array; public ArrayQueue()&#123; array=new Array&lt;&gt;(); &#125; public ArrayQueue(int capacity)&#123; array=new Array&lt;&gt;(capacity); &#125; @Override public void enqueue(E e) &#123; array.addLast(e); &#125; @Override public E dequeue() &#123; return array.removeFirst(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public E getFront() &#123; return array.getFirst(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125;&#125; 循环队列 我们来对上面的数组队列做一个时间复杂度分析 当我们进行入队操作的时候时间复杂度肯定为O(1),这是非常高效的。但是，我们要进行出队的时候就大不相同了，因为我们每次出队，当移除头元素的时候我们就需要将后面的元素挨个往前移动，因为我们这个底层就是依靠动态数组实现的，所以就是调用动态数组删除某个索引元素的方法，那么这个时间复杂度就是O(n),也就是说当我们进行出队操作的时候，队伍量越大我们消耗的时间就越大，这是低效且我们不愿意看到的。在数据结构中，很多时候我们都会使用空间和时间的互换，时间换取空间资源，空间资源换取时间资源，所以我们这里可以使用循环队列来提高出队效率。 循环队列是什么，其实就相当于将队列的头和尾相连接 如图： 我们增加了一个头索引和尾索引来达到虚拟的连接（这个当然不是真实的）。当我们初始化这个队列的时候，头索引和尾索引都是0,当头索引和尾索引相等的时候这个队列为空，首先记着这个（很好理解，就是头和尾中间没有间隔那不就是空了么）。当我们进行入队操作的时候，将元素放入循环队列的尾索引处，放置完成后将尾索引+1（后移一个单位）。当进行出队的时候，我们将头元素删除，并将头索引+1（后移一个单位）。是不是很简单？当然不可能这么简单，因为这个队列是循环的，头和尾是相连的，这里我们就可以利用相连的特性来使用我们刚刚可能出队的时候浪费的空间资源，怎么做？其实就是更改一下我们头索引和为索引相加的位置，我们将他们++操作更改为front=(front+1)%capacity就行，这里的capacity是指整个队列的容量。 还有一个注意点就是当我们整个队列满的时候我们是无法判断队列是否为空的，因为这时候头索引和尾索引也是相等的，这个时候我们就需要牺牲一个存储单元来解决冲突。 下面就直接贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * @author Lin * @date 2019-04-15 19:40 **/public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private E[] array; private int front, tail; public LoopQueue() &#123; this(10); &#125; public LoopQueue(int capacity) &#123; array = (E[])new Object[capacity+1]; //头尾索引置为0 front = 0; tail = 0; &#125; private int getCapacity() &#123; return array.length - 1; &#125; //入队 @Override public void enqueue(E e) &#123; //当使用长度和容量相等的时候进行扩容 if (((tail - front + this.getCapacity()+1) % (this.getCapacity()+1)) == this.getCapacity()) &#123; resize(this.getCapacity() * 2); &#125; //将元素e放入队尾 array[tail]=e; tail++; &#125; //出队 @Override public E dequeue() &#123; //当队列为空抛出异常 if (front==tail)&#123; throw new IllegalArgumentException("The loopQueue has no element"); &#125;else &#123; //将头元素置为null并且将头索引向后移动一个单位 E temp=array[front]; array[front]=null; front=(front+1)%array.length; //当队列只使用了四分之一时将队列缩容 if (this.getSize()==this.getCapacity()/4&amp;&amp;this.getCapacity()/2!=0)&#123; resize(this.getCapacity()/2); &#125; return temp; &#125; &#125; //获取当前队列的实际长度（使用头尾索引计算） @Override public int getSize() &#123; return (tail - front + this.getCapacity()+1) % (this.getCapacity()+1); &#125; @Override public E getFront() &#123; return array[front]; &#125; @Override public boolean isEmpty() &#123; return tail==front; &#125; //扩容 private void resize(int capacity) &#123; E[] newArray = (E[])new Object[capacity+1]; int size = (tail - front + this.getCapacity()+1) % (this.getCapacity()+1); for (int i = 0; i &lt; size; i++) &#123; newArray[i]=array[(front + i) % size]; &#125; array = newArray; front = 0; tail = size ; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("["); for (int i = front; i != tail; i = (i + 1) % array.length) &#123; if ((i + 1) % array.length == tail) &#123; stringBuilder.append(array[i]); &#125; else &#123; stringBuilder.append(array[i]).append(","); &#125; &#125; stringBuilder.append("] tail container:").append(this.getCapacity()); return stringBuilder.toString(); &#125;&#125; //测试 public static void main(String[] args) &#123; LoopQueue&lt;Integer&gt; loopQueue=new LoopQueue&lt;&gt;(); for (int i=0;i&lt;17;i++)&#123; loopQueue.enqueue(i); System.out.println(loopQueue); &#125; loopQueue.dequeue(); loopQueue.dequeue(); loopQueue.dequeue(); System.out.println(loopQueue); &#125; 数组队列和循环队列的比较 大数比较 12345678910111213141516171819202122232425262728293031 private static double testQueue(Queue&lt;Integer&gt; q, int opCount)&#123; long startTime = System.nanoTime(); Random random = new Random(); for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.enqueue(random.nextInt(Integer.MAX_VALUE)); &#125; for(int i = 0 ; i &lt; opCount ; i ++)&#123; q.dequeue(); &#125; long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0;&#125;public static void main(String[] args) &#123; int opCount = 100000; ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;(); double time1 = testQueue(arrayQueue, opCount); System.out.println("ArrayQueue, time: " + time1 + " s"); LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;(); double time2 = testQueue(loopQueue, opCount); System.out.println("LoopQueue, time: " + time2 + " s");&#125; 运行结果： 可以看出，当数据量大的时候，LoopQueue完胜。 当我们把数据量变为10的时候我们不难发现，LoopQueue还是胜出,并且速度比数组队列快一个量级。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手写Stack]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Stack%2F</url>
    <content type="text"><![CDATA[什么是栈 我觉得栈是一个很简单的概念，栈是一种后进先出的数据结构(Last In And First Out)，大家都见过装羽毛球的筒吧，你会发现当你装完羽毛球之后第一个拿出来的肯定是最后一个放进去的。其实这就是栈，它是一种线性结构，我们学习了数组其实就很容易理解栈了。 为什么呢？我们可以先想一下，对于栈这样的数据结构，我们能对它进行什么样的操作。其实也就是入栈（将一个羽毛球放进去），出栈（将一个羽毛球拿出来），判断栈是否为空（羽毛球筒里面有没有羽毛球），计算栈的大小（计算羽毛球筒里有多少个羽毛球），获取栈顶元素（获取羽毛球筒中最上面的羽毛球）。无非就是这几个操作。所以我们现在可以定义栈的接口了，如下面代码。 123456789101112131415161718192021222324252627282930313233343536/** * @author Lin * @date 2019-04-15 12:34 **/public interface Stack&lt;E&gt; &#123; /** * 获取栈的大小 * @return 大小 */ int getSize(); /** * 判断栈是否为空 * @return 布尔 */ boolean isEmpty(); /** * 将元素放入栈 * @param e 元素 */ void push(E e); /** * 出栈 * @return 出栈的元素 */ E pop(); /** * 获得栈最上面的元素 * @return 元素 */ E peek();&#125; 栈与数组的关系之前我的一篇博客介绍了如何实现动态数组，那个动态数组中我们实现了添加删除元素，计算数组大小，判断数组是否为空，获取数组的元素等方法。其实我们对栈的操作也就是对数组操作的子集，计算大小，判断为空我们可以直接使用数组的方法，添加元素对于栈来说就是在末尾添加元素，删除就是删除末尾元素，而获取元素就是获取最后一个元素。所以我们可以直接定义我们的ArrayStack类了（这个类是实现了刚刚的Stack接口的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @author Lin * @date 2019-04-15 13:18 **/public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; /** * 通过数组实现栈 */ private Array&lt;E&gt; array=new Array&lt;&gt;(); @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; //入栈操作 @Override public void push(E e) &#123; array.addLast(e); &#125; //出栈操作 @Override public E pop() &#123; return array.removeLast(); &#125; //上篇博客中没有getLast和getFirst方法 //这里是我后面添加的，其实实现这个方法很简单，只要固定index就行了 @Override public E peek() &#123; return array.getLast(); &#125; //这里重写toString方法为了后面测试能清楚显示 @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("Stack ["); for (int i = 0; i &lt; this.getSize(); i++) &#123; if (i != this.getSize() - 1) &#123; stringBuilder.append(array.get(i)).append(","); &#125;else &#123; stringBuilder.append(array.get(i)).append("]pop"); &#125; &#125; return stringBuilder.toString(); &#125;&#125; 栈的一些应用场景 word和一些IDE中的撤销功能 将用户的操作放入栈中，当实行撤销操作的时候把用户最近的操作撤销。 程序调用的系统栈 比如我们调用A方法需要调用B方法，调用B方法的时候我们需要调用C方法，这时候我们C方法执行完了之后我们系统是不知道我们下面应该执行什么方法的，所以这时候栈就登场了，当我们执行A方法需要调用B方法的时候我们将这时候跳转执行前的方法和代码行数记录到栈中（这时候我们执行的是A方法的第二行代码调用了B方法，所以我们把A2存入栈中）。同理，我们运行B方法的时候在第二行调用了C方法，我们就把B2存入栈中，之后我们C方法执行完之后系统就看栈中有没有还需要返回的方法，如果有就跳回指定的方法的代码行数，比如C方法执行完，我们栈中有B2，我们就跳回B2执行并且把栈顶元素删除，接着我们B方法执行完了，我们看栈中还有A2，我们就跳转到A2执行代码并且把A方法执行完查看栈中没有元素的时候我们就把整个A方法执行完成了。 关于栈的算法题目在leetcode中有一道使用栈解决的简单题目 题目是这样的： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 思考一下题目，其实就可以和栈结合起来了，我们将给出的串进行遍历获取字符，我们判断字符是否为”{“,”[“,”(“,为这三个我们就把字符存入栈中，如果不是我们就把它和栈素比较是否匹配，如果不匹配那么直接返回false。大致思是这样，具体细节代码注释里有详细解释。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public boolean isValid(String s) &#123; //创建一个stack Stack&lt;Character&gt; stack=new Stack&lt;&gt;(); //声明栈顶元素 Character topCharacter; //循环遍历字符串 for (int i=0;i&lt;s.length();i++)&#123; //获取某个字符 Character character=s.charAt(i); //如果该字符等于'&#123;'或'['或'('的时候存入栈中 if (character=='&#123;'||character=='['||character=='(')&#123; stack.push(character); //直接进入下一层循环 continue; &#125; //如果不是，那么就是与之相对的了 else &#123; //首先判断栈是否为空 //因为如果栈中没有元素且这个字符是右边的括号 //那么这个字符串肯定不符合要求 if (stack.isEmpty())&#123; return false; &#125;else &#123; //获取栈顶元素 topCharacter=stack.pop(); //判断栈顶元素是否和该元素匹配，如不匹配直接false if (character=='&#125;'&amp;&amp;topCharacter!='&#123;')&#123; return false; &#125;else if (character==']'&amp;&amp;topCharacter!='[')&#123; return false; &#125;else if (character==')'&amp;&amp;topCharacter!='(')&#123; return false; &#125; &#125; &#125; &#125; //如果循环都是正确的，那么还要判断栈是否为空 //因为"&#123;","["这种类型的情况都是错误的 //但是前面没有考虑到，所以只要判断后面直接没有元素匹配 //也就是栈是否不为空 return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手做Array]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9AArray%2F</url>
    <content type="text"><![CDATA[学习数据结构 一直以来在学习java web开发，里面很少涉及到数据结构相关的编程，再加上大一没有怎么好好学这门课程，这段时间开始慢慢捡回来，不说如何去精通它，但希望自己从数据结构开始训练自己的基础代码能力，如今用框架用的已经连代码都不会写了。。。 Array代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225/** * @author Lin * @date 2019-04-13 16:52 **/public class Array&lt;E&gt; &#123; /** * 泛型数组 */ private E[] array; /** * 数组大小 */ private int size; /** * 有参构造方法 */ public Array(int capacity) &#123; //强制类型转换 array = (E[]) new Object[capacity]; //size指向0 size = 0; &#125; /** * 默认构造函数 */ public Array() &#123; //默认容量为8 array = (E[]) new Object[8]; size = 0; &#125; /** * 获取数组容量 */ public int getCapacity() &#123; return array.length; &#125; /** * 获取数组元素个数 */ public int getSize() &#123; return size; &#125; /** * 返回数组是否为空 */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 在index处插入一个新的元素 * * @param index 索引 * @param e 插入的元素 */ public void add(int index, E e) &#123; //判断index是否合法 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("index is not valid!"); &#125; //判断此时size和capacity是否相等，如果相等需要动态增加数组容量 if (size == this.getCapacity()) &#123; resize(size * 2); &#125; //将index索引处后面的元素向后移一个 for (int i = size-1; i &gt;= index; i--) &#123; array[i + 1] = array[i]; &#125; array[index] = e; ++size; &#125; /** * 动态扩容 * * @param capacity 新的容量 */ private void resize(int capacity) &#123; //新构建一个数组，将原来数组赋值上去 E[] temp = (E[]) new Object[capacity]; for (int i = 0; i &lt; size; i++) &#123; temp[i] = array[i]; &#125; array = temp; &#125; /** * 在头部添加元素 * * @param e 元素 */ public void addFirst(E e) &#123; //直接调用add方法 add(0, e); &#125; /** * 在尾部添加元素 */ public void addLast(E e) &#123; add(size, e); &#125; /** * 获取索引位置的元素 * * @param index 索引 * @return 该索引处的元素 */ public E get(int index) &#123; return array[index]; &#125; /** * 修改索引位置的元素 * * @param index 索引 * @param e 要设置的元素 */ public void set(int index, E e) &#123; array[index] = e; &#125; /** * 数组中是否包含元素 * * @param e 元素 * @return 布尔 */ public boolean contains(E e) &#123; for (E originalElement : array) &#123; if (originalElement.equals(e)) &#123; return true; &#125; &#125; return false; &#125; /** * 查找数组中第一次出现该元素的索引，不存在则返回-1 * * @param e 元素 * @return 索引 */ public int find(E e) &#123; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; /** * 删除指定索引元素 * * @param index 索引 * @return 删除的元素 */ public E remove(int index) &#123; E removeElement = array[index]; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException("index is not valid!"); &#125; for (int i = index; i &lt; size; i++) &#123; array[i] = array[i + 1]; &#125; --size; //压缩空间 //这里使用懒压缩，如果在size为容量一半的时候就缩减容量为一半，则当这个数组再次增加一个元素的时候，它又会进行扩容。所以这里给予一定的空间 if (size==array.length/4&amp;&amp;array.length/2!=0)&#123; resize(array.length/2); &#125; return removeElement; &#125; /** * 删除第一个 * * @return 删除的元素 */ public E removeFirst() &#123; return remove(0); &#125; /** * 删除最后一个元素 * * @return 删除的元素 */ public E removeLast() &#123; return remove(size-1); &#125; /** * 删除第一个出现的某个元素 * * @param e 需要删除的元素 */ public void removeElement(E e) &#123; remove(find(e)); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, array.length)); res.append('['); for (int i = 0; i &lt; size; i++) &#123; res.append(array[i]); if (i != size - 1) &#123; res.append(", "); &#125; &#125; res.append(']'); return res.toString(); &#125;&#125; 总结 在Java中，数组的容量一旦声明就无法改变，这里我们通过封装实现了动态数组，并且实现了动态数组的增删改查等简单的功能。其中最为重要的是数组怎样实现增加，删除和动态扩容。 增加当数组某个位置需要增加元素的时候，我们先要将该索引处后面的元素从最后一个元素开始把各自向后移动一个位置。 删除当数组某个位置需要删除元素的时候，我们先要将该索引处后面的元素从索引处后面的元素开始依次将各自向前移动一个位置。即为后面元素覆盖前面元素。 动态扩容当数组进行增加的时候，如果数组容量不够时我们需要进行扩容。当数组中进行删除的时候，如果数组使用量已经远小于数组容量的时候我们需要进行压缩，来减少无用的空间。 我们上文代码实现扩容的方式是在数组增加和删除的时候重新构建一个数组并且将原来的数组赋值到新的数组中去。为了避免一直重复的重构容量大小，我们将扩充的容量变为原来容量的两倍(如果每次容量只是加1或者很少那么每次add之后都要执行重构容量，但是重构容量需要重新遍历数组，时间复杂度为O(n),极大地浪费时间，所以我们这里通过牺牲空间来节省时间)。当每次删除元素的时候，我们将判断数组使用量是否等于容量的四分之一，当为true的时候我们我们将容量变为原来一半以节省空间(这里为什么是四分之一和一半呢？其实具体数值并不是固定的，但是我们这里实现的是懒压缩，如果这里的判断条件为一半，当使用量为容量一半的时候我们就之间将容量变为原来一半，那么之后再次进行add方法时我们又需要扩容，从而引起复杂震荡，这是得不偿失的)。 上文Array代码基本是模仿JDK的ArrayList来实现的，在ArrayList中也是通过上述方法来实现的。 如实现动态扩容: 12345678910111213141516171819/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里使用了移位，为了使运算更加快速 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //这里设置的是最小容量和最大容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从对称加密到数字证书]]></title>
    <url>%2F2019%2F04%2F11%2F%E4%BB%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%88%B0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[对称加密​ 简单来说，对称加密是解决通信之间的安全问题的最初手段。如下图中张大胖同学通过网络结识了远在美国的Bill同学，两个人聊得水深火热，但是有一天张大胖开始变得疑神疑鬼，因为他们聊得内容越来越隐私。张大胖就跟Bill说我总感觉不安全，我感觉有个人通过截取我们的消息在偷窥我们讲话，Bill听了也连忙说，对！我们的消息都是明文传输，中间被人截获就直接被读出来了。那怎么办？加密呗！ ​ 说着，张大胖就提议，不是有个对称加密嘛？我们用那个进行对消息的加密，我们首先沟通好我们的私钥，保持一致性，我给你发消息的时候我通过私钥加密，你收到消息的时候你再通过私钥进行解密，这样即使被中间人截获他也看不懂啦！Bill连忙夸赞张大胖同学说：”dei dei dei这个办法好呀！”。 ​ 就如下图中一样，张大胖和Bill就通过对称加密来进行通信，看似安全了，但是真的安全了吗？ ​ 可是，当张大胖和Bill开始协商秘钥的时候，问题又出现了！Bill说既然网络是不安全的，万一现在正好有人再偷窥我们协商秘钥，我们协商好之后通过网络传输，这个秘钥就是明文传输的呀！那么，我们的秘钥不就暴露了吗？张大胖听了Bill的一席话，幡然醒悟。“对呀！这个可怎么办？而且当两个人进行通信的时候就要一个秘钥，一个人如果需要同一百个，一万个好友进行通信的时候那么就要有一百个，一万个秘钥，这！这哪能记得住呀？“。Bill这时候说道：“不行不行！这个通信方式也不安全！我们得再想一个。” 非对称加密​ 张大胖和Bill得知这种办法也不行的时候就一直提心吊胆地通信着，都不敢涉及隐私了，这个偷窥者听得也没劲了。直到后来，Bill听说了一种叫RSA非对称加密的算法，他一下子来了灵感。 &nbsp; RSA算法意思是一个人同时拥有公钥和私钥，这个公钥是公开的，别人都可以知道，但是这个私钥是自己保存的，千万不能让别人知道。而且，当文本经过某个人的公钥加密的时候，只有通过这个人的私钥才能进行解密，所以当Bill向张大胖同学发消息的时候，他就使用张大胖的公钥对消息进行加密，当张大胖收到消息的时候他就使用自己的私钥进行解密。流程如下图： 非对称加密+对称加密​ 这样，非对称加密就一下子解决了对称加密的两个缺点（秘钥泛滥和秘钥被网络截取），但是它也带来了一个很致命的缺点，那就是——效率问题，对同样大小的文本对称加密的速度是非对称加密速度的几百倍（我曾经拿RSA算法对一个50kb的文件进行加密，电脑直接叫唤着我不行了，我不行了）。大家知道通信是很讲究速度效率的，这个非对称加密虽然安全但是速度太慢了，这叫人怎么能忍呢？ ​ 这么愚蠢的问题当然不会困惑张大胖和Bill很久，他们想出来了一个二者结合的方法！当张大胖和Bill要进行通信的时候，他们就先使用非对称加密沟通好对称加密的秘钥（也就是在这个非对称加密的通道里传输秘钥）这样秘钥就不会被截获了，就算截获也是密文，偷窥者没办法呀。然后双方就使用刚刚非对称加密通信产生的对称加密的秘钥来进行加密解密，这样一来安全问题和效率问题就得到了很好的解决啦！ 中间人劫持​ 现在张大胖和Bill就很欢快地聊起来了，但是问题就这么简单地结束了吗？当然没有！张大胖把自己和Bill的聊天情况告诉了他女朋友，女朋友一听就发现了一个问题，她说：“Bill给别人，给你发公钥的时候也是通过网络传输的呀！那么这时候有个中间人把这个公钥给劫持了，再把自己的公钥换掉Bill的公钥发给你，你收到的就是中间人的公钥呀！那么你通过中间人的公钥进行消息加密发给Bill，这时候中间人再次劫持消息，通过他的私钥进行解密就直接能获得消息的内容了，然后他再把解密完的消息或者自己编造一个假消息然后使用Bill的公钥进行加密发给Bill，这样就神不知鬼不觉的解密了你们的消息并且还能冒充身份和造假消息！！！张大胖一听，后背就开始发凉，难道自己和Bill发的生活照都被中间人截取了吗？？？这可怎么防呀？ 数字签名和数字证书​ 但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？这真的是一个很头痛的问题呀！可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。这让张大胖想到了一个现实中的问题——签名。像我们签合同，协议都是通过签名来确定这个本人，那么我们可以把它移植到网络上！怎么移植呢？ ​ RSA算法给我们提供了一个很好的办法，因为它不仅可以通过公钥加密私钥解密，它还可以私钥加密公钥解密。这样我们发送公钥的时候可以通过某个消息摘要算法，首先这个消息摘要算法必须有两个特性——不可逆性和可变性。不可逆好理解，就是无法通过密文解出明文，这个可变性就是指当消息发生一点点变化的时候，它形成的密文就会发生翻天覆地的变化，这样就可以防止别人修改。这时候我们通过消息摘要算法来对公钥进行加密形成摘要，然后我们通过自己的私钥对这个摘要进行加密形成摘要密文，这个摘要密文就是我们的数字签名。这样，我们发公钥的时候就发送原本的消息附加上我们的数字签名，这样对方收到这个消息的时候就使用收到的公钥对这个数字签名进行解密（得到其实就是公钥的摘要），然后再通过同样的消息摘要算法对收到的公钥进行加密，如果对公要的加密密文和数字签名解密出来的东西是一样的，那么久说明这个公钥没有被修改过！ ​ 可能有点难理解，我们这么想，如果中间人对这个公钥进行了修改或者替换。比如张大胖和Bill在通信，张大胖把自己的公钥和数字签名发给了Bill，中间人截获这个消息，假如他替换了公钥（替换成自己的了），那么他也不能改动数字签名，使数字签名通过这个公钥来形成中间人公钥的信息摘要，因为这个数字签名就是密文，他不知道如何下手，所以如果只改公钥，那么这样肯定会被Bill发现。但是，作为一个狠角色，要干就要干狠一点，不能改公钥，不能改数字签名，老子干脆就把它全改了，全用自己的！ ​ 所以问题又来了，这时候我们就要请来大人物了——认证中心（CA），我们需要有一个具有公信力的中间商，当我们把自己的公钥和个人信息形成消息摘要的时候，我们使用CA的私钥进行加密形成数字签名。 ​ 然后我们发送消息的时候我们把我们的公钥和个人信息再连带着使用CA的私钥加密过的数字签名发送给对方，这些东西合起来就有另一个名字——数字证书。 ​ 如图所示，当Bill吧这个数字证书发给张大胖的时候，我就用同样的消息摘要算法对原本消息进行摘要，然后使用CA的公钥对数字签名进行解密获取摘要，然后对比我前后获取的摘要，如果一致那么就说明这个东西没有被篡改。你想想，如果中间人截获了这个证书，他把证书全改成自己的，但是张大胖使用的是CA的公钥解密摘要，然而中间人不知道CA的私钥，那么他这么做就露馅了！这时候张大胖就安全地拿到了Bill的公钥，后续的加密工作就可以顺利地进行了。当然，网络本就是不安全的，想必大家也想到了，当Bill获取CA的公钥的时候，这个中间人也可以发起攻击，直接篡改CA公钥，那么这样安全问题就无限的循环下去无法解决了！当然这些CA本身也有证书来证明自己的身份，并且CA的信用是像树一样分级的，高层的CA给底层的CA做信用背书，而操作系统／浏览器中会内置一些顶层的CA的证书，相当于你自动信任了他们。这些顶层的CA证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。 HTTPS​ 这样，https也非常好理解了，看图就知道了。 ​ 本博文参考于刘欣的《码农翻身》，特别感谢此书，也推荐大家阅读。 后记​ 好久没写博客了，因为这学期以来就有一大堆事情要解决处理，有时候学习完，就一直没时间写总结。总感觉自己像头狮子一样，想一口气吃成大胖子，什么都要学，什么都学不精，学了之后不总结，学了就忘。当然有好奇心也是好事，但是我可不想无法精通一门东西，昨天看这本《码农翻身》，书中提到了不要让碎片化信息侵蚀你深度思考的能力，确实如此，我们现在学习知识都是以一种常识的心态去学，我们只是记住了这个常识，死记硬背，并没有深度思考其中的原因和逻辑，所以我们无法精通一门技术，我想，这大概是我现阶段学习最大的问题吧。]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的散列集]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E4%B8%AD%E7%9A%84%E6%95%A3%E5%88%97%E9%9B%86%2F</url>
    <content type="text"><![CDATA[哈希&nbsp;&nbsp;Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 &nbsp;&nbsp;所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 &nbsp;&nbsp;两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。 &nbsp;&nbsp;常见的Hash函数有以下几个： 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 &nbsp;&nbsp;上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种： 开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 线性探查：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。 二次探查：di=12，-12，22，-22，…，k2，-k2 ( k&lt;=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 HashMap 的数据结构&nbsp;&nbsp;在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。上面我们提到过，常用的哈希函数的冲突解决办法中有一种方法叫做链地址法，其实就是将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。 &nbsp;&nbsp;我们可以从上图看到，左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，反过来我们也正是通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是哈希算法，即本文的主角hash()函数（当然，还包括indexOf()函数）。 假设现有 persons.put(“1”,”jack”);persons.put(“2”,”john”); 同时计算到的hash值都为123，那么jack先放在第一列的第一个位置Node-jack，persons.put(“2”,”john”);执行时会将Node-jack的next(Node) = Node(john)，Jack的下个节点将指向Node(john)。 那么取的时候呢，persons.get(“2”)，这个时候取得的hash值是123，即table[123]，这时table[123]其实是Node-jack，Key值不相等，取Node-jack的next下个Node，即Node-John，这时Key值相等了，然后返回对应的person.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOP在Spring中的应用]]></title>
    <url>%2F2019%2F02%2F02%2FAOP%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[AOP(面向切面编程)&nbsp;&nbsp;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 &nbsp;&nbsp;AOP是OOP的扩展和延伸，并不能取代OOP，AOP为OOP不能解决的问题提供了很好的方式。 &nbsp;&nbsp;例如，我们现在需要在持久层的某个save方法前面加一个权限校验的方法。 按照正常的想法，我们会在dao类上添加一个check权限的方法然后在调用save方法之前调用check方法，但是问题来了，当出现成千上百的保存方法的时候，我们就需要在成百上千的类中添加check校验方法，这样就很麻烦 使用纵向继承的方式，我们可以编写一个BaseDao类，这个类中我们编写一个check校验方法，当我们某各类需要加入权限校验方法的时候，我们只需要继承BaseDao类并调用BaseDao类中的check方法就行了。但是，使用继承的方式虽然说比上面的方法好一些，但是也并不尽人意，比如当我们这个权限校验方法不需要的时候，我们必须删除这些extends和子类调用BaseDao的check方法。AOP为我们解决这类问题提供了很好的方案。 AOP(横向抽取)，其实AOP的原理就是使用了Java中的代理模式,具体可以参考这篇文章。这时候我们在把save方法抽取出来，我们使用Proxy模式增强save方法。 AOP的好处和Spring AOP底层实现&nbsp;&nbsp;对程序进行曾倩，不修改源码的情况下，AOP可以进行权限校验，日志记录，性能监控，事务控制等功能。 &nbsp;&nbsp;Spring AOP底层使用动态代理模式，在被代理类实现某种接口的时候使用JDK动态代理，在被代理类没有实现某个接口的时候使用cglib动态代理。 AOP相关术语&nbsp;&nbsp;首先我们先列出需要实现AOP的代码类123456public class UserDao&#123; public void save()&#123;&#125; public void find()&#123;&#125; public void update()&#123;&#125; public void delete()&#123;&#125;&#125; &nbsp;&nbsp;我们对照上面代码看 JoinPoint：连接点，可以被拦截到的点。这里四个crud方法都是可以进行方法增强的，所以这四个方法都可以被称为JoinPoint PointCut：切入点，真正被拦截的点，如果这四个方法中我们只对save方法进行了增强，那么save方法就是PointCut。 Advice：通知增强，假如我们现在对save方法进行权限校验，那么这个check方法就称为通知或者增强，而且这是方法层面的增强 Introduction：引介，类方面的增强 Target：被增强的对象，如果现在我们对UserDao这个类增强，那么UserDao就是Target Waving：织入，它是一个过程，指的是我们将通知（Advice）应用到目标（Target）过程，将全县校验的方法的代码应用到UserDao的save方法上的过程。 Proxy：代理对象，一个类被AOP织入增强之后就产生了一个结果代理类 Aspect：切面，是切入点和通知的结合。 Spring AOP的入门开发AOP的配置123456789&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(表达式)&quot; id=&quot;切入点的id可以随便取，下面要对应&quot;/&gt;&lt;!--这里配置切面类--&gt;&lt;!--前提是切面类需要交给Spring管理--&gt;&lt;aop:aspect ref=&quot;某个切面类&quot;&gt; &lt;!--这里配置通知增强方法，这里是前置增强--&gt; &lt;aop:before method=&quot;切面类里面的增强方法&quot; pointcut-ref=&quot;切入点的id&quot;/&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型 前置通知 目标方法执行前进行操作(权限校验..) 1&lt;aop:before method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot;&gt; 后置通知 目标方法执行之后进行操作(日志..),可以获得被增强方法返回值 12&lt;aop:after-returning method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot; returning=&quot;returning对应的名字&quot;&gt;&lt;!--后置增强方法里面传入 Object 与returning对应的名字--&gt; 环绕通知 目标方法执行之后之前进行操作，可以控制方法是否执行 1&lt;aop:round method=&quot;around&quot; pointcut-ref=&quot;切入点&quot;&gt; 1234567891011//环绕增强方法实例//返回值必须是Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123;&#125;public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;环绕前&quot;); //执行切入点的方法 Object obj =joinPoint.proceed(); System.out.println(&quot;环绕后&quot;); return obj;&#125; 异常抛出通知 抛出异常的时候进行的操作(事物回滚),可以获取异常信息1&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;切入点&quot; throwing=&quot;给异常取个名字&quot;&gt; 1234//增强方法public void afterThrowing(Throwable 异常的名字)&#123; System.out.println(异常名字.getMessage());&#125; 最终通知 类似于finally，不管有没有异常都会执行的操作1&lt;aop:after method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot;&gt; 切入点表达式 基于execution的函数完成 语法 [访问修饰符] 方法返回值 包名.类名.方法名(参数) execution( 方法修饰符 方法返回值 方法所属类 匹配方法名 ( 方法中的形参表 ) 方法申明抛出的异常 ) public void com.lgq.UserDao.save(..) 两个点代表任意参数 public void com.lgq.UserDao.save(*,Integer) “*”：代表一个任意类型的参数 public void com.lgq.UserDao.save(); ()匹配一个无参方法 具体还有 使用注解进行AOP开发 使用注解开发上面的XML配置的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 切面类：注解的切面类 * @author jt *///配置切面@Aspectpublic class MyAspectAnno &#123; // 切入点注解 //后面的方法随便定义，在增强方法中要对应 @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.find(..))&quot;) private void pointcut1()&#123;&#125; @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.save(..))&quot;) private void pointcut2()&#123;&#125; @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.update(..))&quot;) private void pointcut3()&#123;&#125; @Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.delete(..))&quot;) private void pointcut4()&#123;&#125; //前值增强 @Before(value=&quot;MyAspectAnno.pointcut2()&quot;) public void before()&#123; System.out.println(&quot;前置增强===========&quot;); &#125; // 后置通知: @AfterReturning(value=&quot;MyAspectAnno.pointcut4()&quot;,returning=&quot;result&quot;) public void afterReturning(Object result)&#123; System.out.println(&quot;后置增强===========&quot;+result); &#125; // 环绕通知: @Around(value=&quot;MyAspectAnno.pointcut3()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;环绕前增强==========&quot;); Object obj = joinPoint.proceed(); System.out.println(&quot;环绕后增强==========&quot;); return obj; &#125; // 异常抛出通知: @AfterThrowing(value=&quot;MyAspectAnno.pointcut1()&quot;,throwing=&quot;e&quot;) public void afterThrowing(Throwable e)&#123; System.out.println(&quot;异常抛出增强=========&quot;+e.getMessage()); &#125; // 最终通知 @After(value=&quot;MyAspectAnno.pointcut1()&quot;) public void after()&#123; System.out.println(&quot;最终增强============&quot;); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的代理模式]]></title>
    <url>%2F2019%2F02%2F01%2FJava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是代理&nbsp;&nbsp;假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子 代理模式的分类 远程代理模式：为不同地理的对象提供局域网代表对象（例子：通过远程代理可以监控各个店铺，使之可以直观的了解店里的情况） 虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建 (类似于新闻网站加载时，图片加载不出来先用一张空的图片代替) 保护代理：控制用户的访问权限 智能引用代理：提供对目标对象提供额外的服务或者减少特定的服务（火车票代售处） 两种实现方式静态代理&nbsp;&nbsp;代理和被代理对象在代理之前是确定的。他们都是实现相同的接口或者继承相同的抽象类。就比如已知一个汽车类并且也只到要有一个汽车的代理类，且它们实现相同接口或者继承相同抽象类。 继承的方式实现静态代理&nbsp;&nbsp;代理者继承被代理者，对所代理的方法进行改造 &nbsp;&nbsp;需求:一个汽车有一个move方法，方法中打印了移动中三个字并有一个行驶时间(通过Thread.sleep方法)，现在我们需要使用代理类算出移动时间并打印消息。 123456789101112131415161718192021222324252627282930313233343536373839404142//提供一个代理类和被代理类需要实现的接口public interface Movable &#123; void move();&#125;//创建一个Car并实现Movable接口public class Car implements Movable&#123; public void move() &#123; try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;移动中。。。&quot;); &#125;&#125;//使用继承方式//代理类继承被代理类，并重写其方法public class CarTimeProxy extends Car&#123; @Override public void move() &#123; long startTime=System.currentTimeMillis(); System.out.println(&quot;开始移动。。。&quot;); super.move(); long endTime=System.currentTimeMillis(); System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;); &#125;&#125;//客户端只需要创建代理类并实行代理类重写被代理类的方法public class Client &#123; public static void main(String[] args) &#123; CarTimeProxy carTimeProxy=new CarTimeProxy(); carTimeProxy.move(); &#125;&#125; 聚合的方式实现静态代理&nbsp;&nbsp;继承同一个接口，且代理对象持有被代理的对象 1234567891011121314151617181920212223242526//使用聚合方式构造代理对象public class CarTimeProxy implements Movable&#123; private Movable movable; public CarTimeProxy(Movable movable) &#123; this.movable = movable; &#125; public void move() &#123; long startTime=System.currentTimeMillis(); System.out.println(&quot;开始移动。。。&quot;); movable.move(); long endTime=System.currentTimeMillis(); System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;); &#125;&#125;//客户端先要构造car，再将car传入代理对象public class Client &#123; public static void main(String[] args) &#123; Car car=new Car(); CarTimeProxy carTimeProxy=new CarTimeProxy(car); carTimeProxy.move(); &#125;&#125; 聚合方式和继承方式哪个好呢？&nbsp;&nbsp;这时我们又新增了一个需求，我们需要给汽车再添加一个日志代理类，并在移动前后打印日志信息。 &nbsp;&nbsp;首先我们使用继承方式，那么我们只需要再创建一个日志代理类并继承于时间代理类就好了，代码如下: 12345678910//日志代理类public class CarTimeAndLogProxy extends CarTimeProxy &#123; @Override public void move() &#123; System.out.println(&quot;开始打印日志&quot;); super.move(); System.out.println(&quot;结束打印日志&quot;); &#125;&#125; &nbsp;&nbsp;但是这时候我们需求又变动了，我们需要先打印时间信息再打印日志信息，这时候继承方式的静态代理就显得很无力了。 &nbsp;&nbsp;所以我们推荐使用聚合式的静态代理，如下： 1234567891011121314151617181920212223//创建日志代理类并实现Movable接口public class CarLogProxy implements Movable &#123; private Movable movable; public CarLogProxy(Movable movable) &#123; this.movable = movable; &#125; public void move() &#123; System.out.println(&quot;开始打印日志&quot;); movable.move(); System.out.println(&quot;结束打印日志&quot;); &#125;&#125; //这时候我们只需要调换一下代理类的顺序就好 public static void main(String[] args) &#123; Car car=new Car(); CarLogProxy carLogProxy=new CarLogProxy(car); CarTimeProxy carTimeProxy=new CarTimeProxy(carLogProxy); carTimeProxy.move(); &#125; 动态代理&nbsp;&nbsp;来自静态代理的思考:静态代理是对特定类产生代理对象，但是就日志打印这个代理功能而言，成千上百的类都会用到日志打印，那么这时候如果我们使用静态代理的话，我们就要创建成千上百的代理类，这样会非常麻烦。 &nbsp;&nbsp;所以出现了动态代理：动态产生代理，实现对不同类和不同方法的代理。 JDK动态代理 创建事务处理器，实现InvocationHandler接口，覆写invoke方法 参数说明： proxy 代理对象 Method 被代理对象的方法 args 方法的参数 1invoke（Object proxy,Method method,Object[] args） 创建被代理的类以及接口 调用Proxy的静态方法，创建代理类（这个类是实现了被代理类的接口的） 参数说明： loader：被代理类的类加载器 interfaces：被代理类实现的接口 1newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) 事务处理器 通过代理调用被代理的方法 &nbsp;&nbsp;代码如下: 12345678910111213141516171819//创建一个Handler实现InvocationHandler//并重写invoke方法和创建Object对象存放被代理的对象(用来)public class TimeHandler implements InvocationHandler &#123; private Object target; public TimeHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long startTime=System.currentTimeMillis(); System.out.println(&quot;开始移动。。。&quot;);; method.invoke(target); long endTime=System.currentTimeMillis(); System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;); return null; &#125;&#125; cglib动态代理&nbsp;&nbsp;JDK只能代理实现了接口的类，cglib针对类来实现代理，对指定目标类产生一个子类，通过方法拦截技术拦截所有调用父类方法地调用。也因为cglib使用了继承的方式，所以它不能对final修饰的类进行代理。 &nbsp;&nbsp;需求:实现对火车类的日志代理 &nbsp;&nbsp;代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CglibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class clazz)&#123; //设置创建子类的类 enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; /** * 拦截所有目标类方法的调用 * obj 目标类的实例 * m 目标方法的反射对象 * args 方法的参数 * proxy代理类的实例 */ @Override public Object intercept(Object obj, Method m, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;日志开始...&quot;); //代理类调用父类的方法 proxy.invokeSuper(obj, args); System.out.println(&quot;日志结束...&quot;); return null; &#125;&#125;public class Train &#123; public void move()&#123; System.out.println(&quot;火车行驶中...&quot;); &#125;&#125;public class Client &#123; /** * @param args */ public static void main(String[] args) &#123; CglibProxy proxy = new CglibProxy(); Train t = (Train)proxy.getProxy(Train.class); t.move(); &#125;&#125; 参考&nbsp;&nbsp;本博文参考于Java的三种代理模式和慕课网的模式的秘密——代理模式课程]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring基于XML和注解的配置]]></title>
    <url>%2F2019%2F02%2F01%2FSpring%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Bean定义基于XML的配置12&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;&lt;/bean&gt; 基于注解的配置 @Component 在类上标注这个注解,且在XML上需要配置 1234567891011&lt;context:component-scan/&gt;&lt;!--类似这样--&gt;&lt;!--负责包扫描配置组件--&gt;&lt;context:component-scan base-package=&quot;com.lgq.cfw&quot;&gt; &lt;!--exclude不扫描有Controller注解的类--&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;!--只扫描控制器。 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; @Controller Web层 @Service Service层 @Repository DAO层 &nbsp;&nbsp;后面三个注解相当于@Component注解的分类，官方推荐使用后面三个，因为Spring会对这三个注解以后做扩展。 Bean名称基于XML的配置12345678910&lt;!--配置id或者name为...--&gt;&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;&lt;/bean&gt;&lt;!--类似这样--&gt;&lt;!--加载druid数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;&lt;/bean&gt; 基于注解的配置 @Component(“dataSource”) 配置一个id为dataSource的bean，这个类在IOC容器中的id就叫dataSource Bean注入基于XML的配置通过配置property属性或者p命名空间,例如 1234&lt;!-- 将所有mapper接口的实现类自动加入到ioc容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.lgq.cfw.dao&quot;/&gt;&lt;/bean&gt; 基于注解的配置 @AutoWired 按类型注入 @Qualifier 按名称注入 @Value 普通属性 @Resource 对象属性 生命过程，Bean作用范围基于XML的配置 生命周期 init-method, destory-method 范围 scope属性 基于注解的配置 @PostConstruct 初始化 相当于init-method @PreDestory 销毁 相当于 destory-method Scope 设置作用范围 适合场景基于XML的配置bean来自第三方 基于注解的配置bean的实现类由用户自己开发]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring中的IOC和DI]]></title>
    <url>%2F2019%2F02%2F01%2FSpring%E4%B8%AD%E7%9A%84IOC%E5%92%8CDI%2F</url>
    <content type="text"><![CDATA[IOC(控制反转)&nbsp;&nbsp;IOC(控制反转)，将对象的创建权反转交给了Spring。具体原理看这里Java中的反射和工厂模式 DI(依赖注入)&nbsp;&nbsp;这个就先得从依赖讲起 依赖 123456789Class A&#123;&#125;Class B&#123; public void xxx(A a)&#123; &#125;&#125; 继承 is a 1234567Class A&#123;&#125;Class B extends A&#123;&#125; 聚合 has a 例子: Spring配置文件,将name依赖于userDao 123&lt;bean id=&quot;userDao&quot; class=&quot;com.lgq.UserDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; useDao实现类 1234567891011public class UserDaoImpl implements UserDao &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类 1234567@Testpublic void test1()&#123; //创建Spring的工厂 ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); UserDao userDao=(UserDaoImpl)applicationContext.getBean(&quot;userDao&quot;); System.out.println(((UserDaoImpl) userDao).getName());&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的反射和工厂模式]]></title>
    <url>%2F2019%2F01%2F29%2FJava%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是反射&nbsp;&nbsp;反射之中包含了一个“反”的概念，所以要想解释反射就必须先从“正”开始解释，一般而言，当用户使用一个类的时候，应该先知道这个类，而后通过这个类产生实例化对象，但是“反”指的是通过对象找到类。 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; //正的方式创建对象 Person person=new Person(); //反的方式,使用Class的forName静态方法 Class&lt;?&gt; clazz1=Class.forName(&quot;com.lgq.Person&quot;); Object object1=clazz1.newInstance(); Person person1=(Person)object1; //反的方式,使用object的getClass方法 203. Class&lt;?&gt; clazz2=person.getClass(); Object object2=clazz2.newInstance(); Person person2=(Person)object2; //反的方式,使用Class的class方法 Class&lt;?&gt; clazz3=Person.class; Object object3=clazz3.newInstance(); Person person3=(Person)object3; &#125;&#125; 反射的作用&nbsp;&nbsp;那么现在可以发现，对于对象的实例化操作，除了使用关键字new之外又多了一个反射机制操作，而且这个操作要比之前使用的new复杂一些，可是有什么用？ &nbsp;&nbsp;对于程序的开发模式之前一直强调：尽量减少耦合，而减少耦合的最好做法是使用接口，但是就算使用了接口也逃不出关键字new，所以实际上new是造成耦合的关键元凶。 简单讲一下工厂模式简单工厂&nbsp;&nbsp;首先我们先来回顾一下以前我们使用过的简单工厂模式1234567891011121314151617181920212223242526272829303132333435363738public interface Fruit&#123; void eat();&#125;public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Apple&quot;); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Orange&quot;); &#125;&#125;public class FruitFactory&#123; public static Fruit createFruit(String fruitType)&#123; if (&quot;Apple&quot;.equals(fruitType))&#123; return new Apple(); &#125; else if (&quot;Orange&quot;.equals(fruitType))&#123; return new Orange(); &#125; else&#123; return null; &#125; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Fruit fruit=FruitFactory.createFruit(&quot;Apple&quot;); fruit.eat(); &#125;&#125; &nbsp;&nbsp;这里简单说一下工厂模式，以前我们new东西都是自己new，就像现实生活中，很久以前没有制作商品的工厂，那我们获取东西就要自己制造。例子：比如刀耕火种的时代，我们需要需要一把斧子，我们没有工厂，我们只能自己造，只能自己new出来。但是到了，封建时期直至现在，有很多作坊或者工厂，当我们需要某种东西的时候，我们只需要告诉工厂我们需要什么，工厂便会给我们造什么，其实这就相当于我们制造东西的权利交给了工厂，我们变成了客户，我们客户只关心产品之间地差异(产品生产出来的结果，我们获取到了什么产品)，而不是生产产品的过程，这个东西由工厂来负责，我们不关心了。 工厂方法模式&nbsp;&nbsp;这里我们再次思考一下，上面的代码我们不是一个制造水果的工厂吗？这时候作为客户的我们又想吃Pear了，那么我们的工厂又得重新编辑它的代码，这样就会非常麻烦(因为耦合),那么我们该怎么办呢？ &nbsp;&nbsp;这里我又想提到工厂模式了，工厂模式里面有个工厂方法，它是用来解决这个简单工厂模式不可拓展性的方法。比如，这时候我们把水果工厂给抽象出来，然后我们去具体实现这个水果工厂，比如说我们实现一个AppleFactory，一个OrangeFactory。这两个工厂作为我们默认的，一开始就有的，到后来我们需要添加水果的产品种类了，我们怎么办呢？比如我们添加一个Pear类，我们使Pear实现Fruit接口，然后创建一个PearFactory实现FruitFactory，然后客户端当创建一个工厂时就创建一个PearFactory，具体看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public interface Fruit&#123; void eat();&#125;public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Apple&quot;); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Orange&quot;); &#125;&#125;//这里创建一个Pear实现Fruit接口public class Pear implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Pear&quot;); &#125;&#125;//使FruitFactory抽象public abstract class FruitFactory&#123; abstract Fruit getInstance();&#125;//创建一个AppleFactory实现FruitFactorypublic class AppleFactory extends FruitFactory &#123; @Override Fruit getInstance() &#123; return new Apple(); &#125;&#125;public class OrangeFactory extends FruitFactory &#123; @Override Fruit getInstance() &#123; return new Orange(); &#125;&#125;//如果要新增产品，需要产品实现Fruit接口并且实现FruitFactory类public class PearFactory extends FruitFactory &#123; @Override Fruit getInstance() &#123; return new Pear(); &#125;&#125;//此时更换新增的需求时我们只需要new一个新的工厂public class Client &#123; public static void main(String[] args) &#123; Fruit fruit=new PearFactory().getInstance(); fruit.eat(); &#125;&#125; 抽象工厂模式&nbsp;&nbsp;说完工厂方法模式，顺便就讲一下抽象工厂模式吧，其实抽象工厂模式是工厂方法模式的一种推广，最明显的一点就是在工厂方法的类关系图中只有一类产品，他们实现了一个统一的接口，而抽象工厂有多个类别的产品，他们分别实现了不同的功能（多个接口）。其次的一点差别就是工厂本身所具有的方法数量不同，这点差异其实也是由第一点所导致的，工厂需要有生产不同类别产品的功能，如果抽象工厂中的产品的功能简化到一个，也便成为了工厂方法。 &nbsp;&nbsp;再来看选择的过程，在工厂方法中，客户关心的只不过是实现同一样功能的不同产品间的差异，这是一个一维选择的过程。 12IFactory factory = new FactoryA(); //选择了工厂即选择了产品IProduct productA = factory.Create(); //工厂只有一个Create方法，只能生产一种产品 &nbsp;&nbsp;而在抽象工厂中，客户首先要考虑的是需要哪一样功能，其次要考虑才是产品间的差异。也就是说这是一个二维选择的过程。 12IFactory factory = new FactoryA(); //选择了某个具体工厂IProduct productA = factory.CreateProductA(); //工厂具有多个Create方法，这里选择了其中的一个 &nbsp;&nbsp;由于产品类别的增加而导致客户在考虑产品间差异的同时还要考虑产品间功能的差异，这种二维选择的过程才是工厂方法与抽象工厂之间的本质区别。 &nbsp;&nbsp;举个肯德基与麦当劳的例子，假设原来只有一家快餐店叫做麦当劳，提供的食物（具体产品）有汉堡、可乐、薯条，它们都可以满足你吃东西（抽象接口）的需求，那么你想吃快餐的时候，唯一的选择就在于吃什么，是一维选择，现在又开了一家快餐店叫做肯德基，同样供应汉堡、可乐和薯条，那么现在你若打算吃快餐，除了考虑吃什么外，还要考虑去哪里吃–肯德基还是麦当劳？这便是二维的选择。通过横向与纵向的选择才能最终锁定你要的产品。 &nbsp;&nbsp;引入系列的概念，相互间具有差异的同一类别的产品称为不同的系列，如肯德基和麦当劳就是两个不同的系列。 &nbsp;&nbsp;这种选择的区别带来的另外一个后果就是产品间的差异（系列间的差异）变为客户的次要选择，而客户主要的精力放在了功能的选择上（类别的选择）。 &nbsp;&nbsp;其实可以这么理解，像工厂方法模式里面出现多个工厂是因为产品品种的变更，每个工厂决定了一个产品品种。而抽象工厂里面不只有一个产品品种，它是一个系列的，也就是所抽象工厂模式里面出现多个工厂是因为系列产品的变更。 反射对于工厂模式的优化&nbsp;&nbsp;我们回顾一下刚刚上面所讲的工厂模式，工厂方法模式解决了简单工厂模式的不可拓展性(其实抽象工厂跟工厂方法差不多，这里就以工厂方法模式举例) &nbsp;&nbsp;不可拓展的问题是得到解决了，我们再想一下，这样是否是真的完美了吗？当我们要创建一个新的品种的时候我们还需要去创建一个新品种的工厂并且实现原来的基类工厂(FruitFactory)，没新增一个我们就要实现一个，这样是不是太麻烦了。这时候，反射给我们提供了很好的解决办法。先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940public interface Fruit&#123; void eat();&#125;public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Apple&quot;); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Orange&quot;); &#125;&#125;//这里创建一个Pear实现Fruit接口public class Pear implements Fruit &#123; @Override public void eat() &#123; System.out.println(&quot;吃Pear&quot;); &#125;&#125;public class FruitFactory&#123; public static Fruit getInstance(String fruitType) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Fruit fruit=null; //利用反射 Class&lt;?&gt; clazz=Class.forName(fruitType); Object object=clazz.newInstance(); fruit=(Fruit)object; return fruit; &#125;&#125;public class Client &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException &#123; Fruit fruit=FruitFactory.getInstance(&quot;com.lgq.Pear&quot;); fruit.eat(); &#125;&#125; &nbsp;&nbsp;这时候是不是就方便很多了，我们不需要再创建具体类的工厂去实现基类工厂了，我们只需要创建具体类实现基类，然后客户把需求告诉工厂，工厂通过反射创建产品，工厂返回基类就行了。所以最终我们变换的只是那个newInstance方法的参数了，那是一个常量，我们完完全全就可以把它放到配置文件里面。 Spring IOC 和工厂模式&nbsp;&nbsp;放到配置文件里面，这有点像什么呢？对了！Spring的IOC。Spring里面有个bean工厂(BeanFactory),其实它也是利用反射的。我们来看一下Spring配置文件里面有个bean节点 1234567891011121314151617181920212223242526&lt;bean id=&quot;Person&quot; class=&quot;test.Person&quot;&gt; &lt;!-- 第一个bean，是一个Person类，id名字随便取，还要写上类的全名 --&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;小龙&lt;/value&gt; &lt;!-- 这里的名字是通过程序里面的set来赋值的，如果去掉程序对应的set，就出错了 --&gt; &lt;/property&gt; &lt;property name=&quot;age&quot;&gt; &lt;value&gt;23&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;grade&quot;&gt; &lt;!-- 这里有点特别，这个grade变量是一个对象，和一般的变量要区别对待 --&gt; &lt;ref local=&quot;Grade&quot;/&gt; &lt;!-- 这里指向了本配置文件里面一个名字叫Grade(即id=Grade)的bean --&gt; &lt;/property&gt; &lt;/bean&gt;&lt;bean id=&quot;Grade&quot; class=&quot;test.Grade&quot;&gt;&lt;!-- 同上 --&gt; &lt;property name=&quot;math&quot;&gt; &lt;value&gt;99&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;english&quot;&gt; &lt;value&gt;59&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &nbsp;&nbsp;我们是如何获取的12345678910 //加载Spring配置文件BeanFactory f = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //从BeanFactory获取对象，通过bean节点的id值，相当于map里面的key class值是valueObject o = f.getBean(&quot;Person&quot;);Person person = (Person)o; Grade grade=(Grade)f.getBean(&quot;Grade&quot;); //这时候Spring就为你自动装配了person和grade，且将property里面的值赋过去了 //我们此时可以调用person的get方法 System.out.println(person.getName()); //.......等等 &nbsp;&nbsp;其实这里面就用到了反射，这个BeanFactory获取到了Spring的配置文件，就会通过某种方法去解析xml文件(好像是SAX，具体还没看)，解析了xml文件后，BeanFactory就会获取bean节点的class值，使用这个class值通过反射去创建这个对象并放到容器中去，如果用户需要那么他直接调用getBean方法告诉他我要获取的bean的id值就行了。其实这就是Spring最基本的原理。 反射的一些高级应用&nbsp;&nbsp;Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method &nbsp;&nbsp;其中class代表的是 类对象，Constructor是类的构造器对象，Field是类的属性对象，Method是类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组成部分。 得到构造器的方法 1234567891011//获得使用特殊的参数类型的公共构造函数， Constructor getConstructor(Class[] params)//获得类的所有公共构造函数Constructor[] getConstructors() //获得使用特定参数类型的构造函数(与接入级别无关) Constructor getDeclaredConstructor(Class[] params)//获得类的所有构造函数(与接入级别无关)Constructor[] getDeclaredConstructors() 获得字段信息(属性) 1234567891011//获得命名的公共字段 Field getField(String name)//获得类的所有公共字段 Field[] getFields()//获得类声明的命名的字段 Field getDeclaredField(String name)//获得类声明的所有字段Field[] getDeclaredFields() 获得方法信息 1234567891011//使用特定的参数类型，获得命名的公共方法 Method getMethod(String name, Class[] params) //获得类的所有公共方法 Method[] getMethods()//使用特写的参数类型，获得类声明的命名的方法Method getDeclaredMethod(String name, Class[] params) //获得类声明的所有方法Method[] getDeclaredMethods()]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC——数据格式化与数据校验]]></title>
    <url>%2F2019%2F01%2F28%2FSpringMVC%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据格式化 对属性对象的输入/输出进行格式化（告诉后端前端页面是以什么格式书写属性的），如果请求的数据格式不是后端标识的格式则后端不能识别，将会报400请求错误，因为服务器无法解析请求(看不懂请求)，从其本质上讲属于”类型转换”范畴。 Spring 在格式化模块中定义了一个实现ConversionService接口的FormattingConversionService实现类，该类扩展了GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能 FormattingConversionService 拥有一个 FormattingConversionServiceFactroyBean 工厂类，后者用于在 Spring 上下文中构造前者 FormattingConversionServiceFactroyBean 内部已经注册了 : NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解 JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解 装配了 FormattingConversionServiceFactroyBean 后，就可以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了。mvc:annotation-driven/ 默认创建的ConversionService 实例即为FormattingConversionServiceFactroyBean 日期格式化&nbsp;&nbsp; @DateTimeFormat注解可对Date,Calendar,java.long.Long时间类型进行标注 pattern 属性：类型为字符串。指定解析/格式化字段数据的模式，如：”yyyy-MM-dd hh:mm:ss” iso 属性：类型为 DateTimeFormat.ISO。指定解析/格式化字段数据的ISO模式，包括四种：ISO.NONE（不使用） – 默认、ISO.DATE(yyyy-MM-dd) 、ISO.TIME(hh:mm:ss.SSSZ)、ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ) style 属性：字符串类型。通过样式指定日期时间的格式，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式：S：短日期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整日期/时间格式、-：忽略日期或时间格式 数值格式化&nbsp;&nbsp; @NumberFormat 可对类似数字类型的属性进行标注，它拥有两个互斥的属性： style：类型为 NumberFormat.Style。用于指定样式类型，包括三种：Style.NUMBER（正常数字类型）、Style.CURRENCY（货币类型）、 Style.PERCENT（百分数类型） pattern：类型为 String，自定义样式，如patter=”#,###”； 例子： 123456789@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)private Date birth;@NumberFormat(pattern=&quot;#,###,###.#&quot;)private Float salary;public Integer getId() &#123; return id;&#125; 数据校验(JSR303) JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 JSR 303 通过在 Bean 属性上标注类似于@NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证 JSR303注解： 使用 直接将注解加到Java bean中的某个要校验的属性上就行，但是也要在目标方法那个bean 类型前面加上@Valid注解,注意：需要校验数据的bean对象总是和其绑定结果对象或错误对象成对出现，他们之间不允许放入其他入参(他们要连在一起) 数据绑定流程 Spring MVC 通过反射机制对目标处理方法进行解析，将请求消息绑定到处理方法的入参中。数据绑定的核心部件是DataBinder，运行机制如下： &nbsp;&nbsp;所以说当进行数据格式化和数据校验时，最后如果是错误的，错误结果会存到BindingResult对象里面，它其实是个Errors对象，因为它继承了Errors 代码例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445 //COntroller层@RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.POST) //要检验的bean必须和BindingResult(Errors)绑定到一起，中间不能有其他入参public String save(@Valid Employee employee, Errors result, Map&lt;String, Object&gt; map)&#123; System.out.println(&quot;save: &quot; + employee); if(result.getErrorCount() &gt; 0)&#123; System.out.println(&quot;出错了!&quot;); for(FieldError error:result.getFieldErrors())&#123; System.out.println(error.getField() + &quot;:&quot; + error.getDefaultMessage()); &#125; //若验证出错, 则转向定制的页面 map.put(&quot;departments&quot;, departmentDao.getDepartments()); return &quot;input&quot;; &#125; employeeDao.save(employee); return &quot;redirect:/emps&quot;;&#125; //bean里面的属性@NotEmptyprivate String lastName;@Emailprivate String email;//1 male, 0 femaleprivate Integer gender;private Department department;@Past@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)private Date birth;@NumberFormat(pattern=&quot;#,###,###.#&quot;)private Float salary;public Integer getId() &#123; return id;&#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC的数据转换]]></title>
    <url>%2F2019%2F01%2F28%2FSpringMVC%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据转换&nbsp;&nbsp;Spring MVC 上下文中内建了很多转换器,可完成大多数Java类型的转换工作。 &nbsp;&nbsp;自定义类型转换器，ConversionService是Spring类型转换体系的核心接口。可以利用 ConversionServiceFactoryBean 在 Spring 的 IOC容器中定义一个 ConversionService. Spring 将自动识别出IOC 容器中的 ConversionService，并在 Bean 属性配置及Spring MVC 处理方法入参绑定等场合使用它进行数据的转换 &nbsp;&nbsp;可通过ConversionServiceFactoryBean 的 converters 属性注册自定义的类型转换器 123456789&lt;!-- 配置 ConversionService --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;employeeConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; Spring 支持的转换器Spring 定义了 3 种类型的转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到ConversionServiceFactroyBean 中： Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象 ConverterFactory：将相同系列多个 “同质” Converter 封装在一起。如果希望将一种类型的对象转换为另一种类型及其子类的对象（例如将 String 转换为 Number 及 Number 子类（Integer、Long、Double 等）对象）可使用该转换器工厂类 GenericConverter：会根据源类对象及目标类对象所在的宿主类中的上下文信息进行类型转换 123456789101112131415161718192021222324@Componentpublic class EmployeeConverter implements Converter&lt;String, Employee&gt; &#123; @Override public Employee convert(String source) &#123; if(source != null)&#123; String [] vals = source.split(&quot;-&quot;); //GG-gg@atguigu.com-0-105 if(vals != null &amp;&amp; vals.length == 4)&#123; String lastName = vals[0]; String email = vals[1]; Integer gender = Integer.parseInt(vals[2]); Department department = new Department(); department.setId(Integer.parseInt(vals[3])); Employee employee = new Employee(null, lastName, email, gender, department); System.out.println(source + &quot;--convert--&quot; + employee); return employee; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC——处理模型数据]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[ModelAndView 当控制器方法的返回值如果为ModelAndView，那么它既包含视图信息，也包含模型数据信息,其实如果返回String的话，他最终也会被SpringMVc转换成ModelAndView对象。 添加模型数据的方法 ModelAndView addObject(String attributeName,Object attributeValue) ModelAndView addAllObject(Map&lt;String,?&gt; modelMap) 设置视图 void setView(View view) void setViewName(String viewName) 例子: 1234567891011121314151617181920@Controller@RequestMapping(&quot;/user&quot;)public class TestController &#123; /** * 利用ModelAndView来转发数据,给前端视图 * @return modelAndView */ @RequestMapping(&quot;/testModelAndView&quot;) public ModelAndView testModelAndView() &#123; //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); //设置返回视图信息 modelAndView.setViewName(&quot;success&quot;); //添加模型数据 modelAndView.addObject(&quot;message&quot;, &quot;Hello World&quot;); return modelAndView; &#125; &#125; Map和Model Spring MVC 在内部使用了一个org.springframework.ui.Model 接口存储模型数据 Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。 如果方法的入参为Map或Model类型，Spring MVC 会将隐含模型的引用传递给这些入参。在方法体中，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据 @SessionAttributes注解 若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个 @SessionAttributes,Spring MVC 将在模型中对应的属性暂存到 HttpSession 中 该注解只能放在类的上面. 而不能修饰方法。 @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中 @SessionAttributes(types=User.class) 会将隐含模型中所有类型为 User.class 的属性添加到会话中。 @SessionAttributes(value={“user1”, “user2”}) 会将名字为user1和user2的属性添加到session对话中 @SessionAttributes(types={User.class, Dept.class})会将User类型和Dept类型的对象添加到会话中 @SessionAttributes(value={“user1”, “user2”}, types={Dept.class}) 会将名字为user1，user2还有类型为Dept的对象添加到session会话中 ModelAttribute的使用场景 比如当我们要修改一个user对象的属性，但是其中ID属性的值我们不能修改，这时我们可以先从数据库中拿到这个user对象，然后再把用户发送过来的修改请求赋值给这个user对象，(前端只对除ID属性以外的属性赋值修改了)这时我们拿到的就是ID没有被修改的user对象了 例子: 1234567891011121314151617181920 //被ModelAttribute修饰的方法会在每个目标方法执行之前被SpringMVC调用@ModelAttributepublic void getUser(@RequestParam(value=&quot;id&quot;,required=false) Integer id, Map&lt;String, Object&gt; map)&#123; System.out.println(&quot;modelAttribute method&quot;); if(id != null)&#123; //模拟从数据库中获取对象 User user = new User(1, &quot;Tom&quot;, &quot;123456&quot;, &quot;tom@atguigu.com&quot;, 12); System.out.println(&quot;从数据库中获取一个对象: &quot; + user); map.put(&quot;user&quot;, user); &#125;&#125;@RequestMapping(&quot;/testModelAttribute&quot;)public String testModelAttribute(User user)&#123; System.out.println(&quot;修改: &quot; + user); return SUCCESS;&#125; 运行流程： ModelAttribute修饰的方法先从数据库中获取要修改的user对象，并把这个对象放入Map中，键为user SpringMVC从map中取出键为user的对象，并将用户输入的修改的值赋给这个对象的相应属性 SpringMVC将这个被赋值好的对象传到目标方法的入参中 放入map的对象的键值要和目标方法第一个字母小写的String值要相同 SpringMVC 确定目标方法 POJO 类型入参的过程 调用 @ModelAttribute 注解修饰的方法. 实际上把 @ModelAttribute 方法中 Map 中的数据放在了 implicitModel 中. 确定一个 key: 若目标方法的 POJO 类型的参数木有使用 @ModelAttribute 作为修饰, 则 key 为 POJO 类名第一个字母小写 若使用了 @ModelAttribute 来修饰, 则 key 为 @ModelAttribute 注解的 value 属性值. 在 implicitModel 中查找 key 对应的对象, 若存在, 则作为入参传入 若在 @ModelAttribute 标记的方法中在 Map 中保存过, 且 key 和 1 确定的 key 一致, 则会获取到. 若 implicitModel 中不存在 key 对应的对象, 则检查当前的 Handler 是否使用 @SessionAttributes 注解修饰, 若使用了该注解, 且 @SessionAttributes 注解的 value 属性值中包含了 key, 则会从HttpSession 中来获取 key 所对应的 value 值, 若存在则直接传入到目标方法的入参中. 若不存在则将抛出异常. 若 Handler 没有标识 @SessionAttributes 注解或 @SessionAttributes 注解的 value 值中不包含 key, 则 会通过反射来创建 POJO 类型的参数, 传入为目标方法的参数 SpringMVC 会把 key 和 POJO 类型的对象保存到 implicitModel 中, 进而会保存到 request 中. ModelAttribute修饰方法的入参 ModelAttribute修饰的POJO类型入参有个value值，SpringMVC会通过value值为key在implicitModel中查找对应的属性，若存在，则把这个属性直接赋值给目标方法入参(POJO对象)。 若不存在，则SpringMVC会以value为key，POJO入参为value存入Request中]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中POJO对象和Servlet API作为入参]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E4%B8%ADPOJO%E5%AF%B9%E8%B1%A1%E5%92%8CServlet-API%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82%2F</url>
    <content type="text"><![CDATA[使用POJO对象绑定请求参数值 Spring MVC 会按请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel 等 例子： Controller层代码12345@RequestMapping(value = &quot;testPOJO&quot;,method = RequestMethod.POST)public String testPOJO(User user)&#123; System.out.println(user.toString()); return TEST;&#125; jsp页面代码1234567891011&lt;form action=&quot;testPOJO&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt; &lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;address.province&quot; placeholder=&quot;省份&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;address.city&quot; placeholder=&quot;城市&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;TestPOJO&quot;&gt;&lt;/form&gt; 使用Servlet API作为入参 例子:1234567891011121314151617181920 /** * 可以使用 Serlvet 原生的 API 作为目标方法的参数 具体支持以下类型 * * HttpServletRequest * HttpServletResponse * HttpSession * java.security.Principal * Locale InputStream * OutputStream * Reader * Writer * @throws IOException */ @RequestMapping(&quot;/testServletAPI&quot;) public void testServletAPI(HttpServletRequest request, HttpServletResponse response, Writer out) throws IOException &#123; System.out.println(&quot;testServletAPI, &quot; + request + &quot;, &quot; + response); out.write(&quot;hello springmvc&quot;);// return SUCCESS; &#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的RequestParam注解]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E4%B8%AD%E7%9A%84RequestParam%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[请求处理方法签名 Spring MVC 通过分析处理方法的签名，将HTTP 请求信息绑定到处理方法的相应入参中 Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名。 必要时可以对方法及方法入参标注相应的注解（@PathVariable、@RequestParam、@RequestHeader 等）、Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理 使用@RequestParam绑定请求参数值 在处理方法入参使用 @RequestParam 可以把请求参数传递给请求方法 value:参数名 required:是否必须。默认为true，表示请求参数中必须包含对应的参数，若不存在，将抛出异常,网页中会报400请求错误。但是，当required设置为false时，方法参数为int型这种基本类型参数时，访问URL时不加参数值会报500服务器错误，解决方法是给RequestParam加一个defaultValue值。因为，如果参数是非必需的，则会赋值为null，所以参数应该是一个object对象，它才能接受这个null值。 1234567//这里RequestParam的value值id其实指的是传过来的参数，即url上带的参数//当RequestParam不写的时候其实跟写了这个注解加上required=false是一样的，但是为了阅读方便，一般都加上@RequestMapping(value = &quot;/testRequestParam&quot;,method = RequestMethod.GET)public String testRequestParam(@RequestParam(value = &quot;id&quot;,required = false) int id)&#123; System.out.println(&quot;参数为:&quot;+id); return TEST;&#125; 相类似的RequestHeader和CookieValue注解1234567891011121314151617181920/** * 了解: * * @CookieValue: 映射一个 Cookie 值. 属性同 @RequestParam */@RequestMapping(&quot;/testCookieValue&quot;)public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123; System.out.println(&quot;testCookieValue: sessionId: &quot; + sessionId); return SUCCESS;&#125;/** * 了解: 映射请求头信息 用法同 @RequestParam */@RequestMapping(&quot;/testRequestHeader&quot;)public String testRequestHeader( @RequestHeader(value = &quot;Accept-Language&quot;) String al) &#123; System.out.println(&quot;testRequestHeader, Accept-Language: &quot; + al); return SUCCESS;&#125;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的RequestMapping注解]]></title>
    <url>%2F2019%2F01%2F27%2FSpringMVC%E4%B8%AD%E7%9A%84RequestMapping%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[使用@RequestMapping注解映射请求 Spring MVC使用 @RequestMapping 注解为控制器指定可以处理哪些URL请求 这个注解在控制器的类定义和方法定义处都可标注，类定义处提供初步的请求映射信息，相对于WEB应用的根目录，方法处提供进一步的细分信息，若类定义处未标注 @RequestMapping ，则方法处标记的URL相对于WEB应用的根目录 DispatcherServlet 截获请求后，就通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理方法。 映射请求参数、请求方法或请求头 @RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求 @RequestMapping 的 value、method、params 及 heads 分别表示请求 URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可让请求映射更加精确化。 params 和 headers支持简单的表达式： – param1: 表示请求必须包含名为 param1 的请求参数 – !param1: 表示请求不能包含名为 param1 的请求参数 – param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1 – {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2 的两个请求参数，且 param1 参数的值必须为 value1 例子 123456@RequestMapping(value = &quot;testParamsAndHeaders&quot;, params = &#123; &quot;username&quot;, &quot;age!=10&quot; &#125;, headers = &#123; &quot;Accept-Language=en-US,zh;q=0.8&quot; &#125;)public String testParamsAndHeaders() &#123; System.out.println(&quot;testParamsAndHeaders&quot;); return SUCCESS;&#125; 支持ant风格的资源地址 Ant 风格资源地址支持 3 种匹配符： – ?：匹配文件名中的一个字符 – *：匹配文件名中的任意字符 – ： 匹配多层路径 例子： “/testAntPath/*/abc” 等等 @PathVariable 映射URl绑定占位符 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过 @PathVariable(“xxx“) 绑定到操作方法的入参中。 例子： 12345678910/** * @PathVariable 可以来映射 URL 中的占位符到目标方法的参数中. * @param id * @return */@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)public String testPathVariable(@PathVariable(&quot;id&quot;) Integer id) &#123; System.out.println(&quot;testPathVariable: &quot; + id); return SUCCESS;&#125; REST风格的URL REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。 表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。 状态转化（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Rest 风格的 URL. 以 CRUD 为例: * 新增: /order POST * 修改: /order/1 PUT update?id=1 * 获取:/order/1 GET get?id=1 * 删除: /order/1 DELETE delete?id=1 * 如何发送 PUT 请求和 DELETE 请求呢 ? 1. 需要配置 HiddenHttpMethodFilter 2. 需要发送 POST 请求 * 3. 需要在发送 POST 请求时携带一个 name=&quot;_method&quot; 的隐藏域, 值为 DELETE 或 PUT * * 在 SpringMVC 的目标方法中如何得到 id 呢? 使用 @PathVariable 注解 * */@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.PUT)public String testRestPut(@PathVariable Integer id) &#123; System.out.println(&quot;testRest Put: &quot; + id); return SUCCESS;&#125;@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String testRestDelete(@PathVariable Integer id) &#123; System.out.println(&quot;testRest Delete: &quot; + id); return SUCCESS;&#125;@RequestMapping(value = &quot;/testRest&quot;, method = RequestMethod.POST)public String testRest() &#123; System.out.println(&quot;testRest POST&quot;); return SUCCESS;&#125;@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.GET)public String testRest(@PathVariable Integer id) &#123; System.out.println(&quot;testRest GET: &quot; + id); return SUCCESS;&#125; //页面代码 &lt;form action=&quot;springmvc/testRest/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;TestRest PUT&quot;/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;form action=&quot;springmvc/testRest/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;TestRest DELETE&quot;/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;form action=&quot;springmvc/testRest&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;TestRest POST&quot;/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;springmvc/testRest/1&quot;&gt;Test Rest Get&lt;/a&gt; //在web.xml中配置filter &lt;!-- 配置 org.springframework.web.filter.HiddenHttpMethodFilter: 可以把 POST 请求转为 DELETE 或 POST 请求 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; HiddenHttpMethodFilter：浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与DELETE 请求。]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中单例模式的饿汉与懒汉]]></title>
    <url>%2F2019%2F01%2F27%2FJava%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%A5%BF%E6%B1%89%E4%B8%8E%E6%87%92%E6%B1%89%2F</url>
    <content type="text"><![CDATA[单例模式&nbsp;&nbsp;有些对象我们只需要一个，如：配置文件、工具类、线程池、缓存、日志对象等。 &nbsp;&nbsp;如果创造出多个实例，就会导致许多问题,比如占用过多资源，不一样的结果等。 饿汉模式 将构造方法私有化，不允许外部直接访问。 1private Singleton()&#123;&#125; 创建 类的唯一实例, 使用private static修饰。 1private static Singleton instance=new Singleton(); 提供一个用于获取实例的方法, 使用public static修饰。 123public static Singleton getInstance()&#123; return instance;&#125; 懒汉模式 将构造方法私有化，不允许外边直接创建对象。 123 private Singleton2()&#123;&#125;``` 2. 声明 类的唯一实例，使用private static修饰。 private static Singleton2 instance; 13. 提供一个用于获取实例的方法，使用public static修饰。 public static Singleton2 getInstance(){ if(instance==null){ instance=new Singleton2(); } return instance; }` 饿汉模式与懒汉模式的区别 饿汉模式 &nbsp;&nbsp;加载类时比较慢，但运行时获取对象的速度比较快，线程安全 懒汉模式 &nbsp;&nbsp;加载类时比较快，但运行时获取对象的速度比较慢，线程不安全]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS中的定位]]></title>
    <url>%2F2019%2F01%2F26%2FCSS%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[position属性&nbsp;&nbsp;通过设置定位将页面中的元素摆放到页面的任意位置，我们使用position属性来设置元素的定位 static&nbsp;&nbsp;默认值，元素没有开启定位 relative&nbsp;&nbsp;开启元素的相对定位 absolute&nbsp;&nbsp;开启元素的绝对定位 fixed&nbsp;&nbsp;开启元素的固定定位 偏移量 left top right bottom 一般情况我们只设置一个水平偏移量和垂直偏移量，用这两个偏移量来确定元素的位置。 相对定位 开启相对定位时如果不设置偏移量，元素不会发生任何变化 相对定位元素相对于其自身原来在文档流中的位置来定位 相对定位的元素不会脱离文档流 box2开启向对定位且向右偏移box3宽度的像素，但是box3没有向上顶，原因就是原来box2还在文档流中 相对定位不会改变元素的性质，块级元素还是块级元素，内联元素还是内联 相对定位的元素会提升一个层级 此时box2开启相对定位，它把box3给覆盖了一些，说明box2比box3高了一个层级 绝对定位 元素设置成绝对定位以后，如果不设置偏移量，元素位置不会发生改变 绝对定位的元素是相对于距离他最近的开启了定位的祖先元素进行定位的，如果所有祖先元素都没有开启定位，则相对于浏览器窗口进行定位 box1为box4的父元素，box1开启定位，box4开启绝对定位，则他的偏移量是根据box1的位置来定的，也就是最近的开启了定位的祖先元素。 绝对定位会完全脱离文档流 绝对定位会改变元素的性质。内联变成块元素，块元素的高度和宽度都被内容撑开，并且不独占一行(脱离文档流的特点，浮动也有) 绝对定位会使元素提升一个层级 固定定位&nbsp;&nbsp;固定定位是一种特殊的绝对定位，他的特点大部分和绝对定位一样，但是不同的是，固定定位的元素永远都是相对于浏览器窗口进行定位的，并且不会随滚动条滚动(用来实现广告窗口，固定导航条等) 层级&nbsp;&nbsp;在一般开启定位之后，开启定位的元素会提升一个层级，也就是它会覆盖上面的元素，如果两个元素都开启了定位，那么后面的元素就会覆盖前面的元素，那么如果我们想前面的元素覆盖上面的元素，我们可以通过设置z-index属性来做到。 &nbsp;&nbsp;z相当于z轴，因为层级已经不是水平方向的了，一般我们给z-index设置整数，整数越大，层级越高。 opacity&nbsp;&nbsp;当元素出现了层级的概念之后，opacity也很好理解了，比如我们设置了box4是覆盖box1的，但是我们想通过box4来看到box1，那么我们可以通过设置opacity属性来设置box4的透明度。 &nbsp;&nbsp;opacity值在0~1之间，0是全透明，1是不透明，0.5就是半透明。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS的盒子模型]]></title>
    <url>%2F2019%2F01%2F25%2FCSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是盒子模型&nbsp;&nbsp;CSS中将每个元素都设置为了一个矩形的盒子来方便页面的布局，所以当这些元素都变成了盒子之后，我们的布局就变成了在页面中摆放盒子 内容(content)&nbsp;&nbsp;元素的所有子元素都是放在父元素的内容区中 &nbsp;&nbsp;内容区有宽度和高度——width，height 内边距(padding)&nbsp;&nbsp;内边距指的是内容区和边框区之间的距离，内边距会影响盒子的大小。 此时box1原本高度宽度只有10px，设置内边距之后整个盒子可见框的大小就发生变化了，而且元素的背景颜色延伸到了内边距。 其中属性有五种 padding 当只设置一个值的时候这个值则是给上右下左都设置了 当设置两个值时，第一个值是上下，第二个值是左右 当设置三个值时，第一个值是上，第二个值是左右，第三个值是下 当设置四个值时，就是上右下左 padding-top padding-right padding-bottom padding-left 边框&nbsp;&nbsp;整个盒子的可见框大小是由内容区、内边距区，边框区决定的 &nbsp;&nbsp;设置边框需要设置三个样式。他们分别是border-width，border-color，border-style border-width设置的是边框的宽度 border-color设置的是边框的颜色 border-style设置的是边框的样式，一般有solid实线，dotted点线，dashed虚线等等 &nbsp;&nbsp;通过使用border直接给边框三个属性赋值，例:border: 1px solid red;&nbsp;三个属性没有顺序要求 外边距外边距的简述和语法规范&nbsp;&nbsp;外边距是盒子和其他盒子之间地距离，外边距不会影响可见框的大小，但是会影响盒子的位置。 &nbsp;&nbsp;外边距也具有四个方向，语法跟padding相类似。 &nbsp;&nbsp;margin值：单独将左右外边距设置为auto，则会将左右外边距设置为最大值 &nbsp;&nbsp;如果同时将左右外边距设置为auto，则他的左右外边距会相同，所以一般我们会通过这种方式使一个子元素在他的父元素中水平居中&nbsp;&nbsp;margin:0 auto &nbsp;&nbsp;外边距可以设置为负值，则元素会向相反方向移动 外边距的重叠和取和现象&nbsp;&nbsp;相邻元素的外边距会取最大值 上面两张图我们可以看见box1和box2之间地margin值重叠在了一起，所以他们之间地margin值取得是最大的那一个 &nbsp;&nbsp;子元素的外边距会传给父元素 上图我们可以知道box1把外边距传给了他的父元素box3 &nbsp;&nbsp;另外一个就是水平外边距不会重叠，他们会取和 内联元素的盒子模型内联元素的width和height&nbsp;&nbsp;内联元素是不支持宽高属性的! 内联元素的padding&nbsp;&nbsp;内联元素支持水平方向的padding &nbsp;&nbsp;内联元素也支持垂直方向的padding但是不会影响布局 内联元素的border&nbsp;&nbsp;支持四个方向的边框，但是垂直的边框不会影响布局 内联元素的margin&nbsp;&nbsp;支持水平方向的外边距，不支持垂直方向上的 盒模型相关的样式display&nbsp;&nbsp;display决定元素的显示方式 none&nbsp;&nbsp;当属性值为none时，这个元素不会在页面中显示且不会占据页面的位置 block&nbsp;&nbsp;元素作为块元素显示 inline&nbsp;&nbsp;元素作为内联元素显示 inline-block&nbsp;&nbsp;作为行内块元素显示，具有块元素和内联元素的特点——能进行宽高的设置，不会进行换行 visibility&nbsp;&nbsp;visibility属性设置元素是否在页面中显示 visible&nbsp;&nbsp;默认值，元素可以正常显示 hidden&nbsp;&nbsp;元素不在页面中显示，但是依然在页面占据着它原来的空间 overflow&nbsp;&nbsp;overflow设置元素如何处理溢出内容 visible&nbsp;&nbsp;默认值，子元素溢出的东西会在父元素以外的地方显示 hidden 溢出内容会被隐藏 scroll 会添加滚动条显示溢出内容不管内容是否溢出都会添加滚动条 auto&nbsp;&nbsp;根据需要自动生成滚动条 文档流概念文档流指的是网页中的一个位置 文档流是网页的基础，是网页的最底层，所有的元素默认都是在文档流中排列 元素在文档流中默认自左向右，自上向下排列（和我们的书写习惯一致） 块元素 块元素在文档流中自上向下排列 块元素在文档流中宽度默认是父元素的100% 块元素在文档流中高度默认被内容撑开 内联元素 内联元素在文档流中自左向右排列，如果一行中不足以容下所有的内联元素，则换到下一行，继续自左至右排列 内联元素在文档流中宽度和高度默认都被内容撑开]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS的浮动]]></title>
    <url>%2F2019%2F01%2F24%2FCSS%E2%80%94%E7%9A%84%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[如何使用&nbsp;&nbsp;使用float属性给元素设置浮动效果 可选值： none &nbsp;&nbsp;默认值,不浮动，元素还在文档流中 left &nbsp;&nbsp;元素向左浮动 right &nbsp;&nbsp;元素向右浮动特点 元素浮动以后会脱离文档流 浮动以后会向父元素的最上方移动 知道遇到父元素的边框或者其他的浮动元素，会停止移动 首先我们看一下当元素在文档流中，比如div元素在页面的布局 此时div是垂直排列的，因为这是块级元素的特点——块级元素在文档流中默认垂直排列 但是如果我们向让他们水平排列怎么办呢？ 可以把块级元素的display属性设置为inline-block（行内块状元素）。 还有一种就是将元素脱离文档流，此时元素就不会受到文档流的约束。 如果浮动元素上边是个块元素，则浮动元素不会覆盖块元素 这里将box1的浮动效果注释掉，可以看到box2和box3元素被box1元素向墙一样堵住了从而不能浮动上去。 浮动元素不会超过他上边的浮动的兄弟元素，最多对齐 我们把box1，box2的宽度调大使一行里面容不下两个浮动元素，我们再设置box3为右浮动，但是此时我们发现box3不会浮动到最上边，它没有超过上边的浮动元素。 浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果 浮动以后元素的特点块元素不会独占一行，宽度和高度都被内容撑开 内联元素内联元素脱离文档流以后会变成块元素]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的私有构造方法和单例模式]]></title>
    <url>%2F2019%2F01%2F09%2FJava%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[私有构造方法&nbsp;&nbsp;这几天在学习Netty写聊天室的时候看见了一个例子，在例子中的代码使用到了Java的单例模式，基础不是太好，所以特意去搜索了解了一下单例模式。 本文参考于 构造方法私有化和单例模式 &nbsp;&nbsp;写单例模式之前先说一下私有构造方法，即在构造方法之前加上private关键字 12345public class Test&#123; private Test()&#123; &#125;&#125; &nbsp;&nbsp;这时我们定义了构造方法的私有化，如果我们在别的类中实例化Test则会报错，因为私有的方法在其他类中是无法看见的 12345public class Test1&#123; public static void main(String[] args)&#123; Test test=new Test(); &#125;&#125; &nbsp;&nbsp;这时候会报错，因为Test1访问不到Test的私有构造方法 如何去解决呢？&nbsp;&nbsp;解决的方法也简单，因为是私有的构造方法，所以我们可以通过在本类里实例化Test，将Test的实例设置为私有静态变量，再构造这个实例的get方法，那么其他类就可以通过这个类的静态方法getInstance()方法获取要获取的类的实例了。 12345678910111213141516171819202122public class Test()&#123; private Test()&#123; &#125; //创建静态对象instance private static Test instance=new Test(); //通过get方法获取instance实例 public static Test getInstance()&#123; return instance; &#125; public void print()&#123; System.out.println(&quot;Hello!&quot;); &#125;&#125;public class Test1&#123; public static void mian()&#123; //通过调用Test的静态方法获取实例 Test test=Test.getInstance(); test.print(); &#125;&#125; &nbsp;&nbsp;代码运行结果就是Hello! 为什么要这么做呢&nbsp;&nbsp;我们先把上面的Test1的代码改一下1234567891011public class Test1&#123; public static void mian()&#123; //通过调用Test的静态方法获取实例 Test test=Test.getInstance(); Test test1=Test.getInstance(); Test test2=Test.getInstance(); Test test3=Test.getInstance(); //后面一些实例调用print方法就不一一列出来了.... test.print(); &#125;&#125; &nbsp;&nbsp;这时候我们实例化了四个Test，我们再回头看看刚刚Test的代码1234567891011121314public class Test()&#123; private Test()&#123; &#125; //创建静态对象instance private static Test instance=new Test(); //通过get方法获取instance实例 public static Test getInstance()&#123; return instance; &#125; public void print()&#123; System.out.println(&quot;Hello!&quot;); &#125;&#125; &nbsp;&nbsp;我们所有实例化都是通过getInstance方法获取的，但是getInstance方法获取的都是一个instance对象，也就是说我们实例化了那么多Test也只是对instance这个对象的引用。所以如果现在不希望一个类产生过多的对象的话，则必须采用单例设计模式，而且，在以后的java学习中，在支持java的类库中，大量采用了这种模式。 如何理解&nbsp;&nbsp;在window中有一个回收站，除了桌面有回收站，每个硬盘都有回收站，实际上每个硬盘上的回收站和桌面的回收站是同一个，也就是说，整个操作系统只有一个回收站实例，各个地方只是引用这个实例而已。 总结单例设计模式核心就是将类的构造方法私有化，之后在类的内部产生实例化对象，并通过类名引用类的静态方法（static）返回实例化对象的引用。]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC核心配置文件的解析和应用]]></title>
    <url>%2F2018%2F12%2F14%2FSpringMVC%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用maven导入包&nbsp;&nbsp;这里我使用的是maven导入jar包，以前不知道maven，感觉导入jar包时特别麻烦，现在好了，直接Ctrl+c，Ctrl+v就完事了。 配置SpringMVC的jar包 &nbsp;&nbsp;SpringMVC所需要的jar包叫做 spring-webmvc.jar。这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。这里给出spring-webmvc在pom.xml中的代码，大家也可以自己在maven中央仓库中查找1234567&lt;!-- 依赖Spring MVC--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt;+ 配置Servlet的jar包&nbsp;&nbsp;SpringMVC是以Servlet为基础的，这里当然不能少了Servlet的配置，关于Servlet和SpringMVC的关系在接下来的博客里会有所涉及。这里给出servletz在pom.xml中的代码，大家也可以自己在maven中央仓库中查找12345678 &lt;!--servlet的配置--&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;## 在web.xml中配置dispatcherServletdispatcherServlet是前端控制器设计模式的实现，提供SpringWebMVC的集中访问点，而且负责职责的分派，而且与spring IOC容器无缝集成，从而可以获得Spring的优势。其主要职责是调度工作，本身用于控制流程。1.文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；2.通过HandlerMapping，将请求映射到处理器(返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器)；3.通过handlerAdapter支持多种类型的处理器(handlerExceptionChain中的处理器)；4.通过ViewResolver解析逻辑视图名到具体视图实现；5.本地化解析；6.渲染具体的视图等；7.如果执行过程中遇到异常将交给handlerExceptionResolver来解析；可以说dispatcherServlet是SpringMVC的核心 下面是dispatcherServlet在web.xml中的相关配置 12345678910111213&lt;!-- springmvc的前端控制器，拦截所有请求 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- Map all requests to the DispatcherServlet for handling --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;&lt;!--这里设为拦截所有请求，可以根据自己需求设置--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; dispatcherServlet文件一般默认在WEB-INF目录下面，如果需要更改则通过在servlet的初始参数里面修改contextConfigLocation的值，例如: 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;自己设定的路径&lt;/param-value&gt;&lt;/init-param&gt; 配置dispatcherServlet-servlet.xml&nbsp;&nbsp;如果按照默认的话对应的dispatcherServlet文件会以dispatcherServlet-servlet.xml放在WEB-INF目录下面 首先给出基本的dispatcherServlet的配置代码 1234567891011121314151617&lt;!--SpringMVC的配置文件，包含网站跳转逻辑的控制，配置 --&gt;&lt;context:component-scan base-package=&quot;com.lgq&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--只扫描控制器。 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--配置视图解析器，方便页面返回 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--两个标准配置 --&gt;&lt;!-- 将springmvc不能处理的请求交给tomcat --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 能支持springmvc更高级的一些功能，JSR303校验，快捷的ajax...映射动态请求 --&gt;&lt;mvc:annotation-driven/&gt; &nbsp;&nbsp;以上就是SpringMVC的基本配置，其中一些细节方面的会慢慢在以后的博文里面说明]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中==与equals的区别]]></title>
    <url>%2F2018%2F12%2F11%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD-%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[基本数据类型和引用数据类型 &nbsp;&nbsp;在谈==与equals区别之前，我们先来谈一谈java中堆和栈的区别，还有基本数据类型和引用数据类型的区别。 基本数据类型有什么? &nbsp;&nbsp;八个基本数据类型：byte，short，int，long，float，double，char，boolean 引用数据类型是什么? &nbsp;&nbsp;引用数据类型是：类，接口，数组 &nbsp;&nbsp;具体参考下图 引用数据类型，基本数据类型和堆栈之间的关系 引用类型的变量，其内存分布在堆上或者常量池(字符串变量、基本数据类型常量)，需要通过new等方式来创建。堆内主要存放运行时，需要new来创建的对象。 基本数据类型变量(8种基本数据类型)以及对象的引用变量，其内存分布在栈上，变量出了作用域就会自动释放。 如下图: Java中==和equals()与上述两者的关系 ==操作的是栈内存中的值是否相等 equals比较的是堆内存中的值是否相等。 下面我们通过一些实例来证明： 比较两个基本数据类型 输出结果为: a==b &nbsp;&nbsp;可见==b比较的是栈中的内容,a和b栈中都存放了1所以相等 比较两个字符串 输出结果为: a==b 输出结果为: a.equals(b) &nbsp;&nbsp;在这个例子中，我们看到==和equals的作用是相同的，a==b说明a和b引用了同一个String对象。a.equsls(b)说明a和b指向的对象在堆中存储的内容相同。即a和b指向同一个对象。为什么会这样呢，因为Stirng对象在创建时，会现在String缓冲池中查看是否有相同的对象，如果有，则不创建。 当再新建一个String对象 输出结果为: a.equals(b) a!=b &nbsp;&nbsp;此时字符串a，b为不同的对象。equals比较的是堆中的内容，a和b堆中内容都是123，所以输出a.equals(b)。而又a，b不是同一个对象。所以a，b的栈中存储的地址不一样，而==又是比较栈中内容所以输出a!=b。 总结:&nbsp;&nbsp;==比较的是栈中的内容，即两个对象的地址是否为同一个。equals比较的是堆中内容是否相等，即两个对象的内容是否相同。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F12%2F01%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[我的第一篇博客 建站&nbsp;&nbsp;一开始接触Markdown编辑器有些不适应，但是语法学起来不难，上手很快。可能一开始博文的格式会有些不尽人意，希望大家理解。 &nbsp;&nbsp;前天开始搭的博客，踩了一天的坑。昨天狠下心重新开始建站，长痛不如短痛，果然之前解决不了的评论系统，现在几行代码就完事了,感谢next，感谢开源。 &nbsp;&nbsp;之前博客的评论系统是用的来比力的，因为来比力实在是太慢了，无奈只能摒弃。昨天发现一个很友好的评论系统———valine，速度快了很多，也方便了许多，希望大家在我的文章下面多多留言评论，别让它成为一个死站了，哈哈。 愿身后总有力量&nbsp;&nbsp;昨天收到了学校一个技术小组的录取通知，两个月的任务考核，最后做后端的只有我审核通过了(虽然也就六个人)，算是给自己的肯定吧。希望以后一切顺利。 &nbsp;&nbsp;昨天女朋友开始撒起娇来，说我光顾着学习不理她。她真的好可爱，也好懂事，昨夜想了很久，一时也不知道怎么处理好女朋友和生活学习的关系了，只希望她能一直在我身边。 &nbsp;&nbsp;妈妈昨天给我发了微信，今天早上才想起来回。她说：你是不是光顾着谈恋爱了。哈哈，其实不是的，这两天搭博客，无数次跳坑填坑的，真的忘了回。 &nbsp;&nbsp;但是，这些都是以后会陪伴我的人，给自己一个警醒吧，以后工作学习之余，一定要多陪陪他们。 一条路走到黑就到这吧。以后加油。]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
</search>
