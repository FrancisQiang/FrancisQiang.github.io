<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java8新特性——接口中的static，default方法</title>
      <link href="/2019/06/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84static%EF%BC%8Cdefault%E6%96%B9%E6%B3%95/"/>
      <url>/2019/06/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84static%EF%BC%8Cdefault%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h2><p> 这些天在看ES6的语法，包括我以前学了一段时间的dart，这两门语言中都涉及到函数式编程，想想我对Java中的函数式编程还是不太了解，最近开始学习Java8的一些新特性，反正语言都差不多，一起学习好了。</p><p> 在java8中新增了default方法，这个方法可以定义在接口中，其实就是在接口中定义了默认方法，这些默认方法可以在接口中就已经实现。</p><p> 我看的是github上的<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="noopener">Java8——tutorial</a>,原文是英文的，其实理解起来不难。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(formula.calculate(<span class="number">5</span>));</span><br><span class="line">   <span class="comment">// 未实现也可以直接使用</span></span><br><span class="line">   System.out.println(formula.sqrt(<span class="number">5</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h2><p>  上面就已经定义了静态方法在接口中，在以往版本是不可以的。我们可以直接通过接口(不需要实现)来调用静态方法，但注意的是实现接口的类或者子接口(是继承不是实现)不会继承接口中的静态方法。</p><h2 id="Lambda-expressions"><a href="#Lambda-expressions" class="headerlink" title="Lambda expressions"></a>Lambda expressions</h2><p>  因为是跟着教程走的，涉及到的知识和教程的差不多，你们可以直接去原网站看。</p><p>  我们可以使用lambda表达式改造上面的静态方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Formula formula = (a) -&gt; a;</span><br><span class="line">  System.out.println(formula.calculate(<span class="number">5</span>));</span><br><span class="line">  System.out.println(formula.sqrt(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  能使用lambda表达式来实现的接口必须只能有一个抽象方法，然后我们写的那个lambda表达式会和原来类型中的抽象方法进行匹配。</p><p>  这是原文(大概意思就是上面的话):</p><p>  How does lambda expressions fit into Java’s type system? Each lambda corresponds to a given type, specified by an interface. A so called functional interface must contain exactly one abstract method declaration. Each lambda expression of that type will be matched to this abstract method. Since default methods are not abstract you’re free to add default methods to your functional interface.</p><p>  然后我们可以在只有一个抽象方法的接口上面声明一个注解@FunctionalInterface来指明这个接口是一个函数接口，当我们尝试添加第二个抽象方法的时候编译器会报错。</p><p>  We can use arbitrary interfaces as lambda expressions as long as the interface only contains one abstract method. To ensure that your interface meet the requirements, you should add the @FunctionalInterface annotation. The compiler is aware of this annotation and throws a compiler error as soon as you try to add a second abstract method declaration to the interface.</p><p>  <img src="/2019/06/04/Java8新特性——接口中的static，default方法/1.jpg" alt="@FunctionalInterface"></p><h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><p>  方法和构造方法引用，Java 8允许您通过::关键字传递方法或构造函数的引用。</p><p>  例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>  我们可以使用::来化简代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueof</span><br><span class="line"><span class="comment">// 可以这么理解本来我们可以将这个实现写成一个lambda表达式，这个表达式其实就是一个函数，我们现在只是要一个函数，然后我们通过方法引用吧方法赋值给它。这个方法必须参数返回值要相同</span></span><br></pre></td></tr></table></figure><p>  当然我们还可以使用某个实例化的对象的方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br></pre></td></tr></table></figure><p>  通过::引用构造器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  String firstName;</span><br><span class="line">  String lastName;</span><br><span class="line"></span><br><span class="line">  Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Person(String firstName, String lastName) &#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通过构造器引用实现接口</span></span><br><span class="line">PersonFactory&lt;Person&gt; pf = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person  = PersonFactory.create(<span class="string">"11"</span>, <span class="string">"22"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中的赋值和参数传递</title>
      <link href="/2019/06/04/Java%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
      <url>/2019/06/04/Java%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h2 id="Java中的-赋值"><a href="#Java中的-赋值" class="headerlink" title="Java中的=赋值"></a>Java中的=赋值</h2><p>  一直以来我对于这些都有些模糊，今天来写一篇博客总结一下。</p><p>  在Java中，=赋值对于基本类型可以简单理解为就是直接传值</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">System.out.println(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>  我们可以看出我们把a赋值给b然后对b进行改变的时候a的值还是不会变。</p><p>  所以在基本数据类型中，我们可以简单理解为=为传值。</p><p>  而在对象中的=就不是赋值那么简单了，对于对象的=其实赋值的是对象的地址而不是内容，比如a = a1 ，假设这两个变量是对象，那么我们是将a1的地址赋值给a，那么a的地址就是a1的地址，即他们两共享同一地址，所以如果我们对a进行了操作，其实就是通过地址同时操作a1。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder s1 = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">StringBuilder s2 = s1;</span><br><span class="line">s2.append(<span class="string">"456"</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// 123456</span></span><br><span class="line">System.out.println(s2); <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure><p>  所以我们可以理解对于对象的=赋值的是对象的地址，除非我们再次new一个对象，将这个new的对象的地址重新赋值给s2。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder s1 = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">StringBuilder s2 = s1;</span><br><span class="line">s2.append(<span class="string">"456"</span>);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line">s2 = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">s2.append(<span class="string">"789"</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// 123456 不变</span></span><br><span class="line">System.out.println(s2); <span class="comment">// 123789</span></span><br></pre></td></tr></table></figure><p>  我们可以看出当我们给s2重新赋值一个地址的时候这个时候的s2就与s1无关了，因为他们已经不是共享同一个地址了。</p><h2 id="Java中的方法参数传递"><a href="#Java中的方法参数传递" class="headerlink" title="Java中的方法参数传递"></a>Java中的方法参数传递</h2><p>  我觉得方法参数传递和=赋值差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    stringBuilder.append(<span class="string">"我改变了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"我重新赋值地址了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"初始化"</span>);</span><br><span class="line">    System.out.println(stringBuilder); <span class="comment">//初始化</span></span><br><span class="line">    Test.function1(stringBuilder);</span><br><span class="line">    System.out.println(stringBuilder); <span class="comment">//初始化我改变李</span></span><br><span class="line">    Test.function2(stringBuilder);</span><br><span class="line">    System.out.println(stringBuilder); <span class="comment">//初始化我改变了</span></span><br><span class="line">    <span class="comment">//  这里我们看出function2对stringBuilder对象没有任何改变，是因为</span></span><br><span class="line">    <span class="comment">// 我们传入function2的stringBuilder是一个地址，然后我们又重新将</span></span><br><span class="line">    <span class="comment">// 新的地址赋值给stringBuilder，所以指向了不同的地址 自然就不会有关联了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  总之记住一个就是Java中的参数传递就是按值传递，当我们传入的是一个对象的时候我们传入的是地址，我们传入一个基本类型的时候传入的是一个值，我们也可以简单理解为地址就是对象的值。</p><p>  其实也可以这么理解，基本类型的值在栈中，即栈中的的值，然后对象的地址在栈中，这个地址指向堆中的内容，我们可以简单理解为传值就是传入栈中的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构——Trie</title>
      <link href="/2019/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Trie/"/>
      <url>/2019/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Trie/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Trie"><a href="#什么是Trie" class="headerlink" title="什么是Trie"></a>什么是Trie</h2><p>  Trie是字典树，前缀树。Trie的思想就是使用空间换时间，它是一种专门致力于字符串查询的树，因为它的子节点是所有包含的字符，所以它是一个多叉树(使用空间大)，当我们对一个字符串进行查询的时候它的时间复杂度是O(字符串长度)，所以当个字符串集合非常大的时候是不影响Trie的性能的。</p><p>  这是Trie的基本结构，里面存放了see，dog，pain，pand</p><p>  <img src="/2019/06/03/数据结构——Trie/1.jpg" alt="Trie"></p><h2 id="在Trie中添加单词"><a href="#在Trie中添加单词" class="headerlink" title="在Trie中添加单词"></a>在Trie中添加单词</h2><p>  因为Trie是专门对字符串进行操作的，这里我们选择对Trie中添加一个单词。</p><p>  主要思路就是:我们对需要添加的单词进行for循环取出每个字符，然后我们同时在树中进行遍历，比如我们取出第一个字符是a，那我们就在根节点的next(这里是一个map存放着所有的子节点)中查找是否有a这样的节点，如果没有我们就创建，如果有我们进入这个结点继续后面的操作，比如下一个字符是p。。。</p><p>  java代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义每个结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> word;</span><br><span class="line">  <span class="comment">//该结点存放子节点的map</span></span><br><span class="line">  <span class="keyword">private</span> TreeMap&lt;Character, Node&gt; next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.word = word;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = <span class="keyword">new</span> Node();</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将根结点作为当前节点</span></span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="comment">//获取该位置的字符</span></span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="comment">//判断是否有该字符的节点，没有则创建</span></span><br><span class="line">    <span class="comment">//有则继续遍历</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentNode.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果遍历到最后不是个单词那么将它标志位单词</span></span><br><span class="line">  <span class="keyword">if</span> (!currentNode.word)&#123;</span><br><span class="line">    currentNode.word = <span class="keyword">true</span>;</span><br><span class="line">    size++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Trie中查找单词"><a href="#在Trie中查找单词" class="headerlink" title="在Trie中查找单词"></a>在Trie中查找单词</h2><p>  基本思路：</p><p>  对于查找其实就是遍历这个单词字符串然后在Trie中进行遍历，如果符合则继续遍历，不符合就直接return false。如果遍历到最后，我们就查看最后那个节点的单词标志是不是true如果是那么就return true。</p><p>  java代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span> <span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="comment">//如果一个不符合直接false</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//符合继续遍历</span></span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断最后节点是不是单词</span></span><br><span class="line">  <span class="keyword">return</span> currentNode.word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Trie中进行前缀查询"><a href="#在Trie中进行前缀查询" class="headerlink" title="在Trie中进行前缀查询"></a>在Trie中进行前缀查询</h2><p>  基本思路：</p><p>  对于前缀查询其实跟查找差不多，只是我们不需要判断最后一个节点是不是单词了，因为这里只是判断前缀。</p><p>  java代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prefix</span> <span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历到最后直接true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Trie进行模式匹配"><a href="#在Trie进行模式匹配" class="headerlink" title="在Trie进行模式匹配"></a>在Trie进行模式匹配</h2><p>  其实是一个LeetCode题目</p><p>  <img src="/2019/06/03/数据结构——Trie/2.jpg" alt="leetcode"></p><p>  解题思路：</p><p>  主要就是要解决这个.的匹配问题，这里我们使用递归。当我们搜索一个字符串是否存在的时候(包括.的字符串)，我们首先定义一个递归函数，参数为当前查找的node，字符串，当前字符的索引，返回是boolean。</p><p>  我们递归函数的最根本条件就是当index等于这个查询的字符串的长度的时候我们就返回当前节点是否是单词的标志。</p><p>  但我们进行查找的时候我们现在root的node中执行该函数，然后我们字符索引是0，获取到第一个字符，我们首先要判断这个字符是不是等于.,如果不等于，我们判断当前节点的next中是否有当前字符的node如果没有直接返回false，如果有那继续递归到当前节点的next.get(当前字符)的节点，索引是index + 1。</p><p>  如果是. 那么我们就对这个node.next的key进行遍历，并且在遍历中调用递归函数，写法跟上面差不多</p><p>  具体代码实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> word;</span><br><span class="line">  <span class="keyword">private</span> TreeMap&lt;Character, Node&gt; next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.word = word;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = <span class="keyword">new</span> Node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a word into the data structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentNode.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  currentNode.word = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns if the word is in the data structure. A word could contain the dot character '.' to</span></span><br><span class="line"><span class="comment"> * represent any one letter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> match(root, word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Node node, String word, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.word;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line">  <span class="keyword">if</span> (c != <span class="string">'.'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match(node.next.get(c), word, index + <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> nextChar:node.next.keySet()) &#123;</span><br><span class="line">      <span class="comment">// 每个key都进行递归，匹配上了交给下一个节点</span></span><br><span class="line">      <span class="keyword">if</span> (match(node.next.get(nextChar), word, index + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果整个for循环结束都没有成功那就是都没匹配上 直接false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode中的键值映射题目"><a href="#LeetCode中的键值映射题目" class="headerlink" title="LeetCode中的键值映射题目"></a>LeetCode中的键值映射题目</h2><p>  <img src="/2019/06/03/数据结构——Trie/3.jpg" alt="LeetCode"></p><p>  解题思路：</p><p>  其实前面查找都差不多，主要就是我们对这个进行前缀查找之后到了最后那个节点的时候我们需要对后面所有单词的value进行相加最终返回。</p><p>  我们这里可以使用递归，比如我们已经进行前缀查询并且到了前缀查找字符的最后一个字符，我们书写一个sum递归函数，目的是计算符合这个前缀的单词的value的总和，其实就是获取都前缀最后节点的字数所形成的所有单词的value和。</p><p>  这个递归函数的参数只有一个Node，这个node就是前缀遍历到最后的节点。然后我们的根本条件就是node的next的size为0的时候也就是最后没有字符(结尾)的时候直接返回该结点的value，然后我们定义一个result，每次result都对当前节点的value进行+=操作，然后我们对next的key进行遍历，在遍历中进行递归调用，递归到node为当前node.next.get(遍历到的key)</p><p>  具体代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">private</span> TreeMap&lt;Character, Node&gt; next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = <span class="keyword">new</span> Node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = key.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentNode.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  currentNode.value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum(currentNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.next.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> result = node.value;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c: node.next.keySet()) &#123;</span><br><span class="line">    result += sum(node.next.get(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式——Prototype模式</title>
      <link href="/2019/06/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Prototype%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Prototype%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Prototype模式"><a href="#什么是Prototype模式" class="headerlink" title="什么是Prototype模式"></a>什么是Prototype模式</h2><p>  Prototype模式(原型模式)指的就是使用对象去制造新的对象，不像单例模式只制造出一个对象，原型模式制造的对象是多个的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p><h2 id="实现Prototype模式"><a href="#实现Prototype模式" class="headerlink" title="实现Prototype模式"></a>实现Prototype模式</h2><p>  原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：</p><ul><li><p>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</p></li><li><p>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is Circle"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is rectangle"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Shape&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String string, Shape shape)</span></span>&#123;</span><br><span class="line">    map.put(string, shape);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">get</span><span class="params">(String string)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Shape shape = map.get(string);</span><br><span class="line">    <span class="comment">//这里是核心我们获取到这个对象之后使用clone方法</span></span><br><span class="line">    <span class="keyword">return</span> (Shape) shape.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    ShapeMap shapeMap = <span class="keyword">new</span> ShapeMap();</span><br><span class="line">    Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">    Shape rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">    shapeMap.register(<span class="string">"circle"</span>, circle);</span><br><span class="line">    shapeMap.register(<span class="string">"rectangle"</span>, rectangle);</span><br><span class="line">    Shape circleClone = shapeMap.get(<span class="string">"circle"</span>);</span><br><span class="line">    Shape rectangleClone = shapeMap.get(<span class="string">"rectangle"</span>);</span><br><span class="line">    circleClone.draw();</span><br><span class="line">    rectangleClone.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后输出打印</p><p>  this is Circle</p><p>  this is rectangle</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ES6学习——day02</title>
      <link href="/2019/06/02/ES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day02/"/>
      <url>/2019/06/02/ES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day02/</url>
      
        <content type="html"><![CDATA[<h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>  这个参数默认值有些像Java里面注解的默认值，跟dart语言中的默认值有着神似之处，要不然怎么说dart和js很像呢。</p><p>  先上代码吧</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y = <span class="string">'world'</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    test(<span class="string">'hello'</span>); <span class="comment">//打印出来 hello world,当然也可以对y赋值进行更改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">'test'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">x, y = x</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    test2(<span class="string">'kill'</span>); <span class="comment">//输出kill kill 可见x的值为kill</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>  rest参数就是… , 应用场景就是在参数数量可变或者不可预知的时候使用的，这时候…后面的形参会被变成数组传进函数，跟java的…差不多，只是java里面是这样的(java8新特性)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">        <span class="comment">//打印出参数i</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  js代码是这样的</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//rest参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//将输入的参数都转为数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arg)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'rest'</span>,v);<span class="comment">//a b c</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  test3(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将数组转成离散的值</span></span><br><span class="line">  <span class="built_in">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]);<span class="comment">//1 2 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>,...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]);<span class="comment">//a 1 2 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p>  其实就是某个函数的最后一步再调用另一个函数，使用递归函数就经常会有尾递归的情况</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//尾调用：函数的最后一句话是不是函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tail</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'tail'</span>,x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fx</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tail(x);</span><br><span class="line">  &#125;</span><br><span class="line">  fx(<span class="number">123</span>);<span class="comment">//tail 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>  一个革命性的新特性，向着函数式编程挺进。在java里面有lambda表达式(-&gt;)，dart中跟js一样是=&gt;，就叫它胖箭头吧。。。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里的arrow其实就是一个函数</span></span><br><span class="line">    <span class="keyword">let</span> arrow = <span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arrow(<span class="number">3</span>));  <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">let</span> arrow2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h3><p>  这是一个概念性的问题，在没有箭头函数的函数里面，this就是代表调用这个函数的对象，所以当一个函数中调用另一个函数的时候this可能会发生变化。但是在箭头函数中，this是代表调用这个(箭头函数的函数)的对象，所以箭头函数会是this不变化，不是绝对的具体看情况。</p><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>  这里的对象是指Object</p><h3 id="简洁表达式"><a href="#简洁表达式" class="headerlink" title="简洁表达式"></a>简洁表达式</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> o = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">let</span> k = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">let</span> es5 = &#123;</span><br><span class="line">     o: o,</span><br><span class="line">     K: k</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> es6 = &#123;</span><br><span class="line">     o,</span><br><span class="line">     k</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> es5_mrthod=&#123;</span><br><span class="line">   hello:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> es6_method=&#123;</span><br><span class="line">     hello()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性表达式</span></span><br><span class="line"><span class="keyword">let</span> a=<span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">let</span> es5_obj=&#123;</span><br><span class="line">    a: <span class="string">'c'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> es6_obj=&#123;</span><br><span class="line">    [a]:<span class="string">'c'</span> <span class="comment">//这里的a是变量，即b</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es5_obj,es6_obj);</span><br></pre></td></tr></table></figure><h3 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'字符串'</span>,<span class="built_in">Object</span>.is(<span class="string">'abc'</span>,<span class="string">'abc'</span>));<span class="comment">//true 相当于===</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'数组'</span>,<span class="built_in">Object</span>.is([],[]),[]===[]);<span class="comment">//false false 引用地址不同</span></span><br></pre></td></tr></table></figure><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><p>语法：Object.assign(target, …sources); 返回拷贝后的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = <span class="built_in">Object</span>.assign(&#123;<span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">5</span>&#125;, object1);</span><br><span class="line"><span class="built_in">console</span>.log(object2.c, object2.d);</span><br><span class="line"><span class="comment">// expected output: 3 5</span></span><br></pre></td></tr></table></figure><h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;<span class="attr">k</span>:<span class="number">123</span>,<span class="attr">o</span>:<span class="number">456</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(test))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ES6学习——day01</title>
      <link href="/2019/06/01/ES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day01/"/>
      <url>/2019/06/01/ES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day01/</url>
      
        <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>  前段时间学习的mysql到现在还停留在day1阶段，现在就突然学es6。其实我是这么想的 因为这段时间在帮老师弄前端项目，用的JQuery。我想着这东西比较老，然后想用vue逐渐替换掉(做一次尝试吧)，学完vue发现还需要es6的基础，所以看了一下es6语法，并不是很难而且为我写js提供了更好地方法。那就学吧。。。</p><h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><p>  其实学习es6并不打算一个代码一个代码敲过来，可能眼高手低吧。我先学着反正也要项目中使用es6，那我项目中使用多练练吧。</p><p>  在let 和 const之前我们都使用的是var声明变量。这里无非就是作用域的不同，let的作用域是块作用域简单来说就是大括号括起来的部分，而var是函数作用域，如果在全局声明那就全局的。然后let 不准重复声明，又因为es6强制开启了严格模式，所以变量不准在未声明之前引用，不然会报引用错误。</p><p>  而const就是常量，常量是不准重新赋值且声明时必须赋值。有个特殊一点的就是对象常量，对象常量里面的字段都是可以修改的，也许你认为这违反了常量，其实不是(有点像C++里面的常量指针)，在es6中常量对象意味着这个对象引用的地址是不改变的(因为对象是引用类型，所以值其实是地址)，但是里面的内容是可以改变的。这在我学习vuex全局变量的时候看到别人使用const定义全局的变量就很不解，原来是因为他们定义的是全局对象变量。</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>  什么是解构赋值，它有很多分类，数组解构赋值(左右都是数组),对象解构赋值(左右都是对象),字符串解构赋值(左数组，右字符串)，布尔解构赋值，函数参数解构赋值(数组解构赋值在函数上的引用)，数值解构赋值</p><p>  数组解构赋值和对象解构赋值使用的比较多。</p><p>  数组解构赋值例子，在要对数组成员进行变量赋值的时候，尽量使用解构赋值</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个打印出来的ab就是1和2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a,b,rest</span><br><span class="line">  [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a,b,rest</span><br><span class="line">  [a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, rest);</span><br><span class="line">  <span class="comment">//打印结果ab还是1 2 但是rest是[3, 4, 5]数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认值</span></span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, b  = <span class="number">3</span>] = [<span class="number">1</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="comment">//结果是a为1 b为3  </span></span><br><span class="line">  <span class="comment">//如果b为赋值那么就是undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个变量交换</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">  [a, b] = [b, a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取函数返回值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, b] = f()</span><br><span class="line">  <span class="comment">//ab则为12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择型获取</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, , , b] = f()</span><br><span class="line">  <span class="comment">//这时候 a为1  b为6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对象解构赋值例子</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//对象解构赋值</span></span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  (&#123;a, b&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="comment">//a为1b为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> &#123;p, q&#125; = o</span><br><span class="line">  <span class="built_in">console</span>.log(p, q)</span><br><span class="line">  <span class="comment">//这里的p为42 ，q为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用场景</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    title: <span class="string">'abc'</span>,</span><br><span class="line">    test: [&#123;</span><br><span class="line">      title: <span class="string">'test'</span>,</span><br><span class="line">      desc: <span class="string">'description'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> &#123;<span class="attr">title</span>: esTitle, <span class="attr">test</span>: [&#123;<span class="attr">title</span>: testTitle&#125;]&#125; = jsonData</span><br><span class="line">  <span class="built_in">console</span>.log(esTitle, testTitle)</span><br><span class="line">  <span class="comment">//这时候esTitle获取到的就是bc testTitle获取到的就是test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><p>  其实就是对数组的api进行扩展了。</p><ul><li>Array.of()方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arr'</span>, arr)     <span class="comment">//[3, 4, 5, 5, 3]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arr'</span>,<span class="built_in">Array</span>.of())   <span class="comment">//[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Array.from()方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">let</span> pArr=<span class="built_in">Array</span>.from(p); <span class="comment">//将上面的集合转义成数组</span></span><br><span class="line">pArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item.textContent);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;<span class="keyword">return</span>   item + <span class="number">2</span>;&#125;));<span class="comment">//3 5 7</span></span><br></pre></td></tr></table></figure><ul><li>填充数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'fill-7'</span>,[<span class="number">1</span>,<span class="string">'a'</span>,<span class="literal">undefined</span>].fill(<span class="number">7</span>));<span class="comment">//[7,7,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fill,pos'</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>));<span class="comment">//["a", 7, 7, "d", "e"] 1和3表示起始和截至位置，不包括位置3</span></span><br></pre></td></tr></table></figure><ul><li>获取索引和值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'keys'</span>,index);<span class="comment">//0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'values'</span>,value);<span class="comment">//1 c ks</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index,value] <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">//[4,2,3,4,5] （从0开始替换，从3开始读取，也就是第一个读取的数是4，4是截至位置，也就是在位置4之前，因此只取4）</span></span><br></pre></td></tr></table></figure><ul><li>查找和判断包含</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">3</span>;<span class="comment">//4，只找第一个</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">3</span>;<span class="comment">//3</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'number'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'number'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式——模板方法模式</title>
      <link href="/2019/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h2><p>  Template Method模式，我的理解就是它是一种抽象类实现方法的一种升级版的设计模式。所谓模板就是将某一种工序流程方法抽象成一个统一的模板，比如说我有一个绘画的模板，我们可以选择任何一种画笔，比如我使用红笔画这个模板画出来的就是红色的，我用蜡笔那就蜡笔画出来的画。</p><h2 id="模板方法的实现"><a href="#模板方法的实现" class="headerlink" title="模板方法的实现"></a>模板方法的实现</h2><p>  比如这时候我们有一个流程，流程中需要调用几个工序，这几个工序的顺序是不变的，但是具体的工序是会变化的。这时候我们就可以使用模板方法模式了。</p><p>  首先，我们先定义一个抽象类，这个抽象类里面有具体的模板方法和几个工序方法，工序方法是抽象方法(这个就需要子类去实现具体方法)，模板方法里需要调用这几个方法比如说先是工序1然后是工序2最后是工序4。</p><p>  当我们需要具体实现的时候，我们需要加一个类继承于这个抽象类并且实现它的抽象方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>  这里我就直接使用vs在md文件里手敲了，比较简单但最重要的是思想。</p><p>  首先是抽象类AbstractProcess</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        workOrder1();</span><br><span class="line">        workOrder2();</span><br><span class="line">        workOrder4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后是实现类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakePencilProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcess</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MakePencilProcess</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil first"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil second"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil third"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后是客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//里氏替换原则，更加灵活</span></span><br><span class="line">        AbstractProcess abstractProcess = <span class="keyword">new</span> MakePencilProcess();</span><br><span class="line">        abstractProcess.processTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  这两天在看vue，突然有好多要学的现在有点不知所措，期末，练车，数据结构，设计模式，Java项目，大创，前端项目，vue，六级考试，操作系统实验。。。感觉自己野心有点太大了，慢慢来吧，不能太急。</p><p>  这几天突然意识到自己缺少了很多生活的记忆，尤其是前几天肝项目的时候，让我回忆那几天生活里干了啥我已经记不清了，我觉得我不能成为那样的呆子，那不是我，那也是我以前不想成为的人。</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式——适配器模式</title>
      <link href="/2019/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h2><p>  简单来说，适配器就是用来填补实际情况和需求两者之间地差异。比如说我们需要5V电压，但是国内只给的是220V电压，那我们现在就需要一个适配器帮我们将电压转换。</p><h2 id="通过继承方式实现适配器模式"><a href="#通过继承方式实现适配器模式" class="headerlink" title="通过继承方式实现适配器模式"></a>通过继承方式实现适配器模式</h2><p>  Adapter模式，比如我们有一个原本的类A，A中有一个a方法，这时候我们有一个B类需要A中的a方法，但是它不能直接调用(因为某个原因不匹配，但是B确实需要a方法)，这时候我们可以通过一个C适配器类来包装A类的a方法，我们需要做的就是让C继承A类拥有A类的a方法，然后我们再让C实现B接口(B是一个接口),B类有一个方法时b方法(b方法可以理解为将来需要将a封装或者使用a方法的方法),这时候C适配器就重写了B接口的b方法，当我们B接口需要使用b方法的时候我们new一个C适配器类就行了(拿C实现B接口)。</p><p>  示例代码：</p><p>  我们有一个Banner类，Banner类中有showWithParen，showWithAster方法，这两个方法分别是在使用括号括住字符串和使用两个*包住字符串。然后我们有一个Print接口，这个接口有weakPrint和strongPrint方法，其实这两个方法需要使用showWithParen，showWithAster方法，所以我们可以添加一个适配器，让这个适配器作为Print的实现类，我们在适配器中继承Banner并调用Banner中的showWithParen，showWithAster方法，然后在封装这两个方法成为Print接口需要使用的方法就行了。</p><p>  Banner类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.string = string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.string = string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"("</span> + string + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"*"</span> + string + <span class="string">"*"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Print接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrintBanner适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    showWithParen();</span><br><span class="line">    System.out.println(<span class="string">"weak"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    showWithAster();</span><br><span class="line">    System.out.println(<span class="string">"strong"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Print print = <span class="keyword">new</span> PrintBanner(<span class="string">"12345"</span>);</span><br><span class="line">    print.weakPrint();</span><br><span class="line">    print.strongPrint();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用委托方式实现适配器模式"><a href="#使用委托方式实现适配器模式" class="headerlink" title="使用委托方式实现适配器模式"></a>使用委托方式实现适配器模式</h2><p>  其实使用委托的方法就是改动一下适配器类，使适配器不是继承原来的类而是拥有原来的类，将是一个变为有一个在面向对象里会有很多好处。这貌似是Java编程思想里看到的，，，我也忘了。</p><p>  这时候我们需要改动一下适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Banner banner;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.banner = <span class="keyword">new</span> Banner(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    banner.showWithParen();</span><br><span class="line">    System.out.println(<span class="string">"weak"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    banner.showWithAster();</span><br><span class="line">    System.out.println(<span class="string">"strong"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式——迭代器模式</title>
      <link href="/2019/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h2><p>  当我们进行数组遍历的时候需要for循环i一直到arr.length，当我们使用迭代器模式的时候我们只需要生成当前数组的具体迭代器(实现迭代器接口),然后通过这个迭代器遍历就行。</p><h2 id="迭代器UML图及角色介绍"><a href="#迭代器UML图及角色介绍" class="headerlink" title="迭代器UML图及角色介绍"></a>迭代器UML图及角色介绍</h2><p>   <img src="/2019/05/27/设计模式——迭代器模式/1.jpg" alt="迭代器模式"></p><h3 id="Aggregate接口"><a href="#Aggregate接口" class="headerlink" title="Aggregate接口"></a>Aggregate接口</h3><p>  Aggregate是所有需要通过迭代器遍历的集合的接口。所有需要通过迭代器遍历集合的都需要实现这个Aggregate接口，Aggregate本身有聚集集合的意思，这里我们就叫它有迭代器实现的集合接口吧。</p><p>  其中相关Aggregate接口的代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里实现了一个迭代器，需要实现迭代器的集合都必须实现这个方法，这个方法的目的是返回该集合的具体迭代器。</span></span><br><span class="line">  <span class="function">Interator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcreteAggregate实现类"><a href="#ConcreteAggregate实现类" class="headerlink" title="ConcreteAggregate实现类"></a>ConcreteAggregate实现类</h3><p>  ConcreteAggregate实现了Aggregate接口，可以说是具体的实现类，比如说这个类是一个CardList(里面存放了card元素)，里面会有相关的card字段以及获取某个元素，获取长度等等有关集合数组的操作。最重要的是它需要实现iterator方法。</p><p>  其中相关ConcreteAggregate实现类的代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iteratot</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>  Iterator和Aggregate接口的关系就是，Aggregate接口中有产生Iterator的iterator方法，也就是Aggregate接口的具体实现类ConcreteAggregate产生出Iterator具体实现类ConcreteIterator。</p><p>  其中Iterator中有两个方法，分别是hasNext(),next()。hasNext的作用是判断迭代器是否还有下一个元素，如果有返回true否则false。next()的作用是返回当前集合迭代到的元素并将指针移向一下个元素(注意这里是两个作用)。</p><p>  所以有了迭代器我们遍历一个集合是这样的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于产生cardList的迭代器</span></span><br><span class="line"><span class="comment">//这个方法这里还是不可以用的，为了现在介绍迭代器迭代代码，如果要实现必须要有一个具体ConcreteIterator实现类</span></span><br><span class="line">Iteratot iterator = cardList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Card card = (Card)iterator.next();</span><br><span class="line">    <span class="comment">//.......进行相关操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  具体Iterator接口的实现代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcreteIterator实现类"><a href="#ConcreteIterator实现类" class="headerlink" title="ConcreteIterator实现类"></a>ConcreteIterator实现类</h3><p>  ConcreteIterator实现了Iterator接口，比如我们这里实现的是CardList的Iterator，我们可以这样写</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CardList cardList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CardListIterator</span><span class="params">(CardList catdList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardList = cardList;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; cardList.getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Card card = CardList.get(index);</span><br><span class="line">        index ++ ;</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器模式的作用"><a href="#迭代器模式的作用" class="headerlink" title="迭代器模式的作用"></a>迭代器模式的作用</h2><p>  为什么要考虑引入Iterator模式呢？直接for循环不就好了，其实迭代器模式有一个好处就是分离，将遍历和实现分开来，在我们调用如下代码的时候</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Card card = (Card)iterator.next();</span><br><span class="line">    <span class="comment">//.......进行相关操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个遍历并没有依赖于cardList，所以当我们这个cardList切换了数据结构的时候我们不需要将原来代码的for循环再依次改动了，我们只需要修改这个相关的iterator的具体实现类其中的hasNext()方法和next()方法就行了。</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql基础学习——day1</title>
      <link href="/2019/05/23/Mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day1/"/>
      <url>/2019/05/23/Mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day1/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql的数据类型"><a href="#Mysql的数据类型" class="headerlink" title="Mysql的数据类型"></a>Mysql的数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ol><li>TINYINT</li><li>SMALLINT</li><li>MEDIUMINT</li><li>INT</li><li><p>BIGINT</p><p>这五个从小往大，可以对对应字段设置有无符号位。</p><p><img src="/2019/05/23/Mysql基础学习——day1/1.jpg" alt="整型"></p></li></ol><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ol><li>FLOAT 单精度</li><li><p>DOUBLE 双精度</p><p><img src="/2019/05/23/Mysql基础学习——day1/2.jpg" alt="浮点型"></p></li></ol><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ol><li>YEAR</li><li>TIME</li><li>DATE</li><li>DATETIME</li><li><p>TIMESTAMP</p><p>DATE范围：  1000/1/1~9999/12/31</p><p>DATETIME范围：  1000/1/1/0:00:00~9999/12/31/23:59:59</p><p>TIMESTAMP范围：  1970/1/1~2037/12/31</p><p>TIME范围：  -8385959~8385959</p><p>YEAR范围：  可存储俩位或者四位 默认四位，可以是1970~2069</p></li></ol><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ol><li>CHAR</li><li>VARCHAR</li><li>TINYTEXT</li><li>TEXT</li><li>MEDIUMTEXT</li><li>LONGTEXT</li><li>ENUM</li><li><p>SET</p><p><img src="/2019/05/23/Mysql基础学习——day1/3.jpg" alt="字符类型"></p></li></ol><h2 id="Mysql的约束"><a href="#Mysql的约束" class="headerlink" title="Mysql的约束"></a>Mysql的约束</h2><h3 id="五种约束"><a href="#五种约束" class="headerlink" title="五种约束"></a>五种约束</h3><pre><code>NOT NULL（非空约束）PRIMARY  KEY (主键约束)UNIQUE  KEY （唯一约束）DEFAULT  (默认约束)FOREIGN  KEY (外键约束)</code></pre><h3 id="外键约束的条件"><a href="#外键约束的条件" class="headerlink" title="外键约束的条件"></a>外键约束的条件</h3><ol><li><p>父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。</p></li><li><p>数据表的存储引擎只能为InnoDB。</p></li><li><p>外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。</p></li><li><p>外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。</p></li></ol><h3 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h3><ol><li><p>CASCADE:从父表删除或更新且自动删除或更新子表中匹配的行。</p></li><li><p>SET NULL:从父表删除或更新行，并设置子表中的外键列为NULL。</p></li><li><p>RESTRICT:拒绝对父表的删除或更新操作。</p></li><li><p>NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。</p><p>CASCADE的删除案例：（子表中外键列添加ON DELETE CASCADE，父表进行删除时，子表也进行相应删除）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式——观察者模式</title>
      <link href="/2019/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h2><p>  观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>  <img src="/2019/05/23/设计模式——观察者模式/1.jpg" alt="观察者模式结构图"></p><p>  在观察者模式中有如下角色：</p><ul><li><p>Subject：</p><p>抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p></li><li><p>ConcreteSubject：</p><p>具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p></li><li><p>Observer：</p><p>抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p></li><li><p>ConcrereObserver：</p><p>具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p></li></ul><h2 id="简单实现观察者模式"><a href="#简单实现观察者模式" class="headerlink" title="简单实现观察者模式"></a>简单实现观察者模式</h2><p>  这里我们简单实现一下观察者模式，首先我们定义一个被观察者的接口Subject，然后我们再定义一个观察者的接口Observer</p><p>  其中Subject中有三个方法，attach()用来增加用户的，detach()用来移除用户的，notify()用来提醒订阅的用户的。</p><p>  其中Observer中有个update()方法，这是notify()里会调用用来提醒所有订阅用户消息的</p><p>  具体代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User实现观察者接口，并实现update方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"User"</span> + name + <span class="string">"receive the update message:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体被观察者实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面存放观察者的列表</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Observer&gt; observerArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加观察者</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当要通知的时候遍历观察者列表调用他们的update方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Observer observer : observerArrayList) &#123;</span><br><span class="line">    observer.update(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  测试方法和结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"></span><br><span class="line">  User first = <span class="keyword">new</span> User(<span class="string">"first"</span>);</span><br><span class="line">  User second = <span class="keyword">new</span> User(<span class="string">"second"</span>);</span><br><span class="line">  User third = <span class="keyword">new</span> User(<span class="string">"third"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.attach(first);</span><br><span class="line">  concreteSubject.attach(second);</span><br><span class="line">  concreteSubject.attach(third);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第一次更新"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.detach(second);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第二次更新"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/05/23/设计模式——观察者模式/2.jpg" alt="结果"></p><h2 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h2><p>  在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p><p>  我们再刚刚实现的观察者模式中，观察者和被观察者是要互相知道对方的存在的(上述代码只实现了被观察者增加观察者，当然也可以在观察者里面关联被观察者)，不然无法增加和删除观察者列表中的用户。</p><p>  但是发布订阅则是通过一个消息中间者来实现，他们之间通过消息代理，可以说更加松耦合。</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>线段树</title>
      <link href="/2019/05/23/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2019/05/23/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><p>  按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。</p><p>  当然时间复杂度的减少，空间也就会有相应的损失，当我们要通过线段树存储一个线性结构，空间的开销就会增大。比如我们存储的线性结构的大小正好是2的整数幂，那么我们所有的叶子节点都会是单个区间的值，这个叶子节点的数量就是n，我们知道对于一个满二叉树来说，叶子节点的数量就是上层所有节点的和，那么这时候我们需要开辟的空间就是2n。但是当我们存储的大小不是2的整数幂的时候，这时候单个区间节点就不全在叶子节点上，假设我们为了使线段树尽量满足满二叉树的结构，那么在倒数第二层的单个区间的值也需要两个左右孩子节点(虽然他们是空，但还是需要空间的)，那么这时候我们就需要开辟2n*2(4n)的空间。</p><p>  <img src="/2019/05/23/线段树/1.jpg" alt="线段树"></p><h2 id="线段树的实现"><a href="#线段树的实现" class="headerlink" title="线段树的实现"></a>线段树的实现</h2><p>  对于线段树的实现，我们需要使用递归调用。</p><p>  具体思路如下:</p><p>  不考虑动态规划的情况，我们需要将整个区间一分为二，这个 middleIndex 就是(left + right) / 2,然后我们再依次递归到最后的叶子节点，当我们需要划分的left = right的时候也就是区间为1的时候(即一个区间的值)我们返回，然后我们通过后序遍历的思想将两个左右子节点的值相融合赋值给父节点。</p><p>  具体实现代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = data[left];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取左右孩子的节点索引</span></span><br><span class="line">  <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取中间索引</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//int middleIndex = (left + right) / 2;</span></span><br><span class="line">  <span class="comment">//为了防止整型溢出</span></span><br><span class="line"></span><br><span class="line">  buildSegmentTree(leftChildIndex, left, middleIndex);</span><br><span class="line">  buildSegmentTree(rightChildIndex, middleIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[leftChildIndex], tree[rightChildIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的搜索"><a href="#线段树的搜索" class="headerlink" title="线段树的搜索"></a>线段树的搜索</h2><p>  基本思路:</p><p>  其实还是递归的思想，我们需要获取某个区间的值，即我们创建一个query方法，其中参数有treeIndex(遍历的根节点的index)，left(在什么区间查询的左边界index),right(在什么区间查询的右边界index),queryLeft(需要查询的左边界index),queryRight(需要查询的右边界的index)。</p><p>  最根本的条件就是当我们所查询的左右边界值分别和我们需要查询的左右边界值相等，那么我们直接返回这个tree[treeIndex]。</p><p>  我们使用递归转换为小问题的思路就是通过left right，queryLeft queryRight的关系，我们设置一个middleIndex(这个middleIndex也是根据left,right得来的)，我们通过queryLeft和middle比较，如果queryLeft比当前所查询区间的的middle要大的话，那么我们就去查询右子树，如果queryRight比middle要小的话我们就去查询左子树，因为我们查询的一个区间基本可能实现一个大区间的子集中，那么为了精确，我们就需要在大区间的左右孩子树中查找结果然后我们再将左右结果融合在一起然后返回。</p><p>  代码实现:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> queryLeft, <span class="keyword">int</span> queryRight)</span></span>&#123;</span><br><span class="line">  <span class="comment">//当left == queryLeft &amp;&amp; right == queryRight时就说明是我们需要查询的区间直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (left == queryLeft &amp;&amp; right == queryRight)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line">  <span class="comment">//缩小查询范围</span></span><br><span class="line">  <span class="keyword">if</span> (queryLeft &gt;= middle + <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryRight &lt;= middle)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们查询的区间必定是某个大区间的左右孩子树查询结果的融合</span></span><br><span class="line">  E leftResult = query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  E rightResult = query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  <span class="keyword">return</span> merger.merger(leftResult, rightResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树查询的LeetCode题目"><a href="#线段树查询的LeetCode题目" class="headerlink" title="线段树查询的LeetCode题目"></a>线段树查询的LeetCode题目</h2><p>  题目描述:</p><p>  <img src="/2019/05/23/线段树/2.jpg" alt="LeetCode题目"></p><p>  解题思路:</p><p>  题目要求需要我们获得一个数组中某个区间段的值，并且这个sumRange函数会不断被调用，那么我们就可以使用线段树的查询操作(使merge融合改成相加就行了)</p><p>  具体代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SegmentTree&lt;Integer&gt; segmentTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  Integer[] integers = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">  <span class="keyword">if</span> (nums.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">      integers[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//λ表达式，直接实现接口</span></span><br><span class="line">    segmentTree = <span class="keyword">new</span> SegmentTree&lt;&gt;(integers, (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segmentTree.query(i, j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的修改"><a href="#线段树的修改" class="headerlink" title="线段树的修改"></a>线段树的修改</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>  这里我们主要实现对线段树的某个单区间的修改操作，对于单个线段树的修改操作势必会牵连到其父节点的修改，这里我们还是可以使用后序遍历的思想再更新完子节点之后将父节点更新。</p><p>  相关代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//最根本条件就是我们查询的区间左右相等</span></span><br><span class="line">  <span class="comment">//这时候我们直接对该结点更新就行</span></span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = e;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//后面也是拿index和left，right比较</span></span><br><span class="line">  <span class="comment">//通过index和left，right的关系将问题变小</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt;= middleIndex)&#123;</span><br><span class="line">    set(childLeftIndex, left, middleIndex, index, e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= middleIndex + <span class="number">1</span>)&#123;</span><br><span class="line">    set(childRightIndex, middleIndex, right, index, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过后序遍历的思想将父节点更新</span></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[childLeftIndex], tree[childRightIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关的LeetCode题目"><a href="#相关的LeetCode题目" class="headerlink" title="相关的LeetCode题目"></a>相关的LeetCode题目</h3><p>  <img src="/2019/05/23/线段树/3.jpg" alt="LeetCode题目"></p><p>  这里其实就是增加一个update方法，题目又增加了修改单个结点的值，那么我们将更新方法加入原来实现的代码中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  segmentTree.update(i, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式——策略模式</title>
      <link href="/2019/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><h3 id="继承一定好用吗？"><a href="#继承一定好用吗？" class="headerlink" title="继承一定好用吗？"></a>继承一定好用吗？</h3><p>  当我们做到一个项目类似于设计鸭子，鸭子呢有游泳和嘎嘎叫的能力，另外他们都有display显示外貌的方法。现在比如有两个鸭子，绿头鸭和红头鸭。绿头鸭的头是绿色的，可以游泳，叫声是ll声，红头鸭的头是红色的，可以游泳，叫声是rr声。</p><p>  如果我们要设计这两个鸭子类其实可以直接使用继承来实现，我们可以先设计一个Duck基类，类中有display方法，该方法是抽象的(所以类也是抽象的)，因为每个鸭子的外貌不一样。还有swim(),quack()方法，其中定义了基类默认的，比如说会游泳会嘎嘎叫等，之后绿头鸭红头鸭就需要实现display方法和重写swim(),quack()方法就行了。</p><p>  但是这时候，客户增加需求说要增加会飞行的鸭子。也许我们可以在父类里增加fly(),但是这对原先的子类都会有改动，如果绿头鸭不会飞我们还需要重新覆盖fly()方法，如果我们也像display方法变成抽象的，那么重写的代码太多，代码太冗余。</p><p>  <strong>继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应</strong></p><p>  <strong>超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式</strong></p><h3 id="使用组合更加灵活可扩展"><a href="#使用组合更加灵活可扩展" class="headerlink" title="使用组合更加灵活可扩展"></a>使用组合更加灵活可扩展</h3><p>  上面设计的鸭子类主要就是灵活性太差，其实我们可以使用分离的技巧，我们先来看鸭子这个类，它的方法中有变的和不变的，当我们增加需求或者改动需求的时候是只涉及变的的。</p><p>  比如我们现在将叫声和飞行分离出来变成一个行为，然后我们分别实现这两个行为接口QuackBehavior,FlyBehavior,这两个接口里各有方法quack和fly方法，当我们的叫声和飞行方法有变动的时候我们只需要实现要改变的方法的接口就行。比如我们现在需要有一个火箭飞行的行为那么我们创建一个RocketFlyBehavior实现FlyBehavior接口然后重写方法就行了。</p><p>  那么具体怎么使用呢？我们可以直接在Duck基类里增加两个接口字段QuackBehavior和FlyBehavior就行，然后我们基类的fly和quack方法中直接调用接口字段的fly方法和quack方法就行了，如果这时候我们需要给一个鸭子更换功能，我们直接调用接口字段的set方法就行了。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="Duck抽象类"><a href="#Duck抽象类" class="headerlink" title="Duck抽象类"></a>Duck抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> FlyBehavior mFlyBehavior;</span><br><span class="line">  <span class="keyword">protected</span> QuackBehavior mQuackBehavior;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractDuck</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mFlyBehavior.fly();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mQuackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span> </span>&#123;</span><br><span class="line">    mQuackBehavior = qb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = fb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~im swim~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个实现类"><a href="#两个实现类" class="headerlink" title="两个实现类"></a>两个实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GreenHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**GreenHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~no fly~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**RedHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractDuck greenHeadDuck = <span class="keyword">new</span> GreenHeadDuck();</span><br><span class="line">    AbstractDuck redHeadDuck = <span class="keyword">new</span> RedHeadDuck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认调用</span></span><br><span class="line">    greenHeadDuck.display();</span><br><span class="line">    greenHeadDuck.fly();</span><br><span class="line">    greenHeadDuck.quack();</span><br><span class="line">    greenHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将红头鸭的飞行方法改成不能飞</span></span><br><span class="line">    redHeadDuck.setFlyBehavior(<span class="keyword">new</span> BadFlyBehavior());</span><br><span class="line">    redHeadDuck.display();</span><br><span class="line">    redHeadDuck.fly();</span><br><span class="line">    redHeadDuck.quack();</span><br><span class="line">    redHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们增加行为的时候增加相应接口然后实现相应接口并将接口加入基类字段并实现set方法和相应方法调用接口里面的方法就行了</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</p><p>  原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>优先队列和堆</title>
      <link href="/2019/05/19/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/"/>
      <url>/2019/05/19/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>  普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院挂急诊的优先级大于普通排队就诊的，比如在游戏中自动打怪设置，当地图中出现级别高的野怪先打级别高的等等。</p><p>  如果我们实现优先队列使用普通的线性结构，那么当我们入队的时候时间复杂度就是O(1)，但出队的时候我们的时间复杂度就是O(n)，因为出队的时候是优先级最高的出队，所以我们需要遍历整个队列寻找优先级最高的元素。</p><p>  如果我们实现优先队列使用的顺序线性结构，那么我们出队的时间复杂度就是O(1)，因为原本队列就是依靠优先级排列的，这时候我们出队只需要取出第一个元素就行了。但是，当我们进行入队操作的时候我们就需要维持队列的顺序性，这时候入队就是O(n)的时间复杂度了。</p><p>  相较于前面两种实现方法，使用堆来实现优先队列的入队操作和出队操作都是O(logn)的时间复杂度，这是非常快的。</p><p>  <img src="/2019/05/19/优先队列和堆/1.jpg" alt="优先队列的实现方法的时间复杂度比较"></p><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>  堆其实就是按照层由上到下，由左到右的树结构，其中可以分为最大堆和最小堆(根元素为最大的元素就是最大堆)</p><p>  <img src="/2019/05/19/优先队列和堆/2.jpg" alt="堆的数据结构"></p><p>  当我们使用数组实现堆的时候，这时候父子节点的索引值存在着一种数学关系。</p><p>  <img src="/2019/05/19/优先队列和堆/3.jpg" alt="堆的数据结构"></p><p>  当索引从0开始的时候，父亲节点的索引就是子节点的索引-1再除以2(取整的性质，所以左右孩子都一样)，相应的，左孩子就是父亲节点索引乘2+1，右孩子则是左孩子+1。</p><p>  通过这个关系我们就可以很轻松的使用数组存储二叉堆。</p><h2 id="最大堆的代码实现"><a href="#最大堆的代码实现" class="headerlink" title="最大堆的代码实现"></a>最大堆的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 17:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回index索引的父亲节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 父亲节点的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index-0 doesn't have parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取节点左孩子的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 节点索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 左孩子索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取右孩子索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 费节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 右孩子的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">    siftUp(array.getSize() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素上浮</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 指定上浮元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当父元素比指定元素小的时候交换，如果交换则继续去比较</span></span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; array.get(parent(index)).compareTo(array.get(index)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      array.swap(index, parent(index));</span><br><span class="line">      index = parent(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.getSize() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The heap is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    E temp = getMax();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将堆顶元素和堆的最后一个元素交换位置</span></span><br><span class="line">    array.swap(<span class="number">0</span>, array.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//删除最后一个元素(原来的堆顶元素)</span></span><br><span class="line">    array.removeLast();</span><br><span class="line"></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素的下沉</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 需要下沉的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断index合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历堆，条件是左孩子存在</span></span><br><span class="line">    <span class="keyword">while</span> (leftChild(index) &lt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">int</span> j = leftChild(index);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果右孩子存在则比较左右孩子，将大的索引赋值给j</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; array.getSize() &amp;&amp; array.get(j).compareTo(array.get(j + <span class="number">1</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        j ++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (array.get(index).compareTo(array.get(j)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果需要下沉的节点已经比左右孩子最大的大了直接break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        array.swap(index, j);</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大堆的入队和出队的操作"><a href="#最大堆的入队和出队的操作" class="headerlink" title="最大堆的入队和出队的操作"></a>最大堆的入队和出队的操作</h2><p>  在上述代码中，其他操作都是最基本的，但是对于插入和移除元素就会稍微复杂了。</p><p>  当我们插入元素的时候，我们需要在数组最后插入元素，但是插入元素的大小不一定性决定着我们需要重新排列这个二叉堆使它还满足最大堆的特性。所以我们只需要和插入元素的父亲节点比较，如果我们插入的节点大于父亲节点了则交换，然后再和交换后的父亲节点比较，一直到根节点或者子节点小于父亲节点了。</p><p>  当我们移除元素的时候，其实就是移除堆中的顶层元素，这时候如果直接移除的话，那么堆就会变成两个堆，这样整合成一个堆的话太复杂，这时候我们可以将堆底元素和堆顶元素交换，然后再删除堆底元素(原来堆顶元素),然后我们通过现在堆顶元素和它的左右孩子最大的作比较，如果小于最大的那么就交换，然后再次和左右孩子做比较直到自己没有左右孩子为止。</p><h2 id="使用堆来实现优先队列"><a href="#使用堆来实现优先队列" class="headerlink" title="使用堆来实现优先队列"></a>使用堆来实现优先队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 20:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="comment">//优先队列中的元素必须是可比较的</span></span><br><span class="line"> <span class="comment">//其他的方法直接复用堆中的方法就行了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    maxHeap.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.getMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于LeetCode中优先队列的问题"><a href="#关于LeetCode中优先队列的问题" class="headerlink" title="关于LeetCode中优先队列的问题"></a>关于LeetCode中优先队列的问题</h2><p><img src="/2019/05/19/优先队列和堆/4.jpg" alt="题目"></p><p>分析: 我们需要获取频率出现最高的元素，我们需要将频率和元素(key)存入一个map中，然后遍历这个数组，当map不存在相应key的数组中的元素，则将value设置为1，如果存在value++。</p><p>然后我们遍历这个map中的key，将key存入优先队列中(容量为k)，当k的容量存满了并且还需要添加元素到优先队列的时候就判断优先队列优先度最高的元素和插入元素的优先度，如果插入元素的优先度高于现在队列中最高的，那么就将元素插入到队列中，知道整个map遍历完。</p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个Frequency类</span></span><br><span class="line">  <span class="comment">//存放key和频率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Frequency</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> k, freq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frequency</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> freq)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.k = k;</span><br><span class="line">      <span class="keyword">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现比较器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyCompartor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Frequency</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Frequency o1, Frequency o2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o1.freq - o2.freq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//遍历数组并且将频率信息存入map中</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : nums)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!map.containsKey(integer))&#123;</span><br><span class="line">        map.put(integer, <span class="number">1</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(integer, map.get(integer) + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Frequency&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> FrequencyCompartor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历map的key，并且将频率最高的放入优先队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key: map.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (priorityQueue.size() &lt; k)&#123;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; priorityQueue.peek().freq)&#123;</span><br><span class="line">        priorityQueue.poll();</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">      linkedList.add(priorityQueue.poll().k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>集合与映射</title>
      <link href="/2019/05/13/%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84/"/>
      <url>/2019/05/13/%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是集合-Set"><a href="#什么是集合-Set" class="headerlink" title="什么是集合(Set)"></a>什么是集合(Set)</h2><p>  简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。</p><a id="more"></a><h2 id="定义Set接口"><a href="#定义Set接口" class="headerlink" title="定义Set接口"></a>定义Set接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> size大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用二分搜索树实现集合"><a href="#使用二分搜索树实现集合" class="headerlink" title="使用二分搜索树实现集合"></a>使用二分搜索树实现集合</h2><p>  对于二分搜索树有一个很重要的特性就是它是根据元素的大小来放入元素到树中的，所以二分搜索树基本是不存在相同元素的，我们就可以通过二分搜索树底层实现集合</p><p>  这是上一篇博客写的二分搜索树的相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 20:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node left,right;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      left=<span class="keyword">null</span>;</span><br><span class="line">      right=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root = add(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.left = add(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMin(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode=node.right;</span><br><span class="line">      node.right=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.left=removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMax(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node leftNode=node.left;</span><br><span class="line">      node.left=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.right=removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root=remove(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      node.left=remove(node.left,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      node.right=remove(node.right,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果相等就要删除</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先判断这个树是不是只有一边的孩子</span></span><br><span class="line">      <span class="comment">//如果只有左边有孩子或者只有右边有孩子</span></span><br><span class="line">      <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果左右都有孩子</span></span><br><span class="line">      <span class="comment">//寻找该节点的后继节点</span></span><br><span class="line">      <span class="comment">//后继结点就是离该结点最近的节点（数值最近而且是大于该节点）</span></span><br><span class="line">      <span class="comment">//那么这个结点的后继结点就是该节点右孩子的最小结点</span></span><br><span class="line">      Node successorNode=minimum(node.right);</span><br><span class="line">      <span class="comment">//我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子</span></span><br><span class="line">      successorNode.right=removeMin(node.right);</span><br><span class="line">      successorNode.left=node.left;</span><br><span class="line">      node.left=node.right=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> successorNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      preOrder(node.left);</span><br><span class="line">      preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 非递归实现前序遍历</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perOrderWithoutRecurrence</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">      Node currentNode=stack.pop();</span><br><span class="line">      System.out.println(currentNode.e);</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 层序遍历(广度优先遍历)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        Node currentNode=queue.remove();</span><br><span class="line">        System.out.println(currentNode.e);</span><br><span class="line">        <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      inOrder(node.left);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      postOrder(node.left);</span><br><span class="line">      postOrder(node.right);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    generateBSTString(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成以node为根节点，深度为depth的描述二叉树的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> depth</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBSTString</span><span class="params">(Node node, <span class="keyword">int</span> depth, StringBuilder res)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      res.append(generateDepthString(depth) + <span class="string">"null\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.append(generateDepthString(depth) + node.e + <span class="string">"\n"</span>);</span><br><span class="line">    generateBSTString(node.left, depth + <span class="number">1</span>, res);</span><br><span class="line">    generateBSTString(node.right, depth + <span class="number">1</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">generateDepthString</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; depth ; i ++)&#123;</span><br><span class="line">      res.append(<span class="string">"--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这时候我们就可以使用二分搜索树来实现集合了，很简单，直接封装一个二分搜索树然后调用方法就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 21:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BinarySearchTree&lt;E&gt; binarySearchTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.binarySearchTree = <span class="keyword">new</span> BinarySearchTree&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用链表来实现集合"><a href="#使用链表来实现集合" class="headerlink" title="使用链表来实现集合"></a>使用链表来实现集合</h2><p>  链表中有一个contains方法，我们可以在调用add方法的时候使用contains方法判断原来集合中是否已经存在该元素了，如果已经存在那么就添加失败。其他的也是直接调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 10:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否已经存在该元素</span></span><br><span class="line">    <span class="keyword">if</span> (!linkedList.contains(e))&#123;</span><br><span class="line">      linkedList.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkedList.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树和链表实现集合的比较"><a href="#二分搜索树和链表实现集合的比较" class="headerlink" title="二分搜索树和链表实现集合的比较"></a>二分搜索树和链表实现集合的比较</h2><p>  在上面实现链表集合的时候我们很容易就会发现，链表集合的增加操作的时候需要先判断整个链表中是否存在该元素，那么这样就需要O(n)的时间复杂度了，在删除，查找元素的时候都是和普通链表一样O(n)的时间复杂度。可以说链表实现的集合的效率并不是很高。</p><p>  那么我们再来看一看二分搜索树实现的集合的时间复杂度。当我们添加元素的时候我们是依靠二分搜索树的特性来添加的</p><p>  <img src="/2019/05/13/集合与映射/1.jpg" alt="二分搜索树"></p><p>  比如我们需要添加一个元素的时候，我们就需要先判断大小，然后根据树的特性一层一层遍历，这个时候我们就会发现，我们的时间复杂度是和这个二分搜索树的高度呈线性关系的。</p><p>  <img src="/2019/05/13/集合与映射/2.jpg" alt="二分搜索树"></p><p>  <img src="/2019/05/13/集合与映射/3.jpg" alt="二分搜索树"></p><p>  然后我们通过运算就可以得出一个平衡二叉树h层一共有2的h次方-1个元素，我们就很容易得出时间复杂度为log2(n+1)，忽略常数，那么就是logn。</p><p>  <img src="/2019/05/13/集合与映射/4.jpg" alt="二分搜索树"></p><p>  而logn和n的差距在基数很大的时候差距特别明显</p><p>  <img src="/2019/05/13/集合与映射/5.jpg" alt="二分搜索树"></p><p>  所以说二分搜索树实现的集合会比链表实现的集合快很多。当然这也是考虑树的最好情况。当树不为平衡二叉树的时候，最坏情况也会是O(n)。</p><p>  <img src="/2019/05/13/集合与映射/6.jpg" alt="二分搜索树"></p><p>  如上图右边，我们看到当树成一边排列的时候，它的时间复杂度就是O(n)。</p><h2 id="LeetCode上解决关于集合的题目"><a href="#LeetCode上解决关于集合的题目" class="headerlink" title="LeetCode上解决关于集合的题目"></a>LeetCode上解决关于集合的题目</h2><p>  题目是这样的：</p><p>  <img src="/2019/05/13/集合与映射/7.jpg" alt="LeetCode804题目"></p><p>  对于这道题，我们可以遍历这个words数组，然后得到其中的某个元素再次遍历字符串的每个字母，然后通过原先定义的摩尔斯密码表数组和字符相对应，之后我们就可以获取到这个单词的摩尔斯密码，我们循环完一次之后，我们就把得到的摩尔斯密码拼接成字符串然后存入到set中，最终循环完成之后我们只要返回set的size就行了。</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 13:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预先定义摩尔斯密码表</span></span><br><span class="line">    String[] codes = &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length() ; i ++)&#123;</span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        stringBuilder.append(codes[word.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//存入set中</span></span><br><span class="line">      set.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是映射-Map-字典"><a href="#什么是映射-Map-字典" class="headerlink" title="什么是映射(Map,字典)"></a>什么是映射(Map,字典)</h2><ol><li><p>映射，在定义域中每一个值在值域都有一个值与他对应</p></li><li><p>存储(键，值)数据对的数据结构（Key，Value）</p></li><li><p>根据键(Key)，寻找值(Value)</p><p><img src="/2019/05/13/集合与映射/8.jpg" alt="映射的概念"></p></li></ol><h2 id="定义Map接口"><a href="#定义Map接口" class="headerlink" title="定义Map接口"></a>定义Map接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> key对应的value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">remove</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置相应key的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某个key对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否包含</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否包含</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取映射的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 映射大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断映射是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现Map"><a href="#链表实现Map" class="headerlink" title="链表实现Map"></a>链表实现Map</h2><p>  使用链表实现Map其实只需要将私有类Node里面的字段e更改为key和value就行。当然BinarySearchTree也是如此</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node next)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> key.toString() + <span class="string">" : "</span> + value.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">    Node currentNode = dummyHead.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.key.equals(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否已经存在该key的映射</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      dummyHead.next = <span class="keyword">new</span> Node(k, v, dummyHead.next);</span><br><span class="line">      size ++ ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果存在则更新</span></span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node preNode = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (preNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (preNode.next.key.equals(k))&#123;</span><br><span class="line">        Node delNode = preNode.next;</span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">        delNode.next = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        preNode = preNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否存在该key的映射，如果不存在则抛出异常</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(k + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树实现映射-Map"><a href="#二分搜索树实现映射-Map" class="headerlink" title="二分搜索树实现映射(Map)"></a>二分搜索树实现映射(Map)</h2><p>  对于BinarySearchTree来说实现Map也是利用它原先的方法</p><p>  代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//辅助方法，在删除，修改映射的value时候会用到</span></span><br><span class="line">  <span class="comment">//获取相应key对应的Node(递归)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果递归到节点为null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候继续递归该结点的左子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//大于的时候继续递归该结点的右子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不然就是相等，则直接返回该结点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归到最底层，直接添加节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候直接递归该结点的左子树</span></span><br><span class="line">      node.left = add(node.left, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="comment">   * 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode = node.right;</span><br><span class="line">      node.right = <span class="keyword">null</span>;</span><br><span class="line">      size --;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从二分搜索树中删除键为key的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      root = remove(root, key);</span><br><span class="line">      <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.left = remove(node.left , key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.right = remove(node.right, key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">      <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">      Node successor = minimum(node.right);</span><br><span class="line">      successor.right = removeMin(node.right);</span><br><span class="line">      successor.left = node.left;</span><br><span class="line"></span><br><span class="line">      node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(root, k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(root, k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表Map和二分搜索树Map比较"><a href="#链表Map和二分搜索树Map比较" class="headerlink" title="链表Map和二分搜索树Map比较"></a>链表Map和二分搜索树Map比较</h2><p>  测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testMap</span><span class="params">(Map&lt;String, Integer&gt; map, String filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    System.out.println(filename);</span><br><span class="line">    ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(FileOperation.readFile(filename, words)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Total words: "</span> + words.size());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String word : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(word))&#123;</span><br><span class="line">          map.set(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          map.add(word, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Total different words: "</span> + map.getSize());</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PRIDE: "</span> + map.get(<span class="string">"pride"</span>));</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PREJUDICE: "</span> + map.get(<span class="string">"prejudice"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String filename = <span class="string">"I:\\data_structure\\src\\pride-and-prejudice.txt"</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; bstMap = <span class="keyword">new</span> BinarySearchTreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time1 = testMap(bstMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"BST Map: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; linkedListMap = <span class="keyword">new</span> LinkedListMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time2 = testMap(linkedListMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"Linked List Map: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  两者时间差异:</p><p>  <img src="/2019/05/13/集合与映射/9.jpg" alt="测试结果"></p><p>  可以看出，二分搜索树实现的Map的时间性能是远高于链表实现的Map的。</p><p>  因为对于链表实现修改某一映射对应的value值的时间复杂度是O(n),我们需要一个一个去遍历知道找到key符合的元素。</p><p>  而对于二分搜索树实现的Map来说，它修改一个value的时间复杂度是跟二叉树的高度相关的，也就是说它的时间复杂度是O(logn)级别的，所以当数据量大的时候，二分搜索树的优势非常明显。当然我们还需要考虑最坏的情况，那就是这个二分搜索树变成了类似于链表的树，那这时候时间复杂度就是O(n)了。</p><p>  <img src="/2019/05/13/集合与映射/10.jpg" alt="两种map的时间复杂度比较"></p><p>  但是有个细节需要注意的是，链表实现的Map的key是无序的，上文中的set也是无序的。但是二分搜索树实现的set和map都是有序的(这也是它这么快的一部分原因)。</p><h2 id="使用Map来实现Set"><a href="#使用Map来实现Set" class="headerlink" title="使用Map来实现Set"></a>使用Map来实现Set</h2><p>  我们可以发现，其实Set就是一个没有value的的Map。所以，当我们底层实现了一个映射，集合我们就可以理解成Map&lt;K, V&gt;中value为null的情况，对于不管是k，它所对应的的value都为null。</p><p>  所以当我们在Map中只考虑K的时候，整个Map数据结构就变成了K的集合。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringBoot整合RabbitMQ以及四种交换模式</title>
      <link href="/2019/05/09/SpringBoot%E6%95%B4%E5%90%88RabbitMQ%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/09/SpringBoot%E6%95%B4%E5%90%88RabbitMQ%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>  在google的时候发现知乎一个很好的回答，很生动形象。</p><p>  作者：ScienJus<br>  <a href="https://www.zhihu.com/question/34243607/answer/58314162" target="_blank" rel="noopener">原文链接</a></p><p>  个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。使用场景的话，举个例子：假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：校验用户名等信息，如果没问题会在数据库中添加一个用户记录如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他发送给用户一个包含操作指南的系统通知等等……但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了。</p><p>  我理解的消息队列就是当你的一个接口访问量大或者需要进行的操作很多，就比如注册这些功能(里面有发邮件，插入数据各种操作)，但是用户只需要知道是否注册成功，他们需要马上收到注册结果(提高用户体验性)，所以当用户的信息插入到数据库中我们就可以直接返回结果，至于后面的操作可以放入消息队列异步慢慢处理。</p><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><ul><li><p>maven配置</p><p>首先当然是maven配置了，springboot中为我们提供了amqp的start,amqp是一个消息队列的协议，RabbitMQ实现了这个协议。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>springboot配置文件的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">  password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">  virtual-host:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  listener:</span></span><br><span class="line"><span class="attr">    simple:</span></span><br><span class="line"><span class="attr">      concurrency:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      max-concurrency:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      prefetch:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      auto-startup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      default-requeue-rejected:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    retry:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      initial-interval:</span> <span class="number">1000</span><span class="string">ms</span></span><br><span class="line"><span class="attr">      max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      max-interval:</span> <span class="number">10000</span><span class="string">ms</span></span><br><span class="line"><span class="attr">      multiplier:</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>除了host，port什么的其他都可以不写，springboot已经默认帮我们配置好了。</p></li><li><p>RabbitMQ的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE,<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>消息发送者(提供者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"send"</span>);</span><br><span class="line">  <span class="comment">//标注需要发送的某个队列</span></span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.QUEUE,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息接收者(消费者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RabbitListener注解需要标注刚刚我们的队列名</span></span><br><span class="line"><span class="comment">//其作用就是监听那个队列是否有消息，有消息则接收</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.QUEUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span>+message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RabbitMQ的四种模式"><a href="#RabbitMQ的四种模式" class="headerlink" title="RabbitMQ的四种模式"></a>RabbitMQ的四种模式</h2><p>  RabbitMQ分为四种模式</p><pre><code>* Direct模式* Topic模式* Fanout模式* Headers模式</code></pre><ul><li><p>Direct模式(直接交换模式)</p><p>刚刚我们的配置类，接受者和发送者实现的就是Direct模式，其流程就是发送者指定一个Queue来发送消息给那个队列，然后消费者一直监听那个队列，有消息则接收</p></li><li><p>Topic模式</p></li></ul><p>首先是Topic的配置类，这里定义两个Queue，并且生成一个TopicExchange(Topic交换机)。</p><p>然后我们通过Binding来将A和B的消息队列绑定到我们刚刚生成的TopicExchange和指定routingKey中</p><p><img src="/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/1.jpg" alt="RabbitMQ的topic模式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE_A, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE_B, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBindingA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(topicQueueA()).to(topicExchange()).with(<span class="string">"topic.keyA"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBindingB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(topicQueueB()).to(topicExchange()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的消息发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicSend</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"topic send"</span>);</span><br><span class="line">  <span class="comment">//我们指定某个routingkey发送到这个交换机上</span></span><br><span class="line">  <span class="comment">//然后这个topic交换机会将我们的routingKey审核</span></span><br><span class="line">  <span class="comment">//如果这个key和某个队列绑定的key匹配那么这个消息就会发送到这个队列里</span></span><br><span class="line">  <span class="comment">//在队列绑定routingKey的时候可以使用#,*这些通配符,所以就会出现我发送一个消息，两个队列都收到了，我发送两个消息都是一个队列收到等情况，如图所示。</span></span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, <span class="string">"topic.keyA"</span>, message);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, <span class="string">"topic.keyB"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的消息消费者(接收者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收很简单，只要指定队列就行</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.TOPIC_QUEUE_A)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicReceiveA</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.TOPIC_QUEUE_B)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicReceiveB</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Fanout模式</li></ul><p>首先是Fanout的配置类,跟上面的topic查不到，我们先配置一个FanoutExchange类，然后通过Binding将队列绑定到那个Exchange中，我们可以绑定多个队列到Exchange中。</p><p><img src="/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/1.jpg" alt="RabbitMQ的topic模式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(FANOUT_QUEUE_A, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(FANOUT_QUEUE_B, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBindingA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueA()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBindingB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueB()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是我们的发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们只要将消息发送给交换机就好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutSend</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanout send"</span>);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class="string">""</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的消费者,这时候我们会发现这个Fanout模式就是类似于广播模式，我们将所有需要的队列都绑定上Fanout的Exchange中，然后我们发送者只需要将消息发送给Exchange，然后我们的消费者在所有的Queue中都能接收到消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.FANOUT_QUEUE_A)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutReceiveA</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanoutA receive:"</span>+message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.FANOUT_QUEUE_B)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutReceiveB</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanoutB receive:"</span>+message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Headers模式</li></ul><p>首先是我们的配置类，这个Header跟上面几种有些不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">headersQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(HEADERS_QUEUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeadersExchange <span class="title">headersExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前面两个和上述三种都差不多，这里的Binding有些不一样</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">headersBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  map.put(<span class="string">"HeadersAKey"</span>,<span class="string">"HeadersAValue"</span>);</span><br><span class="line">  map.put(<span class="string">"HeadersBKey"</span>,<span class="string">"HeadersBValue"</span>);</span><br><span class="line">  <span class="comment">//我们需要创建一个map存入键值对，然后绑定队列到交换机上，并且有个要求就是where什么什么加入map需要匹配，我们先看消息发送者</span></span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headersSend</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"headers send"</span>);</span><br><span class="line">  <span class="comment">//这里的发送者的发送方法需要的是一个交换机名称，还有一个就是Message对象</span></span><br><span class="line">  <span class="comment">//这个Message对象存入了真正消息的字符数组和消息的配置类，这里的消息配置类就是MessageProperties</span></span><br><span class="line">  <span class="comment">//我们需要对这个MessageProperties设置头，这个头就是键值对，就是我们配置类设置的map</span></span><br><span class="line">  <span class="comment">//我们发送消息给队列，这个消息的头被设置为我配置类书写的那两个map才行，因为我设置了whereAll.match，所以我发送消息给交换机，这个交换机会帮我去匹配请求头和我设置的符合的Queue并把消息存入那个队列中</span></span><br><span class="line">  MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">  messageProperties.setHeader(<span class="string">"HeadersAKey"</span>,<span class="string">"HeadersAValue"</span>);</span><br><span class="line">  messageProperties.setHeader(<span class="string">"HeadersBKey"</span>,<span class="string">"HeadersBValue"</span>);</span><br><span class="line">  Message headersMessage = <span class="keyword">new</span> Message(message.getBytes(),messageProperties);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.HEADERS_EXCHANGE, <span class="string">""</span>, headersMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个时候我们接收的就是字符数组了，因为我们再发送者的方法中是将消息变成byte[]再作为参数进行入队的</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.HEADERS_QUEUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headersReceive</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"headers receive:"</span>+<span class="keyword">new</span> String(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>二分搜索树的遍历</title>
      <link href="/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="二分搜索树的遍历"><a href="#二分搜索树的遍历" class="headerlink" title="二分搜索树的遍历"></a>二分搜索树的遍历</h2><p>  其实这里就是二叉树的遍历，只是因为二分搜索树因为是依靠它的特定规则而排列的，所以再经过不同方法遍历之后，它的顺序会有很多特点。</p><p>  我们是依靠根节点顺序来命名的，记住！是根结点。</p><p>  前序遍历就是先遍历根结点，然后遍历左结点，最后遍历右结点。</p><p>  中序遍历就是先遍历左结点，然后遍历根结点，最后遍历右结点。</p><p>  后序遍历就是先遍历左结点，然后遍历右结点，最后遍历根结点。</p><p>  最后要注意，这个提示可能不是适合所有人，对于我来说，我书写一个二叉树的前中后序遍历的时候都告诫自己要等待一个结点能遍历的时候才能遍历，什么意思呢？就是要遍历一个结点的时候需要把它的子节点先遍历了（子节点优先遍历），其实这个前中后序遍历另一个名字就是深度优先遍历，跟这个有关。</p><p>  慕课网中有另一种快速书写三种遍历方式遍历后的顺序结果的方法，如图:</p><p>  <img src="/2019/05/06/二分搜索树的遍历/1.jpg" alt="三种深度优先遍历"></p><p>  它是在每个结点上画上三个点，然后不管什么遍历方式都从根节点到左节点到右节点的方式遍历(比较图中)，每个结点其实都会经过三次，当中序遍历就去中间的点作为顺序参照，前序遍历就取左边的点作为顺序参照，后序遍历就取右边的点作为顺序参照。</p><p>  如果中序和后序的图看不懂，那么就将前序遍历那些顺序线放入中序和后序的图中，然后根据那个顺序线依次找蓝色的点，最后这些点连接成的就是遍历顺序了。</p><h2 id="深度优先遍历的递归代码实现"><a href="#深度优先遍历的递归代码实现" class="headerlink" title="深度优先遍历的递归代码实现"></a>深度优先遍历的递归代码实现</h2><p>  前面说了，前中后序遍历都可以称为深度优先遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//先打印根节点</span></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    <span class="comment">//然后遍历左节点</span></span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    <span class="comment">//遍历右结点</span></span><br><span class="line">    preOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//优先遍历左节点</span></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//先遍历左节点</span></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    <span class="comment">//然后遍历右结点</span></span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    <span class="comment">//最后遍历根结点</span></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归实现深度优先遍历很简单，只需要记住顺序就行了。</p><h2 id="非递归实现前序遍历"><a href="#非递归实现前序遍历" class="headerlink" title="非递归实现前序遍历"></a>非递归实现前序遍历</h2><p>  其实非递归实现前序遍历就是模拟系统方法栈，这时候我们不通过递归，我们就要自己使用栈来实现前序遍历。</p><p>  比如说我们需要将一个树前序遍历，这时候我们先将根结点放入我们new的一个栈中，然后我们把栈中这个结点元素取出来，对它进行打印(或者其他操作)，然后我们将它的右孩子，左孩子依次放入栈中(因为栈是先进后出)。然后我们再次取出栈中的一个元素，这时候我们取的是根结点的左孩子，然后我们对这个节点进行打印，然后把这个结点的右左孩子依次放入栈中，继续进行出栈操作。。。</p><p>  <img src="/2019/05/06/二分搜索树的遍历/2.jpg" alt="非递归实现前序遍历"></p><p>  代码实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归实现前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perOrderWithoutRecurrence</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//栈中元素不为空那么就出栈操作</span></span><br><span class="line">    Node currentNode=stack.pop();</span><br><span class="line">    System.out.println(currentNode.e);</span><br><span class="line">    <span class="comment">//依次将右左孩子放入栈中</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(currentNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(currentNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p>  层序遍历又是广度优先遍历，它是将树一层一层地进行遍历的。</p><p>  <img src="/2019/05/06/二分搜索树的遍历/3.jpg" alt="广度优先遍历"></p><p>  比如上图，我们广度优先遍历（层序遍历）的顺序就是28,16,30,13,22,29,42.</p><p>  我们如何实现呢？其实我们这时候需要一个队列，这个队列里将根结点放入，然后把根结点取出来进行操作（同时也要将队列里的根节点删除，后面的结点被取出来的时候也要删除），然后把根节点的左孩子，右孩子依次进行入队，这时候我们再取出队列里的第一个元素（根节点的左孩子结点），然后我们对它进行操作并删除队列里它的元素，然后将他的左右孩子依次入队，之后我们再取出来队列的第一个元素（根节点的右孩子），后面依次同上操作，如图所示。</p><p>  代码实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层序遍历(广度优先遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">      Node currentNode=queue.remove();</span><br><span class="line">      System.out.println(currentNode.e);</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(currentNode.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(currentNode.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>二分搜索树的增删改查</title>
      <link href="/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
      <url>/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是二分搜索树"><a href="#什么是二分搜索树" class="headerlink" title="什么是二分搜索树"></a>什么是二分搜索树</h2><p>  首先我们要先知道二叉树是什么，二叉树其实就是从一个根节点左右两端延伸出左右结点，延伸出的结点再次延伸出结点，然后一直延伸下去，所以树这种数据结构天生满足递归特性。</p><p>  而二分搜索树就是对二叉树做了一个限制，首先二分搜索树中的元素必须是可比较的（对于Java来说就是必须继承Comparable接口）。为什么需要它可比较呢？就是因为，二分搜索树的排列需要根据数值来排列。</p><p>  二分搜索树的某个结点的左孩子必须小于原来的节点且某个结点的左子树的所有结点必须比这个结点小。</p><p>  右边同上。</p><p>  <img src="/2019/05/06/二分搜索树的增删改查/1.jpg" alt="什么是二分搜索树和二叉树"></p><h2 id="二分搜索树的基本定义"><a href="#二分搜索树的基本定义" class="headerlink" title="二分搜索树的基本定义"></a>二分搜索树的基本定义</h2><p>  根据上面的定义，我们很容易就能写出代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node left,right;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      left=<span class="keyword">null</span>;</span><br><span class="line">      right=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root=<span class="keyword">null</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树的一些方法"><a href="#二分搜索树的一些方法" class="headerlink" title="二分搜索树的一些方法"></a>二分搜索树的一些方法</h2><ul><li>首先就是getSize()和isEmpty()方法，很容易，返回size和判断size是否为0就行了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>添加元素</p><p>添加元素的时候我们只需要在树的叶子节点中添加就行了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果根节点为空，那么直接new</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        add(root,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果这个结点不等于这个时候才能添加元素</span></span><br><span class="line">  <span class="keyword">if</span> (!e.equals(node.e))&#123;</span><br><span class="line">    <span class="comment">//如果插入元素小于该结点的元素且该结点的左孩子为空</span></span><br><span class="line">    <span class="comment">//那么直接插入左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>&amp;&amp;node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      node.left=<span class="keyword">new</span> Node(e);</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个同上</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>&amp;&amp;node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      node.right=<span class="keyword">new</span> Node(e);</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果小于，那么就递归调用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      add(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//同上</span></span><br><span class="line">      add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当然添加方法还有优化的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">  add(root,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//该结点为空，那么直接返回给上一级new出来的元素为e的节点，这里就是添加，只是现在遍历到最后了而已</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如果小于，那么该结点的左孩子就是下一层二分搜索树的添加元素后的二分搜索树</span></span><br><span class="line">    node.left=add(node.left,e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如果大于，那么该结点的右孩子就是下一层二分搜索树的添加元素后的二分搜索树</span></span><br><span class="line">    node.right=add(node.right,e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最后return被添加过结点的根节点</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>查询元素</p><ul><li><p>这里就是判断二分搜索树是否包含某个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果该树的根节点就是空，那么直接false</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果查询到了那么返回该结点</span></span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//小于的时候遍历左孩子树</span></span><br><span class="line">    <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//大于的时候遍历右孩子树</span></span><br><span class="line">    <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取最小元素和最大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当树的大小为0就不能删除</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当遍历到最后的某个结点的左孩子为null，那么这个结点就是最小元素</span></span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除元素，其中删除元素是最复杂的，对于删除最小最大元素来说并不复杂，因为只需要往左往右遍历二分搜索树就行了，但是对于任意元素的删除就要考虑多种情况。</p><ul><li>删除最小元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> removeMin(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果左孩子为空，那么这个结点就是要删除的结点</span></span><br><span class="line">  <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//将该结点的右子树放入临时变量</span></span><br><span class="line">    Node rightNode=node.right;</span><br><span class="line">    <span class="comment">//将这个结点的右子树置为null，然后返回刚刚的临时变量rightNode</span></span><br><span class="line">    node.right=<span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> rightNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不然就一直向左遍历，并且将下一级删除后返回的二分搜索树赋值给上一级的结点</span></span><br><span class="line">  node.left=removeMin(node.left);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除最大元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> removeMax(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">    Node leftNode=node.left;</span><br><span class="line">    node.left=<span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> leftNode;</span><br><span class="line">  &#125;</span><br><span class="line">  node.right=removeMax(node.right);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除某个结点</li></ul><p>我们可以通过寻找需要被删除节点的后继或者前驱，并且把它从原来树中删除然后代替被删除节点的位置</p><p><img src="/2019/05/06/二分搜索树的增删改查/2.jpg" alt="通过后继删除元素"></p><p><img src="/2019/05/06/二分搜索树的增删改查/3.jpg" alt="通过前驱删除元素"></p><p>这里我只写了通过后继删除某个元素，当然前驱书写方式也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">  root=remove(root,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    node.left=remove(node.left,e);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    node.right=remove(node.right,e);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果相等就要删除</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//首先判断这个树是不是只有一边的孩子</span></span><br><span class="line">    <span class="comment">//如果只有左边有孩子或者只有右边有孩子</span></span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//如果只有左子树</span></span><br><span class="line">      <span class="comment">//那么我们将该结点的左子树返回给上一节点的左子树</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> node.left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左右都有孩子</span></span><br><span class="line">    <span class="comment">//寻找该节点的后继节点</span></span><br><span class="line">    <span class="comment">//后继结点就是离该结点最近的节点（数值最近而且是大于该节点）</span></span><br><span class="line">    <span class="comment">//那么这个结点的后继结点就是该节点右孩子的最小结点</span></span><br><span class="line">    Node successorNode=minimum(node.right);</span><br><span class="line">    <span class="comment">//我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子</span></span><br><span class="line">    successorNode.right=removeMin(node.right);</span><br><span class="line">    successorNode.left=node.left;</span><br><span class="line">    node.left=node.right=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> successorNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git中.gitignore文件修改后不起作用</title>
      <link href="/2019/05/05/Git%E4%B8%AD-gitignore%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
      <url>/2019/05/05/Git%E4%B8%AD-gitignore%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>  当我使用git上传项目的时候，有些本应该忽略的文件没有被忽略，这时候我修改.gitignore文件再次上传的时候，本该忽略的文件还是在那里</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>  这是因为git缓存的原因，如果某些文件已经被纳入版本管理中，就算是在.gitignore文件中声明了忽略文件的路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再add和push。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol><li><p>首先清除本地缓存<br>git rm -r –cached .</p></li><li><p>再次add文件<br>git add .</p></li><li><p>提交<br>git commit -m “chore:update .gitignore”</p></li><li><p>push<br>git push</p></li></ol><h2 id="gitignore书写格式"><a href="#gitignore书写格式" class="headerlink" title=".gitignore书写格式"></a>.gitignore书写格式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从源文件到可执行文件</title>
      <link href="/2019/05/05/%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
      <url>/2019/05/05/%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>  这篇文章是我阅读《程序是怎样跑起来的》这本书第八章后写的读后感，也说不上读后感，就是把原文一些东西整理一下，方便日后阅读记忆。学校图书馆真是一个好地方，原本以为没有什么好的图书，后面去借阅几次发现了很多好书，这本书也是我在图书馆中借阅的。</p><h2 id="计算机只能运行本地代码"><a href="#计算机只能运行本地代码" class="headerlink" title="计算机只能运行本地代码"></a>计算机只能运行本地代码</h2><p>  什么是源文件和源代码，就是使用某种编程语言编写的程序就称为源代码，保存源代码的文件就是源文件。比如说以.c或者.java为扩展名的文件就是源文件。</p><p>  但是源文件是无法直接运行的，这是因为CPU能直接解析并运行的不是源代码而是本地代码的程序。</p><p>  本地(native)，对于CPU来说就是母语的意思，任何编程语言编写的源代码最后都要翻译成本地代码，否则CPU就看不懂。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/1.jpg" alt="转换为本地代码后就变成了同样的语言"></p><h2 id="本地代码的内容"><a href="#本地代码的内容" class="headerlink" title="本地代码的内容"></a>本地代码的内容</h2><p>  比如说Windows中的EXE文件里面就是本地代码。</p><p>  我们使用文本工具打开exe文件可以看到类似下图的代码</p><p>  <img src="/2019/05/05/从源文件到可执行文件/2.jpg" alt="用记事本打卡exe文件"></p><p>  这时候我们将它转变成十六进制</p><p>  <img src="/2019/05/05/从源文件到可执行文件/3.jpg" alt="转换为十六进制"></p><p>  计算机指令也是数值的罗列，这些就是本地代码。</p><h2 id="编译器负责转换源代码"><a href="#编译器负责转换源代码" class="headerlink" title="编译器负责转换源代码"></a>编译器负责转换源代码</h2><p>  能够把C语言等高级语言转换为本地代码的程序成为编译器，相当于现实中的翻译，每个编程语言都需要专用的编译器，C语言的就叫C编译器，这类似于现实中中文翻译成英文需要专业的英文翻译者。</p><p>  编译器读入代码内容，然后通过一些对照表把源代码对照翻译成本地代码，当然不仅仅是这么简单，其中还有语法解析，句法解析，语义解析等等，最后才能生成本地代码。</p><p>  根据CPU的不同，本地代码的类型也不同，所以编译器不仅和编程语言相关还和CPU相关，列入x86系列的CPU用的C编译器就和PowerPC这种CPU的C编译器不同。</p><p>  还有就是编译器也是一种程序，所以也需要运行环境，那么windows用的C编译器和Linux用的C编译器就不同。还有就是交叉编译器，他生产的是和运行环境中的CPU不同的CPU所使用的的本地代码。</p><h2 id="仅靠编译时无法得到可执行文件的"><a href="#仅靠编译时无法得到可执行文件的" class="headerlink" title="仅靠编译时无法得到可执行文件的"></a>仅靠编译时无法得到可执行文件的</h2><p>  C和C++中编译之后生成的是.obj目标文件，这时候还需要链接才能得到可执行的exe文件。</p><p>  比如说我们书写了一个函数</p><p>  <img src="/2019/05/05/从源文件到可执行文件/4.jpg" alt="代码"><br>  <img src="/2019/05/05/从源文件到可执行文件/5.jpg" alt="代码"></p><p>  其中我们调用了MessageBox函数，sprintf函数。但是在我们的源代码中没有这两个函数的相关实现，比如这个文件生成的是sample.obj，那么这个文件就需要和MessageBox，sprintf的目标文件相结合(链接)，才能生成完整的程序。试想一下这个sample是exe文件，那么这个文件就是不完整的，是无法执行的。</p><p>  运行连接的程序就称为链接器。</p><h2 id="启动及库文件"><a href="#启动及库文件" class="headerlink" title="启动及库文件"></a>启动及库文件</h2><p>  当我们执行上述sample.c文件的编译 链接操作的时候，我们需要指定两个文件。一个是sample.obj生成的目标文件，另一个是C0w32.obj文件，这个文件是记录着同所有程序气死位置相结合的处理内容，程序程序的启动。</p><p>  后面我们还需要指定库文件，比如说32.lib cw32.lib库文件，这里面存放着sprintf函数的目标文件和MessageBox函数的目标文件(实际上是在 user32.dll文件中，这是动态链接库)</p><p>  链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件</p><p>  <img src="/2019/05/05/从源文件到可执行文件/6.jpg" alt="编译链接的命令"></p><p>  如果不指定库文件就会发生无法识别sprintf函数和MessageBox函数的错误</p><p>  <img src="/2019/05/05/从源文件到可执行文件/7.jpg" alt="编译器报错"></p><h2 id="DLL文件及导入库"><a href="#DLL文件及导入库" class="headerlink" title="DLL文件及导入库"></a>DLL文件及导入库</h2><p>  Windows以函数的形式为应用提供了各种功能，这些函数被称为API(Application Programming Interface应用程序接口)  上面讲到的MessageBox()函数并不是C语言的标准库函数，而是Windows提供的API，这些API的目标文件存储在名为DLL(Dynamic Link Library)文件的特殊库文件中，它是程序运行动态结合的文件，上面我们提到MessageBox的目标文件存储在import32.lib文件中，其实这个文件只存储了两个信息——MessageBox()存储在user32.dll文件中，还有就是这个dll文件的文件夹信息。</p><p>  我们把类似于import32.lib这样的库文件称为导入库。</p><p>  DLL文件的好处：DLL文件中的函数可以被多个程序共用，因此借助该功能可以节约内存和磁盘。此外，在对函数的内容做修正的时候不需要重新连接(静态链接)。</p><p>  另一个就是静态链接库，就是sprintf，存储着sprintf()的cw32.lib就是静态链接库。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/8.jpg" alt="windows中编译和链接机制"></p><h2 id="可执行文件运行时的必要条件"><a href="#可执行文件运行时的必要条件" class="headerlink" title="可执行文件运行时的必要条件"></a>可执行文件运行时的必要条件</h2><p>  存储在硬盘中的exe文件运行时要读入内存中执行，在exe文件中我们会给变量和函数分配虚拟的内存地址，在程序运行的时候，这些虚拟内存地址会转换为实际内存地址，链接器会在exe文件的开头，追加转换内存地址所需的必要信息，这个信息称为再配置信息。</p><p>  可以这么理解，再配置信息里存放了变量和函数的相对地址，这个相对地址就是相对于基地址的偏移量，这样各个变量的内存地址就可以用变量组的基地址加上偏移量作为地址，而这些基地址是在程序运行时被计算机分配的。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/9.jpg" alt="链接后的exe文件构造"></p><h2 id="程序加载时会生成堆和栈"><a href="#程序加载时会生成堆和栈" class="headerlink" title="程序加载时会生成堆和栈"></a>程序加载时会生成堆和栈</h2><p>  当程序加载到内存中，出再配置信息，变量组，函数组等还会额外生成两个组，那就是堆和栈。栈是用来存储函数内部使用的临时变量以及函数调用时所用的参数的内存区域。堆是用来存储程序运行时的任意数据和对象的内存领域。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/10.jpg" alt="内存中的组"></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>  对于栈来说，它会在函数调用的时候自动分配内存，在函数执行完毕后自动释放内存。但是对于堆来说，C语言需要程序员使用malloc申请分配，free()函数来释放，C++中需要使用new来申请分配，delete来释放，Java和C#这些语言户进行自动垃圾回收，如果我们忘记释放内存，那么这个内存空间就会一直被使用，久而久之就会造成内存泄露(memory leak)从而导致内存不足而卡死，就比如一晚上忘关水龙头，水盆中的水装满并溢出一样。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mybatis插入字段并返回主键的小问题</title>
      <link href="/2019/05/04/Mybatis%E6%8F%92%E5%85%A5%E5%AD%97%E6%AE%B5%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/05/04/Mybatis%E6%8F%92%E5%85%A5%E5%AD%97%E6%AE%B5%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>  这几天在写秒杀项目，其中有一个需求是生成订单并返回订单号（主键）然后再生成秒杀订单将刚刚返回的订单号作为某个字段插入秒杀订单中，也就是秒杀订单表中的order_id。这其中就使用到了插入信息并返回主键。</p><p>  我使用的是Mybatis逆向工程生成的Mapper文件，其中自动生成的insert方法返回的是影响的行数，我在使用的时候一直返回给我的是1，导致报错。</p><h2 id="相关Mapper的编写"><a href="#相关Mapper的编写" class="headerlink" title="相关Mapper的编写"></a>相关Mapper的编写</h2><p>  其中最关键的就是在insert标签上增加useGeneratedKeys和keyProperty</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertOrderAndReturnOrderId"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">parameterType</span>=<span class="string">"com.lgq.miaosha.domain.OrderInfo"</span>&gt;</span></span><br><span class="line">  insert into t_order_info (id, user_id, goods_id,</span><br><span class="line">  delivey_addr_id, goods_name, goods_count,</span><br><span class="line">  goods_price, order_channel, status,</span><br><span class="line">  create_date, pay_date)</span><br><span class="line">  values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=BIGINT&#125;, #&#123;goodsId,jdbcType=BIGINT&#125;,</span><br><span class="line">  #&#123;deliveyAddrId,jdbcType=BIGINT&#125;, #&#123;goodsName,jdbcType=VARCHAR&#125;, #&#123;goodsCount,jdbcType=INTEGER&#125;,</span><br><span class="line">  #&#123;goodsPrice,jdbcType=DECIMAL&#125;, #&#123;orderChannel,jdbcType=TINYINT&#125;, #&#123;status,jdbcType=TINYINT&#125;,</span><br><span class="line">  #&#123;createDate,jdbcType=TIMESTAMP&#125;, #&#123;payDate,jdbcType=TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  其中keyProperty=”id”，这个id就是传入对象中的某个属性值，比如说这里就是OrderInfo对象，执行成功之后就会自动将主键的值赋给对象中的id属性。然后原本作为参数的OrderInfo对象中的id就得到了更新，这时候我们再取这个对象的id字段就可以获取到主键的值了。</p><h2 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成订单</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> user 用户</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> goodsVo 商品</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 订单详情</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">createOrder</span><span class="params">(User user, GoodsVo goodsVo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里主要就是生成OrderInfo对象</span></span><br><span class="line">    OrderInfo orderInfo=<span class="keyword">new</span> OrderInfo();</span><br><span class="line">    orderInfo.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">    orderInfo.setDeliveyAddrId(<span class="number">0L</span>);</span><br><span class="line">    orderInfo.setGoodsCount(<span class="number">1</span>);</span><br><span class="line">    orderInfo.setGoodsId(goodsVo.getId());</span><br><span class="line">    orderInfo.setGoodsName(goodsVo.getGoodsName());</span><br><span class="line">    orderInfo.setGoodsPrice(goodsVo.getMiaoshaPrice());</span><br><span class="line">    <span class="keyword">byte</span> b=<span class="number">1</span>;</span><br><span class="line">    orderInfo.setOrderChannel(b);</span><br><span class="line">    b=<span class="number">0</span>;</span><br><span class="line">    orderInfo.setStatus(b);</span><br><span class="line">    orderInfo.setUserId(user.getId());</span><br><span class="line">    <span class="comment">//插入订单</span></span><br><span class="line">    orderInfoMapper.insertOrderAndReturnOrderId(orderInfo);</span><br><span class="line">    <span class="comment">//最关键的一步</span></span><br><span class="line">    <span class="comment">//获取到刚刚对象中的id字段就是主键的值了</span></span><br><span class="line">    Long orderId=orderInfo.getId();</span><br><span class="line">    MiaoshaOrder miaoshaOrder=<span class="keyword">new</span> MiaoshaOrder();</span><br><span class="line">    miaoshaOrder.setGoodsId(goodsVo.getId());</span><br><span class="line">    <span class="comment">//这里不是很严谨，意思是将MiaoShaOrder的id设置成和OrderInfo的id一样</span></span><br><span class="line">    miaoshaOrder.setId(orderId);</span><br><span class="line">    miaoshaOrder.setUserId(user.getId());</span><br><span class="line">    <span class="comment">//将miaosha_order表中的order_id字段设置为order_id表中的主键</span></span><br><span class="line">    miaoshaOrder.setOrderId(orderId);</span><br><span class="line">    miaoshaOrderMapper.insert(miaoshaOrder);</span><br><span class="line">    <span class="keyword">return</span> orderInfo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringBoot整合Redis</title>
      <link href="/2019/05/03/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
      <url>/2019/05/03/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>  最近在写一个秒杀的项目，是跟着慕课网的一个教程学习的。其中用到了redis进行session共享等等功能，现如今做到的步骤是使用redis将用户信息存入redis中，并且同时将用户的唯一token值存入cookie中（cookie的有效期和redis键值的有效期一样），当我们用户跳转到某个页面的时候，先查询cookie中是否存在键值为user的cookie，如果存在就获取到cookieValue（token值），然后通过这个token作为键去查询redis中查找对应token的用户信息。</p><p>  五一玩了几天，这几天没怎么进食新东西，今天趁着假期学校不熄灯，继续写一篇博客。</p><h2 id="引入依赖和配置变量"><a href="#引入依赖和配置变量" class="headerlink" title="引入依赖和配置变量"></a>引入依赖和配置变量</h2><p>  首先是pom.xml的依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后我们需要在application.yaml文件中写入redis的配置环境</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">host:</span> <span class="number">119.82</span><span class="number">.123</span><span class="number">.134</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h2 id="配置类的编写"><a href="#配置类的编写" class="headerlink" title="配置类的编写"></a>配置类的编写</h2><p>  编写RedisConfig配置类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里是引入刚刚yaml文件的配置变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;redis.host&#125;"</span>) String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;redis.port&#125;"</span>) <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//引入JedisConnection工厂，主要负责的是redis的连接</span></span><br><span class="line">  <span class="comment">//其中要设置地址和端口号</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisStandaloneConfiguration redisStandaloneConfiguration = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">    redisStandaloneConfiguration.setHostName(host);</span><br><span class="line">    redisStandaloneConfiguration.setPort(port);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory(redisStandaloneConfiguration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//配置redis模板，这个主要是进行一些redis的操作，就像jdbc的模板类一样</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">    RedisTemplate&lt;String,Object&gt; redisTemplate=<span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(factory);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关操作的编写"><a href="#相关操作的编写" class="headerlink" title="相关操作的编写"></a>相关操作的编写</h2><p>  关于redis的操作有很多，我也学的不是很好，这里面只写了最简单的set和get</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-18 23:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引入刚刚我们设置的redis模板</span></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这是redis单独印出来的string的模板——因为对于redis的操作大部分都是以String类型为基础的，这里没有用到</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 往redis中缓存数据,这里使用T模板更加灵活</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,T value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将value对象转换为json字符串</span></span><br><span class="line">    String jsonString=beanToString(value);</span><br><span class="line">    <span class="comment">//valueOperations用来set和get 它是由redisTemplate产生的</span></span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">//这里是将value对象转换为jsonString，因为项目中User是一个java对象</span></span><br><span class="line">    valueOperations.set(key,jsonString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 往redis中缓存数据并加上过期时间</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> time 过期时间，秒</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,T value,<span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个方法跟上面差不多，多加了一个设置过期时间，为的是与项目需求设置redis过期时间和cookie相等</span></span><br><span class="line">    String jsonString=beanToString(value);</span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    valueOperations.set(key, jsonString, time,TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从redis1中获取数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">//这里其实获取的是存在redis中对象的json字符串</span></span><br><span class="line">    Object object=valueOperations.get(key);</span><br><span class="line">    <span class="comment">//如果获取的不为空，那么就像这个json字符串转换为java对象</span></span><br><span class="line">    <span class="keyword">if</span> (object!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> stringToBean(object.toString(),clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取为空就return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将对象转换为json</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> json数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>  &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; clazz=value.getClass();</span><br><span class="line">    <span class="comment">//如果value是int类型或者Integer类型的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (clazz==<span class="keyword">int</span>.class||clazz==Integer.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz==String.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> (String)value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (clazz==<span class="keyword">long</span>.class||clazz==Long.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将jsonString转换为java的对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jsonString json字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz 类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> java对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String jsonString,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (jsonString==<span class="keyword">null</span>||jsonString.length()&lt;=<span class="number">0</span>||clazz==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)Integer.valueOf(jsonString);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)jsonString;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">      <span class="keyword">return</span>  (T)Long.valueOf(jsonString);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(jsonString), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码使用了阿里巴巴的fastJson作为json和java对象转换的工具，具体的pom依赖为:</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  对于这个SpringBoot整合Redis虽然是跟着视频写的，但是也踩了很多坑，因为版本更新非常快，我使用的SpringBoot和Redis都是最新版的，很多地方配置和代码书写都和视频中和网上绝大数整合教程不相同，我也是查看很多资料才写好这个整合的，对于英文文档不感冒是真的吃亏，所以英语能力一定要提高！！！</p><p>  还有就是在整合redis的时候，如果连接的是远程服务器中的redis的话一定要更改服务器上的redis.conf文件，最重要的两点就是将bind后面的地址修改或者直接注释掉bind那一行配置，还有就是将protected-mode更改为no，不然远程电脑连接不上。</p><p>  当然还有很多细节问题都需要注意，留下这篇文章作为踩坑记录，希望下面敲代码的日子会越来越顺利。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>链表和递归</title>
      <link href="/2019/04/28/%E9%93%BE%E8%A1%A8%E5%92%8C%E9%80%92%E5%BD%92/"/>
      <url>/2019/04/28/%E9%93%BE%E8%A1%A8%E5%92%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="从一道leetcode题目开始"><a href="#从一道leetcode题目开始" class="headerlink" title="从一道leetcode题目开始"></a>从一道leetcode题目开始</h2><p>  题目描述：</p><p>  <img src="/2019/04/28/链表和递归/1.jpg" alt="avatar"></p><p>  看一下题目内容其实很简单就是删除一个链表中值为val的所有节点并且返回被删除完的链表。</p><p>  上篇文章讲了如何进行链表操作，这时候我们其实就可以通过老方法遍历整个链表，然后通过比较每个节点的值和val的值是否相等，相等则删除，不相等则保留。</p><p>  示例代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="comment">//这里的ListNode是leetcode给定的，里面包含next和val字段</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个虚拟头结点</span></span><br><span class="line">    ListNode virtualNode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//虚拟头结点的next节点是头结点</span></span><br><span class="line">    virtualNode.next=head;</span><br><span class="line">    <span class="comment">//将虚拟头结点赋值给currentNode当前节点</span></span><br><span class="line">    ListNode currentNode=virtualNode;</span><br><span class="line">    <span class="keyword">while</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//通过遍历当前节点来删除元素</span></span><br><span class="line">      <span class="keyword">if</span> (currentNode.next.val==val)&#123;</span><br><span class="line">        <span class="comment">//如果当前头结点的next元素的val值等于给定的val</span></span><br><span class="line">        <span class="comment">//则将当前节点的next元素直接指向next的next</span></span><br><span class="line">        <span class="comment">//那么原来next节点就直接被删除了</span></span><br><span class="line">        currentNode.next=currentNode.next.next;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不相等则跳到下一个节点，循环知道currentNode的next节点为null</span></span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回虚拟头结点的next，这里就是被删除元素的原来的头结点</span></span><br><span class="line">    <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="/2019/04/28/链表和递归/2.jpg" alt="avatar"></p><p>  在考虑递归如何写的时候我们先需要了解递归的宏观语意。</p><p>  一个递归函数其实本质就是函数调用，只不过它是自己调用自己。</p><p>  递归函数就是将原来的问题转化为更小的问题，知道最后求出最基本的解。</p><p>  最基本的解一般是我们通过if条件判断来终结的，如果不添加if判断给递归函数一个终结（最基本的解，例如求阶乘的时候等于1等于0的时候就是最基本的解），那么计算机就会无限产生递归调用，这会导致cpu的方法栈（写栈的时候提过，函数调用就是通过栈来实现的）爆满从而报错。</p><p>  <img src="/2019/04/28/链表和递归/3.jpg" alt="avatar"></p><p>  如何写一个递归函数，我们不要去考虑它的实现细节，最好是通过宏观语意来完成它。</p><p>  首先我们最能确定的就是它的最基本解，然后我们需要在原本函数里面再次调用该函数并修改参数（目的是将原问题转换为更小的问题）。上图的代码只是最简单的示例，当递归函数稍微再复杂点的时候，我们就需要获取到递归调用函数产生的值并对这个return的值来做些修改最后再返回给上一级调用这个级别的递归函数的函数。</p><h2 id="使用递归来实现链表的删除-上述题目"><a href="#使用递归来实现链表的删除-上述题目" class="headerlink" title="使用递归来实现链表的删除(上述题目)"></a>使用递归来实现链表的删除(上述题目)</h2><p>  首先完成一个递归函数我们需要先确定我们怎么把这个递归函数变为更小的函数。</p><p>  这里，我们将这个删除长度n的链表中元素的问题转换成先判断从第二个节点开始到最后节点中删除符合条件的节点，然后再转换为从第三个节点到最后节点删除符合条件的节点，直到我们的问题变成了删除最后一个空节点中符合条件的元素，当然这个时候空节点里面是不可能有的，所以我们这时候直接返回head，这样最基本解就出来了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  之后就是转换为更小的问题了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将问题转换为小问题</span></span><br><span class="line">ListNode result=removeElements(head.next,val);</span><br><span class="line"><span class="comment">//每次return都是return给上一级递归的结果</span></span><br><span class="line"><span class="comment">//如果当前节点的val值和给定val相等</span></span><br><span class="line"><span class="comment">//则直接return给上一级不包含该节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果不相等说明不需要删除</span></span><br><span class="line">    <span class="comment">//则需要将返回的结果前面加上头结点head在返回head</span></span><br><span class="line">    head.next=result;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  完整代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span>  ListNode <span class="title">removeElements</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"> <span class="comment">//首先考虑最基本的问题</span></span><br><span class="line"> <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ListNode resultNode=removeElements(head.next,val);</span><br><span class="line"> <span class="keyword">if</span> (head.val==val)&#123;</span><br><span class="line">   <span class="keyword">return</span> resultNode;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  head.next=resultNode;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其实整个问题可以这么理解，我需要删除一个链表中符合元素的节点，那么我把这个问题转化为小问题，将整个链表转换为从2开始到结尾的链表，然后S到从3开始到结尾的链表，最后到从结尾到结尾的节点（null），那么我就是从最后一个节点找需要删除的节点，假设如果最后一个节点是要删除的节点，那么这时候我们只需要将这个节点删除并且返回给上一级调用递归函数。这时候我们返回的null然后上一级接收到的result就是null，然后这个函数继续执行到if(head.val==val)，这时候就判断（第二级递归就是最后两个节点的链表）当前链表中的头结点的val是否满足，满足就跟刚刚一样“删除”该节点，不满足就将这个head的next设置为result，也就是将result的头结点暂时设置为当前head（将当前head设置为头结点并返回给上一级调用的函数），这样无限的返回，最后返回的就是原本链表中需要删除元素后的链表了。</p><p>  这个时候我们可以将递归写的更简单</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next=removeElements(head.next,val);</span><br><span class="line">    <span class="keyword">return</span> head.val==val?head.next:head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单实用递归实现链表的创建"><a href="#简单实用递归实现链表的创建" class="headerlink" title="简单实用递归实现链表的创建"></a>简单实用递归实现链表的创建</h2><p>  首先我们考虑如何通过递归实现该功能，创建一个链表，我们将问题缩小就是从创建节点开始。例如我们现在给定一个数组，然后我们通过这个数组来创建链表。首先这个数组的索引肯定是我们递归实现的条件，比如一个10个元素的数组，我们需要创建十个元素的链表，我们可以将问题变为创建从索引1开始到结束的链表，然后从索引2到结束，最后到从末尾到末尾（创建最后一个元素），所以这时候我们最基本条件就出来了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((index+<span class="number">1</span>)==array.length)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候我们就要来实现将问题转换为小问题<br>  其实很简单。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode result=createElement(array,index+<span class="number">1</span>);</span><br><span class="line">ListNode currentNode=<span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">currentNode.next=result;</span><br><span class="line"><span class="keyword">return</span> currentNode;</span><br></pre></td></tr></table></figure><p>  完整代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">createListNode</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((index+<span class="number">1</span>)==array.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    ListNode result=createListNode(array,index+<span class="number">1</span>);</span><br><span class="line">    ListNode currentNode=<span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">    currentNode.next=result;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>这个星期开始复习的信号系统，对于我这个学物联网的同学，不会什么高数，硬件是真的很烦躁，信号考完了，能不能过就靠老师助攻了。今天写篇博客来缓解一下一个星期没写代码的愧疚，这个递归还真的有点难理解，还需要勤敲勤练。加油吧！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java实现自定义验证注解</title>
      <link href="/2019/04/20/Java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/04/20/Java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>  从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注释)。</p><p>  Annotation 其实就是代码里的特殊标记, <font color="red">这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。</font> 通过使用 Annotation, 程序员可以在<font color="red">不改变原有逻辑的情况下</font>, 在源文件中嵌入一些补充信息。</p><p>  Annotation 可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在 Annotation 的“name=value” 对中。</p><p>  例如<img src="/2019/04/20/Java实现自定义验证注解/1.jpg" alt="avatar"></p><p>  Annotation 能被用来为程序元素(类, 方法, 成员变量等) 设置元数据。</p><h2 id="基本的Annotation"><a href="#基本的Annotation" class="headerlink" title="基本的Annotation"></a>基本的Annotation</h2><p>  使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。 用于修饰它支持的程序元素。</p><p>  三个基本的 Annotation:</p><ul><li>@Override: 限定重写父类方法, 该注释只能用于方法</li><li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</li><li>@SuppressWarnings: 抑制编译器警告。</li></ul><h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>  定义新的 Annotation 类型使用 @interface 关键字</p><p>  Annotation 的成员变量在 Annotation 定义中以<font color="red">无参数方法</font>的形式来声明。 其方法名和返回值定义了该成员的名字和类型。</p><p>  可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</p><p>  没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation</p><p>  下面是java验证的NotNull注解的源码：</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/2.jpg" alt="avatar"></p><p>  其中所有的成员变量都是以无参方法定义的，default定义了某个成员变量的默认值，这是一个包含成员变量的 Annotation 所以我们也可以称为 元数据 Annotation。</p><p>  下面是Override注解的源码：</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/3.jpg" alt="avatar"></p><p>  这个注解没有成员变量，所以我们可以称为标记。而且可以注意的是这个注解的注解(元注解) @Retention是SOURCE类型的，编译器会直接丢弃这种策略的注释。也就是我们编译成class文件的时候是看不见@Override注解的，这个我们后面会讲。</p><h2 id="提取-Annotation-信息"><a href="#提取-Annotation-信息" class="headerlink" title="提取 Annotation 信息"></a>提取 Annotation 信息</h2><p>  JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注释的程序元素。</p><p>  <font color="red">当一个 Annotation 类型被定义为运行时 Annotation 后</font>, 该注释才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取。</p><p>  程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信息</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/4.jpg" alt="avatar"></p><h2 id="JDK-的元-Annotation"><a href="#JDK-的元-Annotation" class="headerlink" title="JDK 的元 Annotation"></a>JDK 的元 Annotation</h2><p>  JDK 的元 Annotation 用于修饰其他 Annotation 定义(注解的注解)</p><ul><li><p>@Retention注解</p><p> 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值</p><ul><li>RetentionPolicy.CLASS: 编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注释. 这是默认值</li><li>RetentionPolicy.RUNTIME:编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释</li><li>RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释</li></ul></li><li><p>@Target注解</p><p> 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。可以参考本文第一张图片。</p></li><li><p>@Documented注解</p><p> 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档</p></li><li><p>@Inherited注解</p><p> 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注释</p></li></ul><h2 id="实现自定义验证注解-IsMobile"><a href="#实现自定义验证注解-IsMobile" class="headerlink" title="实现自定义验证注解@IsMobile"></a>实现自定义验证注解@IsMobile</h2><p>  参考于<a href="https://www.cnblogs.com/xz816111/p/9484902.html" target="_blank" rel="noopener">实现自定义验证注解</a></p><p>  @IsMobile是一个验证是否为11位手机号码的验证注解。</p><p>  API开发中经常会遇到一些对请求数据进行验证的情况，这时候如果使用注解就有两个好处，一是验证逻辑和业务逻辑分离，代码清晰，二是验证逻辑可以轻松复用，只需要在要验证的地方加上注解就可以。</p><p>  Java提供了一些基本的验证注解，比如@NotNull、@Size，但是更多情况下需要自定义验证逻辑，这时候就可以自己实现一个验证注解，方法很简单，仅需要两个东西：</p><ul><li>一个自定义的注解，并且指定验证器</li><li>一个验证器的实现</li></ul><p>这个时候我们就可以结合刚刚所学的知识就可以根据前面两部来实现验证注解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个表示该注解能对于类型注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span><br><span class="line"><span class="comment">//这个表示在运行时起作用</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//@Constraint是最关键的，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = IsMobileValidator.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IsMobile &#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "手机号码格式错误"</span>;</span><br><span class="line">  <span class="comment">//groups()和payload()也为@Constraint要求，可默认为空</span></span><br><span class="line">  Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">  Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>@Target</p><p>@Target指明这个注解要作用在什么地方，可以是对象、域、构造器等，因为要作用在域上，因此这里可以选择FIELD（这里我是直接所有的可以）。参考了NotNull注解</p></li><li><p>@Retention</p><p>指明生命周期，这里选择RUNTIME</p></li><li><p>@Constraint</p><p>实现验证器最重要的注解，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器。</p></li><li><p>message()</p><p>验证失败之后返回的消息。此方法为@Constraint要求</p></li><li><p>groups()和payload()</p><p>groups()和payload()也为@Constraint要求，可默认为空，详细用途可以查看@Constraint文档</p></li></ul><p>下面是验证器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-20 10:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里实现ConstraintValidator接口需要重写initialize和isValid方法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * required指这个数据是否必须</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    required=constraintAnnotation.required();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是必须的，那么就验证是否为手机号</span></span><br><span class="line">    <span class="keyword">if</span> (required)&#123;</span><br><span class="line">      <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果非必须，那么空值和手机号都可以通过验证</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(value))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其细节说明在注释中。</p><p>这样我们就实现了一个自定义验证注解，我们只需要在要验证的元素的前面加上@IsMobile就行了。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自己动手写链表</title>
      <link href="/2019/04/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>  链表是一种重要的数据结构，是一种数据的存储方式。链表由多个链表元素组成，每个元素称为节点。链表存储的物理结构可能是连续的，但也可能是无序的。但是链表之间的元素（节点）是有序的逻辑相连。</p><p>  <img src="/2019/04/18/自己动手写链表/1.jpg" alt="avatar"></p><p>  链表是一种很灵活的数据结构，它不需要指定内存的大小，删除节点不需要要像数组那样讲数据整体向前移动，只需要更改节点的指向。但是链表的结构也决定了它的许多缺点，比如说访问需要遍历元素，不能像数组那样依靠索引，还有就是链表每个元素存的是一个对象，这是一笔非常大的内存开销。</p><p>  链表从方向可以分为单向链表，双向链表。<br>  从结构上可以分为单链表，环形链表。</p><p>  <img src="/2019/04/18/自己动手写链表/2.jpg" alt="avatar"></p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-17 18:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点里面的元素内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e,Node next)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 虚拟链表头，让add更加有逻辑</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 链表大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead=<span class="keyword">new</span> Node();</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 链表添加头元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    add(<span class="number">0</span>,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定位置添加元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">      <span class="comment">//当index非法排除异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取要插入的元素的前面的元素</span></span><br><span class="line">      Node pre=dummyHead;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index ; i ++)&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        pre = pre.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//首先调用的是new Node(e,pre.next)</span></span><br><span class="line">      <span class="comment">//为的是让新节点的next节点指向它要添加位置的前面一个元素的原来的next节点</span></span><br><span class="line">      <span class="comment">//再进行赋值操作为了将添加节点前面的节点的next改为该元素</span></span><br><span class="line">      pre.next = <span class="keyword">new</span> Node(e,pre.next);</span><br><span class="line">      size ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在链表末尾加入元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    add(size,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某个索引的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Node currentNode=dummyHead.next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currentNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 更新后的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;=size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node currentNode=dummyHead.next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode.e=e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包含某个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    Node currentNode=dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((currentNode.e).equals(e))&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除某个索引元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;=size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node currentNode=dummyHead;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//暂存被删除的节点</span></span><br><span class="line">      Node tempNode=currentNode.next;</span><br><span class="line">      <span class="comment">//将遍历到的节点（被删除节点前面一个）的next指向被删除节点的next节点</span></span><br><span class="line">      currentNode.next=tempNode.next;</span><br><span class="line">      <span class="comment">//将被删除的节点的next指向为null</span></span><br><span class="line">      tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> tempNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    Node currentNode=dummyHead.next;</span><br><span class="line">    <span class="comment">//遍历到节点的next为空</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//判断是否与需要判断的元素相等，如果相等则删除</span></span><br><span class="line">      <span class="keyword">if</span> (currentNode.e.equals(e))&#123;</span><br><span class="line">        Node tempNode=currentNode.next;</span><br><span class="line">        currentNode.next=tempNode.next;</span><br><span class="line">        tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用链表实现栈"><a href="#使用链表实现栈" class="headerlink" title="使用链表实现栈"></a>使用链表实现栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-17 20:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.linkedList=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">    linkedList.addFirst(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表和数组实现栈的比较"><a href="#链表和数组实现栈的比较" class="headerlink" title="链表和数组实现栈的比较"></a>链表和数组实现栈的比较</h2><p>  从复杂度来考虑，数组和链表实现的出栈入栈等操作的复杂度都相同，我们这里来测试一下。测试代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testStack</span><span class="params">(Stack&lt;Integer&gt; stack, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++) &#123;</span><br><span class="line">    stack.push(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++) &#123;</span><br><span class="line">    stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">  ArrayStack&lt;Integer&gt; arrayStack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time1 = testStack(arrayStack, opCount);</span><br><span class="line">  System.out.println(<span class="string">"ArrayStack, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  LinkedListStack&lt;Integer&gt; linkedListStack = <span class="keyword">new</span> LinkedListStack&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time2 = testStack(linkedListStack, opCount);</span><br><span class="line">  System.out.println(<span class="string">"LinkedListStack, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其实这个时间比较很复杂，因为LinkedListStack中包含更多的new操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果如下：<br>  <img src="/2019/04/18/自己动手写链表/3.jpg" alt="avatar"></p><p>  其实这个测试结果不会是稳定的，相比较之下，他们的快慢主要和环境有很大关系。</p><p>  当然，ArrayStack在添加元素时可能会执行扩容操作，这个时间复杂度是O(n)的，在LinkedListStack添加元素的时候虽然没有扩容的操作但是它会执行大量new对象操作，这也是非常占用资源的。总体来说，它们的增添和删除元素的时间复杂度都是O(1),所以可以说它们执行时间的差异并不是很大。</p><p>  <img src="/2019/04/18/自己动手写链表/5.jpg" alt="avatar"></p><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p>前面一篇文章专门讲到了Queue，队列就是（FIFO）的数据结构，我们主要去实现队列的入队（在队尾添加元素），出队（在队首删除元素）。回想我们前面实现的链表，在队首删除元素容易（时间复杂度是O1的），但是要在队尾添加元素就非常繁琐了，我们需要遍历整个链表，当数据量一大，我们的执行时间就会变得非常大，所以我们为了效率考虑，我们需要添加一个尾节点。</p><p>这时候我们怎么实现队列的操作呢？其实很简单，当我们入队的时候只需要将尾节点的next指向当前入队的新的节点，当然我们不得不把所有尾节点的next都置为null，为的是我们的逻辑和效率，浪费一个空间也不是大问题。</p><p>而当我们进行出队操作时，我们只需要将原来头结点变为原来头结点的next节点，返回出队节点的时候我们只需要将被删除的头结点的next节点变为null就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-18 19:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node head,tail;</span><br><span class="line">  <span class="comment">//维持链表元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head=<span class="keyword">null</span>;</span><br><span class="line">    tail=<span class="keyword">null</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队只能从尾部</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果尾节点为空，那么就代表整个链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (tail==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//需要将元素赋值给头节点和尾节点</span></span><br><span class="line">      head=<span class="keyword">new</span> Node(e);</span><br><span class="line">      tail=head;</span><br><span class="line">      size++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不为空则需要新节点赋值给尾节点的next</span></span><br><span class="line">      tail.next=<span class="keyword">new</span> Node(e);</span><br><span class="line">      <span class="comment">//尾节点变换</span></span><br><span class="line">      tail=tail.next;</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队操作，只能从第一个出队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 头节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当链表为空时无法进行出队操作</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the linkedListQueue is empty!"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node tempNode=head;</span><br><span class="line">      <span class="comment">//将原来头结点的next变为当前头结点</span></span><br><span class="line">      head=head.next;</span><br><span class="line">      <span class="comment">//将要返回的“头结点”的next置为null</span></span><br><span class="line">      tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> tempNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种实现对列的比较"><a href="#三种实现对列的比较" class="headerlink" title="三种实现对列的比较"></a>三种实现对列的比较</h2><p>前面我们使用了数组队列和循环队列，这时候我们加入我们刚刚实现的链表队列。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testQueue</span><span class="params">(Queue&lt;Integer&gt; q, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">      q.enqueue(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">      q.dequeue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    ArrayQueue&lt;Integer&gt; arrayQueue = <span class="keyword">new</span> ArrayQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time1 = testQueue(arrayQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"ArrayQueue, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    LoopQueue&lt;Integer&gt; loopQueue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time2 = testQueue(loopQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"LoopQueue, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    LinkedListQueue&lt;Integer&gt; linkedListQueue = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time3 = testQueue(linkedListQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"LinkedListQueue, time: "</span> + time3 + <span class="string">" s"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们能得到结果：<br><img src="/2019/04/18/自己动手写链表/4.jpg" alt="avatar"></p><p>通过我们实践和分析，链表实现的队列也是O(1)的时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>redis初识与安装</title>
      <link href="/2019/04/16/redis%E5%88%9D%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/04/16/redis%E5%88%9D%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>  redis是一款基于C语言的开源的基于键值的存储服务系统它支持丰富的数据类型，如：string、list、set、zset(sorted set)、hash。</p><p>  <img src="/2019/04/16/redis初识与安装/1.jpg" alt="avatar"></p><p>  Redis的创始人是意大利人Salvatore Sanfilippo，他的网名是antirez，我们可以通过<a href="https://github.com/antirez" target="_blank" rel="noopener">https://github.com/antirez</a>来访问他的主页。</p><h2 id="Redis的优势"><a href="#Redis的优势" class="headerlink" title="Redis的优势"></a>Redis的优势</h2><p>  Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。以设置和获取一个256字节字符串为例，它的读取速度可高达110000次/s，写速度高达81000次/s。当然这是官方声明的，但是实际应用达到w级是肯定没问题的。</p><p>  因此redis的性能非常好，而且可以支持多种数据结构和持久化（RDB实现方式和AOF实现方式）。</p><p>  redis可以支持多种编程语言，在java，php，python都有实现。</p><p>  redis可谓短小精悍，redis5.0的代码也就只有5w行，除去实现分布式的代码，它仅仅只有23000行代码，但是redis提供的功能非常丰富，比如发布订阅，Lua脚本，事务等。</p><p>  redis提供主从复制，这为后面实现高并发和高可用打下了基础。</p><h2 id="Redis典型应用场景"><a href="#Redis典型应用场景" class="headerlink" title="Redis典型应用场景"></a>Redis典型应用场景</h2><ul><li>缓存系统</li><li>计数器</li><li>消息队列系统</li><li>排行榜</li><li>社交网络</li><li>实时系统</li></ul><h2 id="Redis的安装和简单运行"><a href="#Redis的安装和简单运行" class="headerlink" title="Redis的安装和简单运行"></a>Redis的安装和简单运行</h2><ul><li>下载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure><p>可能会遇到DNS解析的问题，这时候要去更改<br>/etc/resolv.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8 #google域名服务器</span><br><span class="line">nameserver 8.8.4.4 #google域名服务器</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure><ul><li>创建文件并编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-5.0.3</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>进入目录并运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server</span><br></pre></td></tr></table></figure><ul><li>修改问题和警告</li></ul><p>这时候启动redis的时候难免会出现警告，首先肯定是关于配置文件的问题，redis建议你启动的时候附带配置文件路径</p><p>如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server redis.conf</span><br></pre></td></tr></table></figure><p>我们需要将redis以守护进程的方式启动以避免关闭命令行是redis不退出，我们只需要修改redis.conf文件，设置daemonize为yes就行。</p><p>我们运行之后会发现我们无法再进行其他操作了，这时候我们需要启动的时候添加一个&amp;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server redis.conf &amp;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>你可能还会遇到以下问题</p><ul><li>WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</li></ul><p>大概意思是你的tcp设置为128对于这个环境来说太小了，redis建议你设置为511</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 511 &gt; /proc/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><ul><li>you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis.</li></ul><p>解决办法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure><ul><li>overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.</li></ul><p>按照提示将vm.overcommit_memory = 1加入到/etc/sysctl.conf中并执行命令sysctl vm.overcommit_memory=1就好了</p><ul><li><p>简单的设置值和取值</p><p>命令：</p><pre><code>set key valueget key</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自己动手写Queue</title>
      <link href="/2019/04/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Queue/"/>
      <url>/2019/04/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Queue/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p><img src="/2019/04/15/自己动手写Queue/1.jpg"></p><p>  队列是一种先进先出的数据结构（First In First Out）。结合生活实际，这里的队列就是从生活中的排队得来的。比如我们正在排队办理业务，后来的人只能从队列最后一个进入队伍（入队），当前面的的人办理完业务的时候他就离开了队伍（出队）。由此我们可以发现，要实现队列其实最重要的就是出队和入队的操作。所以我们就可以定义我们的Queue接口了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 19:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 出队的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 队列大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取队头元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 队头元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组队列"><a href="#数组队列" class="headerlink" title="数组队列"></a>数组队列</h2><p>  了解队列的特点，我们不难就想到了上次使用数组实现栈，其实队列和栈也差不多，只不过更改了出和入的操作罢了，这里我就不明细讲了，直接上代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 19:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array=<span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    array=<span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>  我们来对上面的数组队列做一个时间复杂度分析</p><p>  当我们进行入队操作的时候时间复杂度肯定为O(1),这是非常高效的。但是，我们要进行出队的时候就大不相同了，因为我们每次出队，当移除头元素的时候我们就需要将后面的元素挨个往前移动，因为我们这个底层就是依靠动态数组实现的，所以就是调用动态数组删除某个索引元素的方法，那么这个时间复杂度就是O(n),也就是说当我们进行出队操作的时候，队伍量越大我们消耗的时间就越大，这是低效且我们不愿意看到的。在数据结构中，很多时候我们都会使用空间和时间的互换，时间换取空间资源，空间资源换取时间资源，所以我们这里可以使用循环队列来提高出队效率。</p><p>  <img src="/2019/04/15/自己动手写Queue/2.jpg"></p><p>  循环队列是什么，其实就相当于将队列的头和尾相连接</p><p>  如图：<br>  <img src="/2019/04/15/自己动手写Queue/3.jpg"></p><p>  我们增加了一个头索引和尾索引来达到虚拟的连接（这个当然不是真实的）。当我们初始化这个队列的时候，头索引和尾索引都是0,当头索引和尾索引相等的时候这个队列为空，首先记着这个（很好理解，就是头和尾中间没有间隔那不就是空了么）。当我们进行入队操作的时候，将元素放入循环队列的尾索引处，放置完成后将尾索引+1（后移一个单位）。当进行出队的时候，我们将头元素删除，并将头索引+1（后移一个单位）。是不是很简单？当然不可能这么简单，因为这个队列是循环的，头和尾是相连的，这里我们就可以利用相连的特性来使用我们刚刚可能出队的时候浪费的空间资源，怎么做？其实就是更改一下我们头索引和为索引相加的位置，我们将他们++操作更改为front=(front+1)%capacity就行，这里的capacity是指整个队列的容量。</p><p>  还有一个注意点就是当我们整个队列满的时候我们是无法判断队列是否为空的，因为这时候头索引和尾索引也是相等的，这个时候我们就需要牺牲一个存储单元来解决冲突。</p><p>  下面就直接贴代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 19:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> E[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> front, tail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    array = (E[])<span class="keyword">new</span> Object[capacity+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//头尾索引置为0</span></span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入队</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当使用长度和容量相等的时候进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (((tail - front + <span class="keyword">this</span>.getCapacity()+<span class="number">1</span>) % (<span class="keyword">this</span>.getCapacity()+<span class="number">1</span>)) == <span class="keyword">this</span>.getCapacity()) &#123;</span><br><span class="line">      resize(<span class="keyword">this</span>.getCapacity() * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将元素e放入队尾</span></span><br><span class="line">    array[tail]=e;</span><br><span class="line">    tail++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出队</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当队列为空抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (front==tail)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The loopQueue has no element"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//将头元素置为null并且将头索引向后移动一个单位</span></span><br><span class="line">      E temp=array[front];</span><br><span class="line">      array[front]=<span class="keyword">null</span>;</span><br><span class="line">      front=(front+<span class="number">1</span>)%array.length;</span><br><span class="line">      <span class="comment">//当队列只使用了四分之一时将队列缩容</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.getSize()==<span class="keyword">this</span>.getCapacity()/<span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.getCapacity()/<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        resize(<span class="keyword">this</span>.getCapacity()/<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取当前队列的实际长度（使用头尾索引计算）</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tail - front + <span class="keyword">this</span>.getCapacity()+<span class="number">1</span>) % (<span class="keyword">this</span>.getCapacity()+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array[front];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail==front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    E[] newArray = (E[])<span class="keyword">new</span> Object[capacity+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> size = (tail - front + <span class="keyword">this</span>.getCapacity()+<span class="number">1</span>) % (<span class="keyword">this</span>.getCapacity()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      newArray[i]=array[(front + i) % size];</span><br><span class="line">    &#125;</span><br><span class="line">    array = newArray;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = size ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i != tail; i = (i + <span class="number">1</span>) % array.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i + <span class="number">1</span>) % array.length == tail) &#123;</span><br><span class="line">        stringBuilder.append(array[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stringBuilder.append(array[i]).append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(<span class="string">"] tail container:"</span>).append(<span class="keyword">this</span>.getCapacity());</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LoopQueue&lt;Integer&gt; loopQueue=<span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line">      loopQueue.enqueue(i);</span><br><span class="line">      System.out.println(loopQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    loopQueue.dequeue();</span><br><span class="line">    loopQueue.dequeue();</span><br><span class="line">    loopQueue.dequeue();</span><br><span class="line">    System.out.println(loopQueue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/15/自己动手写Queue/4.jpg"></p><h2 id="数组队列和循环队列的比较"><a href="#数组队列和循环队列的比较" class="headerlink" title="数组队列和循环队列的比较"></a>数组队列和循环队列的比较</h2><p>  大数比较</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testQueue</span><span class="params">(Queue&lt;Integer&gt; q, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">    q.enqueue(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">    q.dequeue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">  ArrayQueue&lt;Integer&gt; arrayQueue = <span class="keyword">new</span> ArrayQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time1 = testQueue(arrayQueue, opCount);</span><br><span class="line">  System.out.println(<span class="string">"ArrayQueue, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  LoopQueue&lt;Integer&gt; loopQueue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time2 = testQueue(loopQueue, opCount);</span><br><span class="line">  System.out.println(<span class="string">"LoopQueue, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果： <img src="/2019/04/15/自己动手写Queue/5.jpg"></p><p>  可以看出，当数据量大的时候，LoopQueue完胜。</p><p>  当我们把数据量变为10的时候我们不难发现，LoopQueue还是胜出,并且速度比数组队列快一个量级。</p><p>  <img src="/2019/04/15/自己动手写Queue/6.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自己动手写Stack</title>
      <link href="/2019/04/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Stack/"/>
      <url>/2019/04/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Stack/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p><img src="/2019/04/15/自己动手写Stack/1.jpg"></p><p>我觉得栈是一个很简单的概念，栈是一种后进先出的数据结构(Last In And First Out)，大家都见过装羽毛球的筒吧，你会发现当你装完羽毛球之后第一个拿出来的肯定是最后一个放进去的。其实这就是栈，它是一种线性结构，我们学习了数组其实就很容易理解栈了。</p><p>为什么呢？我们可以先想一下，对于栈这样的数据结构，我们能对它进行什么样的操作。其实也就是入栈（将一个羽毛球放进去），出栈（将一个羽毛球拿出来），判断栈是否为空（羽毛球筒里面有没有羽毛球），计算栈的大小（计算羽毛球筒里有多少个羽毛球），获取栈顶元素（获取羽毛球筒中最上面的羽毛球）。无非就是这几个操作。所以我们现在可以定义栈的接口了，如下面代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 12:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取栈的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断栈是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将元素放入栈</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出栈</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 出栈的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得栈最上面的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与数组的关系"><a href="#栈与数组的关系" class="headerlink" title="栈与数组的关系"></a>栈与数组的关系</h2><p>之前我的一篇博客介绍了如何实现动态数组，那个动态数组中我们实现了添加删除元素，计算数组大小，判断数组是否为空，获取数组的元素等方法。其实我们对栈的操作也就是对数组操作的子集，计算大小，判断为空我们可以直接使用数组的方法，添加元素对于栈来说就是在末尾添加元素，删除就是删除末尾元素，而获取元素就是获取最后一个元素。所以我们可以直接定义我们的ArrayStack类了（这个类是实现了刚刚的Stack接口的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过数组实现栈</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array=<span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入栈操作</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出栈操作</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//上篇博客中没有getLast和getFirst方法</span></span><br><span class="line">  <span class="comment">//这里是我后面添加的，其实实现这个方法很简单，只要固定index就行了</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里重写toString方法为了后面测试能清楚显示</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="string">"Stack ["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getSize(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i != <span class="keyword">this</span>.getSize() - <span class="number">1</span>) &#123;</span><br><span class="line">        stringBuilder.append(array.get(i)).append(<span class="string">","</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        stringBuilder.append(array.get(i)).append(<span class="string">"]pop"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的一些应用场景"><a href="#栈的一些应用场景" class="headerlink" title="栈的一些应用场景"></a>栈的一些应用场景</h2><ul><li>word和一些IDE中的撤销功能</li></ul><p>将用户的操作放入栈中，当实行撤销操作的时候把用户最近的操作撤销。</p><ul><li><p>程序调用的系统栈</p><p>  <img src="/2019/04/15/自己动手写Stack/2.jpg"><br>比如我们调用A方法需要调用B方法，调用B方法的时候我们需要调用C方法，这时候我们C方法执行完了之后我们系统是不知道我们下面应该执行什么方法的，所以这时候栈就登场了，当我们执行A方法需要调用B方法的时候我们将这时候跳转执行前的方法和代码行数记录到栈中（这时候我们执行的是A方法的第二行代码调用了B<br>方法，所以我们把A2存入栈中）。同理，我们运行B方法的时候在第二行调用了C方法，我们就把B2存入栈中，之后我们C方法执行完之后系统就看栈中有没有还需要返回的方法，如果有就跳回指定的方法的代码行数，比如C方法执行完，我们栈中有B2，我们就跳回B2执行并且把栈顶元素删除，接着我们B方法执行完了，我们看栈中还有A2，我们就跳转到A2执行代码并且把A方法执行完查看栈中没有元素的时候我们就把整个A方法执行完成了。</p></li></ul><h2 id="关于栈的算法题目"><a href="#关于栈的算法题目" class="headerlink" title="关于栈的算法题目"></a>关于栈的算法题目</h2><p>在leetcode中有一道使用栈解决的简单题目</p><p>题目是这样的：</p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>思考一下题目，其实就可以和栈结合起来了，我们将给出的串进行遍历获取字符，我们判断字符是否为”{“,”[“,”(“,为这三个我们就把字符存入栈中，如果不是我们就把它和栈素比较是否匹配，如果不匹配那么直接返回false。大致思是这样，具体细节代码注释里有详细解释。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个stack</span></span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//声明栈顶元素</span></span><br><span class="line">    Character topCharacter;</span><br><span class="line">    <span class="comment">//循环遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">      <span class="comment">//获取某个字符</span></span><br><span class="line">      Character character=s.charAt(i);</span><br><span class="line">      <span class="comment">//如果该字符等于'&#123;'或'['或'('的时候存入栈中</span></span><br><span class="line">      <span class="keyword">if</span> (character==<span class="string">'&#123;'</span>||character==<span class="string">'['</span>||character==<span class="string">'('</span>)&#123;</span><br><span class="line">        stack.push(character);</span><br><span class="line">        <span class="comment">//直接进入下一层循环</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果不是，那么就是与之相对的了</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//首先判断栈是否为空</span></span><br><span class="line">        <span class="comment">//因为如果栈中没有元素且这个字符是右边的括号</span></span><br><span class="line">        <span class="comment">//那么这个字符串肯定不符合要求</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//获取栈顶元素</span></span><br><span class="line">          topCharacter=stack.pop();</span><br><span class="line">          <span class="comment">//判断栈顶元素是否和该元素匹配，如不匹配直接false</span></span><br><span class="line">          <span class="keyword">if</span> (character==<span class="string">'&#125;'</span>&amp;&amp;topCharacter!=<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (character==<span class="string">']'</span>&amp;&amp;topCharacter!=<span class="string">'['</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (character==<span class="string">')'</span>&amp;&amp;topCharacter!=<span class="string">'('</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果循环都是正确的，那么还要判断栈是否为空</span></span><br><span class="line">    <span class="comment">//因为"&#123;","["这种类型的情况都是错误的</span></span><br><span class="line">    <span class="comment">//但是前面没有考虑到，所以只要判断后面直接没有元素匹配</span></span><br><span class="line">    <span class="comment">//也就是栈是否不为空</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自己动手做Array</title>
      <link href="/2019/04/13/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9AArray/"/>
      <url>/2019/04/13/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9AArray/</url>
      
        <content type="html"><![CDATA[<h2 id="学习数据结构"><a href="#学习数据结构" class="headerlink" title="学习数据结构"></a>学习数据结构</h2><p>  一直以来在学习java web开发，里面很少涉及到数据结构相关的编程，再加上大一没有怎么好好学这门课程，这段时间开始慢慢捡回来，不说如何去精通它，但希望自己从数据结构开始训练自己的基础代码能力，如今用框架用的已经连代码都不会写了。。。</p><h2 id="Array代码"><a href="#Array代码" class="headerlink" title="Array代码"></a>Array代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-13 16:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 泛型数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> E[] array;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 有参构造方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//强制类型转换</span></span><br><span class="line">    array = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    <span class="comment">//size指向0</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认构造函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认容量为8</span></span><br><span class="line">    array = (E[]) <span class="keyword">new</span> Object[<span class="number">8</span>];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数组容量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数组元素个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回数组是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在index处插入一个新的元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 插入的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断index是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index is not valid!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断此时size和capacity是否相等，如果相等需要动态增加数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="keyword">this</span>.getCapacity()) &#123;</span><br><span class="line">      resize(size * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将index索引处后面的元素向后移一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">      array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array[index] = e;</span><br><span class="line">    ++size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态扩容</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> capacity 新的容量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新构建一个数组，将原来数组赋值上去</span></span><br><span class="line">    E[] temp = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      temp[i] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在头部添加元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用add方法</span></span><br><span class="line">    add(<span class="number">0</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在尾部添加元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取索引位置的元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 该索引处的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改索引位置的元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 要设置的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    array[index] = e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组中是否包含元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E originalElement : array) &#123;</span><br><span class="line">      <span class="keyword">if</span> (originalElement.equals(e)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找数组中第一次出现该元素的索引，不存在则返回-1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i].equals(e)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除指定索引元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E removeElement = array[index];</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index is not valid!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size; i++) &#123;</span><br><span class="line">      array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    --size;</span><br><span class="line">    <span class="comment">//压缩空间</span></span><br><span class="line">    <span class="comment">//这里使用懒压缩，如果在size为容量一半的时候就缩减容量为一半，则当这个数组再次增加一个元素的时候，它又会进行扩容。所以这里给予一定的空间</span></span><br><span class="line">    <span class="keyword">if</span> (size==array.length/<span class="number">4</span>&amp;&amp;array.length/<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">      resize(array.length/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeElement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除第一个</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除最后一个元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除第一个出现的某个元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 需要删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    remove(find(e));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(String.format(<span class="string">"Array: size = %d , capacity = %d\n"</span>, size, array.length));</span><br><span class="line">    res.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      res.append(array[i]);</span><br><span class="line">      <span class="keyword">if</span> (i != size - <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="string">", "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(<span class="string">']'</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  在Java中，数组的容量一旦声明就无法改变，这里我们通过封装实现了动态数组，并且实现了动态数组的增删改查等简单的功能。其中最为重要的是数组怎样实现增加，删除和动态扩容。</p><ul><li><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>当数组某个位置需要增加元素的时候，我们先要将该索引处后面的元素<font color="red">从最后一个元素开始把各自向后移动一个位置</font>。<img src="/2019/04/13/自己动手做Array/1.jpg"></p></li><li><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>当数组某个位置需要删除元素的时候，我们先要将该索引处后面的元素<font color="red">从索引处后面的元素开始依次将各自向前移动一个位置</font>。即为后面元素覆盖前面元素。</p></li><li><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><p>当数组进行增加的时候，如果数组容量不够时我们需要进行扩容。当数组中进行删除的时候，如果数组使用量已经远小于数组容量的时候我们需要进行压缩，来减少无用的空间。</p><p>我们上文代码实现扩容的方式是在数组增加和删除的时候重新构建一个数组并且将原来的数组赋值到新的数组中去。为了避免一直重复的重构容量大小，我们将扩充的容量变为原来容量的两倍(如果每次容量只是加1或者很少那么每次add之后都要执行重构容量，但是重构容量需要重新遍历数组，时间复杂度为O(n),极大地浪费时间，所以我们这里通过牺牲空间来节省时间)。当每次删除元素的时候，我们将判断数组使用量是否等于容量的四分之一，当为true的时候我们我们将容量变为原来一半以节省空间(这里为什么是四分之一和一半呢？其实具体数值并不是固定的，但是我们这里实现的是懒压缩，如果这里的判断条件为一半，当使用量为容量一半的时候我们就之间将容量变为原来一半，那么之后再次进行add方法时我们又需要扩容，从而引起复杂震荡，这是得不偿失的)。</p><p>上文Array代码基本是模仿JDK的ArrayList来实现的，在ArrayList中也是通过上述方法来实现的。</p><p>如实现动态扩容:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//这里使用了移位，为了使运算更加快速</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里设置的是最小容量和最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从对称加密到数字证书</title>
      <link href="/2019/04/11/%E4%BB%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%88%B0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
      <url>/2019/04/11/%E4%BB%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%88%B0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>​    简单来说，对称加密是解决通信之间的安全问题的最初手段。如下图中张大胖同学通过网络结识了远在美国的Bill同学，两个人聊得水深火热，但是有一天张大胖开始变得疑神疑鬼，因为他们聊得内容越来越隐私。张大胖就跟Bill说我总感觉不安全，我感觉有个人通过截取我们的消息在偷窥我们讲话，Bill听了也连忙说，对！我们的消息都是明文传输，中间被人截获就直接被读出来了。那怎么办？加密呗！</p><p>​    说着，张大胖就提议，不是有个对称加密嘛？我们用那个进行对消息的加密，我们首先沟通好我们的私钥，保持一致性，我给你发消息的时候我通过私钥加密，你收到消息的时候你再通过私钥进行解密，这样即使被中间人截获他也看不懂啦！Bill连忙夸赞张大胖同学说：”dei dei dei这个办法好呀！”。</p><p>​    就如下图中一样，张大胖和Bill就通过对称加密来进行通信，看似安全了，但是真的安全了吗？</p><p><img src="/2019/04/11/从对称加密到数字证书/1.jpg"></p><p>​    可是，当张大胖和Bill开始协商秘钥的时候，问题又出现了！Bill说既然网络是不安全的，万一现在正好有人再偷窥我们协商秘钥，我们协商好之后通过网络传输，这个秘钥就是明文传输的呀！那么，我们的秘钥不就暴露了吗？张大胖听了Bill的一席话，幡然醒悟。“对呀！这个可怎么办？而且当两个人进行通信的时候就要一个秘钥，一个人如果需要同一百个，一万个好友进行通信的时候那么就要有一百个，一万个秘钥，这！这哪能记得住呀？“。Bill这时候说道：“不行不行！这个通信方式也不安全！我们得再想一个。”</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>​    张大胖和Bill得知这种办法也不行的时候就一直提心吊胆地通信着，都不敢涉及隐私了，这个偷窥者听得也没劲了。直到后来，Bill听说了一种叫RSA非对称加密的算法，他一下子来了灵感。</p><p><img src="/2019/04/11/从对称加密到数字证书/2.jpg"></p><p>&nbsp;    RSA算法意思是一个人同时拥有公钥和私钥，这个公钥是公开的，别人都可以知道，但是这个私钥是自己保存的，千万不能让别人知道。而且，当文本经过某个人的公钥加密的时候，只有通过这个人的私钥才能进行解密，所以当Bill向张大胖同学发消息的时候，他就使用张大胖的公钥对消息进行加密，当张大胖收到消息的时候他就使用自己的私钥进行解密。流程如下图：</p><p> <img src="/2019/04/11/从对称加密到数字证书/3.jpg">    </p><h2 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密+对称加密"></a>非对称加密+对称加密</h2><p>​    这样，非对称加密就一下子解决了对称加密的两个缺点（秘钥泛滥和秘钥被网络截取），但是它也带来了一个很致命的缺点，那就是——效率问题，对同样大小的文本对称加密的速度是非对称加密速度的几百倍（我曾经拿RSA算法对一个50kb的文件进行加密，电脑直接叫唤着我不行了，我不行了）。大家知道通信是很讲究速度效率的，这个非对称加密虽然安全但是速度太慢了，这叫人怎么能忍呢？</p><p>​    这么愚蠢的问题当然不会困惑张大胖和Bill很久，他们想出来了一个二者结合的方法！当张大胖和Bill要进行通信的时候，他们就先使用非对称加密沟通好对称加密的秘钥（也就是在这个非对称加密的通道里传输秘钥）这样秘钥就不会被截获了，就算截获也是密文，偷窥者没办法呀。然后双方就使用刚刚非对称加密通信产生的对称加密的秘钥来进行加密解密，这样一来安全问题和效率问题就得到了很好的解决啦！</p><h2 id="中间人劫持"><a href="#中间人劫持" class="headerlink" title="中间人劫持"></a>中间人劫持</h2><p>​    现在张大胖和Bill就很欢快地聊起来了，但是问题就这么简单地结束了吗？当然没有！张大胖把自己和Bill的聊天情况告诉了他女朋友，女朋友一听就发现了一个问题，她说：“Bill给别人，给你发公钥的时候也是通过网络传输的呀！那么这时候有个中间人把这个公钥给劫持了，再把自己的公钥换掉Bill的公钥发给你，你收到的就是中间人的公钥呀！那么你通过中间人的公钥进行消息加密发给Bill，这时候中间人再次劫持消息，通过他的私钥进行解密就直接能获得消息的内容了，然后他再把解密完的消息或者自己编造一个假消息然后使用Bill的公钥进行加密发给Bill，这样就神不知鬼不觉的解密了你们的消息并且还能冒充身份和造假消息！！！张大胖一听，后背就开始发凉，难道自己和Bill发的生活照都被中间人截取了吗？？？这可怎么防呀？</p><p><img src="/2019/04/11/从对称加密到数字证书/4.jpg"></p><h2 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h2><p>​    但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？这真的是一个很头痛的问题呀！可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。这让张大胖想到了一个现实中的问题——签名。像我们签合同，协议都是通过签名来确定这个本人，那么我们可以把它移植到网络上！怎么移植呢？</p><p>​    RSA算法给我们提供了一个很好的办法，因为它不仅可以通过公钥加密私钥解密，它还可以私钥加密公钥解密。这样我们发送公钥的时候可以通过某个消息摘要算法，首先这个消息摘要算法必须有两个特性——不可逆性和可变性。不可逆好理解，就是无法通过密文解出明文，这个可变性就是指当消息发生一点点变化的时候，它形成的密文就会发生翻天覆地的变化，这样就可以防止别人修改。这时候我们通过消息摘要算法来对公钥进行加密形成摘要，然后我们通过自己的私钥对这个摘要进行加密形成摘要密文，这个摘要密文就是我们的数字签名。这样，我们发公钥的时候就发送原本的消息附加上我们的数字签名，这样对方收到这个消息的时候就使用收到的公钥对这个数字签名进行解密（得到其实就是公钥的摘要），然后再通过同样的消息摘要算法对收到的公钥进行加密，如果对公要的加密密文和数字签名解密出来的东西是一样的，那么久说明这个公钥没有被修改过！</p><p>​    可能有点难理解，我们这么想，如果中间人对这个公钥进行了修改或者替换。比如张大胖和Bill在通信，张大胖把自己的公钥和数字签名发给了Bill，中间人截获这个消息，假如他替换了公钥（替换成自己的了），那么他也不能改动数字签名，使数字签名通过这个公钥来形成中间人公钥的信息摘要，因为这个数字签名就是密文，他不知道如何下手，所以如果只改公钥，那么这样肯定会被Bill发现。但是，作为一个狠角色，要干就要干狠一点，不能改公钥，不能改数字签名，老子干脆就把它全改了，全用自己的！</p><p>​    所以问题又来了，这时候我们就要请来大人物了——认证中心（CA），我们需要有一个具有公信力的中间商，当我们把自己的公钥和个人信息形成消息摘要的时候，我们使用CA的私钥进行加密形成数字签名。</p><p><img src="/2019/04/11/从对称加密到数字证书/5.jpg"></p><p>​    然后我们发送消息的时候我们把我们的公钥和个人信息再连带着使用CA的私钥加密过的数字签名发送给对方，这些东西合起来就有另一个名字——数字证书。</p><p><img src="/2019/04/11/从对称加密到数字证书/6.jpg"></p><p>​    如图所示，当Bill吧这个数字证书发给张大胖的时候，我就用同样的消息摘要算法对原本消息进行摘要，然后使用CA的公钥对数字签名进行解密获取摘要，然后对比我前后获取的摘要，如果一致那么就说明这个东西没有被篡改。你想想，如果中间人截获了这个证书，他把证书全改成自己的，但是张大胖使用的是CA的公钥解密摘要，然而中间人不知道CA的私钥，那么他这么做就露馅了！这时候张大胖就安全地拿到了Bill的公钥，后续的加密工作就可以顺利地进行了。当然，网络本就是不安全的，想必大家也想到了，当Bill获取CA的公钥的时候，这个中间人也可以发起攻击，直接篡改CA公钥，那么这样安全问题就无限的循环下去无法解决了！当然这些CA本身也有证书来证明自己的身份，并且CA的信用是像树一样分级的，高层的CA给底层的CA做信用背书，而操作系统／浏览器中会内置一些顶层的CA的证书，相当于你自动信任了他们。这些顶层的CA证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>​    这样，https也非常好理解了，看图就知道了。</p><p><img src="/2019/04/11/从对称加密到数字证书/7.jpg"></p><p>​    本博文参考于刘欣的《码农翻身》，特别感谢此书，也推荐大家阅读。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    好久没写博客了，因为这学期以来就有一大堆事情要解决处理，有时候学习完，就一直没时间写总结。总感觉自己像头狮子一样，想一口气吃成大胖子，什么都要学，什么都学不精，学了之后不总结，学了就忘。当然有好奇心也是好事，但是我可不想无法精通一门东西，昨天看这本《码农翻身》，书中提到了不要让碎片化信息侵蚀你深度思考的能力，确实如此，我们现在学习知识都是以一种常识的心态去学，我们只是记住了这个常识，死记硬背，并没有深度思考其中的原因和逻辑，所以我们无法精通一门技术，我想，这大概是我现阶段学习最大的问题吧。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中的散列集</title>
      <link href="/2019/03/08/Java%E4%B8%AD%E7%9A%84%E6%95%A3%E5%88%97%E9%9B%86/"/>
      <url>/2019/03/08/Java%E4%B8%AD%E7%9A%84%E6%95%A3%E5%88%97%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>&nbsp;&nbsp;Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>&nbsp;&nbsp;所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，<strong>那么输入值肯定也不同。</strong>但是，根据同一散列函数计算出的散列值如果相同，<strong>输入值不一定相同。</strong></p><p>&nbsp;&nbsp;<strong>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</strong></p><p>&nbsp;&nbsp;常见的Hash函数有以下几个：</p><ul><li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</li><li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li><li>伪随机数法：采用一个伪随机数当作哈希函数。</li></ul><p>&nbsp;&nbsp;上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：</p><ul><li><p>开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><ul><li>线性探查：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</li><li>二次探查：di=12，-12，22，-22，…，k2，-k2    ( k&lt;=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</li></ul></li><li><p>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</p></li><li>再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li><li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul><h2 id="HashMap-的数据结构"><a href="#HashMap-的数据结构" class="headerlink" title="HashMap 的数据结构"></a>HashMap 的数据结构</h2><p>&nbsp;&nbsp;在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：<strong>寻址容易，插入和删除困难</strong>；而链表的特点是：<strong>寻址困难，插入和删除容易</strong>。上面我们提到过，常用的哈希函数的冲突解决办法中有一种方法叫做链地址法，其实就是将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。</p><p><img src="/2019/03/08/Java中的散列集/1.jpg"></p><p>&nbsp;&nbsp;我们可以从上图看到，左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，反过来我们也正是通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是哈希算法，即本文的主角hash()函数（当然，还包括indexOf()函数）。</p><ol><li><p>假设现有 persons.put(“1”,”jack”);persons.put(“2”,”john”); 同时计算到的hash值都为123，那么jack先放在第一列的第一个位置Node-jack，persons.put(“2”,”john”);执行时会将Node-jack的next(Node) = Node(john)，Jack的下个节点将指向Node(john)。</p></li><li><p>那么取的时候呢，persons.get(“2”)，这个时候取得的hash值是123，即table[123]，这时table[123]其实是Node-jack，Key值不相等，取Node-jack的next下个Node，即Node-John，这时Key值相等了，然后返回对应的person.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>AOP在Spring中的应用</title>
      <link href="/2019/02/02/AOP%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/02/02/AOP%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h2><p>&nbsp;&nbsp;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>&nbsp;&nbsp;AOP是OOP的扩展和延伸，并不能取代OOP，AOP为OOP不能解决的问题提供了很好的方式。</p><p>&nbsp;&nbsp;例如，我们现在需要在持久层的某个save方法前面加一个权限校验的方法。</p><ul><li><p>按照正常的想法，我们会在dao类上添加一个check权限的方法然后在调用save方法之前调用check方法，但是问题来了，当出现成千上百的保存方法的时候，我们就需要在成百上千的类中添加check校验方法，这样就很麻烦</p></li><li><p>使用纵向继承的方式，我们可以编写一个BaseDao类，这个类中我们编写一个check校验方法，当我们某各类需要加入权限校验方法的时候，我们只需要继承BaseDao类并调用BaseDao类中的check方法就行了。但是，使用继承的方式虽然说比上面的方法好一些，但是也并不尽人意，比如当我们这个权限校验方法不需要的时候，我们必须删除这些extends和子类调用BaseDao的check方法。AOP为我们解决这类问题提供了很好的方案。</p></li><li><p>AOP(横向抽取)，其实AOP的原理就是使用了<a href="https://francisqiang.github.io/2019/02/01/Java中的代理模式">Java中的代理模式</a>,具体可以参考这篇文章。这时候我们在把save方法抽取出来，我们使用Proxy模式增强save方法。</p></li></ul><h2 id="AOP的好处和Spring-AOP底层实现"><a href="#AOP的好处和Spring-AOP底层实现" class="headerlink" title="AOP的好处和Spring AOP底层实现"></a>AOP的好处和Spring AOP底层实现</h2><p>&nbsp;&nbsp;对程序进行曾倩，不修改源码的情况下，AOP可以进行权限校验，日志记录，性能监控，事务控制等功能。</p><p>&nbsp;&nbsp;Spring AOP底层使用动态代理模式，在被代理类实现某种接口的时候使用JDK动态代理，在被代理类没有实现某个接口的时候使用cglib动态代理。</p><h2 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h2><p>&nbsp;&nbsp;首先我们先列出需要实现AOP的代码类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao&#123;</span><br><span class="line">    public void save()&#123;&#125;</span><br><span class="line">    public void find()&#123;&#125;</span><br><span class="line">    public void update()&#123;&#125;</span><br><span class="line">    public void delete()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;我们对照上面代码看</p><ul><li><p>JoinPoint：连接点，可以被拦截到的点。这里四个crud方法都是可以进行方法增强的，所以这四个方法都可以被称为JoinPoint</p></li><li><p>PointCut：切入点，真正被拦截的点，如果这四个方法中我们只对save方法进行了增强，那么save方法就是PointCut。</p></li><li><p>Advice：通知增强，假如我们现在对save方法进行权限校验，那么这个check方法就称为通知或者增强，而且这是方法层面的增强</p></li><li><p>Introduction：引介，类方面的增强</p></li><li><p>Target：被增强的对象，如果现在我们对UserDao这个类增强，那么UserDao就是Target</p></li><li><p>Waving：织入，它是一个过程，指的是我们将通知（Advice）应用到目标（Target）过程，将全县校验的方法的代码应用到UserDao的save方法上的过程。</p></li><li><p>Proxy：代理对象，一个类被AOP织入增强之后就产生了一个结果代理类</p></li><li><p>Aspect：切面，是切入点和通知的结合。</p></li></ul><h2 id="Spring-AOP的入门开发"><a href="#Spring-AOP的入门开发" class="headerlink" title="Spring AOP的入门开发"></a>Spring AOP的入门开发</h2><h3 id="AOP的配置"><a href="#AOP的配置" class="headerlink" title="AOP的配置"></a>AOP的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:pointcut expression=&quot;execution(表达式)&quot; id=&quot;切入点的id可以随便取，下面要对应&quot;/&gt;</span><br><span class="line">&lt;!--这里配置切面类--&gt;</span><br><span class="line">&lt;!--前提是切面类需要交给Spring管理--&gt;</span><br><span class="line">&lt;aop:aspect ref=&quot;某个切面类&quot;&gt;</span><br><span class="line">    &lt;!--这里配置通知增强方法，这里是前置增强--&gt;</span><br><span class="line">&lt;aop:before method=&quot;切面类里面的增强方法&quot; pointcut-ref=&quot;切入点的id&quot;/&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><ul><li><p>前置通知 目标方法执行前进行操作(权限校验..)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:before method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>后置通知 目标方法执行之后进行操作(日志..),可以获得被增强方法返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:after-returning method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot; returning=&quot;returning对应的名字&quot;&gt;</span><br><span class="line">&lt;!--后置增强方法里面传入 Object 与returning对应的名字--&gt;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知 目标方法执行之后之前进行操作，可以控制方法是否执行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:round method=&quot;around&quot; pointcut-ref=&quot;切入点&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//环绕增强方法实例</span><br><span class="line">//返回值必须是Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">    System.out.println(&quot;环绕前&quot;);</span><br><span class="line">    //执行切入点的方法</span><br><span class="line">    Object obj =joinPoint.proceed();</span><br><span class="line">    System.out.println(&quot;环绕后&quot;);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常抛出通知 抛出异常的时候进行的操作(事物回滚),可以获取异常信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;切入点&quot; throwing=&quot;给异常取个名字&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//增强方法</span><br><span class="line">public void afterThrowing(Throwable 异常的名字)&#123;</span><br><span class="line">    System.out.println(异常名字.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最终通知 类似于finally，不管有没有异常都会执行的操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:after method=&quot;xxx&quot; pointcut-ref=&quot;xxx&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><ul><li><p>基于execution的函数完成</p></li><li><p>语法</p><ul><li><p>[访问修饰符] 方法返回值 包名.类名.方法名(参数)</p><p>execution(   方法修饰符  方法返回值  方法所属类 匹配方法名 (  方法中的形参表 )  方法申明抛出的异常  )</p></li><li><p>public void com.lgq.UserDao.save(..)  两个点代表任意参数</p></li><li><p>public void com.lgq.UserDao.save(*,Integer)</p><p>“*”：代表一个任意类型的参数 </p></li><li><p>public void com.lgq.UserDao.save();   ()匹配一个无参方法</p></li><li><p>具体还有</p><p><img src="/2019/02/02/AOP在Spring中的应用/1.jpg"></p></li></ul></li></ul><h2 id="使用注解进行AOP开发"><a href="#使用注解进行AOP开发" class="headerlink" title="使用注解进行AOP开发"></a>使用注解进行AOP开发</h2><ul><li>使用注解开发上面的XML配置的代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 切面类：注解的切面类</span><br><span class="line"> * @author jt</span><br><span class="line"> */</span><br><span class="line">//配置切面</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAspectAnno &#123;</span><br><span class="line">    // 切入点注解</span><br><span class="line">    //后面的方法随便定义，在增强方法中要对应</span><br><span class="line">@Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.find(..))&quot;)</span><br><span class="line">private void pointcut1()&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.save(..))&quot;)</span><br><span class="line">private void pointcut2()&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.update(..))&quot;)</span><br><span class="line">private void pointcut3()&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Pointcut(value=&quot;execution(* com.itheima.spring.demo1.OrderDao.delete(..))&quot;)</span><br><span class="line">private void pointcut4()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //前值增强</span><br><span class="line">@Before(value=&quot;MyAspectAnno.pointcut2()&quot;)</span><br><span class="line">public void before()&#123;</span><br><span class="line">System.out.println(&quot;前置增强===========&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 后置通知:</span><br><span class="line">@AfterReturning(value=&quot;MyAspectAnno.pointcut4()&quot;,returning=&quot;result&quot;)</span><br><span class="line">public void afterReturning(Object result)&#123;</span><br><span class="line">System.out.println(&quot;后置增强===========&quot;+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 环绕通知:</span><br><span class="line">@Around(value=&quot;MyAspectAnno.pointcut3()&quot;)</span><br><span class="line">public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">System.out.println(&quot;环绕前增强==========&quot;);</span><br><span class="line">Object obj  = joinPoint.proceed();</span><br><span class="line">System.out.println(&quot;环绕后增强==========&quot;);</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 异常抛出通知:</span><br><span class="line">@AfterThrowing(value=&quot;MyAspectAnno.pointcut1()&quot;,throwing=&quot;e&quot;)</span><br><span class="line">public void afterThrowing(Throwable e)&#123;</span><br><span class="line">System.out.println(&quot;异常抛出增强=========&quot;+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最终通知</span><br><span class="line">@After(value=&quot;MyAspectAnno.pointcut1()&quot;)</span><br><span class="line">public void after()&#123;</span><br><span class="line">System.out.println(&quot;最终增强============&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中的代理模式</title>
      <link href="/2019/02/01/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/02/01/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>&nbsp;&nbsp;假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子</p><p><img src="/2019/02/01/Java中的代理模式/1.jpg"></p><h2 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h2><ul><li><p>远程代理模式：为不同地理的对象提供局域网代表对象（例子：通过远程代理可以监控各个店铺，使之可以直观的了解店里的情况）</p></li><li><p>虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建 (类似于新闻网站加载时，图片加载不出来先用一张空的图片代替)</p></li><li><p>保护代理：控制用户的访问权限 </p></li><li><p>智能引用代理：提供对目标对象提供额外的服务或者减少特定的服务（火车票代售处）</p></li></ul><h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>&nbsp;&nbsp;代理和被代理对象在代理之前是确定的。他们都是实现相同的接口或者继承相同的抽象类。就比如已知一个汽车类并且也只到要有一个汽车的代理类，且它们实现相同接口或者继承相同抽象类。</p><p><img src="/2019/02/01/Java中的代理模式/2.jpg"></p><h4 id="继承的方式实现静态代理"><a href="#继承的方式实现静态代理" class="headerlink" title="继承的方式实现静态代理"></a>继承的方式实现静态代理</h4><p>&nbsp;&nbsp;代理者继承被代理者，对所代理的方法进行改造</p><p>&nbsp;&nbsp;需求:一个汽车有一个move方法，方法中打印了移动中三个字并有一个行驶时间(通过Thread.sleep方法)，现在我们需要使用代理类算出移动时间并打印消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//提供一个代理类和被代理类需要实现的接口</span><br><span class="line">public interface Movable &#123;</span><br><span class="line">  void move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个Car并实现Movable接口</span><br><span class="line">public class Car implements Movable&#123;</span><br><span class="line"></span><br><span class="line">  public void move() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;移动中。。。&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用继承方式</span><br><span class="line">//代理类继承被代理类，并重写其方法</span><br><span class="line">public class CarTimeProxy extends Car&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void move() &#123;</span><br><span class="line">    long startTime=System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;开始移动。。。&quot;);</span><br><span class="line">    super.move();</span><br><span class="line">    long endTime=System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端只需要创建代理类并实行代理类重写被代理类的方法</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    CarTimeProxy carTimeProxy=new CarTimeProxy();</span><br><span class="line">    carTimeProxy.move();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聚合的方式实现静态代理"><a href="#聚合的方式实现静态代理" class="headerlink" title="聚合的方式实现静态代理"></a>聚合的方式实现静态代理</h4><p>&nbsp;&nbsp;继承同一个接口，且代理对象持有被代理的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//使用聚合方式构造代理对象</span><br><span class="line">public class CarTimeProxy implements Movable&#123;</span><br><span class="line"></span><br><span class="line">  private Movable movable;</span><br><span class="line"></span><br><span class="line">  public CarTimeProxy(Movable movable) &#123;</span><br><span class="line">    this.movable = movable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void move() &#123;</span><br><span class="line">    long startTime=System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;开始移动。。。&quot;);</span><br><span class="line">    movable.move();</span><br><span class="line">    long endTime=System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端先要构造car，再将car传入代理对象</span><br><span class="line">public class Client &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Car car=new Car();</span><br><span class="line">    CarTimeProxy carTimeProxy=new CarTimeProxy(car);</span><br><span class="line">    carTimeProxy.move();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聚合方式和继承方式哪个好呢？"><a href="#聚合方式和继承方式哪个好呢？" class="headerlink" title="聚合方式和继承方式哪个好呢？"></a>聚合方式和继承方式哪个好呢？</h4><p>&nbsp;&nbsp;这时我们又新增了一个需求，我们需要给汽车再添加一个日志代理类，并在移动前后打印日志信息。</p><p>&nbsp;&nbsp;首先我们使用继承方式，那么我们只需要再创建一个日志代理类并继承于时间代理类就好了，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//日志代理类</span><br><span class="line">public class CarTimeAndLogProxy extends CarTimeProxy &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void move() &#123;</span><br><span class="line">    System.out.println(&quot;开始打印日志&quot;);</span><br><span class="line">    super.move();</span><br><span class="line">    System.out.println(&quot;结束打印日志&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;但是这时候我们需求又变动了，我们需要先打印时间信息再打印日志信息，这时候继承方式的静态代理就显得很无力了。</p><p>&nbsp;&nbsp;所以我们推荐使用聚合式的静态代理，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//创建日志代理类并实现Movable接口</span><br><span class="line">public class CarLogProxy implements Movable &#123;</span><br><span class="line"></span><br><span class="line">  private Movable movable;</span><br><span class="line"></span><br><span class="line">  public CarLogProxy(Movable movable) &#123;</span><br><span class="line">    this.movable = movable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void move() &#123;</span><br><span class="line">    System.out.println(&quot;开始打印日志&quot;);</span><br><span class="line">    movable.move();</span><br><span class="line">    System.out.println(&quot;结束打印日志&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //这时候我们只需要调换一下代理类的顺序就好</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Car car=new Car();</span><br><span class="line">    CarLogProxy carLogProxy=new CarLogProxy(car);</span><br><span class="line">    CarTimeProxy carTimeProxy=new CarTimeProxy(carLogProxy);</span><br><span class="line">    carTimeProxy.move();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>&nbsp;&nbsp;来自静态代理的思考:静态代理是对特定类产生代理对象，但是就日志打印这个代理功能而言，成千上百的类都会用到日志打印，那么这时候如果我们使用静态代理的话，我们就要创建成千上百的代理类，这样会非常麻烦。</p><p>&nbsp;&nbsp;所以出现了动态代理：动态产生代理，实现对不同类和不同方法的代理。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p><img src="/2019/02/01/Java中的代理模式/3.jpg"></p><ol><li><p>创建事务处理器，实现InvocationHandler接口，覆写invoke方法</p><p>  参数说明：</p><p> proxy   代理对象</p><p> Method  被代理对象的方法</p><p> args    方法的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke（Object proxy,Method method,Object[] args）</span><br></pre></td></tr></table></figure></li><li><p>创建被代理的类以及接口</p></li><li><p>调用Proxy的静态方法，创建代理类（这个类是实现了被代理类的接口的）</p><p> 参数说明：</p><p> loader：被代理类的类加载器</p><p> interfaces：被代理类实现的接口</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure><ol start="4"><li><p>事务处理器</p></li><li><p>通过代理调用被代理的方法</p></li></ol><p>&nbsp;&nbsp;代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//创建一个Handler实现InvocationHandler</span><br><span class="line">//并重写invoke方法和创建Object对象</span><br><span class="line">存放被代理的对象(用来)</span><br><span class="line">public class TimeHandler implements InvocationHandler &#123;</span><br><span class="line">  private Object target;</span><br><span class="line"></span><br><span class="line">  public TimeHandler(Object target) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    long startTime=System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;开始移动。。。&quot;);;</span><br><span class="line">    method.invoke(target);</span><br><span class="line">    long endTime=System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;结束移动。。。,一共移动&quot;+(endTime-startTime)+&quot;毫秒!&quot;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><p>&nbsp;&nbsp;JDK只能代理实现了接口的类，cglib针对类来实现代理，对指定目标类产生一个子类，通过方法拦截技术拦截所有调用父类方法地调用。也因为cglib使用了继承的方式，所以它不能对final修饰的类进行代理。</p><p>&nbsp;&nbsp;需求:实现对火车类的日志代理</p><p>&nbsp;&nbsp;代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">private Enhancer enhancer = new Enhancer();</span><br><span class="line"></span><br><span class="line">public Object getProxy(Class clazz)&#123;</span><br><span class="line">//设置创建子类的类</span><br><span class="line">enhancer.setSuperclass(clazz);</span><br><span class="line">enhancer.setCallback(this);</span><br><span class="line"></span><br><span class="line">return enhancer.create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 拦截所有目标类方法的调用</span><br><span class="line"> * obj  目标类的实例</span><br><span class="line"> * m   目标方法的反射对象</span><br><span class="line"> * args  方法的参数</span><br><span class="line"> * proxy代理类的实例</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method m, Object[] args,</span><br><span class="line">MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;日志开始...&quot;);</span><br><span class="line">//代理类调用父类的方法</span><br><span class="line">proxy.invokeSuper(obj, args);</span><br><span class="line">System.out.println(&quot;日志结束...&quot;);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Train &#123;</span><br><span class="line"></span><br><span class="line">public void move()&#123;</span><br><span class="line">System.out.println(&quot;火车行驶中...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param args</span><br><span class="line"> */</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">CglibProxy proxy = new CglibProxy();</span><br><span class="line">Train t = (Train)proxy.getProxy(Train.class);</span><br><span class="line">t.move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>&nbsp;&nbsp;本博文参考于<a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">Java的三种代理模式</a>和慕课网的模式的秘密——代理模式课程</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring基于XML和注解的配置</title>
      <link href="/2019/02/01/Spring%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/02/01/Spring%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h2><h3 id="基于XML的配置"><a href="#基于XML的配置" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><ul><li><p>@Component 在类上标注这个注解,且在XML上需要配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--类似这样--&gt;</span><br><span class="line">&lt;!--负责包扫描配置组件--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.lgq.cfw&quot;&gt;</span><br><span class="line">  &lt;!--exclude不扫描有Controller注解的类--&gt;</span><br><span class="line">  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--只扫描控制器。  --&gt;</span><br><span class="line">  &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></li><li><p>@Controller   Web层</p></li><li><p>@Service    Service层</p></li><li><p>@Repository  DAO层</p></li></ul><p>&nbsp;&nbsp;后面三个注解相当于@Component注解的分类，官方推荐使用后面三个，因为Spring会对这三个注解以后做扩展。</p><h2 id="Bean名称"><a href="#Bean名称" class="headerlink" title="Bean名称"></a>Bean名称</h2><h3 id="基于XML的配置-1"><a href="#基于XML的配置-1" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置id或者name为...--&gt;</span><br><span class="line">&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--类似这样--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--加载druid数据源--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="基于注解的配置-1"><a href="#基于注解的配置-1" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><ul><li>@Component(“dataSource”)</li></ul><p>配置一个id为dataSource的bean，这个类在IOC容器中的id就叫dataSource</p><h2 id="Bean注入"><a href="#Bean注入" class="headerlink" title="Bean注入"></a>Bean注入</h2><h3 id="基于XML的配置-2"><a href="#基于XML的配置-2" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h3><p>通过配置property属性或者p命名空间,例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将所有mapper接口的实现类自动加入到ioc容器中  --&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;basePackage&quot; value=&quot;com.lgq.cfw.dao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="基于注解的配置-2"><a href="#基于注解的配置-2" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><ul><li><p>@AutoWired 按类型注入</p></li><li><p>@Qualifier 按名称注入</p></li><li><p>@Value  普通属性</p></li><li><p>@Resource 对象属性 </p></li></ul><h2 id="生命过程，Bean作用范围"><a href="#生命过程，Bean作用范围" class="headerlink" title="生命过程，Bean作用范围"></a>生命过程，Bean作用范围</h2><h3 id="基于XML的配置-3"><a href="#基于XML的配置-3" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h3><ul><li>生命周期 init-method, destory-method</li><li>范围 scope属性 </li></ul><h3 id="基于注解的配置-3"><a href="#基于注解的配置-3" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><ul><li><p>@PostConstruct 初始化 相当于init-method</p></li><li><p>@PreDestory 销毁 相当于 destory-method</p></li><li><p>Scope 设置作用范围</p></li></ul><h2 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h2><h3 id="基于XML的配置-4"><a href="#基于XML的配置-4" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h3><p>bean来自第三方</p><h3 id="基于注解的配置-4"><a href="#基于注解的配置-4" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><p>bean的实现类由用户自己开发</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring中的IOC和DI</title>
      <link href="/2019/02/01/Spring%E4%B8%AD%E7%9A%84IOC%E5%92%8CDI/"/>
      <url>/2019/02/01/Spring%E4%B8%AD%E7%9A%84IOC%E5%92%8CDI/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC(控制反转)"></a>IOC(控制反转)</h2><p>&nbsp;&nbsp;IOC(控制反转)，将对象的创建权反转交给了Spring。具体原理看这里<a href="https://francisqiang.github.io/2019/01/29/Java中的反射和工厂模式/">Java中的反射和工厂模式</a></p><h2 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI(依赖注入)"></a>DI(依赖注入)</h2><p>&nbsp;&nbsp;这个就先得从依赖讲起</p><ul><li><p>依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B&#123;</span><br><span class="line">    public void xxx(A a)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承   is a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>聚合  has a</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><ul><li><p>Spring配置文件,将name依赖于userDao</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.lgq.UserDaoImpl&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>useDao实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setName(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">   //创建Spring的工厂</span><br><span class="line">  ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</span><br><span class="line">  UserDao userDao=(UserDaoImpl)applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">  System.out.println(((UserDaoImpl) userDao).getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中的反射和工厂模式</title>
      <link href="/2019/01/29/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/29/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>&nbsp;&nbsp;反射之中包含了一个“反”的概念，所以要想解释反射就必须先从“正”开始解释，一般而言，当用户使用一个类的时候，应该先知道这个类，而后通过这个类产生实例化对象，但是“反”指的是通过对象找到类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        //正的方式创建对象</span><br><span class="line">        Person person=new Person();</span><br><span class="line">        </span><br><span class="line">        //反的方式,使用Class的forName静态方法</span><br><span class="line">        Class&lt;?&gt; clazz1=Class.forName(&quot;com.lgq.Person&quot;);</span><br><span class="line">        Object object1=clazz1.newInstance();</span><br><span class="line">        Person person1=(Person)object1;</span><br><span class="line">        </span><br><span class="line">        //反的方式,使用object的getClass方法</span><br><span class="line">        203.</span><br><span class="line">        Class&lt;?&gt; clazz2=person.getClass();</span><br><span class="line">        Object object2=clazz2.newInstance();</span><br><span class="line">        Person person2=(Person)object2;</span><br><span class="line">        </span><br><span class="line">        //反的方式,使用Class的class方法</span><br><span class="line">        Class&lt;?&gt; clazz3=Person.class;</span><br><span class="line">        Object object3=clazz3.newInstance();</span><br><span class="line">        Person person3=(Person)object3;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>&nbsp;&nbsp;那么现在可以发现，对于对象的实例化操作，除了使用关键字new之外又多了一个反射机制操作，而且这个操作要比之前使用的new复杂一些，可是有什么用？</p><p>&nbsp;&nbsp;对于程序的开发模式之前一直强调：尽量减少耦合，而减少耦合的最好做法是使用接口，但是就算使用了接口也逃不出关键字new，所以实际上new是造成耦合的关键元凶。</p><h2 id="简单讲一下工厂模式"><a href="#简单讲一下工厂模式" class="headerlink" title="简单讲一下工厂模式"></a>简单讲一下工厂模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>&nbsp;&nbsp;首先我们先来回顾一下以前我们使用过的简单工厂模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public interface Fruit&#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Orange implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FruitFactory&#123;</span><br><span class="line">    public static Fruit createFruit(String fruitType)&#123;</span><br><span class="line">        if (&quot;Apple&quot;.equals(fruitType))&#123;</span><br><span class="line">            return new Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (&quot;Orange&quot;.equals(fruitType))&#123;</span><br><span class="line">            return new Orange();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Fruit fruit=FruitFactory.createFruit(&quot;Apple&quot;);</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;这里简单说一下工厂模式，以前我们new东西都是自己new，就像现实生活中，很久以前没有制作商品的工厂，那我们获取东西就要自己制造。例子：比如刀耕火种的时代，我们需要需要一把斧子，我们没有工厂，我们只能自己造，只能自己new出来。但是到了，封建时期直至现在，有很多作坊或者工厂，当我们需要某种东西的时候，我们只需要告诉工厂我们需要什么，工厂便会给我们造什么，其实这就相当于我们制造东西的权利交给了工厂，我们变成了客户，我们客户只关心产品之间地差异(产品生产出来的结果，我们获取到了什么产品)，而不是生产产品的过程，这个东西由工厂来负责，我们不关心了。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>&nbsp;&nbsp;这里我们再次思考一下，上面的代码我们不是一个制造水果的工厂吗？这时候作为客户的我们又想吃Pear了，那么我们的工厂又得重新编辑它的代码，这样就会非常麻烦(因为耦合),那么我们该怎么办呢？</p><p>&nbsp;&nbsp;这里我又想提到工厂模式了，工厂模式里面有个工厂方法，它是用来解决这个简单工厂模式不可拓展性的方法。比如，这时候我们把水果工厂给抽象出来，然后我们去具体实现这个水果工厂，比如说我们实现一个AppleFactory，一个OrangeFactory。这两个工厂作为我们默认的，一开始就有的，到后来我们需要添加水果的产品种类了，我们怎么办呢？比如我们添加一个Pear类，我们使Pear实现Fruit接口，然后创建一个PearFactory实现FruitFactory，然后客户端当创建一个工厂时就创建一个PearFactory，具体看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public interface Fruit&#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Orange implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里创建一个Pear实现Fruit接口</span><br><span class="line">public class Pear implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Pear&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使FruitFactory抽象</span><br><span class="line">public abstract class FruitFactory&#123;</span><br><span class="line">    abstract Fruit getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个AppleFactory实现FruitFactory</span><br><span class="line">public class AppleFactory extends FruitFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Fruit getInstance() &#123;</span><br><span class="line">        return new Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class OrangeFactory extends FruitFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Fruit getInstance() &#123;</span><br><span class="line">        return new Orange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果要新增产品，需要产品实现Fruit接口并且实现FruitFactory类</span><br><span class="line">public class PearFactory extends FruitFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Fruit getInstance() &#123;</span><br><span class="line">        return new Pear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此时更换新增的需求时我们只需要new一个新的工厂</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Fruit fruit=new PearFactory().getInstance();</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>&nbsp;&nbsp;说完工厂方法模式，顺便就讲一下抽象工厂模式吧，其实抽象工厂模式是工厂方法模式的一种推广，最明显的一点就是在工厂方法的类关系图中只有一类产品，他们实现了一个统一的接口，而抽象工厂有多个类别的产品，他们分别实现了不同的功能（多个接口）。其次的一点差别就是工厂本身所具有的方法数量不同，这点差异其实也是由第一点所导致的，工厂需要有生产不同类别产品的功能，如果抽象工厂中的产品的功能简化到一个，也便成为了工厂方法。 </p><p>&nbsp;&nbsp;再来看选择的过程，在工厂方法中，客户关心的只不过是实现同一样功能的不同产品间的差异，这是一个一维选择的过程。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IFactory factory = new FactoryA(); //选择了工厂即选择了产品</span><br><span class="line">IProduct productA = factory.Create(); //工厂只有一个Create方法，只能生产一种产品</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;而在抽象工厂中，客户首先要考虑的是需要哪一样功能，其次要考虑才是产品间的差异。也就是说这是一个二维选择的过程。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IFactory factory = new FactoryA(); //选择了某个具体工厂</span><br><span class="line">IProduct productA = factory.CreateProductA(); //工厂具有多个Create方法，这里选择了其中的一个</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;由于产品类别的增加而导致客户在考虑产品间差异的同时还要考虑产品间功能的差异，这种二维选择的过程才是工厂方法与抽象工厂之间的本质区别。 </p><p>&nbsp;&nbsp;举个肯德基与麦当劳的例子，假设原来只有一家快餐店叫做麦当劳，提供的食物（具体产品）有汉堡、可乐、薯条，它们都可以满足你吃东西（抽象接口）的需求，那么你想吃快餐的时候，唯一的选择就在于吃什么，是一维选择，现在又开了一家快餐店叫做肯德基，同样供应汉堡、可乐和薯条，那么现在你若打算吃快餐，除了考虑吃什么外，还要考虑去哪里吃–肯德基还是麦当劳？这便是二维的选择。通过横向与纵向的选择才能最终锁定你要的产品。 </p><p><img src="/2019/01/29/Java中的反射和工厂模式/1.jpg"></p><p>&nbsp;&nbsp;引入系列的概念，相互间具有差异的同一类别的产品称为不同的系列，如肯德基和麦当劳就是两个不同的系列。</p><p>&nbsp;&nbsp;这种选择的区别带来的另外一个后果就是产品间的差异（系列间的差异）变为客户的次要选择，而客户主要的精力放在了功能的选择上（类别的选择）。</p><p>&nbsp;&nbsp;其实可以这么理解，像工厂方法模式里面出现多个工厂是因为产品品种的变更，每个工厂决定了一个产品品种。而抽象工厂里面不只有一个产品品种，它是一个系列的，也就是所抽象工厂模式里面出现多个工厂是因为系列产品的变更。</p><h2 id="反射对于工厂模式的优化"><a href="#反射对于工厂模式的优化" class="headerlink" title="反射对于工厂模式的优化"></a>反射对于工厂模式的优化</h2><p>&nbsp;&nbsp;我们回顾一下刚刚上面所讲的工厂模式，工厂方法模式解决了简单工厂模式的不可拓展性(其实抽象工厂跟工厂方法差不多，这里就以工厂方法模式举例)</p><p>&nbsp;&nbsp;不可拓展的问题是得到解决了，我们再想一下，这样是否是真的完美了吗？当我们要创建一个新的品种的时候我们还需要去创建一个新品种的工厂并且实现原来的基类工厂(FruitFactory)，没新增一个我们就要实现一个，这样是不是太麻烦了。这时候，反射给我们提供了很好的解决办法。先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public interface Fruit&#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Orange implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里创建一个Pear实现Fruit接口</span><br><span class="line">public class Pear implements Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃Pear&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FruitFactory&#123;</span><br><span class="line">    public static Fruit getInstance(String fruitType) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Fruit fruit=null;</span><br><span class="line">        //利用反射</span><br><span class="line">        Class&lt;?&gt; clazz=Class.forName(fruitType);</span><br><span class="line">        Object object=clazz.newInstance();</span><br><span class="line">        fruit=(Fruit)object;</span><br><span class="line">        return fruit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException &#123;</span><br><span class="line">        Fruit fruit=FruitFactory.getInstance(&quot;com.lgq.Pear&quot;);</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;这时候是不是就方便很多了，我们不需要再创建具体类的工厂去实现基类工厂了，我们只需要创建具体类实现基类，然后客户把需求告诉工厂，工厂通过反射创建产品，工厂返回基类就行了。所以最终我们变换的只是那个newInstance方法的参数了，那是一个常量，我们完完全全就可以把它放到配置文件里面。</p><h2 id="Spring-IOC-和工厂模式"><a href="#Spring-IOC-和工厂模式" class="headerlink" title="Spring IOC 和工厂模式"></a>Spring IOC 和工厂模式</h2><p>&nbsp;&nbsp;放到配置文件里面，这有点像什么呢？对了！Spring的IOC。Spring里面有个bean工厂(BeanFactory),其实它也是利用反射的。我们来看一下Spring配置文件里面有个bean节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;Person&quot; class=&quot;test.Person&quot;&gt;</span><br><span class="line"> &lt;!-- 第一个bean，是一个Person类，id名字随便取，还要写上类的全名 --&gt;  </span><br><span class="line">    &lt;property name=&quot;name&quot;&gt; </span><br><span class="line">      &lt;value&gt;小龙&lt;/value&gt;</span><br><span class="line">      &lt;!-- 这里的名字是通过程序里面的set来赋值的，如果去掉程序对应的set，就出错了 --&gt;  </span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;age&quot;&gt;  </span><br><span class="line">       &lt;value&gt;23&lt;/value&gt;  </span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;grade&quot;&gt;</span><br><span class="line">    &lt;!-- 这里有点特别，这个grade变量是一个对象，和一般的变量要区别对待 --&gt;  </span><br><span class="line">    &lt;ref local=&quot;Grade&quot;/&gt;</span><br><span class="line">    &lt;!-- 这里指向了本配置文件里面一个名字叫Grade(即id=Grade)的bean --&gt; </span><br><span class="line">   &lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;Grade&quot; class=&quot;test.Grade&quot;&gt;&lt;!-- 同上 --&gt;  </span><br><span class="line">   &lt;property name=&quot;math&quot;&gt;  </span><br><span class="line">      &lt;value&gt;99&lt;/value&gt;  </span><br><span class="line">   &lt;/property&gt;  </span><br><span class="line">   &lt;property name=&quot;english&quot;&gt;  </span><br><span class="line">      &lt;value&gt;59&lt;/value&gt;  </span><br><span class="line">   &lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;我们是如何获取的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   //加载Spring配置文件</span><br><span class="line">BeanFactory f = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">   //从BeanFactory获取对象，通过bean节点的id值，相当于map里面的key class值是value</span><br><span class="line">Object o = f.getBean(&quot;Person&quot;);</span><br><span class="line">Person person = (Person)o;</span><br><span class="line">   Grade grade=(Grade)f.getBean(&quot;Grade&quot;);</span><br><span class="line">   //这时候Spring就为你自动装配了person和grade，且将property里面的值赋过去了</span><br><span class="line">   //我们此时可以调用person的get方法</span><br><span class="line">   System.out.println(person.getName());</span><br><span class="line">   //.......等等</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;其实这里面就用到了反射，这个BeanFactory获取到了Spring的配置文件，就会通过某种方法去解析xml文件(好像是SAX，具体还没看)，解析了xml文件后，BeanFactory就会获取bean节点的class值，使用这个class值通过反射去创建这个对象并放到容器中去，如果用户需要那么他直接调用getBean方法告诉他我要获取的bean的id值就行了。其实这就是Spring最基本的原理。</p><h2 id="反射的一些高级应用"><a href="#反射的一些高级应用" class="headerlink" title="反射的一些高级应用"></a>反射的一些高级应用</h2><p>&nbsp;&nbsp;Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method</p><p>&nbsp;&nbsp;其中class代表的是 类对象，Constructor是类的构造器对象，Field是类的属性对象，Method是类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组成部分。</p><ol><li><p>得到构造器的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//获得使用特殊的参数类型的公共构造函数， </span><br><span class="line">Constructor getConstructor(Class[] params)</span><br><span class="line"></span><br><span class="line">//获得类的所有公共构造函数</span><br><span class="line">Constructor[] getConstructors() </span><br><span class="line"></span><br><span class="line">//获得使用特定参数类型的构造函数(与接入级别无关) </span><br><span class="line">Constructor getDeclaredConstructor(Class[] params)</span><br><span class="line"></span><br><span class="line">//获得类的所有构造函数(与接入级别无关)</span><br><span class="line">Constructor[] getDeclaredConstructors()</span><br></pre></td></tr></table></figure></li><li><p>获得字段信息(属性)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//获得命名的公共字段 </span><br><span class="line">Field getField(String name)</span><br><span class="line"></span><br><span class="line">//获得类的所有公共字段 </span><br><span class="line">Field[] getFields()</span><br><span class="line"></span><br><span class="line">//获得类声明的命名的字段 </span><br><span class="line">Field getDeclaredField(String name)</span><br><span class="line"></span><br><span class="line">//获得类声明的所有字段</span><br><span class="line">Field[] getDeclaredFields()</span><br></pre></td></tr></table></figure><ol start="3"><li>获得方法信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//使用特定的参数类型，获得命名的公共方法 </span><br><span class="line">Method getMethod(String name, Class[] params) </span><br><span class="line"></span><br><span class="line">//获得类的所有公共方法 </span><br><span class="line">Method[] getMethods()</span><br><span class="line"></span><br><span class="line">//使用特写的参数类型，获得类声明的命名的方法</span><br><span class="line">Method getDeclaredMethod(String name, Class[] params) </span><br><span class="line"></span><br><span class="line">//获得类声明的所有方法</span><br><span class="line">Method[] getDeclaredMethods()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringMVC——数据格式化与数据校验</title>
      <link href="/2019/01/28/SpringMVC%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
      <url>/2019/01/28/SpringMVC%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h2><ul><li><p>对属性对象的输入/输出进行格式化（告诉后端前端页面是以什么格式书写属性的），如果请求的数据格式不是后端标识的格式则后端不能识别，将会报400请求错误，因为服务器无法解析请求(看不懂请求)，从其本质上讲属于”类型转换”范畴。</p></li><li><p>Spring 在格式化模块中定义了一个实现ConversionService接口的<font color="red">FormattingConversionService</font>实现类，该类扩展了GenericConversionService，因此它<font color="red">既具有类型转换的功能，又具有格式化的功能</font></p></li><li><p>FormattingConversionService 拥有一个<font color="red"> FormattingConversionServiceFactroyBean </font> 工厂类，后者用于在 Spring 上下文中构造前者</p></li><li><p>FormattingConversionServiceFactroyBean 内部已经注册了 :</p><ul><li><p>NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解</p></li><li><p>JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解</p></li></ul></li><li><p>装配了 FormattingConversionServiceFactroyBean 后，就可以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了。<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a> 默认创建的<br>ConversionService 实例即为<br>FormattingConversionServiceFactroyBean</p></li></ul><h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p>&nbsp;&nbsp; @DateTimeFormat注解可对Date,Calendar,java.long.Long时间类型进行标注</p><ul><li><p><font color="red">pattern 属性</font>：类型为字符串。指定解析/格式化字段数据的模式，如：”yyyy-MM-dd hh:mm:ss”</p></li><li><p>iso 属性：类型为 DateTimeFormat.ISO。指定解析/格式化字段数据<br>的ISO模式，包括四种：ISO.NONE（不使用） – 默<br>认、ISO.DATE(yyyy-MM-dd) 、ISO.TIME(hh:mm:ss.SSSZ)、<br>ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ)</p></li><li><p>style 属性：字符串类型。通过样式指定日期时间的格式，由两位字<br>符组成，第一位表示日期的格式，第二位表示时间的格式：S：短日<br>期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整<br>日期/时间格式、-：忽略日期或时间格式</p></li></ul><h3 id="数值格式化"><a href="#数值格式化" class="headerlink" title="数值格式化"></a>数值格式化</h3><p>&nbsp;&nbsp; @NumberFormat 可对类似数字类型的属性进行标注，它拥有两个互斥的属性：</p><ul><li><p>style：类型为 NumberFormat.Style。用于指定样式类型，包括三种：Style.NUMBER（正常数字类型）、<br>Style.CURRENCY（货币类型）、 Style.PERCENT（<br>百分数类型）</p></li><li><p><font color="red">pattern</font>：类型为 String，自定义样式，如patter=”#,###”；</p></li><li><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span><br><span class="line">private Date birth;</span><br><span class="line"></span><br><span class="line">@NumberFormat(pattern=&quot;#,###,###.#&quot;)</span><br><span class="line">private Float salary;</span><br><span class="line"></span><br><span class="line">public Integer getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据校验-JSR303"><a href="#数据校验-JSR303" class="headerlink" title="数据校验(JSR303)"></a>数据校验(JSR303)</h2><ul><li><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中  </p></li><li><p>JSR 303 通过在 Bean 属性上标注类似于@NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证</p></li><li><p>JSR303注解：</p></li></ul><p><img src="/2019/01/28/SpringMVC——数据格式化与数据校验/1.jpg"></p><ul><li>使用   直接将注解加到Java bean中的某个要校验的属性上就行，但是也要在目标方法那个bean 类型前面加上@Valid注解,注意：需要校验数据的bean对象总是和其绑定结果对象或错误对象成对出现，他们之间不允许放入其他入参(他们要连在一起)</li></ul><h2 id="数据绑定流程"><a href="#数据绑定流程" class="headerlink" title="数据绑定流程"></a>数据绑定流程</h2><ul><li>Spring MVC 通过反射机制对目标处理方法进行解析，将请求消息绑定到处理方法的入参中。数据绑定的核心部件是DataBinder，运行机制如下：</li></ul><p><img src="/2019/01/28/SpringMVC——数据格式化与数据校验/2.jpg"></p><p>&nbsp;&nbsp;所以说当进行数据格式化和数据校验时，最后如果是错误的，错误结果会存到BindingResult对象里面，它其实是个Errors对象，因为它继承了Errors</p><p><img src="/2019/01/28/SpringMVC——数据格式化与数据校验/3.jpg"></p><h2 id="代码例子："><a href="#代码例子：" class="headerlink" title="代码例子："></a>代码例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   //COntroller层</span><br><span class="line">@RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.POST)</span><br><span class="line">   //要检验的bean必须和BindingResult(Errors)绑定到一起，中间不能有其他入参</span><br><span class="line">public String save(@Valid Employee employee, Errors result, </span><br><span class="line">Map&lt;String, Object&gt; map)&#123;</span><br><span class="line">System.out.println(&quot;save: &quot; + employee);</span><br><span class="line"></span><br><span class="line">if(result.getErrorCount() &gt; 0)&#123;</span><br><span class="line">System.out.println(&quot;出错了!&quot;);</span><br><span class="line"></span><br><span class="line">for(FieldError error:result.getFieldErrors())&#123;</span><br><span class="line">System.out.println(error.getField() + &quot;:&quot; + error.getDefaultMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//若验证出错, 则转向定制的页面</span><br><span class="line">map.put(&quot;departments&quot;, departmentDao.getDepartments());</span><br><span class="line">return &quot;input&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">employeeDao.save(employee);</span><br><span class="line">return &quot;redirect:/emps&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //bean里面的属性</span><br><span class="line"></span><br><span class="line">@NotEmpty</span><br><span class="line">private String lastName;</span><br><span class="line"></span><br><span class="line">@Email</span><br><span class="line">private String email;</span><br><span class="line">//1 male, 0 female</span><br><span class="line">private Integer gender;</span><br><span class="line"></span><br><span class="line">private Department department;</span><br><span class="line"></span><br><span class="line">@Past</span><br><span class="line">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span><br><span class="line">private Date birth;</span><br><span class="line"></span><br><span class="line">@NumberFormat(pattern=&quot;#,###,###.#&quot;)</span><br><span class="line">private Float salary;</span><br><span class="line"></span><br><span class="line">public Integer getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringMVC的数据转换</title>
      <link href="/2019/01/28/SpringMVC%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/01/28/SpringMVC%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>&nbsp;&nbsp;Spring MVC 上下文中内建了很多转换器,可完成大多数Java类型的转换工作。</p><p>&nbsp;&nbsp;自定义类型转换器，ConversionService是Spring类型转换体系的核心接口。可以利用 ConversionServiceFactoryBean 在 Spring 的 IOC<br>容器中定义一个 ConversionService. Spring 将自动识别出<br>IOC 容器中的 ConversionService，并在 Bean 属性配置及<br>Spring MVC 处理方法入参绑定等场合使用它进行数据的转换</p><p>&nbsp;&nbsp;可通过ConversionServiceFactoryBean 的 converters 属性注册自定义的类型转换器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置 ConversionService --&gt;</span><br><span class="line">&lt;bean id=&quot;conversionService&quot;</span><br><span class="line">class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name=&quot;converters&quot;&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;ref bean=&quot;employeeConverter&quot;/&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="Spring-支持的转换器"><a href="#Spring-支持的转换器" class="headerlink" title="Spring 支持的转换器"></a>Spring 支持的转换器</h2><p>Spring 定义了 3 种类型的转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到<br>ConversionServiceFactroyBean 中：</p><ul><li><p>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</p></li><li><p>ConverterFactory：将相同系列多个 “同质” Converter 封装在一<br>起。如果希望将一种类型的对象转换为另一种类型及其子类的对<br>象（例如将 String 转换为 Number 及 Number 子类<br>（Integer、Long、Double 等）对象）可使用该转换器工厂类</p></li><li><p>GenericConverter：会根据源类对象及目标类对象所在的宿主类<br>中的上下文信息进行类型转换</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EmployeeConverter implements Converter&lt;String, Employee&gt; &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Employee convert(String source) &#123;</span><br><span class="line">if(source != null)&#123;</span><br><span class="line">String [] vals = source.split(&quot;-&quot;);</span><br><span class="line">//GG-gg@atguigu.com-0-105</span><br><span class="line">if(vals != null &amp;&amp; vals.length == 4)&#123;</span><br><span class="line">String lastName = vals[0];</span><br><span class="line">String email = vals[1];</span><br><span class="line">Integer gender = Integer.parseInt(vals[2]);</span><br><span class="line">Department department = new Department();</span><br><span class="line">department.setId(Integer.parseInt(vals[3]));</span><br><span class="line"></span><br><span class="line">Employee employee = new Employee(null, lastName, email, gender, department);</span><br><span class="line">System.out.println(source + &quot;--convert--&quot; + employee);</span><br><span class="line">return employee;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringMVC——处理模型数据</title>
      <link href="/2019/01/27/SpringMVC%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/01/27/SpringMVC%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h2><ul><li><p>当控制器方法的返回值如果为ModelAndView，那么它既包含视图信息，也包含模型数据信息,其实如果返回String的话，他最终也会被SpringMVc转换成ModelAndView对象。</p></li><li><p>添加模型数据的方法</p><ul><li>ModelAndView  addObject(String attributeName,Object attributeValue)</li><li>ModelAndView  addAllObject(Map&lt;String,?&gt; modelMap)</li></ul></li><li><p>设置视图</p><ul><li>void setView(View view)</li><li>void setViewName(String viewName)</li></ul></li><li><p>例子:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 利用ModelAndView来转发数据,给前端视图</span><br><span class="line">     * @return modelAndView</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testModelAndView&quot;)</span><br><span class="line">    public ModelAndView testModelAndView() &#123;</span><br><span class="line">        //创建ModelAndView对象</span><br><span class="line">        ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">        //设置返回视图信息</span><br><span class="line">        modelAndView.setViewName(&quot;success&quot;);</span><br><span class="line">        //添加模型数据</span><br><span class="line">        modelAndView.addObject(&quot;message&quot;, &quot;Hello World&quot;);</span><br><span class="line">        return modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map和Model"><a href="#Map和Model" class="headerlink" title="Map和Model"></a>Map和Model</h2><ul><li><p>Spring MVC 在内部使用了一个org.springframework.ui.Model 接口存储模型数据</p></li><li><p>Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。</p></li><li><p><font color="red">如果方法的入参为Map或Model类型</font>，Spring MVC 会将隐含模型的引用传递给这些入参。在方法体中，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据</p></li></ul><h2 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="@SessionAttributes注解"></a>@SessionAttributes注解</h2><ul><li><p>若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个 @SessionAttributes,Spring MVC 将在模型中对应的属性暂存到 HttpSession 中</p></li><li><p>该注解只能放在类的上面. 而不能修饰方法。</p></li><li><p>@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中</p><ul><li><p>@SessionAttributes(types=User.class) 会将隐含模型中所有类型为 User.class 的属性添加到会话中。</p></li><li><p>@SessionAttributes(value={“user1”, “user2”}) 会将名字为user1和user2的属性添加到session对话中</p></li><li><p>@SessionAttributes(types={User.class, Dept.class})会将User类型和Dept类型的对象添加到会话中</p></li><li><p>@SessionAttributes(value={“user1”, “user2”}, types={Dept.class}) 会将名字为user1，user2还有类型为Dept的对象添加到session会话中</p></li></ul></li></ul><h2 id="ModelAttribute的使用场景"><a href="#ModelAttribute的使用场景" class="headerlink" title="ModelAttribute的使用场景"></a>ModelAttribute的使用场景</h2><ul><li><p>比如当我们要修改一个user对象的属性，但是其中ID属性的值我们不能修改，这时我们可以先从数据库中拿到这个user对象，然后再把用户发送过来的修改请求赋值给这个user对象，(前端只对除ID属性以外的属性赋值修改了)这时我们拿到的就是ID没有被修改的user对象了</p></li><li><p>例子:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   //被ModelAttribute修饰的方法会在每个目标方法执行之前被SpringMVC调用</span><br><span class="line"></span><br><span class="line">@ModelAttribute</span><br><span class="line">public void getUser(@RequestParam(value=&quot;id&quot;,required=false) Integer id, </span><br><span class="line">Map&lt;String, Object&gt; map)&#123;</span><br><span class="line">System.out.println(&quot;modelAttribute method&quot;);</span><br><span class="line">if(id != null)&#123;</span><br><span class="line">//模拟从数据库中获取对象</span><br><span class="line">User user = new User(1, &quot;Tom&quot;, &quot;123456&quot;, &quot;tom@atguigu.com&quot;, 12);</span><br><span class="line">System.out.println(&quot;从数据库中获取一个对象: &quot; + user);</span><br><span class="line"></span><br><span class="line">map.put(&quot;user&quot;, user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/testModelAttribute&quot;)</span><br><span class="line">public String testModelAttribute(User user)&#123;</span><br><span class="line">System.out.println(&quot;修改: &quot; + user);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行流程：</p><ol><li><p>ModelAttribute修饰的方法先从数据库中获取要修改的user对象，并把这个对象放入Map中，键为user</p></li><li><p>SpringMVC从map中取出键为user的对象，并将用户输入的修改的值赋给这个对象的相应属性</p></li><li><p>SpringMVC将这个被赋值好的对象传到目标方法的入参中</p></li><li><p>放入map的对象的键值要和目标方法第一个字母小写的String值要相同</p></li></ol><h2 id="SpringMVC-确定目标方法-POJO-类型入参的过程"><a href="#SpringMVC-确定目标方法-POJO-类型入参的过程" class="headerlink" title="SpringMVC 确定目标方法 POJO 类型入参的过程"></a>SpringMVC 确定目标方法 POJO 类型入参的过程</h2><ul><li>调用 @ModelAttribute 注解修饰的方法. 实际上把 @ModelAttribute 方法中 Map 中的数据放在了 implicitModel 中.</li><li><p>确定一个 key:</p><ul><li><p>若目标方法的 POJO 类型的参数木有使用 @ModelAttribute 作为修饰, 则 key 为 POJO 类名第一个字母小写</p></li><li><p>若使用了  @ModelAttribute 来修饰, 则 key 为 @ModelAttribute 注解的 value 属性值. </p></li></ul></li><li><p>在 implicitModel 中查找 key 对应的对象, 若存在, 则作为入参传入</p><ul><li><p>若在 @ModelAttribute 标记的方法中在 Map 中保存过, 且 key 和 1 确定的 key 一致, 则会获取到.</p></li><li><p>若 implicitModel 中不存在 key 对应的对象, 则检查当前的 Handler 是否使用 @SessionAttributes 注解修饰, 若使用了该注解, 且 @SessionAttributes 注解的 value 属性值中包含了 key, 则会从HttpSession 中来获取 key 所对应的 value 值, 若存在则直接传入到目标方法的入参中. 若不存在则将抛出异常. </p></li><li><p>若 Handler 没有标识 @SessionAttributes 注解或 @SessionAttributes 注解的 value 值中不包含 key, 则 会通过反射来创建 POJO 类型的参数, 传入为目标方法的参数</p></li></ul></li><li><p>SpringMVC 会把 key 和 POJO 类型的对象保存到 implicitModel 中, 进而会保存到 request 中. </p></li></ul><h2 id="ModelAttribute修饰方法的入参"><a href="#ModelAttribute修饰方法的入参" class="headerlink" title="ModelAttribute修饰方法的入参"></a>ModelAttribute修饰方法的入参</h2><ul><li><p>ModelAttribute修饰的POJO类型入参有个value值，SpringMVC会通过value值为key在implicitModel中查找对应的属性，若存在，则把这个属性直接赋值给目标方法入参(POJO对象)。</p></li><li><p>若不存在，则SpringMVC会以value为key，POJO入参为value存入Request中</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringMVC中POJO对象和Servlet API作为入参</title>
      <link href="/2019/01/27/SpringMVC%E4%B8%ADPOJO%E5%AF%B9%E8%B1%A1%E5%92%8CServlet-API%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82/"/>
      <url>/2019/01/27/SpringMVC%E4%B8%ADPOJO%E5%AF%B9%E8%B1%A1%E5%92%8CServlet-API%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<h2 id="使用POJO对象绑定请求参数值"><a href="#使用POJO对象绑定请求参数值" class="headerlink" title="使用POJO对象绑定请求参数值"></a>使用POJO对象绑定请求参数值</h2><ul><li><p>Spring MVC 会按请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel 等</p></li><li><p>例子：</p></li></ul><p>Controller层代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;testPOJO&quot;,method = RequestMethod.POST)</span><br><span class="line">public String testPOJO(User user)&#123;</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">    return TEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>jsp页面代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;testPOJO&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;address.province&quot; placeholder=&quot;省份&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;address.city&quot; placeholder=&quot;城市&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;TestPOJO&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><h2 id="使用Servlet-API作为入参"><a href="#使用Servlet-API作为入参" class="headerlink" title="使用Servlet API作为入参"></a>使用Servlet API作为入参</h2><ul><li>例子:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 可以使用 Serlvet 原生的 API 作为目标方法的参数 具体支持以下类型</span><br><span class="line"> * </span><br><span class="line"> * HttpServletRequest </span><br><span class="line"> * HttpServletResponse </span><br><span class="line"> * HttpSession</span><br><span class="line"> * java.security.Principal </span><br><span class="line"> * Locale InputStream </span><br><span class="line"> * OutputStream </span><br><span class="line"> * Reader </span><br><span class="line"> * Writer</span><br><span class="line"> * @throws IOException </span><br><span class="line"> */</span><br><span class="line">@RequestMapping(&quot;/testServletAPI&quot;)</span><br><span class="line">public void testServletAPI(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, Writer out) throws IOException &#123;</span><br><span class="line">System.out.println(&quot;testServletAPI, &quot; + request + &quot;, &quot; + response);</span><br><span class="line">out.write(&quot;hello springmvc&quot;);</span><br><span class="line">//return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringMVC中的RequestParam注解</title>
      <link href="/2019/01/27/SpringMVC%E4%B8%AD%E7%9A%84RequestParam%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/01/27/SpringMVC%E4%B8%AD%E7%9A%84RequestParam%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="请求处理方法签名"><a href="#请求处理方法签名" class="headerlink" title="请求处理方法签名"></a>请求处理方法签名</h2><ul><li><p>Spring MVC 通过分析处理方法的签名，将HTTP 请求信息绑定到处理方法的相应入参中</p></li><li><p>Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名。</p></li><li><p>必要时可以对方法及方法入参标注相应的注解（<br>@PathVariable、@RequestParam、@RequestHeader 等）、Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理</p></li></ul><h2 id="使用-RequestParam绑定请求参数值"><a href="#使用-RequestParam绑定请求参数值" class="headerlink" title="使用@RequestParam绑定请求参数值"></a>使用@RequestParam绑定请求参数值</h2><ul><li><p>在处理方法入参使用 @RequestParam 可以把请求参数传递给请求方法</p><ul><li><p>value:参数名</p></li><li><p>required:是否必须。默认为true，表示请求参数中必须包含对应的参数，若不存在，将抛出异常,网页中会报400请求错误。但是，当required设置为false时，方法参数为int型这种基本类型参数时，访问URL时不加参数值会报500服务器错误，解决方法是给RequestParam加一个defaultValue值。因为，如果参数是非必需的，则会赋值为null，所以参数应该是一个object对象，它才能接受这个null值。</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这里RequestParam的value值id其实指的是传过来的参数，即url上带的参数</span><br><span class="line">//当RequestParam不写的时候其实跟写了这个注解加上required=false是一样的，但是为了阅读方便，一般都加上</span><br><span class="line">@RequestMapping(value = &quot;/testRequestParam&quot;,method = RequestMethod.GET)</span><br><span class="line">public String testRequestParam(@RequestParam(value = &quot;id&quot;,required = false) int id)&#123;</span><br><span class="line">    System.out.println(&quot;参数为:&quot;+id);</span><br><span class="line">    return TEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/01/27/SpringMVC中的RequestParam注解/1.jpg"></p><h2 id="相类似的RequestHeader和CookieValue注解"><a href="#相类似的RequestHeader和CookieValue注解" class="headerlink" title="相类似的RequestHeader和CookieValue注解"></a>相类似的RequestHeader和CookieValue注解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 了解:</span><br><span class="line"> * </span><br><span class="line"> * @CookieValue: 映射一个 Cookie 值. 属性同 @RequestParam</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(&quot;/testCookieValue&quot;)</span><br><span class="line">public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123;</span><br><span class="line">System.out.println(&quot;testCookieValue: sessionId: &quot; + sessionId);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 了解: 映射请求头信息 用法同 @RequestParam</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(&quot;/testRequestHeader&quot;)</span><br><span class="line">public String testRequestHeader(</span><br><span class="line">@RequestHeader(value = &quot;Accept-Language&quot;) String al) &#123;</span><br><span class="line">System.out.println(&quot;testRequestHeader, Accept-Language: &quot; + al);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringMVC中的RequestMapping注解</title>
      <link href="/2019/01/27/SpringMVC%E4%B8%AD%E7%9A%84RequestMapping%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/01/27/SpringMVC%E4%B8%AD%E7%9A%84RequestMapping%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-RequestMapping注解映射请求"><a href="#使用-RequestMapping注解映射请求" class="headerlink" title="使用@RequestMapping注解映射请求"></a>使用@RequestMapping注解映射请求</h2><ul><li><p>Spring MVC使用 @RequestMapping 注解为控制器指定可以处理哪些URL请求</p></li><li><p>这个注解在控制器的类定义和方法定义处都可标注，类定义处提供初步的请求映射信息，相对于WEB应用的根目录，方法处提供进一步的细分信息，若类定义处未标注  @RequestMapping ，则方法处标记的URL相对于WEB应用的根目录</p></li><li><p>DispatcherServlet 截获请求后，就通过控制器上<br>@RequestMapping 提供的映射信息确定请求所对应的处理<br>方法。</p></li></ul><h2 id="映射请求参数、请求方法或请求头"><a href="#映射请求参数、请求方法或请求头" class="headerlink" title="映射请求参数、请求方法或请求头"></a>映射请求参数、请求方法或请求头</h2><ul><li><p>@RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求</p></li><li><p>@RequestMapping 的 value、method、params 及 heads 分别表示请求 URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，<font color="red">联合使用多个条件可让请求映射更加精确化。</font></p></li><li><p>params 和 headers支持简单的表达式：</p><p>– param1: 表示请求必须包含名为 param1 的请求参数</p><p>– !param1: 表示请求不能包含名为 param1 的请求参数 </p><p>– param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1</p><p>– {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2 的两个请求参数，且 param1 参数的值必须为 value1</p></li><li><p>例子</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;testParamsAndHeaders&quot;, params = &#123; &quot;username&quot;,</span><br><span class="line">&quot;age!=10&quot; &#125;, headers = &#123; &quot;Accept-Language=en-US,zh;q=0.8&quot; &#125;)</span><br><span class="line">public String testParamsAndHeaders() &#123;</span><br><span class="line">System.out.println(&quot;testParamsAndHeaders&quot;);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持ant风格的资源地址"><a href="#支持ant风格的资源地址" class="headerlink" title="支持ant风格的资源地址"></a>支持ant风格的资源地址</h2><ul><li><p>Ant 风格资源地址支持 3 种匹配符：</p><p>– ?：匹配文件名中的一个字符</p><p>– *：匹配文件名中的任意字符</p><p>– <strong> ：</strong> 匹配多层路径</p></li><li><p>例子：</p><p>“/testAntPath/*/abc” 等等</p></li></ul><h2 id="PathVariable-映射URl绑定占位符"><a href="#PathVariable-映射URl绑定占位符" class="headerlink" title="@PathVariable 映射URl绑定占位符"></a>@PathVariable 映射URl绑定占位符</h2><ul><li><p>带占位符的 URL 是 Spring3.0 新增的功能，该功能在<br>SpringMVC 向 REST 目标挺进发展过程中具有里程碑的<br>意义</p></li><li><p>通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {<font color="red">xxx</font>} 占位符可以通过 @PathVariable(“<font color="red">xxx</font>“) 绑定到操作方法的入参中。</p></li><li><p>例子：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @PathVariable 可以来映射 URL 中的占位符到目标方法的参数中.</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span><br><span class="line">public String testPathVariable(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">System.out.println(&quot;testPathVariable: &quot; + id);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="REST风格的URL"><a href="#REST风格的URL" class="headerlink" title="REST风格的URL"></a>REST风格的URL</h2><ul><li><p>REST：即 Representational State Transfer。（资源）表现层状态转化。是目前<br>最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p></li><li><p>资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。</p></li><li><p>表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层<br>（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。</p></li><li><p>状态转化（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p></li><li><p>例子：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Rest 风格的 URL. 以 CRUD 为例: </span><br><span class="line">        * 新增: /order POST </span><br><span class="line">        * 修改: /order/1 PUT  update?id=1 </span><br><span class="line">        * 获取:/order/1 GET  get?id=1</span><br><span class="line">        * 删除: /order/1 DELETE  delete?id=1</span><br><span class="line"> * 如何发送 PUT 请求和 DELETE 请求呢 ? 1. 需要配置 HiddenHttpMethodFilter 2. 需要发送 POST 请求</span><br><span class="line"> * 3. 需要在发送 POST 请求时携带一个 name=&quot;_method&quot; 的隐藏域, 值为 DELETE 或 PUT</span><br><span class="line"> * </span><br><span class="line"> * 在 SpringMVC 的目标方法中如何得到 id 呢? 使用 @PathVariable 注解</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.PUT)</span><br><span class="line">public String testRestPut(@PathVariable Integer id) &#123;</span><br><span class="line">System.out.println(&quot;testRest Put: &quot; + id);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span><br><span class="line">public String testRestDelete(@PathVariable Integer id) &#123;</span><br><span class="line">System.out.println(&quot;testRest Delete: &quot; + id);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/testRest&quot;, method = RequestMethod.POST)</span><br><span class="line">public String testRest() &#123;</span><br><span class="line">System.out.println(&quot;testRest POST&quot;);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/testRest/&#123;id&#125;&quot;, method = RequestMethod.GET)</span><br><span class="line">public String testRest(@PathVariable Integer id) &#123;</span><br><span class="line">System.out.println(&quot;testRest GET: &quot; + id);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //页面代码</span><br><span class="line">   &lt;form action=&quot;springmvc/testRest/1&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;TestRest PUT&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;springmvc/testRest/1&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;TestRest DELETE&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;springmvc/testRest&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;TestRest POST&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;springmvc/testRest/1&quot;&gt;Test Rest Get&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">   //在web.xml中配置filter</span><br><span class="line"></span><br><span class="line">   &lt;!-- 配置 org.springframework.web.filter.HiddenHttpMethodFilter: 可以把 POST 请求转为 DELETE 或 POST 请求 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><ul><li>HiddenHttpMethodFilter：浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与DELETE 请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中单例模式的饿汉与懒汉</title>
      <link href="/2019/01/27/Java%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%A5%BF%E6%B1%89%E4%B8%8E%E6%87%92%E6%B1%89/"/>
      <url>/2019/01/27/Java%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%A5%BF%E6%B1%89%E4%B8%8E%E6%87%92%E6%B1%89/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>&nbsp;&nbsp;有些对象我们只需要一个，如：配置文件、工具类、线程池、缓存、日志对象等。</p><p>&nbsp;&nbsp;如果创造出多个实例，就会导致许多问题,比如占用过多资源，不一样的结果等。</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><ol><li><p>将构造方法私有化，不允许外部直接访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Singleton()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建 类的唯一实例, 使用private static修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton  instance=new Singleton();</span><br></pre></td></tr></table></figure></li><li><p>提供一个用于获取实例的方法, 使用public static修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><ol><li><p>将构造方法私有化，不允许外边直接创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    private Singleton2()&#123;&#125;</span><br><span class="line">``` </span><br><span class="line">2. 声明 类的唯一实例，使用private static修饰。</span><br></pre></td></tr></table></figure><p> private static Singleton2 instance;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 提供一个用于获取实例的方法，使用public static修饰。</span><br></pre></td></tr></table></figure><p> public static Singleton2 getInstance(){</p><pre><code>if(instance==null){    instance=new Singleton2();}return instance;</code></pre><p> }<br><code>`</code></p></li></ol><h2 id="饿汉模式与懒汉模式的区别"><a href="#饿汉模式与懒汉模式的区别" class="headerlink" title="饿汉模式与懒汉模式的区别"></a>饿汉模式与懒汉模式的区别</h2><ul><li>饿汉模式</li></ul><p>&nbsp;&nbsp;加载类时比较慢，但运行时获取对象的速度比较快，线程安全</p><ul><li>懒汉模式</li></ul><p>&nbsp;&nbsp;加载类时比较快，但运行时获取对象的速度比较慢，线程不安全</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS中的定位</title>
      <link href="/2019/01/26/CSS%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D/"/>
      <url>/2019/01/26/CSS%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h2><p>&nbsp;&nbsp;通过设置定位将页面中的元素摆放到页面的任意位置，我们使用position属性来设置元素的定位</p><ul><li>static&nbsp;&nbsp;默认值，元素没有开启定位</li><li>relative&nbsp;&nbsp;开启元素的相对定位</li><li>absolute&nbsp;&nbsp;开启元素的绝对定位</li><li>fixed&nbsp;&nbsp;开启元素的固定定位</li></ul><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><ul><li>left</li><li>top</li><li>right</li><li>bottom</li></ul><p>一般情况我们只设置一个水平偏移量和垂直偏移量，用这两个偏移量来确定元素的位置。</p><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><ol><li>开启相对定位时如果不设置偏移量，元素不会发生任何变化</li><li>相对定位元素相对于其自身原来在文档流中的位置来定位</li><li>相对定位的元素不会脱离文档流</li></ol><p><img src="/2019/01/26/CSS中的定位/1.jpg"></p><p>box2开启向对定位且向右偏移box3宽度的像素，但是box3没有向上顶，原因就是原来box2还在文档流中</p><ol start="4"><li>相对定位不会改变元素的性质，块级元素还是块级元素，内联元素还是内联</li><li>相对定位的元素会提升一个层级</li></ol><p><img src="/2019/01/26/CSS中的定位/2.jpg"></p><p>此时box2开启相对定位，它把box3给覆盖了一些，说明box2比box3高了一个层级</p><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><ol><li>元素设置成绝对定位以后，如果不设置偏移量，元素位置不会发生改变</li><li>绝对定位的元素是相对于距离他最近的开启了定位的祖先元素进行定位的，如果所有祖先元素都没有开启定位，则相对于浏览器窗口进行定位</li></ol><p><img src="/2019/01/26/CSS中的定位/3.jpg"></p><p>box1为box4的父元素，box1开启定位，box4开启绝对定位，则他的偏移量是根据box1的位置来定的，也就是最近的开启了定位的祖先元素。</p><ol start="3"><li><p>绝对定位会完全脱离文档流</p></li><li><p>绝对定位会改变元素的性质。内联变成块元素，块元素的高度和宽度都被内容撑开，并且不独占一行(脱离文档流的特点，浮动也有)</p></li><li><p>绝对定位会使元素提升一个层级</p></li></ol><h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><p>&nbsp;&nbsp;固定定位是一种特殊的绝对定位，他的特点大部分和绝对定位一样，但是不同的是，固定定位的元素永远都是相对于浏览器窗口进行定位的，并且不会随滚动条滚动(用来实现广告窗口，固定导航条等)</p><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p>&nbsp;&nbsp;在一般开启定位之后，开启定位的元素会提升一个层级，也就是它会覆盖上面的元素，如果两个元素都开启了定位，那么后面的元素就会覆盖前面的元素，那么如果我们想前面的元素覆盖上面的元素，我们可以通过设置z-index属性来做到。</p><p>&nbsp;&nbsp;z相当于z轴，因为层级已经不是水平方向的了，一般我们给z-index设置整数，整数越大，层级越高。</p><h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h2><p>&nbsp;&nbsp;当元素出现了层级的概念之后，opacity也很好理解了，比如我们设置了box4是覆盖box1的，但是我们想通过box4来看到box1，那么我们可以通过设置opacity属性来设置box4的透明度。</p><p>&nbsp;&nbsp;opacity值在0~1之间，0是全透明，1是不透明，0.5就是半透明。</p><p><img src="/2019/01/26/CSS中的定位/4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS的盒子模型</title>
      <link href="/2019/01/25/CSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/25/CSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是盒子模型"><a href="#什么是盒子模型" class="headerlink" title="什么是盒子模型"></a>什么是盒子模型</h2><p>&nbsp;&nbsp;CSS中将每个元素都设置为了一个矩形的盒子来方便页面的布局，所以当这些元素都变成了盒子之后，我们的布局就变成了在页面中摆放盒子</p><p><img src="/2019/01/25/CSS的盒子模型/1.png"></p><h2 id="内容-content"><a href="#内容-content" class="headerlink" title="内容(content)"></a>内容(content)</h2><p>&nbsp;&nbsp;元素的所有子元素都是放在父元素的内容区中</p><p>&nbsp;&nbsp;内容区有宽度和高度——width，height</p><h2 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h2><p>&nbsp;&nbsp;内边距指的是内容区和边框区之间的距离，<font color="red">内边距会影响盒子的大小</font>。</p><p><img src="/2019/01/25/CSS的盒子模型/2.jpg"></p><p>此时box1原本高度宽度只有10px，设置内边距之后整个盒子可见框的大小就发生变化了，而且元素的背景颜色延伸到了内边距。</p><p>其中属性有五种</p><ul><li>padding</li></ul><p>当只设置一个值的时候这个值则是给上右下左都设置了</p><p>当设置两个值时，第一个值是上下，第二个值是左右</p><p>当设置三个值时，第一个值是上，第二个值是左右，第三个值是下</p><p>当设置四个值时，就是上右下左</p><ul><li><p>padding-top</p></li><li><p>padding-right</p></li><li><p>padding-bottom</p></li><li><p>padding-left</p></li></ul><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>&nbsp;&nbsp;<font color="red">整个盒子的可见框大小是由内容区、内边距区，边框区决定的</font></p><p>&nbsp;&nbsp;设置边框需要设置三个样式。他们分别是border-width，border-color，border-style</p><p>border-width设置的是边框的宽度</p><p>border-color设置的是边框的颜色</p><p>border-style设置的是边框的样式，一般有solid实线，dotted点线，dashed虚线等等</p><p>&nbsp;&nbsp;通过使用border直接给边框三个属性赋值，例:border: 1px solid red;&nbsp;三个属性没有顺序要求</p><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><h3 id="外边距的简述和语法规范"><a href="#外边距的简述和语法规范" class="headerlink" title="外边距的简述和语法规范"></a>外边距的简述和语法规范</h3><p>&nbsp;&nbsp;外边距是盒子和其他盒子之间地距离，外边距不会影响可见框的大小，但是会影响盒子的位置。</p><p>&nbsp;&nbsp;外边距也具有四个方向，语法跟padding相类似。</p><p>&nbsp;&nbsp;margin值：单独将左右外边距设置为auto，则会将左右外边距设置为最大值</p><p>&nbsp;&nbsp;如果同时将左右外边距设置为auto，则他的左右外边距会相同，所以一般我们会通过这种方式使一个子元素在他的父元素中水平居中&nbsp;&nbsp;<font color="red">margin:0 auto</font></p><p>&nbsp;&nbsp;外边距可以设置为负值，则元素会向相反方向移动</p><h3 id="外边距的重叠和取和现象"><a href="#外边距的重叠和取和现象" class="headerlink" title="外边距的重叠和取和现象"></a>外边距的重叠和取和现象</h3><p>&nbsp;&nbsp;相邻元素的外边距会取最大值</p><p><img src="/2019/01/25/CSS的盒子模型/3.jpg"><br><img src="/2019/01/25/CSS的盒子模型/4.jpg"></p><p>上面两张图我们可以看见box1和box2之间地margin值重叠在了一起，所以他们之间地margin值取得是最大的那一个</p><p>&nbsp;&nbsp;子元素的外边距会传给父元素</p><p><img src="/2019/01/25/CSS的盒子模型/5.jpg"></p><p>上图我们可以知道box1把外边距传给了他的父元素box3</p><p>&nbsp;&nbsp;另外一个就是水平外边距不会重叠，他们会取和</p><h2 id="内联元素的盒子模型"><a href="#内联元素的盒子模型" class="headerlink" title="内联元素的盒子模型"></a>内联元素的盒子模型</h2><h3 id="内联元素的width和height"><a href="#内联元素的width和height" class="headerlink" title="内联元素的width和height"></a>内联元素的width和height</h3><p>&nbsp;&nbsp;<font color="red">内联元素是不支持宽高属性的!</font></p><h3 id="内联元素的padding"><a href="#内联元素的padding" class="headerlink" title="内联元素的padding"></a>内联元素的padding</h3><p>&nbsp;&nbsp;内联元素支持水平方向的padding</p><p><img src="/2019/01/25/CSS的盒子模型/6.jpg"></p><p>&nbsp;&nbsp;内联元素也支持垂直方向的padding但是不会影响布局</p><p><img src="/2019/01/25/CSS的盒子模型/7.jpg"></p><h3 id="内联元素的border"><a href="#内联元素的border" class="headerlink" title="内联元素的border"></a>内联元素的border</h3><p>&nbsp;&nbsp;支持四个方向的边框，但是垂直的边框不会影响布局</p><h3 id="内联元素的margin"><a href="#内联元素的margin" class="headerlink" title="内联元素的margin"></a>内联元素的margin</h3><p>&nbsp;&nbsp;支持水平方向的外边距，不支持垂直方向上的</p><p><img src="/2019/01/25/CSS的盒子模型/8.jpg"></p><h2 id="盒模型相关的样式"><a href="#盒模型相关的样式" class="headerlink" title="盒模型相关的样式"></a>盒模型相关的样式</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>&nbsp;&nbsp;display决定元素的显示方式</p><ul><li>none&nbsp;&nbsp;当属性值为none时，这个元素不会在页面中显示且不会占据页面的位置</li><li>block&nbsp;&nbsp;元素作为块元素显示</li><li>inline&nbsp;&nbsp;元素作为内联元素显示</li><li>inline-block&nbsp;&nbsp;作为行内块元素显示，具有块元素和内联元素的特点——<font color="red">能进行宽高的设置，不会进行换行</font></li></ul><h3 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h3><p>&nbsp;&nbsp;visibility属性设置元素是否在页面中显示</p><ul><li>visible&nbsp;&nbsp;默认值，元素可以正常显示</li><li>hidden&nbsp;&nbsp;元素不在页面中显示，但是<font color="red">依然在页面占据着它原来的空间</font></li></ul><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>&nbsp;&nbsp;overflow设置元素如何处理溢出内容</p><ul><li>visible&nbsp;&nbsp;默认值，子元素溢出的东西会在父元素以外的地方显示</li></ul><p><img src="/2019/01/25/CSS的盒子模型/9.jpg"></p><ul><li>hidden 溢出内容会被隐藏</li><li>scroll 会添加滚动条显示溢出内容不管内容是否溢出都会添加滚动条</li></ul><p><img src="/2019/01/25/CSS的盒子模型/10.jpg"></p><ul><li>auto&nbsp;&nbsp;根据需要自动生成滚动条</li></ul><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>文档流指的是网页中的一个位置</p><p>文档流是网页的基础，是网页的最底层，所有的元素默认都是在文档流中排列</p><p>元素在文档流中默认自左向右，自上向下排列（和我们的书写习惯一致）</p><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><ol><li>块元素在文档流中自上向下排列</li><li>块元素在文档流中宽度默认是父元素的100%</li><li>块元素在文档流中高度默认被内容撑开</li></ol><h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><ol><li>内联元素在文档流中自左向右排列，如果一行中不足以容下所有的内联元素，则换到下一行，继续自左至右排列</li><li>内联元素在文档流中宽度和高度默认都被内容撑开</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS的浮动</title>
      <link href="/2019/01/24/CSS%E2%80%94%E7%9A%84%E6%B5%AE%E5%8A%A8/"/>
      <url>/2019/01/24/CSS%E2%80%94%E7%9A%84%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>&nbsp;&nbsp;使用float属性给元素设置浮动效果</p><p>可选值：</p><ul><li>none  &nbsp;&nbsp;默认值,不浮动，元素还在文档流中</li><li>left  &nbsp;&nbsp;元素向左浮动</li><li>right  &nbsp;&nbsp;元素向右浮动<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2></li></ul><ol><li>元素浮动以后会脱离文档流</li><li>浮动以后会向父元素的最上方移动</li><li>知道遇到父元素的边框或者其他的浮动元素，会停止移动</li></ol><p>首先我们看一下当元素在文档流中，比如div元素在页面的布局</p><p><img src="/2019/01/24/CSS—的浮动/1.jpg" height="280" width="400"></p><p>此时div是垂直排列的，因为这是块级元素的特点——块级元素在文档流中默认垂直排列</p><p>但是如果我们向让他们水平排列怎么办呢？ 可以把块级元素的display属性设置为inline-block（行内块状元素）。</p><p>还有一种就是将元素脱离文档流，此时元素就不会受到文档流的约束。</p><p><img src="/2019/01/24/CSS—的浮动/2.jpg" height="200" width="500"></p><ol start="4"><li>如果浮动元素上边是个块元素，则浮动元素不会覆盖块元素</li></ol><p><img src="/2019/01/24/CSS—的浮动/3.jpg" height="200" width="500"></p><p>这里将box1的浮动效果注释掉，可以看到box2和box3元素被box1元素向墙一样堵住了从而不能浮动上去。</p><ol start="5"><li>浮动元素不会超过他上边的浮动的兄弟元素，最多对齐</li></ol><p><img src="/2019/01/24/CSS—的浮动/4.jpg" height="200" width="500"></p><p>我们把box1，box2的宽度调大使一行里面容不下两个浮动元素，我们再设置box3为右浮动，但是此时我们发现box3不会浮动到最上边，它没有超过上边的浮动元素。</p><ol start="6"><li>浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果</li></ol><p><img src="/2019/01/24/CSS—的浮动/5.jpg" height="200" width="500"></p><h2 id="浮动以后元素的特点"><a href="#浮动以后元素的特点" class="headerlink" title="浮动以后元素的特点"></a>浮动以后元素的特点</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>不会独占一行，宽度和高度都被内容撑开</p><h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p>内联元素脱离文档流以后会变成块元素</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中的私有构造方法和单例模式</title>
      <link href="/2019/01/09/Java%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/09/Java%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="私有构造方法"><a href="#私有构造方法" class="headerlink" title="私有构造方法"></a>私有构造方法</h2><p>&nbsp;&nbsp;这几天在学习Netty写聊天室的时候看见了一个例子，在例子中的代码使用到了Java的单例模式，基础不是太好，所以特意去搜索了解了一下单例模式。</p><p>本文参考于 <a href="https://www.cnblogs.com/alsf/p/5517504.html" target="_blank" rel="noopener">构造方法私有化和单例模式</a></p><p>&nbsp;&nbsp;写单例模式之前先说一下私有构造方法，即在构造方法之前加上private关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    private Test()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;这时我们定义了构造方法的私有化，如果我们在别的类中实例化Test则会报错，因为私有的方法在其他类中是无法看见的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test1&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Test test=new Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;这时候会报错，因为Test1访问不到Test的私有构造方法</p><h2 id="如何去解决呢？"><a href="#如何去解决呢？" class="headerlink" title="如何去解决呢？"></a>如何去解决呢？</h2><p>&nbsp;&nbsp;解决的方法也简单，因为是私有的构造方法，所以我们可以通过在本类里实例化Test，将Test的实例设置为私有静态变量，再构造这个实例的get方法，那么其他类就可以通过这个类的静态方法getInstance()方法获取要获取的类的实例了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test()&#123;</span><br><span class="line">    private Test()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //创建静态对象instance</span><br><span class="line">    private static Test instance=new Test();</span><br><span class="line">    //通过get方法获取instance实例</span><br><span class="line">    public static Test getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test1&#123;</span><br><span class="line">    public static void mian()&#123;</span><br><span class="line">        //通过调用Test的静态方法获取实例</span><br><span class="line">        Test test=Test.getInstance();</span><br><span class="line">        test.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;代码运行结果就是Hello!</p><h2 id="为什么要这么做呢"><a href="#为什么要这么做呢" class="headerlink" title="为什么要这么做呢"></a>为什么要这么做呢</h2><p>&nbsp;&nbsp;我们先把上面的Test1的代码改一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test1&#123;</span><br><span class="line">    public static void mian()&#123;</span><br><span class="line">        //通过调用Test的静态方法获取实例</span><br><span class="line">        Test test=Test.getInstance();</span><br><span class="line">        Test test1=Test.getInstance();</span><br><span class="line">        Test test2=Test.getInstance();</span><br><span class="line">        Test test3=Test.getInstance();</span><br><span class="line">        //后面一些实例调用print方法就不一一列出来了....</span><br><span class="line">        test.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;这时候我们实例化了四个Test，我们再回头看看刚刚Test的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test()&#123;</span><br><span class="line">    private Test()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //创建静态对象instance</span><br><span class="line">    private static Test instance=new Test();</span><br><span class="line">    //通过get方法获取instance实例</span><br><span class="line">    public static Test getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;我们所有实例化都是通过getInstance方法获取的，但是getInstance方法获取的都是一个instance对象，也就是说我们实例化了那么多Test也只是对instance这个对象的引用。所以如果现在不希望一个类产生过多的对象的话，则必须采用单例设计模式，而且，在以后的java学习中，在支持java的类库中，大量采用了这种模式。</p><h3 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h3><p>&nbsp;&nbsp;在window中有一个回收站，除了桌面有回收站，每个硬盘都有回收站，实际上每个硬盘上的回收站和桌面的回收站是同一个，<br>也就是说，整个操作系统只有一个回收站实例，各个地方只是引用这个实例而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例设计模式核心就是将类的构造方法私有化，之后在类的内部产生实例化对象，并通过类名引用类的静态方法（static）返回实例化对象的引用。</p>]]></content>
      
      
      <categories>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringMVC核心配置文件的解析和应用</title>
      <link href="/2018/12/14/SpringMVC%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/"/>
      <url>/2018/12/14/SpringMVC%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用maven导入包"><a href="#使用maven导入包" class="headerlink" title="使用maven导入包"></a>使用maven导入包</h2><p>&nbsp;&nbsp;这里我使用的是maven导入jar包，以前不知道maven，感觉导入jar包时特别麻烦，现在好了，直接Ctrl+c，Ctrl+v就完事了。</p><ul><li>配置SpringMVC的jar包</li></ul><p>&nbsp;&nbsp;SpringMVC所需要的jar包叫做</p><font color="red"><strong>spring-webmvc.jar</strong></font>。<br><br>这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。<br><br>这里给出spring-webmvc在pom.xml中的代码，大家也可以自己在maven中央仓库中查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 依赖Spring MVC--&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><br><br>+ 配置Servlet的jar包<br><br>&nbsp;&nbsp;SpringMVC是以Servlet为基础的，这里当然不能少了Servlet的配置，关于Servlet和SpringMVC的关系在接下来的博客里会有所涉及。<br><br>这里给出servletz在pom.xml中的代码，大家也可以自己在maven中央仓库中查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">           &lt;!--servlet的配置--&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><br><br>## 在web.xml中配置dispatcherServlet<br><br>dispatcherServlet是前端控制器设计模式的实现，提供SpringWebMVC的集中访问点，而且负责职责的分派，而且与spring IOC容器无缝集成，从而可以获得Spring的优势。其主要职责是调度工作，本身用于控制流程。<br><br>1.文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；<br><br>2.通过HandlerMapping，将请求映射到处理器(返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器)；<br><br>3.通过handlerAdapter支持多种类型的处理器(handlerExceptionChain中的处理器)；<br><br>4.通过ViewResolver解析逻辑视图名到具体视图实现；<br><br>5.本地化解析；<br><br>6.渲染具体的视图等；<br><br>7.如果执行过程中遇到异常将交给handlerExceptionResolver来解析；<br><br>可以说<font color="red"><strong>dispatcherServlet是SpringMVC的核心</strong></font><ul><li>下面是dispatcherServlet在web.xml中的相关配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- springmvc的前端控制器，拦截所有请求  --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;!--这里设为拦截所有请求，可以根据自己需求设置--&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><ul><li><font color="red"><strong>dispatcherServlet文件一般默认在WEB-INF目录下面</strong></font>，如果需要更改则通过在servlet的初始参数里面修改contextConfigLocation的值，例如:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;自己设定的路径&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure><h2 id="配置dispatcherServlet-servlet-xml"><a href="#配置dispatcherServlet-servlet-xml" class="headerlink" title="配置dispatcherServlet-servlet.xml"></a>配置<font color="red"><strong>dispatcherServlet-servlet.xml</strong></font></h2><p>&nbsp;&nbsp;如果按照默认的话对应的dispatcherServlet文件会以dispatcherServlet-servlet.xml放在WEB-INF目录下面</p><ul><li>首先给出基本的dispatcherServlet的配置代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringMVC的配置文件，包含网站跳转逻辑的控制，配置  --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.lgq&quot; use-default-filters=&quot;false&quot;&gt;</span><br><span class="line">&lt;!--只扫描控制器。  --&gt;</span><br><span class="line">&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置视图解析器，方便页面返回  --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--两个标准配置  --&gt;</span><br><span class="line">&lt;!-- 将springmvc不能处理的请求交给tomcat --&gt;</span><br><span class="line">&lt;mvc:default-servlet-handler/&gt;</span><br><span class="line">&lt;!-- 能支持springmvc更高级的一些功能，JSR303校验，快捷的ajax...映射动态请求 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven/&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;以上就是SpringMVC的基本配置，其中一些细节方面的会慢慢在以后的博文里面说明</p>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浅谈Java中==与equals的区别</title>
      <link href="/2018/12/11/%E6%B5%85%E8%B0%88Java%E4%B8%AD-%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/12/11/%E6%B5%85%E8%B0%88Java%E4%B8%AD-%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h2><p>  &nbsp;&nbsp;在谈==与equals区别之前，我们先来谈一谈java中堆和栈的区别，还有基本数据类型和引用数据类型的区别。</p><ul><li><p><strong>基本数据类型有什么?</strong></p><p>&nbsp;&nbsp;八个基本数据类型：byte，short，int，long，float，double，char，boolean</p></li><li><p><strong>引用数据类型是什么?</strong></p><p>&nbsp;&nbsp;引用数据类型是：类，接口，数组</p><p>&nbsp;&nbsp;<font size="4"><strong>具体参考下图</strong></font></p></li></ul><p><img src="/2018/12/11/浅谈Java中-与equals的区别/1.png"></p><h2 id="引用数据类型，基本数据类型和堆栈之间的关系"><a href="#引用数据类型，基本数据类型和堆栈之间的关系" class="headerlink" title="引用数据类型，基本数据类型和堆栈之间的关系"></a>引用数据类型，基本数据类型和堆栈之间的关系</h2><ul><li>引用类型的变量，其内存分布在堆上或者常量池(字符串变量、基本数据类型常量)，需要通过new等方式来创建。堆内主要存放运行时，需要new来创建的对象。</li><li>基本数据类型变量(8种基本数据类型)以及对象的引用变量，其内存分布在栈上，变量出了作用域就会自动释放。</li></ul><font size="4"><strong>如下图:</strong></font><p><img src="/2018/12/11/浅谈Java中-与equals的区别/2.png" height="240" width="440"></p><h2 id="Java中-和equals-与上述两者的关系"><a href="#Java中-和equals-与上述两者的关系" class="headerlink" title="Java中==和equals()与上述两者的关系"></a>Java中==和equals()与上述两者的关系</h2><ul><li>==操作的是栈内存中的值是否相等</li><li>equals比较的是堆内存中的值是否相等。</li></ul><font size="4">下面我们通过一些实例来证明：</font><ul><li><strong>比较两个基本数据类型</strong></li></ul><p><img src="/2018/12/11/浅谈Java中-与equals的区别/3.png" height="230" width="360"></p><p>输出结果为: a==b</p><p>&nbsp;&nbsp;<strong>可见==b比较的是栈中的内容,a和b栈中都存放了1所以相等</strong></p><ul><li><strong>比较两个字符串</strong></li></ul><p><img src="/2018/12/11/浅谈Java中-与equals的区别/4.png" height="230" width="380"></p><p>输出结果为:  a==b</p><p><img src="/2018/12/11/浅谈Java中-与equals的区别/5.png" height="230" width="380"></p><p>输出结果为:  a.equals(b)</p><p>&nbsp;&nbsp;<strong>在这个例子中，我们看到==和equals的作用是相同的，a==b说明a和b引用了同一个String对象。a.equsls(b)说明a和b指向的对象在堆中存储的内容相同。即a和b指向同一个对象。为什么会这样呢，因为<font color="red">Stirng对象在创建时，会现在String缓冲池中查看是否有相同的对象，如果有，则不创建。</font></strong></p><ul><li><strong>当再新建一个String对象</strong></li></ul><p><img src="/2018/12/11/浅谈Java中-与equals的区别/6.png" height="300" width="500"></p><p>输出结果为:  a.equals(b) a!=b</p><p>&nbsp;&nbsp;<strong>此时字符串a，b为不同的对象。equals比较的是堆中的内容，a和b堆中内容都是123，所以输出a.equals(b)。而又a，b不是同一个对象。所以a，b的栈中存储的地址不一样，而==又是比较栈中内容所以输出a!=b。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>&nbsp;&nbsp;<strong><font size="4">==比较的是<font color="red">栈中的内容</font>，即两个对象的地址是否为同一个。equals比较的是<font color="red">堆中内容是否相等</font>，即两个对象的内容是否相同。</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello Blog</title>
      <link href="/2018/12/01/hello-blog/"/>
      <url>/2018/12/01/hello-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><a id="more"></a><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>&nbsp;&nbsp;一开始接触Markdown编辑器有些不适应，但是语法学起来不难，上手很快。可能一开始博文的格式会有些不尽人意，希望大家理解。</p><p>&nbsp;&nbsp;前天开始搭的博客，踩了一天的坑。昨天狠下心重新开始建站，长痛不如短痛，果然之前解决不了的评论系统，现在几行代码就完事了,感谢next，感谢开源。</p><p>&nbsp;&nbsp;之前博客的评论系统是用的来比力的，因为来比力实在是太慢了，无奈只能摒弃。昨天发现一个很友好的评论系统———valine，速度快了很多，也方便了许多，希望大家在我的文章下面多多留言评论，别让它成为一个死站了，哈哈。</p><h2 id="愿身后总有力量"><a href="#愿身后总有力量" class="headerlink" title="愿身后总有力量"></a>愿身后总有力量</h2><p>&nbsp;&nbsp;昨天收到了学校一个技术小组的录取通知，两个月的任务考核，最后做后端的只有我审核通过了(虽然也就六个人)，算是给自己的肯定吧。希望以后一切顺利。</p><p>&nbsp;&nbsp;昨天女朋友开始撒起娇来，说我光顾着学习不理她。她真的好可爱，也好懂事，昨夜想了很久，一时也不知道怎么处理好女朋友和生活学习的关系了，只希望她能一直在我身边。</p><p>&nbsp;&nbsp;妈妈昨天给我发了微信，今天早上才想起来回。她说：你是不是光顾着谈恋爱了。哈哈，其实不是的，这两天搭博客，无数次跳坑填坑的，真的忘了回。</p><p>&nbsp;&nbsp;但是，这些都是以后会陪伴我的人，给自己一个警醒吧，以后工作学习之余，一定要多陪陪他们。</p><h2 id="一条路走到黑"><a href="#一条路走到黑" class="headerlink" title="一条路走到黑"></a>一条路走到黑</h2><p>就到这吧。以后加油。</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
