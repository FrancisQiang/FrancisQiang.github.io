<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Francis的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://francisqiang.github.io/"/>
  <updated>2019-06-08T11:48:03.890Z</updated>
  <id>https://francisqiang.github.io/</id>
  
  <author>
    <name>Francis Qiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter组件——ListView和GridView</title>
    <link href="https://francisqiang.github.io/2019/06/08/Flutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94ListView%E5%92%8CGridView/"/>
    <id>https://francisqiang.github.io/2019/06/08/Flutter组件——ListView和GridView/</id>
    <published>2019-06-08T10:45:34.000Z</published>
    <updated>2019-06-08T11:48:03.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ListView组件"><a href="#ListView组件" class="headerlink" title="ListView组件"></a>ListView组件</h2><p>  ListView是可滚动的列表组件，使用的范围非常广。</p><ul><li><h2 id="静态构建ListView"><a href="#静态构建ListView" class="headerlink" title="静态构建ListView"></a>静态构建ListView</h2><p>我们直接使用ListView标准构造函数就可以构建了(只适合列表元素已经确定并且数目比较少的时候)。里面最重要的一个属性就是children，里面接受一个Widget数组，我们可以将需要的放置的组件放入数组里面。</p></li><li><h2 id="动态构造ListView"><a href="#动态构造ListView" class="headerlink" title="动态构造ListView"></a>动态构造ListView</h2><p>ListView的标准构造函数会将所有item一次性创建，而ListView.builder会创建滚动到屏幕上显示的item。</p><p>ListView.builder其实是dart里面的一种可命名构造函数(直接理解为一种构造函数就好了)。还有这两种ListView.separated<br>ListView.custom。</p><p>我们直接来看builder命名构造函数的属性</p><p>首先我们看一下源码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  ListView.builder(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  Axis scrollDirection = Axis.vertical,</span><br><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">  ScrollController controller,</span><br><span class="line">  <span class="built_in">bool</span> primary,</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  <span class="keyword">this</span>.itemExtent,</span><br><span class="line">  <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">  <span class="built_in">int</span> itemCount,</span><br><span class="line">  <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">double</span> cacheExtent,</span><br><span class="line">  <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">  DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span><br><span class="line">&#125;) : childrenDelegate = SliverChildBuilderDelegate(</span><br><span class="line">       itemBuilder,</span><br><span class="line">       childCount: itemCount,</span><br><span class="line">       addAutomaticKeepAlives: addAutomaticKeepAlives,</span><br><span class="line">       addRepaintBoundaries: addRepaintBoundaries,</span><br><span class="line">       addSemanticIndexes: addSemanticIndexes,</span><br><span class="line">     ),</span><br><span class="line">     <span class="keyword">super</span>(</span><br><span class="line">       key: key,</span><br><span class="line">       scrollDirection: scrollDirection,</span><br><span class="line">       reverse: reverse,</span><br><span class="line">       controller: controller,</span><br><span class="line">       primary: primary,</span><br><span class="line">       physics: physics,</span><br><span class="line">       shrinkWrap: shrinkWrap,</span><br><span class="line">       padding: padding,</span><br><span class="line">       cacheExtent: cacheExtent,</span><br><span class="line">       semanticChildCount: semanticChildCount ?? itemCount,</span><br><span class="line">       dragStartBehavior: dragStartBehavior,</span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p>构造函数后面的childrenDelegate和super是初始化列表，先只作了解。</p><ul><li><p>itemBuilder </p><p>这个属性是required的，他需要一个IndexedWidgetBuilder对象,我们查看源码发现他是一个方法，参数是上下文对象BuildContext和index。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> IndexedWidgetBuilder = Widget <span class="built_in">Function</span>(BuildContext context, <span class="built_in">int</span> index);</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>所以这里面我们可以直接传进去一个方法，参数是上下文和index，需要返回一个Widget，我们这里直接可以使用匿名函数加上胖箭头表达式。</code></pre><ul><li><p>itemCount</p><p>这个属性是指定item(元素)的个数</p></li><li><p>scrollDirection</p><p>指定能滑动方向，接受一个Axis，其中可以设置horizontal或者vertical，默认为vertical(垂直方向)。</p></li><li><p>itemExtent</p><p>接受double类型参数，指定每个元素在滑动方向所占的高度值。</p></li><li><p>padding</p><p>设置内边距</p></li></ul><h2 id="GridView组件"><a href="#GridView组件" class="headerlink" title="GridView组件"></a>GridView组件</h2><p>  我们首先看一下GridView常用的count命名构造函数</p>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  GridView.count(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  Axis scrollDirection = Axis.vertical,</span><br><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">  ScrollController controller,</span><br><span class="line">  <span class="built_in">bool</span> primary,</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  <span class="meta">@required</span> <span class="built_in">int</span> crossAxisCount,</span><br><span class="line">  <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">  <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">double</span> cacheExtent,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">  <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">  DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span><br><span class="line">&#125;) : gridDelegate = SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">       crossAxisCount: crossAxisCount,</span><br><span class="line">       mainAxisSpacing: mainAxisSpacing,</span><br><span class="line">       crossAxisSpacing: crossAxisSpacing,</span><br><span class="line">       childAspectRatio: childAspectRatio,</span><br><span class="line">     ),</span><br><span class="line">     childrenDelegate = SliverChildListDelegate(</span><br><span class="line">       children,</span><br><span class="line">       addAutomaticKeepAlives: addAutomaticKeepAlives,</span><br><span class="line">       addRepaintBoundaries: addRepaintBoundaries,</span><br><span class="line">       addSemanticIndexes: addSemanticIndexes,</span><br><span class="line">     ),</span><br><span class="line">     <span class="keyword">super</span>(</span><br><span class="line">       key: key,</span><br><span class="line">       scrollDirection: scrollDirection,</span><br><span class="line">       reverse: reverse,</span><br><span class="line">       controller: controller,</span><br><span class="line">       primary: primary,</span><br><span class="line">       physics: physics,</span><br><span class="line">       shrinkWrap: shrinkWrap,</span><br><span class="line">       padding: padding,</span><br><span class="line">       cacheExtent: cacheExtent,</span><br><span class="line">       semanticChildCount: semanticChildCount ?? children.length,</span><br><span class="line">       dragStartBehavior: dragStartBehavior,</span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p>  其中有很多属性是和ListView的一样的</p><ul><li><p>reverse</p><p>接受bool，是否沿反方向滚动</p></li><li><p>controller</p><p>控制child滚动时候的位置</p></li><li><p>shrinkWrap</p><p>滚动方向的滚动视图内容是否应该由正在查看的内容所决定。</p></li><li><p>primary</p><p>是否是与父节点的PrimaryScrollController所关联的主滚动视图。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ListView组件&quot;&gt;&lt;a href=&quot;#ListView组件&quot; class=&quot;headerlink&quot; title=&quot;ListView组件&quot;&gt;&lt;/a&gt;ListView组件&lt;/h2&gt;&lt;p&gt;  ListView是可滚动的列表组件，使用的范围非常广。&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Flutter" scheme="https://francisqiang.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter组件——Image</title>
    <link href="https://francisqiang.github.io/2019/06/06/Flutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Image/"/>
    <id>https://francisqiang.github.io/2019/06/06/Flutter组件——Image/</id>
    <published>2019-06-06T08:51:45.000Z</published>
    <updated>2019-06-06T09:10:47.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>  Image就是图片组件，其中分为很多中，比如说network(url<br>  获取图片)，asset(本地获取图片)，还有File，Memory。这里我学习了network和asset的。</p><ul><li><h2 id="必须属性"><a href="#必须属性" class="headerlink" title="必须属性"></a>必须属性</h2><p>这里必须属性和Text组件的字符串内容差不多，我们需要加入图片地址，asset需要放入本地地址，network需要放入网络地址。不过在new Image.asset之前，我们需要在yaml文件中注册asset资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  assets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">images/avatar.gif</span></span><br></pre></td></tr></table></figure></li><li><h2 id="width-height"><a href="#width-height" class="headerlink" title="width,height"></a>width,height</h2><p>宽高设置，需要double</p></li><li><h2 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h2><p>排列位置，接受Alignment对象。控制的是图片在图片组件中的位置。</p></li><li><h2 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h2><p>图片充满格式，接受BoxFit对象，可以使用其中已经预定义了一些常量fill(充满)，cover(覆盖)等。</p></li><li><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p>重复，接受ImageRepeat对象，控制的是如果图片没有占满图片组件，那么就重复。</p></li><li><h2 id="color"><a href="#color" class="headerlink" title="color"></a>color</h2><p>与混合模式一起使用，在图片上增加一个颜色层，然后使用混合模式混合，如果不加混合模式，图片就会被颜色给覆盖掉。</p></li><li><h2 id="ColorBlendMode"><a href="#ColorBlendMode" class="headerlink" title="ColorBlendMode"></a>ColorBlendMode</h2><p>接受一个BlendMode，图片混合模式，该对象已经定义好几种混合类型，BlendMode.darken,BlendMode.clear等。</p></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(<span class="string">"images/avatar.gif"</span>,</span><br><span class="line">              width: <span class="number">200.0</span>,</span><br><span class="line">              height: <span class="number">400.0</span>,</span><br><span class="line">              color: Colors.pink,</span><br><span class="line">              colorBlendMode: BlendMode.colorBurn,</span><br><span class="line">              fit: BoxFit.scaleDown,</span><br><span class="line">              alignment: Alignment.bottomCenter,</span><br><span class="line">              repeat: ImageRepeat.repeat,</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Image&quot;&gt;&lt;a href=&quot;#Image&quot; class=&quot;headerlink&quot; title=&quot;Image&quot;&gt;&lt;/a&gt;Image&lt;/h2&gt;&lt;p&gt;  Image就是图片组件，其中分为很多中，比如说network(url&lt;br&gt;  获取图片)，asset(本地获取
      
    
    </summary>
    
      <category term="Flutter" scheme="https://francisqiang.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter组件——Container</title>
    <link href="https://francisqiang.github.io/2019/06/06/Flutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Container/"/>
    <id>https://francisqiang.github.io/2019/06/06/Flutter组件——Container/</id>
    <published>2019-06-06T05:30:45.000Z</published>
    <updated>2019-06-06T05:49:35.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Container组件"><a href="#Container组件" class="headerlink" title="Container组件"></a>Container组件</h2><p>  Container组件是一个非常重要的组件有点类似于html中的div。</p><ul><li><h2 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h2><p>这个是设置子组件的布局的，注意是子组件，它接受一个Alignment对象，我们可以使用Alignment(x, y)来构造它，或者我们也可以使用它已经定义好的几个常量来构造它</p><p><img src="/2019/06/06/Flutter组件——Container/1.jpg" alt="Alignment常量定义"></p></li><li><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>这个是设置内边距的，接受一个EdgeInsetsGeometry, 我们可以将它的子类EdgeInsets对象赋值给它，我们可以使用const EdgeInsets.all(double value)，const EdgeInsets.only等方式声明</p></li><li><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p>它是设置Container的外边距，接受参数和padding一样</p></li><li><h2 id="height，width"><a href="#height，width" class="headerlink" title="height，width"></a>height，width</h2><p>它们是设置宽和高的，里面接受一个double</p></li><li><h2 id="decoration"><a href="#decoration" class="headerlink" title="decoration"></a>decoration</h2><p>绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在decoration中进行颜色的设置。</p><p>其中它接受一个Decoration，我们可以使用它的子类BoxDecoration来赋值给它。</p><p>在BoxDecoration中也有许多参数</p><ul><li><p>color  设置颜色的</p></li><li><p>image  设置背景图片，可以添加一个DecorationImage对象</p></li><li><p>border 设置边，接受一个BoxBorder，我们可以使用Border.all(width: 1.5, style: BorderStyle.solid, color: Colors.deepPurple),这样的发情时来构造它。</p></li><li><p>borderRadius  设置边角的，可以增加弧度，接受一个BorderRadius对象，我们可以使用BorderRadius.all来构造</p></li><li><p>gradient  设置颜色渐变效果，接受一个Gradient对象</p></li></ul></li><li><h2 id="child"><a href="#child" class="headerlink" title="child"></a>child</h2><p>接受一个孩子，孩子里面可以放置子组件</p></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">            alignment: Alignment.bottomCenter,</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">            margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">100.0</span>),</span><br><span class="line">            height: <span class="number">500.0</span>,</span><br><span class="line">            width: <span class="number">200.0</span>,</span><br><span class="line">            decoration: BoxDecoration(</span><br><span class="line">              border: Border.all(width: <span class="number">1.5</span>, style: BorderStyle.solid, color: Colors.deepPurple),</span><br><span class="line">              borderRadius: BorderRadius.circular(<span class="number">1.0</span>),</span><br><span class="line">              gradient: LinearGradient(colors: [</span><br><span class="line">                Colors.deepPurple,</span><br><span class="line">                Colors.deepOrange,</span><br><span class="line">                Colors.pink,</span><br><span class="line">                Colors.greenAccent</span><br><span class="line">              ])</span><br><span class="line">            ),</span><br><span class="line">            child: Image.network(<span class="string">'https://francisqiang.github.io/images/avatar.gif'</span>,</span><br><span class="line">              fit: BoxFit.fitWidth,</span><br><span class="line">              color: Colors.deepOrangeAccent,</span><br><span class="line">              colorBlendMode: BlendMode.darken,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Container组件&quot;&gt;&lt;a href=&quot;#Container组件&quot; class=&quot;headerlink&quot; title=&quot;Container组件&quot;&gt;&lt;/a&gt;Container组件&lt;/h2&gt;&lt;p&gt;  Container组件是一个非常重要的组件有点类似于html中的
      
    
    </summary>
    
      <category term="Flutter" scheme="https://francisqiang.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter组件——Text</title>
    <link href="https://francisqiang.github.io/2019/06/06/Flutter%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Text/"/>
    <id>https://francisqiang.github.io/2019/06/06/Flutter组件——Text/</id>
    <published>2019-06-06T05:22:33.000Z</published>
    <updated>2019-06-06T05:24:51.272Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h2><p>Text中有个默认必须的属性就是字符串了，你需要在一开始设置字符串的内容</p></li><li><h2 id="textAlign"><a href="#textAlign" class="headerlink" title="textAlign"></a>textAlign</h2><p>这个属性主要就是设置字符串的对齐方式的，他接受一个TextAlign对象，这个对象里面有几个常见的枚举比如说left，center，start等。</p></li><li><h2 id="maxLines"><a href="#maxLines" class="headerlink" title="maxLines"></a>maxLines</h2><p>maxLines指的是Text的最大行数，如果超过剩余字符串内容则会被隐藏</p></li><li><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>overflow定义了超出字符串部分内容的显示样式(不太精确，先这么理解)，其中它接受TextOverFlow对象，这个对象设置了几个枚举类型，其中有clip，fade，ellipsis，visible效果，其中ellipsis是用的比较多的</p></li><li><h2 id="textScaleFactor"><a href="#textScaleFactor" class="headerlink" title="textScaleFactor"></a>textScaleFactor</h2><p>这个属性是设置字体大小的，它是根据比例设置，接受的是一个double，如果你设置2.0就是两倍大小，当你设置这个属性的时候就不要设置fontSize了，会有冲突</p></li><li><h2 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h2><p>Text中最重要的就是style属性了，style属性主要设置字体的样式，它接受一个TextStyle对象并且这个对象中还有很多属性，下面是几个常见属性。</p><ul><li><p>color属性</p><p>主要是字体的颜色，里面接受一个Color对象，我们可以使用Colors.dark的形式，因为Colors里面已经内置了很多Color常量，或者使用Color.fromARGB(a, r, g, b)</p></li><li><p>fontSize属性</p><p>字体大小不用多说，接受一个double</p></li><li><p>fontWeight属性</p><p>字体粗度，里面接受一个FontWeight对象，比如FontWeight.w800等</p></li><li><p>decoration属性</p><p>用于下划线类型的装饰，接受一个TextDecoration对象，里面有下划线，上划线等等样式，你还可以设置combine里面接受一个数组，可以把样式都添加进去。</p></li><li><p>decorationStyle属性</p><p>装饰的样式，比如将下划线变成波浪线等等。接受一个TextDecorationStyle对象，里面有solid，double，dashed，wavy，dotted类型的。</p></li><li><p>decorationColor属性</p><p>装饰的颜色，可以设置下划线的颜色，接受一个Color对象</p></li><li><p>backgroundColor属性</p><p>这个属性就是设置字体的背景的颜色，接受一个Color对象</p></li></ul></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyText</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'This is my first page'</span>,</span><br><span class="line">      textAlign: TextAlign.justify,</span><br><span class="line">      maxLines: <span class="number">1</span>,</span><br><span class="line">      overflow: TextOverflow.ellipsis,</span><br><span class="line">      textScaleFactor: <span class="number">1.5</span>,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          fontSize: <span class="number">30.0</span>,</span><br><span class="line">          fontWeight: FontWeight.w800,</span><br><span class="line">          decoration: TextDecoration.combine([</span><br><span class="line">            TextDecoration.lineThrough,</span><br><span class="line">            TextDecoration.underline</span><br><span class="line">          ]),</span><br><span class="line">          decorationStyle: TextDecorationStyle.wavy,</span><br><span class="line">          decorationColor: Colors.lightGreenAccent,</span><br><span class="line">        backgroundColor: Colors.red</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;默认属性&quot;&gt;&lt;a href=&quot;#默认属性&quot; class=&quot;headerlink&quot; title=&quot;默认属性&quot;&gt;&lt;/a&gt;默认属性&lt;/h2&gt;&lt;p&gt;Text中有个默认必须的属性就是字符串了，你需要在一开始设置字符串的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h
      
    
    </summary>
    
      <category term="Flutter" scheme="https://francisqiang.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8新特性——lambda范围和内置功能接口</title>
    <link href="https://francisqiang.github.io/2019/06/05/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94lambda%E8%8C%83%E5%9B%B4%E5%92%8C%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3/"/>
    <id>https://francisqiang.github.io/2019/06/05/Java8新特性——lambda范围和内置功能接口/</id>
    <published>2019-06-05T00:07:50.000Z</published>
    <updated>2019-06-05T07:16:15.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lambda-scopes"><a href="#lambda-scopes" class="headerlink" title="lambda scopes"></a>lambda scopes</h2><p>  在lambda表达式中我们可以访问外部变量，这个功能和匿名内部类一样，但是对于匿名内部类，我们只能访问final变量，lambda表达式中都可以访问，但是它只是隐式地将变量变成了final</p><p>  首先我们能通过lambda表达式来访问外部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    Converter&lt;Integer, String&gt; converter = (from -&gt; String.valueOf(from + num));</span><br><span class="line">    System.out.println(converter.convert(<span class="number">2</span>)); <span class="comment">// 输出3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但是我们不能再改变lambda表达式中调用的外部变量了，因为一旦被lambda表达式调用，这个变量就被隐式地声明成了final变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    Converter&lt;Integer, String&gt; converter = (from -&gt; String.valueOf(from + num));</span><br><span class="line">    System.out.println(converter.convert(<span class="number">2</span>));</span><br><span class="line">    num = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候就会报错 从lambda 表达式引用的本地变量必须是最终变量或实际上的最终变量。</p><p>  还有一个容易混淆的点就是这样的写法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  Converter&lt;Integer, String&gt; converter = String::valueOf;</span><br><span class="line">  System.out.println(converter.convert(<span class="number">2</span> + num));</span><br><span class="line">  num = <span class="number">2</span>;</span><br><span class="line">  System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  即使是对象也是一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">    Converter&lt;StringBuilder, String&gt; converter = (stringBuilder1) -&gt; stringBuilder1.toString();</span><br><span class="line">    System.out.println(converter.convert(stringBuilder));</span><br><span class="line">    stringBuilder.append(<span class="string">"234"</span>);</span><br><span class="line">    System.out.println(stringBuilder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候其实我们只是将num作为函数参数传进去了，在lambda表达式中并没有显示声明调用这个变量。</p><p>  在lambda表达式中我们还可以访问静态和类中的字段</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">  <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">          outerNum = <span class="number">23</span>;</span><br><span class="line">          <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">          outerStaticNum = <span class="number">72</span>;</span><br><span class="line">          <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  还记得上次声明的Formula接口么，其中定义了一个sqrt的默认方法，在lambda中我们是不能调用默认方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>); <span class="comment">//这样编译不通过</span></span><br></pre></td></tr></table></figure><h2 id="Built-in-Functional-Interfaces"><a href="#Built-in-Functional-Interfaces" class="headerlink" title="Built-in Functional Interfaces"></a>Built-in Functional Interfaces</h2><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>  这是断言，判断的意思。先上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><p>  其中test方法就是Predicate接口中的唯一抽象方法，我们lambda表达式中就是实现了它。</p><p>  negate方法是取反的意思，其中还有and(), or()这两个默认方法对应语，或。</p><p>  可以直接看源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of arguments to the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetRef the object reference with which to compare for equality,</span></span><br><span class="line"><span class="comment">     *               which may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>  Function从字面理解就是函数的意思，这也是Java支持函数式编程的一个很重要的函数式接口。我们先看源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function and then applies this function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中apply()是我们需要实现的一个函数，为什么这里说是函数不是方法呢？我们现在用函数式的思想去思考这个问题，其实这个方法就是我们给定一个参数然后我们返回一个结果，具体这个函数是怎么实现我们先不管。这就是函数式思想(先考虑参数和结果，然后再去考虑实现行为)。</p><p>  这是作者给的实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是实现apply方法</span></span><br><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure><p>  这里多出来了个andThen方法，我们来具体看一看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判空</span></span><br><span class="line">  Objects.requireNonNull(after);</span><br><span class="line">  <span class="comment">// 我们传入的是一个Function</span></span><br><span class="line">  <span class="comment">// 该语句是先调用当前Function的apply方法</span></span><br><span class="line">  <span class="comment">// 然后将该方法的返回值作为after(传入的Function)的apply方法中的参数</span></span><br><span class="line">  <span class="comment">// 最终返回的是after的apply方法的返回值</span></span><br><span class="line">  <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  里面还有一个compose方法,其实和andThen方法正好相反</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(before);</span><br><span class="line">  <span class="comment">// 先调用传入的befor的apply方法，然后将返回值作为当前Function的apply的参数</span></span><br><span class="line">  <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>  这个函数很简单，就相当于无参函数，我们不需要设置给定参数，只关注结果</p><p>  具体源码也很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h3 id="Comsumer"><a href="#Comsumer" class="headerlink" title="Comsumer"></a>Comsumer</h3><p>  我们先来看一下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面有一个accept()是我们需要实现的抽象方法，其实就是我们给定一个参数但是我们没有返回值，然后这个andThen()就是传入一个Consumer先调用原来的Consumer的accept方法然后再调用传入的accept()</p><h3 id="Comparators"><a href="#Comparators" class="headerlink" title="Comparators"></a>Comparators</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是实现了compare方法</span></span><br><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line"><span class="comment">// reversed方法是默认方法</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;lambda-scopes&quot;&gt;&lt;a href=&quot;#lambda-scopes&quot; class=&quot;headerlink&quot; title=&quot;lambda scopes&quot;&gt;&lt;/a&gt;lambda scopes&lt;/h2&gt;&lt;p&gt;  在lambda表达式中我们可以访问外部变量，这个
      
    
    </summary>
    
      <category term="Java SE" scheme="https://francisqiang.github.io/categories/Java-SE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8新特性——接口中的static，default方法</title>
    <link href="https://francisqiang.github.io/2019/06/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84static%EF%BC%8Cdefault%E6%96%B9%E6%B3%95/"/>
    <id>https://francisqiang.github.io/2019/06/04/Java8新特性——接口中的static，default方法/</id>
    <published>2019-06-04T05:57:09.000Z</published>
    <updated>2019-06-04T06:40:40.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h2><p> 这些天在看ES6的语法，包括我以前学了一段时间的dart，这两门语言中都涉及到函数式编程，想想我对Java中的函数式编程还是不太了解，最近开始学习Java8的一些新特性，反正语言都差不多，一起学习好了。</p><p> 在java8中新增了default方法，这个方法可以定义在接口中，其实就是在接口中定义了默认方法，这些默认方法可以在接口中就已经实现。</p><p> 我看的是github上的<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="noopener">Java8——tutorial</a>,原文是英文的，其实理解起来不难。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   System.out.println(formula.calculate(<span class="number">5</span>));</span><br><span class="line">   <span class="comment">// 未实现也可以直接使用</span></span><br><span class="line">   System.out.println(formula.sqrt(<span class="number">5</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h2><p>  上面就已经定义了静态方法在接口中，在以往版本是不可以的。我们可以直接通过接口(不需要实现)来调用静态方法，但注意的是实现接口的类或者子接口(是继承不是实现)不会继承接口中的静态方法。</p><h2 id="Lambda-expressions"><a href="#Lambda-expressions" class="headerlink" title="Lambda expressions"></a>Lambda expressions</h2><p>  因为是跟着教程走的，涉及到的知识和教程的差不多，你们可以直接去原网站看。</p><p>  我们可以使用lambda表达式改造上面的静态方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Formula formula = (a) -&gt; a;</span><br><span class="line">  System.out.println(formula.calculate(<span class="number">5</span>));</span><br><span class="line">  System.out.println(formula.sqrt(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  能使用lambda表达式来实现的接口必须只能有一个抽象方法，然后我们写的那个lambda表达式会和原来类型中的抽象方法进行匹配。</p><p>  这是原文(大概意思就是上面的话):</p><p>  How does lambda expressions fit into Java’s type system? Each lambda corresponds to a given type, specified by an interface. A so called functional interface must contain exactly one abstract method declaration. Each lambda expression of that type will be matched to this abstract method. Since default methods are not abstract you’re free to add default methods to your functional interface.</p><p>  然后我们可以在只有一个抽象方法的接口上面声明一个注解@FunctionalInterface来指明这个接口是一个函数接口，当我们尝试添加第二个抽象方法的时候编译器会报错。</p><p>  We can use arbitrary interfaces as lambda expressions as long as the interface only contains one abstract method. To ensure that your interface meet the requirements, you should add the @FunctionalInterface annotation. The compiler is aware of this annotation and throws a compiler error as soon as you try to add a second abstract method declaration to the interface.</p><p>  <img src="/2019/06/04/Java8新特性——接口中的static，default方法/1.jpg" alt="@FunctionalInterface"></p><h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><p>  方法和构造方法引用，Java 8允许您通过::关键字传递方法或构造函数的引用。</p><p>  例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>  我们可以使用::来化简代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueof</span><br><span class="line"><span class="comment">// 可以这么理解本来我们可以将这个实现写成一个lambda表达式，这个表达式其实就是一个函数，我们现在只是要一个函数，然后我们通过方法引用吧方法赋值给它。这个方法必须参数返回值要相同</span></span><br></pre></td></tr></table></figure><p>  当然我们还可以使用某个实例化的对象的方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br></pre></td></tr></table></figure><p>  通过::引用构造器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  String firstName;</span><br><span class="line">  String lastName;</span><br><span class="line"></span><br><span class="line">  Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Person(String firstName, String lastName) &#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通过构造器引用实现接口</span></span><br><span class="line">PersonFactory&lt;Person&gt; pf = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person  = PersonFactory.create(<span class="string">"11"</span>, <span class="string">"22"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;default方法&quot;&gt;&lt;a href=&quot;#default方法&quot; class=&quot;headerlink&quot; title=&quot;default方法&quot;&gt;&lt;/a&gt;default方法&lt;/h2&gt;&lt;p&gt; 这些天在看ES6的语法，包括我以前学了一段时间的dart，这两门语言中都涉及到函数
      
    
    </summary>
    
      <category term="Java SE" scheme="https://francisqiang.github.io/categories/Java-SE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的赋值和参数传递</title>
    <link href="https://francisqiang.github.io/2019/06/04/Java%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <id>https://francisqiang.github.io/2019/06/04/Java中的赋值和参数传递/</id>
    <published>2019-06-04T02:16:02.000Z</published>
    <updated>2019-06-04T02:50:36.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的-赋值"><a href="#Java中的-赋值" class="headerlink" title="Java中的=赋值"></a>Java中的=赋值</h2><p>  一直以来我对于这些都有些模糊，今天来写一篇博客总结一下。</p><p>  在Java中，=赋值对于基本类型可以简单理解为就是直接传值</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">System.out.println(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>  我们可以看出我们把a赋值给b然后对b进行改变的时候a的值还是不会变。</p><p>  所以在基本数据类型中，我们可以简单理解为=为传值。</p><p>  而在对象中的=就不是赋值那么简单了，对于对象的=其实赋值的是对象的地址而不是内容，比如a = a1 ，假设这两个变量是对象，那么我们是将a1的地址赋值给a，那么a的地址就是a1的地址，即他们两共享同一地址，所以如果我们对a进行了操作，其实就是通过地址同时操作a1。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder s1 = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">StringBuilder s2 = s1;</span><br><span class="line">s2.append(<span class="string">"456"</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// 123456</span></span><br><span class="line">System.out.println(s2); <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure><p>  所以我们可以理解对于对象的=赋值的是对象的地址，除非我们再次new一个对象，将这个new的对象的地址重新赋值给s2。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder s1 = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">StringBuilder s2 = s1;</span><br><span class="line">s2.append(<span class="string">"456"</span>);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line">s2 = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">s2.append(<span class="string">"789"</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// 123456 不变</span></span><br><span class="line">System.out.println(s2); <span class="comment">// 123789</span></span><br></pre></td></tr></table></figure><p>  我们可以看出当我们给s2重新赋值一个地址的时候这个时候的s2就与s1无关了，因为他们已经不是共享同一个地址了。</p><h2 id="Java中的方法参数传递"><a href="#Java中的方法参数传递" class="headerlink" title="Java中的方法参数传递"></a>Java中的方法参数传递</h2><p>  我觉得方法参数传递和=赋值差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    stringBuilder.append(<span class="string">"我改变了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"我重新赋值地址了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"初始化"</span>);</span><br><span class="line">    System.out.println(stringBuilder); <span class="comment">//初始化</span></span><br><span class="line">    Test.function1(stringBuilder);</span><br><span class="line">    System.out.println(stringBuilder); <span class="comment">//初始化我改变李</span></span><br><span class="line">    Test.function2(stringBuilder);</span><br><span class="line">    System.out.println(stringBuilder); <span class="comment">//初始化我改变了</span></span><br><span class="line">    <span class="comment">//  这里我们看出function2对stringBuilder对象没有任何改变，是因为</span></span><br><span class="line">    <span class="comment">// 我们传入function2的stringBuilder是一个地址，然后我们又重新将</span></span><br><span class="line">    <span class="comment">// 新的地址赋值给stringBuilder，所以指向了不同的地址 自然就不会有关联了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  总之记住一个就是Java中的参数传递就是按值传递，当我们传入的是一个对象的时候我们传入的是地址，我们传入一个基本类型的时候传入的是一个值，我们也可以简单理解为地址就是对象的值。</p><p>  其实也可以这么理解，基本类型的值在栈中，即栈中的的值，然后对象的地址在栈中，这个地址指向堆中的内容，我们可以简单理解为传值就是传入栈中的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java中的-赋值&quot;&gt;&lt;a href=&quot;#Java中的-赋值&quot; class=&quot;headerlink&quot; title=&quot;Java中的=赋值&quot;&gt;&lt;/a&gt;Java中的=赋值&lt;/h2&gt;&lt;p&gt;  一直以来我对于这些都有些模糊，今天来写一篇博客总结一下。&lt;/p&gt;
&lt;p&gt;  在J
      
    
    </summary>
    
      <category term="Java SE" scheme="https://francisqiang.github.io/categories/Java-SE/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构——Trie</title>
    <link href="https://francisqiang.github.io/2019/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Trie/"/>
    <id>https://francisqiang.github.io/2019/06/03/数据结构——Trie/</id>
    <published>2019-06-03T12:56:57.000Z</published>
    <updated>2019-06-03T13:40:48.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Trie"><a href="#什么是Trie" class="headerlink" title="什么是Trie"></a>什么是Trie</h2><p>  Trie是字典树，前缀树。Trie的思想就是使用空间换时间，它是一种专门致力于字符串查询的树，因为它的子节点是所有包含的字符，所以它是一个多叉树(使用空间大)，当我们对一个字符串进行查询的时候它的时间复杂度是O(字符串长度)，所以当个字符串集合非常大的时候是不影响Trie的性能的。</p><p>  这是Trie的基本结构，里面存放了see，dog，pain，pand</p><p>  <img src="/2019/06/03/数据结构——Trie/1.jpg" alt="Trie"></p><h2 id="在Trie中添加单词"><a href="#在Trie中添加单词" class="headerlink" title="在Trie中添加单词"></a>在Trie中添加单词</h2><p>  因为Trie是专门对字符串进行操作的，这里我们选择对Trie中添加一个单词。</p><p>  主要思路就是:我们对需要添加的单词进行for循环取出每个字符，然后我们同时在树中进行遍历，比如我们取出第一个字符是a，那我们就在根节点的next(这里是一个map存放着所有的子节点)中查找是否有a这样的节点，如果没有我们就创建，如果有我们进入这个结点继续后面的操作，比如下一个字符是p。。。</p><p>  java代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义每个结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> word;</span><br><span class="line">  <span class="comment">//该结点存放子节点的map</span></span><br><span class="line">  <span class="keyword">private</span> TreeMap&lt;Character, Node&gt; next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.word = word;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = <span class="keyword">new</span> Node();</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将根结点作为当前节点</span></span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="comment">//获取该位置的字符</span></span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="comment">//判断是否有该字符的节点，没有则创建</span></span><br><span class="line">    <span class="comment">//有则继续遍历</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentNode.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果遍历到最后不是个单词那么将它标志位单词</span></span><br><span class="line">  <span class="keyword">if</span> (!currentNode.word)&#123;</span><br><span class="line">    currentNode.word = <span class="keyword">true</span>;</span><br><span class="line">    size++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Trie中查找单词"><a href="#在Trie中查找单词" class="headerlink" title="在Trie中查找单词"></a>在Trie中查找单词</h2><p>  基本思路：</p><p>  对于查找其实就是遍历这个单词字符串然后在Trie中进行遍历，如果符合则继续遍历，不符合就直接return false。如果遍历到最后，我们就查看最后那个节点的单词标志是不是true如果是那么就return true。</p><p>  java代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span> <span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="comment">//如果一个不符合直接false</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//符合继续遍历</span></span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断最后节点是不是单词</span></span><br><span class="line">  <span class="keyword">return</span> currentNode.word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Trie中进行前缀查询"><a href="#在Trie中进行前缀查询" class="headerlink" title="在Trie中进行前缀查询"></a>在Trie中进行前缀查询</h2><p>  基本思路：</p><p>  对于前缀查询其实跟查找差不多，只是我们不需要判断最后一个节点是不是单词了，因为这里只是判断前缀。</p><p>  java代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prefix</span> <span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历到最后直接true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Trie进行模式匹配"><a href="#在Trie进行模式匹配" class="headerlink" title="在Trie进行模式匹配"></a>在Trie进行模式匹配</h2><p>  其实是一个LeetCode题目</p><p>  <img src="/2019/06/03/数据结构——Trie/2.jpg" alt="leetcode"></p><p>  解题思路：</p><p>  主要就是要解决这个.的匹配问题，这里我们使用递归。当我们搜索一个字符串是否存在的时候(包括.的字符串)，我们首先定义一个递归函数，参数为当前查找的node，字符串，当前字符的索引，返回是boolean。</p><p>  我们递归函数的最根本条件就是当index等于这个查询的字符串的长度的时候我们就返回当前节点是否是单词的标志。</p><p>  但我们进行查找的时候我们现在root的node中执行该函数，然后我们字符索引是0，获取到第一个字符，我们首先要判断这个字符是不是等于.,如果不等于，我们判断当前节点的next中是否有当前字符的node如果没有直接返回false，如果有那继续递归到当前节点的next.get(当前字符)的节点，索引是index + 1。</p><p>  如果是. 那么我们就对这个node.next的key进行遍历，并且在遍历中调用递归函数，写法跟上面差不多</p><p>  具体代码实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> word;</span><br><span class="line">  <span class="keyword">private</span> TreeMap&lt;Character, Node&gt; next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.word = word;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = <span class="keyword">new</span> Node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a word into the data structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentNode.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  currentNode.word = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns if the word is in the data structure. A word could contain the dot character '.' to</span></span><br><span class="line"><span class="comment"> * represent any one letter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> match(root, word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Node node, String word, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.word;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line">  <span class="keyword">if</span> (c != <span class="string">'.'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match(node.next.get(c), word, index + <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> nextChar:node.next.keySet()) &#123;</span><br><span class="line">      <span class="comment">// 每个key都进行递归，匹配上了交给下一个节点</span></span><br><span class="line">      <span class="keyword">if</span> (match(node.next.get(nextChar), word, index + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果整个for循环结束都没有成功那就是都没匹配上 直接false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode中的键值映射题目"><a href="#LeetCode中的键值映射题目" class="headerlink" title="LeetCode中的键值映射题目"></a>LeetCode中的键值映射题目</h2><p>  <img src="/2019/06/03/数据结构——Trie/3.jpg" alt="LeetCode"></p><p>  解题思路：</p><p>  其实前面查找都差不多，主要就是我们对这个进行前缀查找之后到了最后那个节点的时候我们需要对后面所有单词的value进行相加最终返回。</p><p>  我们这里可以使用递归，比如我们已经进行前缀查询并且到了前缀查找字符的最后一个字符，我们书写一个sum递归函数，目的是计算符合这个前缀的单词的value的总和，其实就是获取都前缀最后节点的字数所形成的所有单词的value和。</p><p>  这个递归函数的参数只有一个Node，这个node就是前缀遍历到最后的节点。然后我们的根本条件就是node的next的size为0的时候也就是最后没有字符(结尾)的时候直接返回该结点的value，然后我们定义一个result，每次result都对当前节点的value进行+=操作，然后我们对next的key进行遍历，在遍历中进行递归调用，递归到node为当前node.next.get(遍历到的key)</p><p>  具体代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">private</span> TreeMap&lt;Character, Node&gt; next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = <span class="keyword">new</span> Node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = key.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentNode.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  currentNode.value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">  Node currentNode = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (currentNode.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next.get(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum(currentNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.next.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> result = node.value;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c: node.next.keySet()) &#123;</span><br><span class="line">    result += sum(node.next.get(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Trie&quot;&gt;&lt;a href=&quot;#什么是Trie&quot; class=&quot;headerlink&quot; title=&quot;什么是Trie&quot;&gt;&lt;/a&gt;什么是Trie&lt;/h2&gt;&lt;p&gt;  Trie是字典树，前缀树。Trie的思想就是使用空间换时间，它是一种专门致力于字符串查询的树，因
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——Prototype模式</title>
    <link href="https://francisqiang.github.io/2019/06/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Prototype%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/06/03/设计模式——Prototype模式/</id>
    <published>2019-06-03T02:14:45.000Z</published>
    <updated>2019-06-03T03:36:45.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Prototype模式"><a href="#什么是Prototype模式" class="headerlink" title="什么是Prototype模式"></a>什么是Prototype模式</h2><p>  Prototype模式(原型模式)指的就是使用对象去制造新的对象，不像单例模式只制造出一个对象，原型模式制造的对象是多个的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p><h2 id="实现Prototype模式"><a href="#实现Prototype模式" class="headerlink" title="实现Prototype模式"></a>实现Prototype模式</h2><p>  原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：</p><ul><li><p>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</p></li><li><p>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is Circle"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is rectangle"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Shape&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String string, Shape shape)</span></span>&#123;</span><br><span class="line">    map.put(string, shape);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">get</span><span class="params">(String string)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Shape shape = map.get(string);</span><br><span class="line">    <span class="comment">//这里是核心我们获取到这个对象之后使用clone方法</span></span><br><span class="line">    <span class="keyword">return</span> (Shape) shape.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    ShapeMap shapeMap = <span class="keyword">new</span> ShapeMap();</span><br><span class="line">    Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">    Shape rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">    shapeMap.register(<span class="string">"circle"</span>, circle);</span><br><span class="line">    shapeMap.register(<span class="string">"rectangle"</span>, rectangle);</span><br><span class="line">    Shape circleClone = shapeMap.get(<span class="string">"circle"</span>);</span><br><span class="line">    Shape rectangleClone = shapeMap.get(<span class="string">"rectangle"</span>);</span><br><span class="line">    circleClone.draw();</span><br><span class="line">    rectangleClone.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后输出打印</p><p>  this is Circle</p><p>  this is rectangle</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Prototype模式&quot;&gt;&lt;a href=&quot;#什么是Prototype模式&quot; class=&quot;headerlink&quot; title=&quot;什么是Prototype模式&quot;&gt;&lt;/a&gt;什么是Prototype模式&lt;/h2&gt;&lt;p&gt;  Prototype模式(原型模式)指的就
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6学习——day02</title>
    <link href="https://francisqiang.github.io/2019/06/02/ES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day02/"/>
    <id>https://francisqiang.github.io/2019/06/02/ES6学习——day02/</id>
    <published>2019-06-02T11:24:15.000Z</published>
    <updated>2019-06-02T12:03:38.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>  这个参数默认值有些像Java里面注解的默认值，跟dart语言中的默认值有着神似之处，要不然怎么说dart和js很像呢。</p><p>  先上代码吧</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y = <span class="string">'world'</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    test(<span class="string">'hello'</span>); <span class="comment">//打印出来 hello world,当然也可以对y赋值进行更改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">'test'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">x, y = x</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    test2(<span class="string">'kill'</span>); <span class="comment">//输出kill kill 可见x的值为kill</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>  rest参数就是… , 应用场景就是在参数数量可变或者不可预知的时候使用的，这时候…后面的形参会被变成数组传进函数，跟java的…差不多，只是java里面是这样的(java8新特性)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">        <span class="comment">//打印出参数i</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  js代码是这样的</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//rest参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//将输入的参数都转为数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arg)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'rest'</span>,v);<span class="comment">//a b c</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  test3(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将数组转成离散的值</span></span><br><span class="line">  <span class="built_in">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]);<span class="comment">//1 2 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>,...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]);<span class="comment">//a 1 2 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p>  其实就是某个函数的最后一步再调用另一个函数，使用递归函数就经常会有尾递归的情况</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//尾调用：函数的最后一句话是不是函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tail</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'tail'</span>,x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fx</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tail(x);</span><br><span class="line">  &#125;</span><br><span class="line">  fx(<span class="number">123</span>);<span class="comment">//tail 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>  一个革命性的新特性，向着函数式编程挺进。在java里面有lambda表达式(-&gt;)，dart中跟js一样是=&gt;，就叫它胖箭头吧。。。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里的arrow其实就是一个函数</span></span><br><span class="line">    <span class="keyword">let</span> arrow = <span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arrow(<span class="number">3</span>));  <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">let</span> arrow2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h3><p>  这是一个概念性的问题，在没有箭头函数的函数里面，this就是代表调用这个函数的对象，所以当一个函数中调用另一个函数的时候this可能会发生变化。但是在箭头函数中，this是代表调用这个(箭头函数的函数)的对象，所以箭头函数会是this不变化，不是绝对的具体看情况。</p><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>  这里的对象是指Object</p><h3 id="简洁表达式"><a href="#简洁表达式" class="headerlink" title="简洁表达式"></a>简洁表达式</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> o = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">let</span> k = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">let</span> es5 = &#123;</span><br><span class="line">     o: o,</span><br><span class="line">     K: k</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> es6 = &#123;</span><br><span class="line">     o,</span><br><span class="line">     k</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> es5_mrthod=&#123;</span><br><span class="line">   hello:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> es6_method=&#123;</span><br><span class="line">     hello()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性表达式</span></span><br><span class="line"><span class="keyword">let</span> a=<span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">let</span> es5_obj=&#123;</span><br><span class="line">    a: <span class="string">'c'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> es6_obj=&#123;</span><br><span class="line">    [a]:<span class="string">'c'</span> <span class="comment">//这里的a是变量，即b</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es5_obj,es6_obj);</span><br></pre></td></tr></table></figure><h3 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'字符串'</span>,<span class="built_in">Object</span>.is(<span class="string">'abc'</span>,<span class="string">'abc'</span>));<span class="comment">//true 相当于===</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'数组'</span>,<span class="built_in">Object</span>.is([],[]),[]===[]);<span class="comment">//false false 引用地址不同</span></span><br></pre></td></tr></table></figure><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><p>语法：Object.assign(target, …sources); 返回拷贝后的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = <span class="built_in">Object</span>.assign(&#123;<span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">5</span>&#125;, object1);</span><br><span class="line"><span class="built_in">console</span>.log(object2.c, object2.d);</span><br><span class="line"><span class="comment">// expected output: 3 5</span></span><br></pre></td></tr></table></figure><h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;<span class="attr">k</span>:<span class="number">123</span>,<span class="attr">o</span>:<span class="number">456</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(test))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数扩展&quot;&gt;&lt;a href=&quot;#函数扩展&quot; class=&quot;headerlink&quot; title=&quot;函数扩展&quot;&gt;&lt;/a&gt;函数扩展&lt;/h2&gt;&lt;h3 id=&quot;参数默认值&quot;&gt;&lt;a href=&quot;#参数默认值&quot; class=&quot;headerlink&quot; title=&quot;参数默认值&quot;&gt;
      
    
    </summary>
    
      <category term="ES6" scheme="https://francisqiang.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6学习——day01</title>
    <link href="https://francisqiang.github.io/2019/06/01/ES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day01/"/>
    <id>https://francisqiang.github.io/2019/06/01/ES6学习——day01/</id>
    <published>2019-06-01T02:14:53.000Z</published>
    <updated>2019-06-01T03:17:22.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>  前段时间学习的mysql到现在还停留在day1阶段，现在就突然学es6。其实我是这么想的 因为这段时间在帮老师弄前端项目，用的JQuery。我想着这东西比较老，然后想用vue逐渐替换掉(做一次尝试吧)，学完vue发现还需要es6的基础，所以看了一下es6语法，并不是很难而且为我写js提供了更好地方法。那就学吧。。。</p><h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><p>  其实学习es6并不打算一个代码一个代码敲过来，可能眼高手低吧。我先学着反正也要项目中使用es6，那我项目中使用多练练吧。</p><p>  在let 和 const之前我们都使用的是var声明变量。这里无非就是作用域的不同，let的作用域是块作用域简单来说就是大括号括起来的部分，而var是函数作用域，如果在全局声明那就全局的。然后let 不准重复声明，又因为es6强制开启了严格模式，所以变量不准在未声明之前引用，不然会报引用错误。</p><p>  而const就是常量，常量是不准重新赋值且声明时必须赋值。有个特殊一点的就是对象常量，对象常量里面的字段都是可以修改的，也许你认为这违反了常量，其实不是(有点像C++里面的常量指针)，在es6中常量对象意味着这个对象引用的地址是不改变的(因为对象是引用类型，所以值其实是地址)，但是里面的内容是可以改变的。这在我学习vuex全局变量的时候看到别人使用const定义全局的变量就很不解，原来是因为他们定义的是全局对象变量。</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>  什么是解构赋值，它有很多分类，数组解构赋值(左右都是数组),对象解构赋值(左右都是对象),字符串解构赋值(左数组，右字符串)，布尔解构赋值，函数参数解构赋值(数组解构赋值在函数上的引用)，数值解构赋值</p><p>  数组解构赋值和对象解构赋值使用的比较多。</p><p>  数组解构赋值例子，在要对数组成员进行变量赋值的时候，尽量使用解构赋值</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个打印出来的ab就是1和2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a,b,rest</span><br><span class="line">  [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a,b,rest</span><br><span class="line">  [a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, rest);</span><br><span class="line">  <span class="comment">//打印结果ab还是1 2 但是rest是[3, 4, 5]数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认值</span></span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, b  = <span class="number">3</span>] = [<span class="number">1</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="comment">//结果是a为1 b为3  </span></span><br><span class="line">  <span class="comment">//如果b为赋值那么就是undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个变量交换</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">  [a, b] = [b, a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取函数返回值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, b] = f()</span><br><span class="line">  <span class="comment">//ab则为12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择型获取</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, , , b] = f()</span><br><span class="line">  <span class="comment">//这时候 a为1  b为6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对象解构赋值例子</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//对象解构赋值</span></span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  (&#123;a, b&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="comment">//a为1b为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> &#123;p, q&#125; = o</span><br><span class="line">  <span class="built_in">console</span>.log(p, q)</span><br><span class="line">  <span class="comment">//这里的p为42 ，q为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用场景</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    title: <span class="string">'abc'</span>,</span><br><span class="line">    test: [&#123;</span><br><span class="line">      title: <span class="string">'test'</span>,</span><br><span class="line">      desc: <span class="string">'description'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> &#123;<span class="attr">title</span>: esTitle, <span class="attr">test</span>: [&#123;<span class="attr">title</span>: testTitle&#125;]&#125; = jsonData</span><br><span class="line">  <span class="built_in">console</span>.log(esTitle, testTitle)</span><br><span class="line">  <span class="comment">//这时候esTitle获取到的就是bc testTitle获取到的就是test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><p>  其实就是对数组的api进行扩展了。</p><ul><li>Array.of()方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arr'</span>, arr)     <span class="comment">//[3, 4, 5, 5, 3]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arr'</span>,<span class="built_in">Array</span>.of())   <span class="comment">//[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Array.from()方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">let</span> pArr=<span class="built_in">Array</span>.from(p); <span class="comment">//将上面的集合转义成数组</span></span><br><span class="line">pArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item.textContent);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;<span class="keyword">return</span>   item + <span class="number">2</span>;&#125;));<span class="comment">//3 5 7</span></span><br></pre></td></tr></table></figure><ul><li>填充数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'fill-7'</span>,[<span class="number">1</span>,<span class="string">'a'</span>,<span class="literal">undefined</span>].fill(<span class="number">7</span>));<span class="comment">//[7,7,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fill,pos'</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>));<span class="comment">//["a", 7, 7, "d", "e"] 1和3表示起始和截至位置，不包括位置3</span></span><br></pre></td></tr></table></figure><ul><li>获取索引和值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'keys'</span>,index);<span class="comment">//0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'values'</span>,value);<span class="comment">//1 c ks</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index,value] <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">//[4,2,3,4,5] （从0开始替换，从3开始读取，也就是第一个读取的数是4，4是截至位置，也就是在位置4之前，因此只取4）</span></span><br></pre></td></tr></table></figure><ul><li>查找和判断包含</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">3</span>;<span class="comment">//4，只找第一个</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">3</span>;<span class="comment">//3</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'number'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'number'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h2&gt;&lt;p&gt;  前段时间学习的mysql到现在还停留在day1阶段，现在就突然学es6。其实我是这么想的 因为这段时间在帮老师弄前端项目，用的JQuer
      
    
    </summary>
    
      <category term="ES6" scheme="https://francisqiang.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——模板方法模式</title>
    <link href="https://francisqiang.github.io/2019/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/30/设计模式——模板方法模式/</id>
    <published>2019-05-30T15:11:45.000Z</published>
    <updated>2019-05-30T15:36:14.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h2><p>  Template Method模式，我的理解就是它是一种抽象类实现方法的一种升级版的设计模式。所谓模板就是将某一种工序流程方法抽象成一个统一的模板，比如说我有一个绘画的模板，我们可以选择任何一种画笔，比如我使用红笔画这个模板画出来的就是红色的，我用蜡笔那就蜡笔画出来的画。</p><h2 id="模板方法的实现"><a href="#模板方法的实现" class="headerlink" title="模板方法的实现"></a>模板方法的实现</h2><p>  比如这时候我们有一个流程，流程中需要调用几个工序，这几个工序的顺序是不变的，但是具体的工序是会变化的。这时候我们就可以使用模板方法模式了。</p><p>  首先，我们先定义一个抽象类，这个抽象类里面有具体的模板方法和几个工序方法，工序方法是抽象方法(这个就需要子类去实现具体方法)，模板方法里需要调用这几个方法比如说先是工序1然后是工序2最后是工序4。</p><p>  当我们需要具体实现的时候，我们需要加一个类继承于这个抽象类并且实现它的抽象方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>  这里我就直接使用vs在md文件里手敲了，比较简单但最重要的是思想。</p><p>  首先是抽象类AbstractProcess</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        workOrder1();</span><br><span class="line">        workOrder2();</span><br><span class="line">        workOrder4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后是实现类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakePencilProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcess</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MakePencilProcess</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil first"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil second"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil third"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后是客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//里氏替换原则，更加灵活</span></span><br><span class="line">        AbstractProcess abstractProcess = <span class="keyword">new</span> MakePencilProcess();</span><br><span class="line">        abstractProcess.processTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  这两天在看vue，突然有好多要学的现在有点不知所措，期末，练车，数据结构，设计模式，Java项目，大创，前端项目，vue，六级考试，操作系统实验。。。感觉自己野心有点太大了，慢慢来吧，不能太急。</p><p>  这几天突然意识到自己缺少了很多生活的记忆，尤其是前几天肝项目的时候，让我回忆那几天生活里干了啥我已经记不清了，我觉得我不能成为那样的呆子，那不是我，那也是我以前不想成为的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是模板方法模式&quot;&gt;&lt;a href=&quot;#什么是模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;什么是模板方法模式&quot;&gt;&lt;/a&gt;什么是模板方法模式&lt;/h2&gt;&lt;p&gt;  Template Method模式，我的理解就是它是一种抽象类实现方法的一种升级
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——适配器模式</title>
    <link href="https://francisqiang.github.io/2019/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/29/设计模式——适配器模式/</id>
    <published>2019-05-29T12:31:26.000Z</published>
    <updated>2019-05-29T15:25:57.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h2><p>  简单来说，适配器就是用来填补实际情况和需求两者之间地差异。比如说我们需要5V电压，但是国内只给的是220V电压，那我们现在就需要一个适配器帮我们将电压转换。</p><h2 id="通过继承方式实现适配器模式"><a href="#通过继承方式实现适配器模式" class="headerlink" title="通过继承方式实现适配器模式"></a>通过继承方式实现适配器模式</h2><p>  Adapter模式，比如我们有一个原本的类A，A中有一个a方法，这时候我们有一个B类需要A中的a方法，但是它不能直接调用(因为某个原因不匹配，但是B确实需要a方法)，这时候我们可以通过一个C适配器类来包装A类的a方法，我们需要做的就是让C继承A类拥有A类的a方法，然后我们再让C实现B接口(B是一个接口),B类有一个方法时b方法(b方法可以理解为将来需要将a封装或者使用a方法的方法),这时候C适配器就重写了B接口的b方法，当我们B接口需要使用b方法的时候我们new一个C适配器类就行了(拿C实现B接口)。</p><p>  示例代码：</p><p>  我们有一个Banner类，Banner类中有showWithParen，showWithAster方法，这两个方法分别是在使用括号括住字符串和使用两个*包住字符串。然后我们有一个Print接口，这个接口有weakPrint和strongPrint方法，其实这两个方法需要使用showWithParen，showWithAster方法，所以我们可以添加一个适配器，让这个适配器作为Print的实现类，我们在适配器中继承Banner并调用Banner中的showWithParen，showWithAster方法，然后在封装这两个方法成为Print接口需要使用的方法就行了。</p><p>  Banner类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.string = string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.string = string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"("</span> + string + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"*"</span> + string + <span class="string">"*"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Print接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrintBanner适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    showWithParen();</span><br><span class="line">    System.out.println(<span class="string">"weak"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    showWithAster();</span><br><span class="line">    System.out.println(<span class="string">"strong"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Print print = <span class="keyword">new</span> PrintBanner(<span class="string">"12345"</span>);</span><br><span class="line">    print.weakPrint();</span><br><span class="line">    print.strongPrint();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用委托方式实现适配器模式"><a href="#使用委托方式实现适配器模式" class="headerlink" title="使用委托方式实现适配器模式"></a>使用委托方式实现适配器模式</h2><p>  其实使用委托的方法就是改动一下适配器类，使适配器不是继承原来的类而是拥有原来的类，将是一个变为有一个在面向对象里会有很多好处。这貌似是Java编程思想里看到的，，，我也忘了。</p><p>  这时候我们需要改动一下适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Banner banner;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.banner = <span class="keyword">new</span> Banner(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    banner.showWithParen();</span><br><span class="line">    System.out.println(<span class="string">"weak"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    banner.showWithAster();</span><br><span class="line">    System.out.println(<span class="string">"strong"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是适配器模式&quot;&gt;&lt;a href=&quot;#什么是适配器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是适配器模式&quot;&gt;&lt;/a&gt;什么是适配器模式&lt;/h2&gt;&lt;p&gt;  简单来说，适配器就是用来填补实际情况和需求两者之间地差异。比如说我们需要5V电压，但是国
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——迭代器模式</title>
    <link href="https://francisqiang.github.io/2019/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/27/设计模式——迭代器模式/</id>
    <published>2019-05-27T02:06:40.000Z</published>
    <updated>2019-05-27T03:00:03.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h2><p>  当我们进行数组遍历的时候需要for循环i一直到arr.length，当我们使用迭代器模式的时候我们只需要生成当前数组的具体迭代器(实现迭代器接口),然后通过这个迭代器遍历就行。</p><h2 id="迭代器UML图及角色介绍"><a href="#迭代器UML图及角色介绍" class="headerlink" title="迭代器UML图及角色介绍"></a>迭代器UML图及角色介绍</h2><p>   <img src="/2019/05/27/设计模式——迭代器模式/1.jpg" alt="迭代器模式"></p><h3 id="Aggregate接口"><a href="#Aggregate接口" class="headerlink" title="Aggregate接口"></a>Aggregate接口</h3><p>  Aggregate是所有需要通过迭代器遍历的集合的接口。所有需要通过迭代器遍历集合的都需要实现这个Aggregate接口，Aggregate本身有聚集集合的意思，这里我们就叫它有迭代器实现的集合接口吧。</p><p>  其中相关Aggregate接口的代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里实现了一个迭代器，需要实现迭代器的集合都必须实现这个方法，这个方法的目的是返回该集合的具体迭代器。</span></span><br><span class="line">  <span class="function">Interator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcreteAggregate实现类"><a href="#ConcreteAggregate实现类" class="headerlink" title="ConcreteAggregate实现类"></a>ConcreteAggregate实现类</h3><p>  ConcreteAggregate实现了Aggregate接口，可以说是具体的实现类，比如说这个类是一个CardList(里面存放了card元素)，里面会有相关的card字段以及获取某个元素，获取长度等等有关集合数组的操作。最重要的是它需要实现iterator方法。</p><p>  其中相关ConcreteAggregate实现类的代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iteratot</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>  Iterator和Aggregate接口的关系就是，Aggregate接口中有产生Iterator的iterator方法，也就是Aggregate接口的具体实现类ConcreteAggregate产生出Iterator具体实现类ConcreteIterator。</p><p>  其中Iterator中有两个方法，分别是hasNext(),next()。hasNext的作用是判断迭代器是否还有下一个元素，如果有返回true否则false。next()的作用是返回当前集合迭代到的元素并将指针移向一下个元素(注意这里是两个作用)。</p><p>  所以有了迭代器我们遍历一个集合是这样的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于产生cardList的迭代器</span></span><br><span class="line"><span class="comment">//这个方法这里还是不可以用的，为了现在介绍迭代器迭代代码，如果要实现必须要有一个具体ConcreteIterator实现类</span></span><br><span class="line">Iteratot iterator = cardList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Card card = (Card)iterator.next();</span><br><span class="line">    <span class="comment">//.......进行相关操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  具体Iterator接口的实现代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcreteIterator实现类"><a href="#ConcreteIterator实现类" class="headerlink" title="ConcreteIterator实现类"></a>ConcreteIterator实现类</h3><p>  ConcreteIterator实现了Iterator接口，比如我们这里实现的是CardList的Iterator，我们可以这样写</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CardList cardList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CardListIterator</span><span class="params">(CardList catdList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardList = cardList;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; cardList.getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Card card = CardList.get(index);</span><br><span class="line">        index ++ ;</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器模式的作用"><a href="#迭代器模式的作用" class="headerlink" title="迭代器模式的作用"></a>迭代器模式的作用</h2><p>  为什么要考虑引入Iterator模式呢？直接for循环不就好了，其实迭代器模式有一个好处就是分离，将遍历和实现分开来，在我们调用如下代码的时候</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Card card = (Card)iterator.next();</span><br><span class="line">    <span class="comment">//.......进行相关操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个遍历并没有依赖于cardList，所以当我们这个cardList切换了数据结构的时候我们不需要将原来代码的for循环再依次改动了，我们只需要修改这个相关的iterator的具体实现类其中的hasNext()方法和next()方法就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是迭代器模式&quot;&gt;&lt;a href=&quot;#什么是迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代器模式&quot;&gt;&lt;/a&gt;什么是迭代器模式&lt;/h2&gt;&lt;p&gt;  当我们进行数组遍历的时候需要for循环i一直到arr.length，当我们使用迭代器模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql基础学习——day1</title>
    <link href="https://francisqiang.github.io/2019/05/23/Mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day1/"/>
    <id>https://francisqiang.github.io/2019/05/23/Mysql基础学习——day1/</id>
    <published>2019-05-23T15:02:34.000Z</published>
    <updated>2019-05-23T15:47:32.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql的数据类型"><a href="#Mysql的数据类型" class="headerlink" title="Mysql的数据类型"></a>Mysql的数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ol><li>TINYINT</li><li>SMALLINT</li><li>MEDIUMINT</li><li>INT</li><li><p>BIGINT</p><p>这五个从小往大，可以对对应字段设置有无符号位。</p><p><img src="/2019/05/23/Mysql基础学习——day1/1.jpg" alt="整型"></p></li></ol><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ol><li>FLOAT 单精度</li><li><p>DOUBLE 双精度</p><p><img src="/2019/05/23/Mysql基础学习——day1/2.jpg" alt="浮点型"></p></li></ol><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ol><li>YEAR</li><li>TIME</li><li>DATE</li><li>DATETIME</li><li><p>TIMESTAMP</p><p>DATE范围：  1000/1/1~9999/12/31</p><p>DATETIME范围：  1000/1/1/0:00:00~9999/12/31/23:59:59</p><p>TIMESTAMP范围：  1970/1/1~2037/12/31</p><p>TIME范围：  -8385959~8385959</p><p>YEAR范围：  可存储俩位或者四位 默认四位，可以是1970~2069</p></li></ol><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ol><li>CHAR</li><li>VARCHAR</li><li>TINYTEXT</li><li>TEXT</li><li>MEDIUMTEXT</li><li>LONGTEXT</li><li>ENUM</li><li><p>SET</p><p><img src="/2019/05/23/Mysql基础学习——day1/3.jpg" alt="字符类型"></p></li></ol><h2 id="Mysql的约束"><a href="#Mysql的约束" class="headerlink" title="Mysql的约束"></a>Mysql的约束</h2><h3 id="五种约束"><a href="#五种约束" class="headerlink" title="五种约束"></a>五种约束</h3><pre><code>NOT NULL（非空约束）PRIMARY  KEY (主键约束)UNIQUE  KEY （唯一约束）DEFAULT  (默认约束)FOREIGN  KEY (外键约束)</code></pre><h3 id="外键约束的条件"><a href="#外键约束的条件" class="headerlink" title="外键约束的条件"></a>外键约束的条件</h3><ol><li><p>父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。</p></li><li><p>数据表的存储引擎只能为InnoDB。</p></li><li><p>外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。</p></li><li><p>外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。</p></li></ol><h3 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h3><ol><li><p>CASCADE:从父表删除或更新且自动删除或更新子表中匹配的行。</p></li><li><p>SET NULL:从父表删除或更新行，并设置子表中的外键列为NULL。</p></li><li><p>RESTRICT:拒绝对父表的删除或更新操作。</p></li><li><p>NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。</p><p>CASCADE的删除案例：（子表中外键列添加ON DELETE CASCADE，父表进行删除时，子表也进行相应删除）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mysql的数据类型&quot;&gt;&lt;a href=&quot;#Mysql的数据类型&quot; class=&quot;headerlink&quot; title=&quot;Mysql的数据类型&quot;&gt;&lt;/a&gt;Mysql的数据类型&lt;/h2&gt;&lt;h3 id=&quot;整型&quot;&gt;&lt;a href=&quot;#整型&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Mysql" scheme="https://francisqiang.github.io/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——观察者模式</title>
    <link href="https://francisqiang.github.io/2019/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/23/设计模式——观察者模式/</id>
    <published>2019-05-23T10:29:21.000Z</published>
    <updated>2019-05-23T11:37:53.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h2><p>  观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>  <img src="/2019/05/23/设计模式——观察者模式/1.jpg" alt="观察者模式结构图"></p><p>  在观察者模式中有如下角色：</p><ul><li><p>Subject：</p><p>抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p></li><li><p>ConcreteSubject：</p><p>具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p></li><li><p>Observer：</p><p>抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p></li><li><p>ConcrereObserver：</p><p>具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p></li></ul><h2 id="简单实现观察者模式"><a href="#简单实现观察者模式" class="headerlink" title="简单实现观察者模式"></a>简单实现观察者模式</h2><p>  这里我们简单实现一下观察者模式，首先我们定义一个被观察者的接口Subject，然后我们再定义一个观察者的接口Observer</p><p>  其中Subject中有三个方法，attach()用来增加用户的，detach()用来移除用户的，notify()用来提醒订阅的用户的。</p><p>  其中Observer中有个update()方法，这是notify()里会调用用来提醒所有订阅用户消息的</p><p>  具体代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User实现观察者接口，并实现update方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"User"</span> + name + <span class="string">"receive the update message:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体被观察者实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面存放观察者的列表</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Observer&gt; observerArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加观察者</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当要通知的时候遍历观察者列表调用他们的update方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Observer observer : observerArrayList) &#123;</span><br><span class="line">    observer.update(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  测试方法和结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"></span><br><span class="line">  User first = <span class="keyword">new</span> User(<span class="string">"first"</span>);</span><br><span class="line">  User second = <span class="keyword">new</span> User(<span class="string">"second"</span>);</span><br><span class="line">  User third = <span class="keyword">new</span> User(<span class="string">"third"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.attach(first);</span><br><span class="line">  concreteSubject.attach(second);</span><br><span class="line">  concreteSubject.attach(third);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第一次更新"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.detach(second);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第二次更新"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/05/23/设计模式——观察者模式/2.jpg" alt="结果"></p><h2 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h2><p>  在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p><p>  我们再刚刚实现的观察者模式中，观察者和被观察者是要互相知道对方的存在的(上述代码只实现了被观察者增加观察者，当然也可以在观察者里面关联被观察者)，不然无法增加和删除观察者列表中的用户。</p><p>  但是发布订阅则是通过一个消息中间者来实现，他们之间通过消息代理，可以说更加松耦合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;观察者模式的定义&quot;&gt;&lt;a href=&quot;#观察者模式的定义&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的定义&quot;&gt;&lt;/a&gt;观察者模式的定义&lt;/h2&gt;&lt;p&gt;  观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://francisqiang.github.io/2019/05/23/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://francisqiang.github.io/2019/05/23/线段树/</id>
    <published>2019-05-23T07:29:30.000Z</published>
    <updated>2019-05-23T08:33:22.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><p>  按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。</p><p>  当然时间复杂度的减少，空间也就会有相应的损失，当我们要通过线段树存储一个线性结构，空间的开销就会增大。比如我们存储的线性结构的大小正好是2的整数幂，那么我们所有的叶子节点都会是单个区间的值，这个叶子节点的数量就是n，我们知道对于一个满二叉树来说，叶子节点的数量就是上层所有节点的和，那么这时候我们需要开辟的空间就是2n。但是当我们存储的大小不是2的整数幂的时候，这时候单个区间节点就不全在叶子节点上，假设我们为了使线段树尽量满足满二叉树的结构，那么在倒数第二层的单个区间的值也需要两个左右孩子节点(虽然他们是空，但还是需要空间的)，那么这时候我们就需要开辟2n*2(4n)的空间。</p><p>  <img src="/2019/05/23/线段树/1.jpg" alt="线段树"></p><h2 id="线段树的实现"><a href="#线段树的实现" class="headerlink" title="线段树的实现"></a>线段树的实现</h2><p>  对于线段树的实现，我们需要使用递归调用。</p><p>  具体思路如下:</p><p>  不考虑动态规划的情况，我们需要将整个区间一分为二，这个 middleIndex 就是(left + right) / 2,然后我们再依次递归到最后的叶子节点，当我们需要划分的left = right的时候也就是区间为1的时候(即一个区间的值)我们返回，然后我们通过后序遍历的思想将两个左右子节点的值相融合赋值给父节点。</p><p>  具体实现代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = data[left];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取左右孩子的节点索引</span></span><br><span class="line">  <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取中间索引</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//int middleIndex = (left + right) / 2;</span></span><br><span class="line">  <span class="comment">//为了防止整型溢出</span></span><br><span class="line"></span><br><span class="line">  buildSegmentTree(leftChildIndex, left, middleIndex);</span><br><span class="line">  buildSegmentTree(rightChildIndex, middleIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[leftChildIndex], tree[rightChildIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的搜索"><a href="#线段树的搜索" class="headerlink" title="线段树的搜索"></a>线段树的搜索</h2><p>  基本思路:</p><p>  其实还是递归的思想，我们需要获取某个区间的值，即我们创建一个query方法，其中参数有treeIndex(遍历的根节点的index)，left(在什么区间查询的左边界index),right(在什么区间查询的右边界index),queryLeft(需要查询的左边界index),queryRight(需要查询的右边界的index)。</p><p>  最根本的条件就是当我们所查询的左右边界值分别和我们需要查询的左右边界值相等，那么我们直接返回这个tree[treeIndex]。</p><p>  我们使用递归转换为小问题的思路就是通过left right，queryLeft queryRight的关系，我们设置一个middleIndex(这个middleIndex也是根据left,right得来的)，我们通过queryLeft和middle比较，如果queryLeft比当前所查询区间的的middle要大的话，那么我们就去查询右子树，如果queryRight比middle要小的话我们就去查询左子树，因为我们查询的一个区间基本可能实现一个大区间的子集中，那么为了精确，我们就需要在大区间的左右孩子树中查找结果然后我们再将左右结果融合在一起然后返回。</p><p>  代码实现:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> queryLeft, <span class="keyword">int</span> queryRight)</span></span>&#123;</span><br><span class="line">  <span class="comment">//当left == queryLeft &amp;&amp; right == queryRight时就说明是我们需要查询的区间直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (left == queryLeft &amp;&amp; right == queryRight)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line">  <span class="comment">//缩小查询范围</span></span><br><span class="line">  <span class="keyword">if</span> (queryLeft &gt;= middle + <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryRight &lt;= middle)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们查询的区间必定是某个大区间的左右孩子树查询结果的融合</span></span><br><span class="line">  E leftResult = query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  E rightResult = query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  <span class="keyword">return</span> merger.merger(leftResult, rightResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树查询的LeetCode题目"><a href="#线段树查询的LeetCode题目" class="headerlink" title="线段树查询的LeetCode题目"></a>线段树查询的LeetCode题目</h2><p>  题目描述:</p><p>  <img src="/2019/05/23/线段树/2.jpg" alt="LeetCode题目"></p><p>  解题思路:</p><p>  题目要求需要我们获得一个数组中某个区间段的值，并且这个sumRange函数会不断被调用，那么我们就可以使用线段树的查询操作(使merge融合改成相加就行了)</p><p>  具体代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SegmentTree&lt;Integer&gt; segmentTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  Integer[] integers = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">  <span class="keyword">if</span> (nums.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">      integers[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//λ表达式，直接实现接口</span></span><br><span class="line">    segmentTree = <span class="keyword">new</span> SegmentTree&lt;&gt;(integers, (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segmentTree.query(i, j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的修改"><a href="#线段树的修改" class="headerlink" title="线段树的修改"></a>线段树的修改</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>  这里我们主要实现对线段树的某个单区间的修改操作，对于单个线段树的修改操作势必会牵连到其父节点的修改，这里我们还是可以使用后序遍历的思想再更新完子节点之后将父节点更新。</p><p>  相关代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//最根本条件就是我们查询的区间左右相等</span></span><br><span class="line">  <span class="comment">//这时候我们直接对该结点更新就行</span></span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = e;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//后面也是拿index和left，right比较</span></span><br><span class="line">  <span class="comment">//通过index和left，right的关系将问题变小</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt;= middleIndex)&#123;</span><br><span class="line">    set(childLeftIndex, left, middleIndex, index, e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= middleIndex + <span class="number">1</span>)&#123;</span><br><span class="line">    set(childRightIndex, middleIndex, right, index, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过后序遍历的思想将父节点更新</span></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[childLeftIndex], tree[childRightIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关的LeetCode题目"><a href="#相关的LeetCode题目" class="headerlink" title="相关的LeetCode题目"></a>相关的LeetCode题目</h3><p>  <img src="/2019/05/23/线段树/3.jpg" alt="LeetCode题目"></p><p>  这里其实就是增加一个update方法，题目又增加了修改单个结点的值，那么我们将更新方法加入原来实现的代码中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  segmentTree.update(i, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是线段树&quot;&gt;&lt;a href=&quot;#什么是线段树&quot; class=&quot;headerlink&quot; title=&quot;什么是线段树&quot;&gt;&lt;/a&gt;什么是线段树&lt;/h2&gt;&lt;p&gt;  按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="https://francisqiang.github.io/2019/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/21/设计模式——策略模式/</id>
    <published>2019-05-21T12:11:37.000Z</published>
    <updated>2019-05-21T13:28:56.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><h3 id="继承一定好用吗？"><a href="#继承一定好用吗？" class="headerlink" title="继承一定好用吗？"></a>继承一定好用吗？</h3><p>  当我们做到一个项目类似于设计鸭子，鸭子呢有游泳和嘎嘎叫的能力，另外他们都有display显示外貌的方法。现在比如有两个鸭子，绿头鸭和红头鸭。绿头鸭的头是绿色的，可以游泳，叫声是ll声，红头鸭的头是红色的，可以游泳，叫声是rr声。</p><p>  如果我们要设计这两个鸭子类其实可以直接使用继承来实现，我们可以先设计一个Duck基类，类中有display方法，该方法是抽象的(所以类也是抽象的)，因为每个鸭子的外貌不一样。还有swim(),quack()方法，其中定义了基类默认的，比如说会游泳会嘎嘎叫等，之后绿头鸭红头鸭就需要实现display方法和重写swim(),quack()方法就行了。</p><p>  但是这时候，客户增加需求说要增加会飞行的鸭子。也许我们可以在父类里增加fly(),但是这对原先的子类都会有改动，如果绿头鸭不会飞我们还需要重新覆盖fly()方法，如果我们也像display方法变成抽象的，那么重写的代码太多，代码太冗余。</p><p>  <strong>继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应</strong></p><p>  <strong>超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式</strong></p><h3 id="使用组合更加灵活可扩展"><a href="#使用组合更加灵活可扩展" class="headerlink" title="使用组合更加灵活可扩展"></a>使用组合更加灵活可扩展</h3><p>  上面设计的鸭子类主要就是灵活性太差，其实我们可以使用分离的技巧，我们先来看鸭子这个类，它的方法中有变的和不变的，当我们增加需求或者改动需求的时候是只涉及变的的。</p><p>  比如我们现在将叫声和飞行分离出来变成一个行为，然后我们分别实现这两个行为接口QuackBehavior,FlyBehavior,这两个接口里各有方法quack和fly方法，当我们的叫声和飞行方法有变动的时候我们只需要实现要改变的方法的接口就行。比如我们现在需要有一个火箭飞行的行为那么我们创建一个RocketFlyBehavior实现FlyBehavior接口然后重写方法就行了。</p><p>  那么具体怎么使用呢？我们可以直接在Duck基类里增加两个接口字段QuackBehavior和FlyBehavior就行，然后我们基类的fly和quack方法中直接调用接口字段的fly方法和quack方法就行了，如果这时候我们需要给一个鸭子更换功能，我们直接调用接口字段的set方法就行了。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="Duck抽象类"><a href="#Duck抽象类" class="headerlink" title="Duck抽象类"></a>Duck抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> FlyBehavior mFlyBehavior;</span><br><span class="line">  <span class="keyword">protected</span> QuackBehavior mQuackBehavior;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractDuck</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mFlyBehavior.fly();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mQuackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span> </span>&#123;</span><br><span class="line">    mQuackBehavior = qb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = fb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~im swim~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个实现类"><a href="#两个实现类" class="headerlink" title="两个实现类"></a>两个实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GreenHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**GreenHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~no fly~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**RedHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractDuck greenHeadDuck = <span class="keyword">new</span> GreenHeadDuck();</span><br><span class="line">    AbstractDuck redHeadDuck = <span class="keyword">new</span> RedHeadDuck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认调用</span></span><br><span class="line">    greenHeadDuck.display();</span><br><span class="line">    greenHeadDuck.fly();</span><br><span class="line">    greenHeadDuck.quack();</span><br><span class="line">    greenHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将红头鸭的飞行方法改成不能飞</span></span><br><span class="line">    redHeadDuck.setFlyBehavior(<span class="keyword">new</span> BadFlyBehavior());</span><br><span class="line">    redHeadDuck.display();</span><br><span class="line">    redHeadDuck.fly();</span><br><span class="line">    redHeadDuck.quack();</span><br><span class="line">    redHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们增加行为的时候增加相应接口然后实现相应接口并将接口加入基类字段并实现set方法和相应方法调用接口里面的方法就行了</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</p><p>  原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用背景&quot;&gt;&lt;a href=&quot;#应用背景&quot; class=&quot;headerlink&quot; title=&quot;应用背景&quot;&gt;&lt;/a&gt;应用背景&lt;/h2&gt;&lt;h3 id=&quot;继承一定好用吗？&quot;&gt;&lt;a href=&quot;#继承一定好用吗？&quot; class=&quot;headerlink&quot; title=&quot;继
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>优先队列和堆</title>
    <link href="https://francisqiang.github.io/2019/05/19/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/"/>
    <id>https://francisqiang.github.io/2019/05/19/优先队列和堆/</id>
    <published>2019-05-19T14:51:28.000Z</published>
    <updated>2019-05-19T15:36:49.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>  普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院挂急诊的优先级大于普通排队就诊的，比如在游戏中自动打怪设置，当地图中出现级别高的野怪先打级别高的等等。</p><p>  如果我们实现优先队列使用普通的线性结构，那么当我们入队的时候时间复杂度就是O(1)，但出队的时候我们的时间复杂度就是O(n)，因为出队的时候是优先级最高的出队，所以我们需要遍历整个队列寻找优先级最高的元素。</p><p>  如果我们实现优先队列使用的顺序线性结构，那么我们出队的时间复杂度就是O(1)，因为原本队列就是依靠优先级排列的，这时候我们出队只需要取出第一个元素就行了。但是，当我们进行入队操作的时候我们就需要维持队列的顺序性，这时候入队就是O(n)的时间复杂度了。</p><p>  相较于前面两种实现方法，使用堆来实现优先队列的入队操作和出队操作都是O(logn)的时间复杂度，这是非常快的。</p><p>  <img src="/2019/05/19/优先队列和堆/1.jpg" alt="优先队列的实现方法的时间复杂度比较"></p><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>  堆其实就是按照层由上到下，由左到右的树结构，其中可以分为最大堆和最小堆(根元素为最大的元素就是最大堆)</p><p>  <img src="/2019/05/19/优先队列和堆/2.jpg" alt="堆的数据结构"></p><p>  当我们使用数组实现堆的时候，这时候父子节点的索引值存在着一种数学关系。</p><p>  <img src="/2019/05/19/优先队列和堆/3.jpg" alt="堆的数据结构"></p><p>  当索引从0开始的时候，父亲节点的索引就是子节点的索引-1再除以2(取整的性质，所以左右孩子都一样)，相应的，左孩子就是父亲节点索引乘2+1，右孩子则是左孩子+1。</p><p>  通过这个关系我们就可以很轻松的使用数组存储二叉堆。</p><h2 id="最大堆的代码实现"><a href="#最大堆的代码实现" class="headerlink" title="最大堆的代码实现"></a>最大堆的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 17:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回index索引的父亲节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 父亲节点的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index-0 doesn't have parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取节点左孩子的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 节点索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 左孩子索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取右孩子索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 费节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 右孩子的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">    siftUp(array.getSize() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素上浮</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 指定上浮元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当父元素比指定元素小的时候交换，如果交换则继续去比较</span></span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; array.get(parent(index)).compareTo(array.get(index)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      array.swap(index, parent(index));</span><br><span class="line">      index = parent(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.getSize() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The heap is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    E temp = getMax();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将堆顶元素和堆的最后一个元素交换位置</span></span><br><span class="line">    array.swap(<span class="number">0</span>, array.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//删除最后一个元素(原来的堆顶元素)</span></span><br><span class="line">    array.removeLast();</span><br><span class="line"></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素的下沉</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 需要下沉的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断index合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历堆，条件是左孩子存在</span></span><br><span class="line">    <span class="keyword">while</span> (leftChild(index) &lt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">int</span> j = leftChild(index);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果右孩子存在则比较左右孩子，将大的索引赋值给j</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; array.getSize() &amp;&amp; array.get(j).compareTo(array.get(j + <span class="number">1</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        j ++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (array.get(index).compareTo(array.get(j)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果需要下沉的节点已经比左右孩子最大的大了直接break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        array.swap(index, j);</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大堆的入队和出队的操作"><a href="#最大堆的入队和出队的操作" class="headerlink" title="最大堆的入队和出队的操作"></a>最大堆的入队和出队的操作</h2><p>  在上述代码中，其他操作都是最基本的，但是对于插入和移除元素就会稍微复杂了。</p><p>  当我们插入元素的时候，我们需要在数组最后插入元素，但是插入元素的大小不一定性决定着我们需要重新排列这个二叉堆使它还满足最大堆的特性。所以我们只需要和插入元素的父亲节点比较，如果我们插入的节点大于父亲节点了则交换，然后再和交换后的父亲节点比较，一直到根节点或者子节点小于父亲节点了。</p><p>  当我们移除元素的时候，其实就是移除堆中的顶层元素，这时候如果直接移除的话，那么堆就会变成两个堆，这样整合成一个堆的话太复杂，这时候我们可以将堆底元素和堆顶元素交换，然后再删除堆底元素(原来堆顶元素),然后我们通过现在堆顶元素和它的左右孩子最大的作比较，如果小于最大的那么就交换，然后再次和左右孩子做比较直到自己没有左右孩子为止。</p><h2 id="使用堆来实现优先队列"><a href="#使用堆来实现优先队列" class="headerlink" title="使用堆来实现优先队列"></a>使用堆来实现优先队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 20:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="comment">//优先队列中的元素必须是可比较的</span></span><br><span class="line"> <span class="comment">//其他的方法直接复用堆中的方法就行了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    maxHeap.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.getMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于LeetCode中优先队列的问题"><a href="#关于LeetCode中优先队列的问题" class="headerlink" title="关于LeetCode中优先队列的问题"></a>关于LeetCode中优先队列的问题</h2><p><img src="/2019/05/19/优先队列和堆/4.jpg" alt="题目"></p><p>分析: 我们需要获取频率出现最高的元素，我们需要将频率和元素(key)存入一个map中，然后遍历这个数组，当map不存在相应key的数组中的元素，则将value设置为1，如果存在value++。</p><p>然后我们遍历这个map中的key，将key存入优先队列中(容量为k)，当k的容量存满了并且还需要添加元素到优先队列的时候就判断优先队列优先度最高的元素和插入元素的优先度，如果插入元素的优先度高于现在队列中最高的，那么就将元素插入到队列中，知道整个map遍历完。</p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个Frequency类</span></span><br><span class="line">  <span class="comment">//存放key和频率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Frequency</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> k, freq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frequency</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> freq)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.k = k;</span><br><span class="line">      <span class="keyword">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现比较器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyCompartor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Frequency</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Frequency o1, Frequency o2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o1.freq - o2.freq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//遍历数组并且将频率信息存入map中</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : nums)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!map.containsKey(integer))&#123;</span><br><span class="line">        map.put(integer, <span class="number">1</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(integer, map.get(integer) + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Frequency&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> FrequencyCompartor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历map的key，并且将频率最高的放入优先队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key: map.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (priorityQueue.size() &lt; k)&#123;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; priorityQueue.peek().freq)&#123;</span><br><span class="line">        priorityQueue.poll();</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">      linkedList.add(priorityQueue.poll().k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是优先队列&quot;&gt;&lt;a href=&quot;#什么是优先队列&quot; class=&quot;headerlink&quot; title=&quot;什么是优先队列&quot;&gt;&lt;/a&gt;什么是优先队列&lt;/h2&gt;&lt;p&gt;  普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>集合与映射</title>
    <link href="https://francisqiang.github.io/2019/05/13/%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84/"/>
    <id>https://francisqiang.github.io/2019/05/13/集合与映射/</id>
    <published>2019-05-13T11:04:08.000Z</published>
    <updated>2019-05-13T14:47:39.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是集合-Set"><a href="#什么是集合-Set" class="headerlink" title="什么是集合(Set)"></a>什么是集合(Set)</h2><p>  简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。</p><a id="more"></a><h2 id="定义Set接口"><a href="#定义Set接口" class="headerlink" title="定义Set接口"></a>定义Set接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> size大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用二分搜索树实现集合"><a href="#使用二分搜索树实现集合" class="headerlink" title="使用二分搜索树实现集合"></a>使用二分搜索树实现集合</h2><p>  对于二分搜索树有一个很重要的特性就是它是根据元素的大小来放入元素到树中的，所以二分搜索树基本是不存在相同元素的，我们就可以通过二分搜索树底层实现集合</p><p>  这是上一篇博客写的二分搜索树的相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 20:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node left,right;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      left=<span class="keyword">null</span>;</span><br><span class="line">      right=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root = add(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.left = add(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMin(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode=node.right;</span><br><span class="line">      node.right=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.left=removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMax(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node leftNode=node.left;</span><br><span class="line">      node.left=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.right=removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root=remove(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      node.left=remove(node.left,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      node.right=remove(node.right,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果相等就要删除</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先判断这个树是不是只有一边的孩子</span></span><br><span class="line">      <span class="comment">//如果只有左边有孩子或者只有右边有孩子</span></span><br><span class="line">      <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果左右都有孩子</span></span><br><span class="line">      <span class="comment">//寻找该节点的后继节点</span></span><br><span class="line">      <span class="comment">//后继结点就是离该结点最近的节点（数值最近而且是大于该节点）</span></span><br><span class="line">      <span class="comment">//那么这个结点的后继结点就是该节点右孩子的最小结点</span></span><br><span class="line">      Node successorNode=minimum(node.right);</span><br><span class="line">      <span class="comment">//我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子</span></span><br><span class="line">      successorNode.right=removeMin(node.right);</span><br><span class="line">      successorNode.left=node.left;</span><br><span class="line">      node.left=node.right=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> successorNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      preOrder(node.left);</span><br><span class="line">      preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 非递归实现前序遍历</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perOrderWithoutRecurrence</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">      Node currentNode=stack.pop();</span><br><span class="line">      System.out.println(currentNode.e);</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 层序遍历(广度优先遍历)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        Node currentNode=queue.remove();</span><br><span class="line">        System.out.println(currentNode.e);</span><br><span class="line">        <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      inOrder(node.left);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      postOrder(node.left);</span><br><span class="line">      postOrder(node.right);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    generateBSTString(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成以node为根节点，深度为depth的描述二叉树的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> depth</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBSTString</span><span class="params">(Node node, <span class="keyword">int</span> depth, StringBuilder res)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      res.append(generateDepthString(depth) + <span class="string">"null\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.append(generateDepthString(depth) + node.e + <span class="string">"\n"</span>);</span><br><span class="line">    generateBSTString(node.left, depth + <span class="number">1</span>, res);</span><br><span class="line">    generateBSTString(node.right, depth + <span class="number">1</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">generateDepthString</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; depth ; i ++)&#123;</span><br><span class="line">      res.append(<span class="string">"--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这时候我们就可以使用二分搜索树来实现集合了，很简单，直接封装一个二分搜索树然后调用方法就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 21:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BinarySearchTree&lt;E&gt; binarySearchTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.binarySearchTree = <span class="keyword">new</span> BinarySearchTree&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用链表来实现集合"><a href="#使用链表来实现集合" class="headerlink" title="使用链表来实现集合"></a>使用链表来实现集合</h2><p>  链表中有一个contains方法，我们可以在调用add方法的时候使用contains方法判断原来集合中是否已经存在该元素了，如果已经存在那么就添加失败。其他的也是直接调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 10:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否已经存在该元素</span></span><br><span class="line">    <span class="keyword">if</span> (!linkedList.contains(e))&#123;</span><br><span class="line">      linkedList.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkedList.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树和链表实现集合的比较"><a href="#二分搜索树和链表实现集合的比较" class="headerlink" title="二分搜索树和链表实现集合的比较"></a>二分搜索树和链表实现集合的比较</h2><p>  在上面实现链表集合的时候我们很容易就会发现，链表集合的增加操作的时候需要先判断整个链表中是否存在该元素，那么这样就需要O(n)的时间复杂度了，在删除，查找元素的时候都是和普通链表一样O(n)的时间复杂度。可以说链表实现的集合的效率并不是很高。</p><p>  那么我们再来看一看二分搜索树实现的集合的时间复杂度。当我们添加元素的时候我们是依靠二分搜索树的特性来添加的</p><p>  <img src="/2019/05/13/集合与映射/1.jpg" alt="二分搜索树"></p><p>  比如我们需要添加一个元素的时候，我们就需要先判断大小，然后根据树的特性一层一层遍历，这个时候我们就会发现，我们的时间复杂度是和这个二分搜索树的高度呈线性关系的。</p><p>  <img src="/2019/05/13/集合与映射/2.jpg" alt="二分搜索树"></p><p>  <img src="/2019/05/13/集合与映射/3.jpg" alt="二分搜索树"></p><p>  然后我们通过运算就可以得出一个平衡二叉树h层一共有2的h次方-1个元素，我们就很容易得出时间复杂度为log2(n+1)，忽略常数，那么就是logn。</p><p>  <img src="/2019/05/13/集合与映射/4.jpg" alt="二分搜索树"></p><p>  而logn和n的差距在基数很大的时候差距特别明显</p><p>  <img src="/2019/05/13/集合与映射/5.jpg" alt="二分搜索树"></p><p>  所以说二分搜索树实现的集合会比链表实现的集合快很多。当然这也是考虑树的最好情况。当树不为平衡二叉树的时候，最坏情况也会是O(n)。</p><p>  <img src="/2019/05/13/集合与映射/6.jpg" alt="二分搜索树"></p><p>  如上图右边，我们看到当树成一边排列的时候，它的时间复杂度就是O(n)。</p><h2 id="LeetCode上解决关于集合的题目"><a href="#LeetCode上解决关于集合的题目" class="headerlink" title="LeetCode上解决关于集合的题目"></a>LeetCode上解决关于集合的题目</h2><p>  题目是这样的：</p><p>  <img src="/2019/05/13/集合与映射/7.jpg" alt="LeetCode804题目"></p><p>  对于这道题，我们可以遍历这个words数组，然后得到其中的某个元素再次遍历字符串的每个字母，然后通过原先定义的摩尔斯密码表数组和字符相对应，之后我们就可以获取到这个单词的摩尔斯密码，我们循环完一次之后，我们就把得到的摩尔斯密码拼接成字符串然后存入到set中，最终循环完成之后我们只要返回set的size就行了。</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 13:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预先定义摩尔斯密码表</span></span><br><span class="line">    String[] codes = &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length() ; i ++)&#123;</span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        stringBuilder.append(codes[word.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//存入set中</span></span><br><span class="line">      set.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是映射-Map-字典"><a href="#什么是映射-Map-字典" class="headerlink" title="什么是映射(Map,字典)"></a>什么是映射(Map,字典)</h2><ol><li><p>映射，在定义域中每一个值在值域都有一个值与他对应</p></li><li><p>存储(键，值)数据对的数据结构（Key，Value）</p></li><li><p>根据键(Key)，寻找值(Value)</p><p><img src="/2019/05/13/集合与映射/8.jpg" alt="映射的概念"></p></li></ol><h2 id="定义Map接口"><a href="#定义Map接口" class="headerlink" title="定义Map接口"></a>定义Map接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> key对应的value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">remove</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置相应key的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某个key对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否包含</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否包含</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取映射的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 映射大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断映射是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现Map"><a href="#链表实现Map" class="headerlink" title="链表实现Map"></a>链表实现Map</h2><p>  使用链表实现Map其实只需要将私有类Node里面的字段e更改为key和value就行。当然BinarySearchTree也是如此</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node next)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> key.toString() + <span class="string">" : "</span> + value.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">    Node currentNode = dummyHead.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.key.equals(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否已经存在该key的映射</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      dummyHead.next = <span class="keyword">new</span> Node(k, v, dummyHead.next);</span><br><span class="line">      size ++ ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果存在则更新</span></span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node preNode = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (preNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (preNode.next.key.equals(k))&#123;</span><br><span class="line">        Node delNode = preNode.next;</span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">        delNode.next = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        preNode = preNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否存在该key的映射，如果不存在则抛出异常</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(k + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树实现映射-Map"><a href="#二分搜索树实现映射-Map" class="headerlink" title="二分搜索树实现映射(Map)"></a>二分搜索树实现映射(Map)</h2><p>  对于BinarySearchTree来说实现Map也是利用它原先的方法</p><p>  代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//辅助方法，在删除，修改映射的value时候会用到</span></span><br><span class="line">  <span class="comment">//获取相应key对应的Node(递归)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果递归到节点为null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候继续递归该结点的左子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//大于的时候继续递归该结点的右子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不然就是相等，则直接返回该结点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归到最底层，直接添加节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候直接递归该结点的左子树</span></span><br><span class="line">      node.left = add(node.left, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="comment">   * 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode = node.right;</span><br><span class="line">      node.right = <span class="keyword">null</span>;</span><br><span class="line">      size --;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从二分搜索树中删除键为key的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      root = remove(root, key);</span><br><span class="line">      <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.left = remove(node.left , key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.right = remove(node.right, key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">      <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">      Node successor = minimum(node.right);</span><br><span class="line">      successor.right = removeMin(node.right);</span><br><span class="line">      successor.left = node.left;</span><br><span class="line"></span><br><span class="line">      node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(root, k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(root, k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表Map和二分搜索树Map比较"><a href="#链表Map和二分搜索树Map比较" class="headerlink" title="链表Map和二分搜索树Map比较"></a>链表Map和二分搜索树Map比较</h2><p>  测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testMap</span><span class="params">(Map&lt;String, Integer&gt; map, String filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    System.out.println(filename);</span><br><span class="line">    ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(FileOperation.readFile(filename, words)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Total words: "</span> + words.size());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String word : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(word))&#123;</span><br><span class="line">          map.set(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          map.add(word, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Total different words: "</span> + map.getSize());</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PRIDE: "</span> + map.get(<span class="string">"pride"</span>));</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PREJUDICE: "</span> + map.get(<span class="string">"prejudice"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String filename = <span class="string">"I:\\data_structure\\src\\pride-and-prejudice.txt"</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; bstMap = <span class="keyword">new</span> BinarySearchTreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time1 = testMap(bstMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"BST Map: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; linkedListMap = <span class="keyword">new</span> LinkedListMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time2 = testMap(linkedListMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"Linked List Map: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  两者时间差异:</p><p>  <img src="/2019/05/13/集合与映射/9.jpg" alt="测试结果"></p><p>  可以看出，二分搜索树实现的Map的时间性能是远高于链表实现的Map的。</p><p>  因为对于链表实现修改某一映射对应的value值的时间复杂度是O(n),我们需要一个一个去遍历知道找到key符合的元素。</p><p>  而对于二分搜索树实现的Map来说，它修改一个value的时间复杂度是跟二叉树的高度相关的，也就是说它的时间复杂度是O(logn)级别的，所以当数据量大的时候，二分搜索树的优势非常明显。当然我们还需要考虑最坏的情况，那就是这个二分搜索树变成了类似于链表的树，那这时候时间复杂度就是O(n)了。</p><p>  <img src="/2019/05/13/集合与映射/10.jpg" alt="两种map的时间复杂度比较"></p><p>  但是有个细节需要注意的是，链表实现的Map的key是无序的，上文中的set也是无序的。但是二分搜索树实现的set和map都是有序的(这也是它这么快的一部分原因)。</p><h2 id="使用Map来实现Set"><a href="#使用Map来实现Set" class="headerlink" title="使用Map来实现Set"></a>使用Map来实现Set</h2><p>  我们可以发现，其实Set就是一个没有value的的Map。所以，当我们底层实现了一个映射，集合我们就可以理解成Map&lt;K, V&gt;中value为null的情况，对于不管是k，它所对应的的value都为null。</p><p>  所以当我们在Map中只考虑K的时候，整个Map数据结构就变成了K的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是集合-Set&quot;&gt;&lt;a href=&quot;#什么是集合-Set&quot; class=&quot;headerlink&quot; title=&quot;什么是集合(Set)&quot;&gt;&lt;/a&gt;什么是集合(Set)&lt;/h2&gt;&lt;p&gt;  简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
