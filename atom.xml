<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Francis的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://francisqiang.github.io/"/>
  <updated>2019-06-01T03:17:22.617Z</updated>
  <id>https://francisqiang.github.io/</id>
  
  <author>
    <name>Francis Qiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6学习——day01</title>
    <link href="https://francisqiang.github.io/2019/06/01/ES6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day01/"/>
    <id>https://francisqiang.github.io/2019/06/01/ES6学习——day01/</id>
    <published>2019-06-01T02:14:53.000Z</published>
    <updated>2019-06-01T03:17:22.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>  前段时间学习的mysql到现在还停留在day1阶段，现在就突然学es6。其实我是这么想的 因为这段时间在帮老师弄前端项目，用的JQuery。我想着这东西比较老，然后想用vue逐渐替换掉(做一次尝试吧)，学完vue发现还需要es6的基础，所以看了一下es6语法，并不是很难而且为我写js提供了更好地方法。那就学吧。。。</p><h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><p>  其实学习es6并不打算一个代码一个代码敲过来，可能眼高手低吧。我先学着反正也要项目中使用es6，那我项目中使用多练练吧。</p><p>  在let 和 const之前我们都使用的是var声明变量。这里无非就是作用域的不同，let的作用域是块作用域简单来说就是大括号括起来的部分，而var是函数作用域，如果在全局声明那就全局的。然后let 不准重复声明，又因为es6强制开启了严格模式，所以变量不准在未声明之前引用，不然会报引用错误。</p><p>  而const就是常量，常量是不准重新赋值且声明时必须赋值。有个特殊一点的就是对象常量，对象常量里面的字段都是可以修改的，也许你认为这违反了常量，其实不是(有点像C++里面的常量指针)，在es6中常量对象意味着这个对象引用的地址是不改变的(因为对象是引用类型，所以值其实是地址)，但是里面的内容是可以改变的。这在我学习vuex全局变量的时候看到别人使用const定义全局的变量就很不解，原来是因为他们定义的是全局对象变量。</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>  什么是解构赋值，它有很多分类，数组解构赋值(左右都是数组),对象解构赋值(左右都是对象),字符串解构赋值(左数组，右字符串)，布尔解构赋值，函数参数解构赋值(数组解构赋值在函数上的引用)，数值解构赋值</p><p>  数组解构赋值和对象解构赋值使用的比较多。</p><p>  数组解构赋值例子，在要对数组成员进行变量赋值的时候，尽量使用解构赋值</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个打印出来的ab就是1和2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a,b,rest</span><br><span class="line">  [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a,b,rest</span><br><span class="line">  [a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, rest);</span><br><span class="line">  <span class="comment">//打印结果ab还是1 2 但是rest是[3, 4, 5]数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认值</span></span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, b  = <span class="number">3</span>] = [<span class="number">1</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="comment">//结果是a为1 b为3  </span></span><br><span class="line">  <span class="comment">//如果b为赋值那么就是undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个变量交换</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">  [a, b] = [b, a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取函数返回值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, b] = f()</span><br><span class="line">  <span class="comment">//ab则为12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择型获取</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  [a, , , b] = f()</span><br><span class="line">  <span class="comment">//这时候 a为1  b为6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对象解构赋值例子</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//对象解构赋值</span></span><br><span class="line">  <span class="keyword">let</span> a,b</span><br><span class="line">  (&#123;a, b&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="comment">//a为1b为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> &#123;p, q&#125; = o</span><br><span class="line">  <span class="built_in">console</span>.log(p, q)</span><br><span class="line">  <span class="comment">//这里的p为42 ，q为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用场景</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    title: <span class="string">'abc'</span>,</span><br><span class="line">    test: [&#123;</span><br><span class="line">      title: <span class="string">'test'</span>,</span><br><span class="line">      desc: <span class="string">'description'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> &#123;<span class="attr">title</span>: esTitle, <span class="attr">test</span>: [&#123;<span class="attr">title</span>: testTitle&#125;]&#125; = jsonData</span><br><span class="line">  <span class="built_in">console</span>.log(esTitle, testTitle)</span><br><span class="line">  <span class="comment">//这时候esTitle获取到的就是bc testTitle获取到的就是test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><p>  其实就是对数组的api进行扩展了。</p><ul><li>Array.of()方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arr'</span>, arr)     <span class="comment">//[3, 4, 5, 5, 3]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arr'</span>,<span class="built_in">Array</span>.of())   <span class="comment">//[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Array.from()方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">let</span> pArr=<span class="built_in">Array</span>.from(p); <span class="comment">//将上面的集合转义成数组</span></span><br><span class="line">pArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item.textContent);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;<span class="keyword">return</span>   item + <span class="number">2</span>;&#125;));<span class="comment">//3 5 7</span></span><br></pre></td></tr></table></figure><ul><li>填充数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'fill-7'</span>,[<span class="number">1</span>,<span class="string">'a'</span>,<span class="literal">undefined</span>].fill(<span class="number">7</span>));<span class="comment">//[7,7,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fill,pos'</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>));<span class="comment">//["a", 7, 7, "d", "e"] 1和3表示起始和截至位置，不包括位置3</span></span><br></pre></td></tr></table></figure><ul><li>获取索引和值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'keys'</span>,index);<span class="comment">//0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'values'</span>,value);<span class="comment">//1 c ks</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index,value] <span class="keyword">of</span> [<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="string">'ks'</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">//[4,2,3,4,5] （从0开始替换，从3开始读取，也就是第一个读取的数是4，4是截至位置，也就是在位置4之前，因此只取4）</span></span><br></pre></td></tr></table></figure><ul><li>查找和判断包含</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">3</span>;<span class="comment">//4，只找第一个</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">3</span>;<span class="comment">//3</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'number'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'number'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h2&gt;&lt;p&gt;  前段时间学习的mysql到现在还停留在day1阶段，现在就突然学es6。其实我是这么想的 因为这段时间在帮老师弄前端项目，用的JQuer
      
    
    </summary>
    
      <category term="ES6" scheme="https://francisqiang.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——模板方法模式</title>
    <link href="https://francisqiang.github.io/2019/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/30/设计模式——模板方法模式/</id>
    <published>2019-05-30T15:11:45.000Z</published>
    <updated>2019-05-30T15:36:14.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h2><p>  Template Method模式，我的理解就是它是一种抽象类实现方法的一种升级版的设计模式。所谓模板就是将某一种工序流程方法抽象成一个统一的模板，比如说我有一个绘画的模板，我们可以选择任何一种画笔，比如我使用红笔画这个模板画出来的就是红色的，我用蜡笔那就蜡笔画出来的画。</p><h2 id="模板方法的实现"><a href="#模板方法的实现" class="headerlink" title="模板方法的实现"></a>模板方法的实现</h2><p>  比如这时候我们有一个流程，流程中需要调用几个工序，这几个工序的顺序是不变的，但是具体的工序是会变化的。这时候我们就可以使用模板方法模式了。</p><p>  首先，我们先定义一个抽象类，这个抽象类里面有具体的模板方法和几个工序方法，工序方法是抽象方法(这个就需要子类去实现具体方法)，模板方法里需要调用这几个方法比如说先是工序1然后是工序2最后是工序4。</p><p>  当我们需要具体实现的时候，我们需要加一个类继承于这个抽象类并且实现它的抽象方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>  这里我就直接使用vs在md文件里手敲了，比较简单但最重要的是思想。</p><p>  首先是抽象类AbstractProcess</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">workOrder4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        workOrder1();</span><br><span class="line">        workOrder2();</span><br><span class="line">        workOrder4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后是实现类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakePencilProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcess</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MakePencilProcess</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil first"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil second"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">workOrder4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is make pencil third"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后是客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//里氏替换原则，更加灵活</span></span><br><span class="line">        AbstractProcess abstractProcess = <span class="keyword">new</span> MakePencilProcess();</span><br><span class="line">        abstractProcess.processTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  这两天在看vue，突然有好多要学的现在有点不知所措，期末，练车，数据结构，设计模式，Java项目，大创，前端项目，vue，六级考试，操作系统实验。。。感觉自己野心有点太大了，慢慢来吧，不能太急。</p><p>  这几天突然意识到自己缺少了很多生活的记忆，尤其是前几天肝项目的时候，让我回忆那几天生活里干了啥我已经记不清了，我觉得我不能成为那样的呆子，那不是我，那也是我以前不想成为的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是模板方法模式&quot;&gt;&lt;a href=&quot;#什么是模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;什么是模板方法模式&quot;&gt;&lt;/a&gt;什么是模板方法模式&lt;/h2&gt;&lt;p&gt;  Template Method模式，我的理解就是它是一种抽象类实现方法的一种升级
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——适配器模式</title>
    <link href="https://francisqiang.github.io/2019/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/29/设计模式——适配器模式/</id>
    <published>2019-05-29T12:31:26.000Z</published>
    <updated>2019-05-29T15:25:57.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h2><p>  简单来说，适配器就是用来填补实际情况和需求两者之间地差异。比如说我们需要5V电压，但是国内只给的是220V电压，那我们现在就需要一个适配器帮我们将电压转换。</p><h2 id="通过继承方式实现适配器模式"><a href="#通过继承方式实现适配器模式" class="headerlink" title="通过继承方式实现适配器模式"></a>通过继承方式实现适配器模式</h2><p>  Adapter模式，比如我们有一个原本的类A，A中有一个a方法，这时候我们有一个B类需要A中的a方法，但是它不能直接调用(因为某个原因不匹配，但是B确实需要a方法)，这时候我们可以通过一个C适配器类来包装A类的a方法，我们需要做的就是让C继承A类拥有A类的a方法，然后我们再让C实现B接口(B是一个接口),B类有一个方法时b方法(b方法可以理解为将来需要将a封装或者使用a方法的方法),这时候C适配器就重写了B接口的b方法，当我们B接口需要使用b方法的时候我们new一个C适配器类就行了(拿C实现B接口)。</p><p>  示例代码：</p><p>  我们有一个Banner类，Banner类中有showWithParen，showWithAster方法，这两个方法分别是在使用括号括住字符串和使用两个*包住字符串。然后我们有一个Print接口，这个接口有weakPrint和strongPrint方法，其实这两个方法需要使用showWithParen，showWithAster方法，所以我们可以添加一个适配器，让这个适配器作为Print的实现类，我们在适配器中继承Banner并调用Banner中的showWithParen，showWithAster方法，然后在封装这两个方法成为Print接口需要使用的方法就行了。</p><p>  Banner类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.string = string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.string = string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"("</span> + string + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"*"</span> + string + <span class="string">"*"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Print接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrintBanner适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    showWithParen();</span><br><span class="line">    System.out.println(<span class="string">"weak"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    showWithAster();</span><br><span class="line">    System.out.println(<span class="string">"strong"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Print print = <span class="keyword">new</span> PrintBanner(<span class="string">"12345"</span>);</span><br><span class="line">    print.weakPrint();</span><br><span class="line">    print.strongPrint();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用委托方式实现适配器模式"><a href="#使用委托方式实现适配器模式" class="headerlink" title="使用委托方式实现适配器模式"></a>使用委托方式实现适配器模式</h2><p>  其实使用委托的方法就是改动一下适配器类，使适配器不是继承原来的类而是拥有原来的类，将是一个变为有一个在面向对象里会有很多好处。这貌似是Java编程思想里看到的，，，我也忘了。</p><p>  这时候我们需要改动一下适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Banner banner;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.banner = <span class="keyword">new</span> Banner(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    banner.showWithParen();</span><br><span class="line">    System.out.println(<span class="string">"weak"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    banner.showWithAster();</span><br><span class="line">    System.out.println(<span class="string">"strong"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是适配器模式&quot;&gt;&lt;a href=&quot;#什么是适配器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是适配器模式&quot;&gt;&lt;/a&gt;什么是适配器模式&lt;/h2&gt;&lt;p&gt;  简单来说，适配器就是用来填补实际情况和需求两者之间地差异。比如说我们需要5V电压，但是国
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——迭代器模式</title>
    <link href="https://francisqiang.github.io/2019/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/27/设计模式——迭代器模式/</id>
    <published>2019-05-27T02:06:40.000Z</published>
    <updated>2019-05-27T03:00:03.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h2><p>  当我们进行数组遍历的时候需要for循环i一直到arr.length，当我们使用迭代器模式的时候我们只需要生成当前数组的具体迭代器(实现迭代器接口),然后通过这个迭代器遍历就行。</p><h2 id="迭代器UML图及角色介绍"><a href="#迭代器UML图及角色介绍" class="headerlink" title="迭代器UML图及角色介绍"></a>迭代器UML图及角色介绍</h2><p>   <img src="/2019/05/27/设计模式——迭代器模式/1.jpg" alt="迭代器模式"></p><h3 id="Aggregate接口"><a href="#Aggregate接口" class="headerlink" title="Aggregate接口"></a>Aggregate接口</h3><p>  Aggregate是所有需要通过迭代器遍历的集合的接口。所有需要通过迭代器遍历集合的都需要实现这个Aggregate接口，Aggregate本身有聚集集合的意思，这里我们就叫它有迭代器实现的集合接口吧。</p><p>  其中相关Aggregate接口的代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里实现了一个迭代器，需要实现迭代器的集合都必须实现这个方法，这个方法的目的是返回该集合的具体迭代器。</span></span><br><span class="line">  <span class="function">Interator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcreteAggregate实现类"><a href="#ConcreteAggregate实现类" class="headerlink" title="ConcreteAggregate实现类"></a>ConcreteAggregate实现类</h3><p>  ConcreteAggregate实现了Aggregate接口，可以说是具体的实现类，比如说这个类是一个CardList(里面存放了card元素)，里面会有相关的card字段以及获取某个元素，获取长度等等有关集合数组的操作。最重要的是它需要实现iterator方法。</p><p>  其中相关ConcreteAggregate实现类的代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iteratot</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>  Iterator和Aggregate接口的关系就是，Aggregate接口中有产生Iterator的iterator方法，也就是Aggregate接口的具体实现类ConcreteAggregate产生出Iterator具体实现类ConcreteIterator。</p><p>  其中Iterator中有两个方法，分别是hasNext(),next()。hasNext的作用是判断迭代器是否还有下一个元素，如果有返回true否则false。next()的作用是返回当前集合迭代到的元素并将指针移向一下个元素(注意这里是两个作用)。</p><p>  所以有了迭代器我们遍历一个集合是这样的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于产生cardList的迭代器</span></span><br><span class="line"><span class="comment">//这个方法这里还是不可以用的，为了现在介绍迭代器迭代代码，如果要实现必须要有一个具体ConcreteIterator实现类</span></span><br><span class="line">Iteratot iterator = cardList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Card card = (Card)iterator.next();</span><br><span class="line">    <span class="comment">//.......进行相关操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  具体Iterator接口的实现代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcreteIterator实现类"><a href="#ConcreteIterator实现类" class="headerlink" title="ConcreteIterator实现类"></a>ConcreteIterator实现类</h3><p>  ConcreteIterator实现了Iterator接口，比如我们这里实现的是CardList的Iterator，我们可以这样写</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CardList cardList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CardListIterator</span><span class="params">(CardList catdList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardList = cardList;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; cardList.getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Card card = CardList.get(index);</span><br><span class="line">        index ++ ;</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器模式的作用"><a href="#迭代器模式的作用" class="headerlink" title="迭代器模式的作用"></a>迭代器模式的作用</h2><p>  为什么要考虑引入Iterator模式呢？直接for循环不就好了，其实迭代器模式有一个好处就是分离，将遍历和实现分开来，在我们调用如下代码的时候</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Card card = (Card)iterator.next();</span><br><span class="line">    <span class="comment">//.......进行相关操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个遍历并没有依赖于cardList，所以当我们这个cardList切换了数据结构的时候我们不需要将原来代码的for循环再依次改动了，我们只需要修改这个相关的iterator的具体实现类其中的hasNext()方法和next()方法就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是迭代器模式&quot;&gt;&lt;a href=&quot;#什么是迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代器模式&quot;&gt;&lt;/a&gt;什么是迭代器模式&lt;/h2&gt;&lt;p&gt;  当我们进行数组遍历的时候需要for循环i一直到arr.length，当我们使用迭代器模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql基础学习——day1</title>
    <link href="https://francisqiang.github.io/2019/05/23/Mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day1/"/>
    <id>https://francisqiang.github.io/2019/05/23/Mysql基础学习——day1/</id>
    <published>2019-05-23T15:02:34.000Z</published>
    <updated>2019-05-23T15:47:32.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql的数据类型"><a href="#Mysql的数据类型" class="headerlink" title="Mysql的数据类型"></a>Mysql的数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ol><li>TINYINT</li><li>SMALLINT</li><li>MEDIUMINT</li><li>INT</li><li><p>BIGINT</p><p>这五个从小往大，可以对对应字段设置有无符号位。</p><p><img src="/2019/05/23/Mysql基础学习——day1/1.jpg" alt="整型"></p></li></ol><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ol><li>FLOAT 单精度</li><li><p>DOUBLE 双精度</p><p><img src="/2019/05/23/Mysql基础学习——day1/2.jpg" alt="浮点型"></p></li></ol><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ol><li>YEAR</li><li>TIME</li><li>DATE</li><li>DATETIME</li><li><p>TIMESTAMP</p><p>DATE范围：  1000/1/1~9999/12/31</p><p>DATETIME范围：  1000/1/1/0:00:00~9999/12/31/23:59:59</p><p>TIMESTAMP范围：  1970/1/1~2037/12/31</p><p>TIME范围：  -8385959~8385959</p><p>YEAR范围：  可存储俩位或者四位 默认四位，可以是1970~2069</p></li></ol><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ol><li>CHAR</li><li>VARCHAR</li><li>TINYTEXT</li><li>TEXT</li><li>MEDIUMTEXT</li><li>LONGTEXT</li><li>ENUM</li><li><p>SET</p><p><img src="/2019/05/23/Mysql基础学习——day1/3.jpg" alt="字符类型"></p></li></ol><h2 id="Mysql的约束"><a href="#Mysql的约束" class="headerlink" title="Mysql的约束"></a>Mysql的约束</h2><h3 id="五种约束"><a href="#五种约束" class="headerlink" title="五种约束"></a>五种约束</h3><pre><code>NOT NULL（非空约束）PRIMARY  KEY (主键约束)UNIQUE  KEY （唯一约束）DEFAULT  (默认约束)FOREIGN  KEY (外键约束)</code></pre><h3 id="外键约束的条件"><a href="#外键约束的条件" class="headerlink" title="外键约束的条件"></a>外键约束的条件</h3><ol><li><p>父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。</p></li><li><p>数据表的存储引擎只能为InnoDB。</p></li><li><p>外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。</p></li><li><p>外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。</p></li></ol><h3 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h3><ol><li><p>CASCADE:从父表删除或更新且自动删除或更新子表中匹配的行。</p></li><li><p>SET NULL:从父表删除或更新行，并设置子表中的外键列为NULL。</p></li><li><p>RESTRICT:拒绝对父表的删除或更新操作。</p></li><li><p>NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。</p><p>CASCADE的删除案例：（子表中外键列添加ON DELETE CASCADE，父表进行删除时，子表也进行相应删除）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mysql的数据类型&quot;&gt;&lt;a href=&quot;#Mysql的数据类型&quot; class=&quot;headerlink&quot; title=&quot;Mysql的数据类型&quot;&gt;&lt;/a&gt;Mysql的数据类型&lt;/h2&gt;&lt;h3 id=&quot;整型&quot;&gt;&lt;a href=&quot;#整型&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Mysql" scheme="https://francisqiang.github.io/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——观察者模式</title>
    <link href="https://francisqiang.github.io/2019/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/23/设计模式——观察者模式/</id>
    <published>2019-05-23T10:29:21.000Z</published>
    <updated>2019-05-23T11:37:53.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h2><p>  观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>  <img src="/2019/05/23/设计模式——观察者模式/1.jpg" alt="观察者模式结构图"></p><p>  在观察者模式中有如下角色：</p><ul><li><p>Subject：</p><p>抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p></li><li><p>ConcreteSubject：</p><p>具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p></li><li><p>Observer：</p><p>抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p></li><li><p>ConcrereObserver：</p><p>具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p></li></ul><h2 id="简单实现观察者模式"><a href="#简单实现观察者模式" class="headerlink" title="简单实现观察者模式"></a>简单实现观察者模式</h2><p>  这里我们简单实现一下观察者模式，首先我们定义一个被观察者的接口Subject，然后我们再定义一个观察者的接口Observer</p><p>  其中Subject中有三个方法，attach()用来增加用户的，detach()用来移除用户的，notify()用来提醒订阅的用户的。</p><p>  其中Observer中有个update()方法，这是notify()里会调用用来提醒所有订阅用户消息的</p><p>  具体代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User实现观察者接口，并实现update方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"User"</span> + name + <span class="string">"receive the update message:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体被观察者实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面存放观察者的列表</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Observer&gt; observerArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加观察者</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当要通知的时候遍历观察者列表调用他们的update方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Observer observer : observerArrayList) &#123;</span><br><span class="line">    observer.update(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  测试方法和结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"></span><br><span class="line">  User first = <span class="keyword">new</span> User(<span class="string">"first"</span>);</span><br><span class="line">  User second = <span class="keyword">new</span> User(<span class="string">"second"</span>);</span><br><span class="line">  User third = <span class="keyword">new</span> User(<span class="string">"third"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.attach(first);</span><br><span class="line">  concreteSubject.attach(second);</span><br><span class="line">  concreteSubject.attach(third);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第一次更新"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.detach(second);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第二次更新"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/05/23/设计模式——观察者模式/2.jpg" alt="结果"></p><h2 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h2><p>  在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p><p>  我们再刚刚实现的观察者模式中，观察者和被观察者是要互相知道对方的存在的(上述代码只实现了被观察者增加观察者，当然也可以在观察者里面关联被观察者)，不然无法增加和删除观察者列表中的用户。</p><p>  但是发布订阅则是通过一个消息中间者来实现，他们之间通过消息代理，可以说更加松耦合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;观察者模式的定义&quot;&gt;&lt;a href=&quot;#观察者模式的定义&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的定义&quot;&gt;&lt;/a&gt;观察者模式的定义&lt;/h2&gt;&lt;p&gt;  观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://francisqiang.github.io/2019/05/23/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://francisqiang.github.io/2019/05/23/线段树/</id>
    <published>2019-05-23T07:29:30.000Z</published>
    <updated>2019-05-23T08:33:22.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><p>  按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。</p><p>  当然时间复杂度的减少，空间也就会有相应的损失，当我们要通过线段树存储一个线性结构，空间的开销就会增大。比如我们存储的线性结构的大小正好是2的整数幂，那么我们所有的叶子节点都会是单个区间的值，这个叶子节点的数量就是n，我们知道对于一个满二叉树来说，叶子节点的数量就是上层所有节点的和，那么这时候我们需要开辟的空间就是2n。但是当我们存储的大小不是2的整数幂的时候，这时候单个区间节点就不全在叶子节点上，假设我们为了使线段树尽量满足满二叉树的结构，那么在倒数第二层的单个区间的值也需要两个左右孩子节点(虽然他们是空，但还是需要空间的)，那么这时候我们就需要开辟2n*2(4n)的空间。</p><p>  <img src="/2019/05/23/线段树/1.jpg" alt="线段树"></p><h2 id="线段树的实现"><a href="#线段树的实现" class="headerlink" title="线段树的实现"></a>线段树的实现</h2><p>  对于线段树的实现，我们需要使用递归调用。</p><p>  具体思路如下:</p><p>  不考虑动态规划的情况，我们需要将整个区间一分为二，这个 middleIndex 就是(left + right) / 2,然后我们再依次递归到最后的叶子节点，当我们需要划分的left = right的时候也就是区间为1的时候(即一个区间的值)我们返回，然后我们通过后序遍历的思想将两个左右子节点的值相融合赋值给父节点。</p><p>  具体实现代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = data[left];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取左右孩子的节点索引</span></span><br><span class="line">  <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取中间索引</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//int middleIndex = (left + right) / 2;</span></span><br><span class="line">  <span class="comment">//为了防止整型溢出</span></span><br><span class="line"></span><br><span class="line">  buildSegmentTree(leftChildIndex, left, middleIndex);</span><br><span class="line">  buildSegmentTree(rightChildIndex, middleIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[leftChildIndex], tree[rightChildIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的搜索"><a href="#线段树的搜索" class="headerlink" title="线段树的搜索"></a>线段树的搜索</h2><p>  基本思路:</p><p>  其实还是递归的思想，我们需要获取某个区间的值，即我们创建一个query方法，其中参数有treeIndex(遍历的根节点的index)，left(在什么区间查询的左边界index),right(在什么区间查询的右边界index),queryLeft(需要查询的左边界index),queryRight(需要查询的右边界的index)。</p><p>  最根本的条件就是当我们所查询的左右边界值分别和我们需要查询的左右边界值相等，那么我们直接返回这个tree[treeIndex]。</p><p>  我们使用递归转换为小问题的思路就是通过left right，queryLeft queryRight的关系，我们设置一个middleIndex(这个middleIndex也是根据left,right得来的)，我们通过queryLeft和middle比较，如果queryLeft比当前所查询区间的的middle要大的话，那么我们就去查询右子树，如果queryRight比middle要小的话我们就去查询左子树，因为我们查询的一个区间基本可能实现一个大区间的子集中，那么为了精确，我们就需要在大区间的左右孩子树中查找结果然后我们再将左右结果融合在一起然后返回。</p><p>  代码实现:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> queryLeft, <span class="keyword">int</span> queryRight)</span></span>&#123;</span><br><span class="line">  <span class="comment">//当left == queryLeft &amp;&amp; right == queryRight时就说明是我们需要查询的区间直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (left == queryLeft &amp;&amp; right == queryRight)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line">  <span class="comment">//缩小查询范围</span></span><br><span class="line">  <span class="keyword">if</span> (queryLeft &gt;= middle + <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryRight &lt;= middle)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们查询的区间必定是某个大区间的左右孩子树查询结果的融合</span></span><br><span class="line">  E leftResult = query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  E rightResult = query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  <span class="keyword">return</span> merger.merger(leftResult, rightResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树查询的LeetCode题目"><a href="#线段树查询的LeetCode题目" class="headerlink" title="线段树查询的LeetCode题目"></a>线段树查询的LeetCode题目</h2><p>  题目描述:</p><p>  <img src="/2019/05/23/线段树/2.jpg" alt="LeetCode题目"></p><p>  解题思路:</p><p>  题目要求需要我们获得一个数组中某个区间段的值，并且这个sumRange函数会不断被调用，那么我们就可以使用线段树的查询操作(使merge融合改成相加就行了)</p><p>  具体代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SegmentTree&lt;Integer&gt; segmentTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  Integer[] integers = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">  <span class="keyword">if</span> (nums.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">      integers[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//λ表达式，直接实现接口</span></span><br><span class="line">    segmentTree = <span class="keyword">new</span> SegmentTree&lt;&gt;(integers, (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segmentTree.query(i, j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的修改"><a href="#线段树的修改" class="headerlink" title="线段树的修改"></a>线段树的修改</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>  这里我们主要实现对线段树的某个单区间的修改操作，对于单个线段树的修改操作势必会牵连到其父节点的修改，这里我们还是可以使用后序遍历的思想再更新完子节点之后将父节点更新。</p><p>  相关代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//最根本条件就是我们查询的区间左右相等</span></span><br><span class="line">  <span class="comment">//这时候我们直接对该结点更新就行</span></span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = e;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//后面也是拿index和left，right比较</span></span><br><span class="line">  <span class="comment">//通过index和left，right的关系将问题变小</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt;= middleIndex)&#123;</span><br><span class="line">    set(childLeftIndex, left, middleIndex, index, e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= middleIndex + <span class="number">1</span>)&#123;</span><br><span class="line">    set(childRightIndex, middleIndex, right, index, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过后序遍历的思想将父节点更新</span></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[childLeftIndex], tree[childRightIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关的LeetCode题目"><a href="#相关的LeetCode题目" class="headerlink" title="相关的LeetCode题目"></a>相关的LeetCode题目</h3><p>  <img src="/2019/05/23/线段树/3.jpg" alt="LeetCode题目"></p><p>  这里其实就是增加一个update方法，题目又增加了修改单个结点的值，那么我们将更新方法加入原来实现的代码中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  segmentTree.update(i, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是线段树&quot;&gt;&lt;a href=&quot;#什么是线段树&quot; class=&quot;headerlink&quot; title=&quot;什么是线段树&quot;&gt;&lt;/a&gt;什么是线段树&lt;/h2&gt;&lt;p&gt;  按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="https://francisqiang.github.io/2019/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/21/设计模式——策略模式/</id>
    <published>2019-05-21T12:11:37.000Z</published>
    <updated>2019-05-21T13:28:56.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><h3 id="继承一定好用吗？"><a href="#继承一定好用吗？" class="headerlink" title="继承一定好用吗？"></a>继承一定好用吗？</h3><p>  当我们做到一个项目类似于设计鸭子，鸭子呢有游泳和嘎嘎叫的能力，另外他们都有display显示外貌的方法。现在比如有两个鸭子，绿头鸭和红头鸭。绿头鸭的头是绿色的，可以游泳，叫声是ll声，红头鸭的头是红色的，可以游泳，叫声是rr声。</p><p>  如果我们要设计这两个鸭子类其实可以直接使用继承来实现，我们可以先设计一个Duck基类，类中有display方法，该方法是抽象的(所以类也是抽象的)，因为每个鸭子的外貌不一样。还有swim(),quack()方法，其中定义了基类默认的，比如说会游泳会嘎嘎叫等，之后绿头鸭红头鸭就需要实现display方法和重写swim(),quack()方法就行了。</p><p>  但是这时候，客户增加需求说要增加会飞行的鸭子。也许我们可以在父类里增加fly(),但是这对原先的子类都会有改动，如果绿头鸭不会飞我们还需要重新覆盖fly()方法，如果我们也像display方法变成抽象的，那么重写的代码太多，代码太冗余。</p><p>  <strong>继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应</strong></p><p>  <strong>超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式</strong></p><h3 id="使用组合更加灵活可扩展"><a href="#使用组合更加灵活可扩展" class="headerlink" title="使用组合更加灵活可扩展"></a>使用组合更加灵活可扩展</h3><p>  上面设计的鸭子类主要就是灵活性太差，其实我们可以使用分离的技巧，我们先来看鸭子这个类，它的方法中有变的和不变的，当我们增加需求或者改动需求的时候是只涉及变的的。</p><p>  比如我们现在将叫声和飞行分离出来变成一个行为，然后我们分别实现这两个行为接口QuackBehavior,FlyBehavior,这两个接口里各有方法quack和fly方法，当我们的叫声和飞行方法有变动的时候我们只需要实现要改变的方法的接口就行。比如我们现在需要有一个火箭飞行的行为那么我们创建一个RocketFlyBehavior实现FlyBehavior接口然后重写方法就行了。</p><p>  那么具体怎么使用呢？我们可以直接在Duck基类里增加两个接口字段QuackBehavior和FlyBehavior就行，然后我们基类的fly和quack方法中直接调用接口字段的fly方法和quack方法就行了，如果这时候我们需要给一个鸭子更换功能，我们直接调用接口字段的set方法就行了。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="Duck抽象类"><a href="#Duck抽象类" class="headerlink" title="Duck抽象类"></a>Duck抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> FlyBehavior mFlyBehavior;</span><br><span class="line">  <span class="keyword">protected</span> QuackBehavior mQuackBehavior;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractDuck</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mFlyBehavior.fly();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mQuackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span> </span>&#123;</span><br><span class="line">    mQuackBehavior = qb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = fb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~im swim~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个实现类"><a href="#两个实现类" class="headerlink" title="两个实现类"></a>两个实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GreenHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**GreenHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~no fly~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**RedHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractDuck greenHeadDuck = <span class="keyword">new</span> GreenHeadDuck();</span><br><span class="line">    AbstractDuck redHeadDuck = <span class="keyword">new</span> RedHeadDuck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认调用</span></span><br><span class="line">    greenHeadDuck.display();</span><br><span class="line">    greenHeadDuck.fly();</span><br><span class="line">    greenHeadDuck.quack();</span><br><span class="line">    greenHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将红头鸭的飞行方法改成不能飞</span></span><br><span class="line">    redHeadDuck.setFlyBehavior(<span class="keyword">new</span> BadFlyBehavior());</span><br><span class="line">    redHeadDuck.display();</span><br><span class="line">    redHeadDuck.fly();</span><br><span class="line">    redHeadDuck.quack();</span><br><span class="line">    redHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们增加行为的时候增加相应接口然后实现相应接口并将接口加入基类字段并实现set方法和相应方法调用接口里面的方法就行了</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</p><p>  原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用背景&quot;&gt;&lt;a href=&quot;#应用背景&quot; class=&quot;headerlink&quot; title=&quot;应用背景&quot;&gt;&lt;/a&gt;应用背景&lt;/h2&gt;&lt;h3 id=&quot;继承一定好用吗？&quot;&gt;&lt;a href=&quot;#继承一定好用吗？&quot; class=&quot;headerlink&quot; title=&quot;继
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>优先队列和堆</title>
    <link href="https://francisqiang.github.io/2019/05/19/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/"/>
    <id>https://francisqiang.github.io/2019/05/19/优先队列和堆/</id>
    <published>2019-05-19T14:51:28.000Z</published>
    <updated>2019-05-19T15:36:49.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>  普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院挂急诊的优先级大于普通排队就诊的，比如在游戏中自动打怪设置，当地图中出现级别高的野怪先打级别高的等等。</p><p>  如果我们实现优先队列使用普通的线性结构，那么当我们入队的时候时间复杂度就是O(1)，但出队的时候我们的时间复杂度就是O(n)，因为出队的时候是优先级最高的出队，所以我们需要遍历整个队列寻找优先级最高的元素。</p><p>  如果我们实现优先队列使用的顺序线性结构，那么我们出队的时间复杂度就是O(1)，因为原本队列就是依靠优先级排列的，这时候我们出队只需要取出第一个元素就行了。但是，当我们进行入队操作的时候我们就需要维持队列的顺序性，这时候入队就是O(n)的时间复杂度了。</p><p>  相较于前面两种实现方法，使用堆来实现优先队列的入队操作和出队操作都是O(logn)的时间复杂度，这是非常快的。</p><p>  <img src="/2019/05/19/优先队列和堆/1.jpg" alt="优先队列的实现方法的时间复杂度比较"></p><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>  堆其实就是按照层由上到下，由左到右的树结构，其中可以分为最大堆和最小堆(根元素为最大的元素就是最大堆)</p><p>  <img src="/2019/05/19/优先队列和堆/2.jpg" alt="堆的数据结构"></p><p>  当我们使用数组实现堆的时候，这时候父子节点的索引值存在着一种数学关系。</p><p>  <img src="/2019/05/19/优先队列和堆/3.jpg" alt="堆的数据结构"></p><p>  当索引从0开始的时候，父亲节点的索引就是子节点的索引-1再除以2(取整的性质，所以左右孩子都一样)，相应的，左孩子就是父亲节点索引乘2+1，右孩子则是左孩子+1。</p><p>  通过这个关系我们就可以很轻松的使用数组存储二叉堆。</p><h2 id="最大堆的代码实现"><a href="#最大堆的代码实现" class="headerlink" title="最大堆的代码实现"></a>最大堆的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 17:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回index索引的父亲节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 父亲节点的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index-0 doesn't have parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取节点左孩子的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 节点索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 左孩子索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取右孩子索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 费节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 右孩子的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">    siftUp(array.getSize() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素上浮</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 指定上浮元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当父元素比指定元素小的时候交换，如果交换则继续去比较</span></span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; array.get(parent(index)).compareTo(array.get(index)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      array.swap(index, parent(index));</span><br><span class="line">      index = parent(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.getSize() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The heap is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    E temp = getMax();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将堆顶元素和堆的最后一个元素交换位置</span></span><br><span class="line">    array.swap(<span class="number">0</span>, array.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//删除最后一个元素(原来的堆顶元素)</span></span><br><span class="line">    array.removeLast();</span><br><span class="line"></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素的下沉</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 需要下沉的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断index合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历堆，条件是左孩子存在</span></span><br><span class="line">    <span class="keyword">while</span> (leftChild(index) &lt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">int</span> j = leftChild(index);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果右孩子存在则比较左右孩子，将大的索引赋值给j</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; array.getSize() &amp;&amp; array.get(j).compareTo(array.get(j + <span class="number">1</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        j ++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (array.get(index).compareTo(array.get(j)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果需要下沉的节点已经比左右孩子最大的大了直接break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        array.swap(index, j);</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大堆的入队和出队的操作"><a href="#最大堆的入队和出队的操作" class="headerlink" title="最大堆的入队和出队的操作"></a>最大堆的入队和出队的操作</h2><p>  在上述代码中，其他操作都是最基本的，但是对于插入和移除元素就会稍微复杂了。</p><p>  当我们插入元素的时候，我们需要在数组最后插入元素，但是插入元素的大小不一定性决定着我们需要重新排列这个二叉堆使它还满足最大堆的特性。所以我们只需要和插入元素的父亲节点比较，如果我们插入的节点大于父亲节点了则交换，然后再和交换后的父亲节点比较，一直到根节点或者子节点小于父亲节点了。</p><p>  当我们移除元素的时候，其实就是移除堆中的顶层元素，这时候如果直接移除的话，那么堆就会变成两个堆，这样整合成一个堆的话太复杂，这时候我们可以将堆底元素和堆顶元素交换，然后再删除堆底元素(原来堆顶元素),然后我们通过现在堆顶元素和它的左右孩子最大的作比较，如果小于最大的那么就交换，然后再次和左右孩子做比较直到自己没有左右孩子为止。</p><h2 id="使用堆来实现优先队列"><a href="#使用堆来实现优先队列" class="headerlink" title="使用堆来实现优先队列"></a>使用堆来实现优先队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 20:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="comment">//优先队列中的元素必须是可比较的</span></span><br><span class="line"> <span class="comment">//其他的方法直接复用堆中的方法就行了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    maxHeap.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.getMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于LeetCode中优先队列的问题"><a href="#关于LeetCode中优先队列的问题" class="headerlink" title="关于LeetCode中优先队列的问题"></a>关于LeetCode中优先队列的问题</h2><p><img src="/2019/05/19/优先队列和堆/4.jpg" alt="题目"></p><p>分析: 我们需要获取频率出现最高的元素，我们需要将频率和元素(key)存入一个map中，然后遍历这个数组，当map不存在相应key的数组中的元素，则将value设置为1，如果存在value++。</p><p>然后我们遍历这个map中的key，将key存入优先队列中(容量为k)，当k的容量存满了并且还需要添加元素到优先队列的时候就判断优先队列优先度最高的元素和插入元素的优先度，如果插入元素的优先度高于现在队列中最高的，那么就将元素插入到队列中，知道整个map遍历完。</p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个Frequency类</span></span><br><span class="line">  <span class="comment">//存放key和频率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Frequency</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> k, freq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frequency</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> freq)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.k = k;</span><br><span class="line">      <span class="keyword">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现比较器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyCompartor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Frequency</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Frequency o1, Frequency o2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o1.freq - o2.freq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//遍历数组并且将频率信息存入map中</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : nums)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!map.containsKey(integer))&#123;</span><br><span class="line">        map.put(integer, <span class="number">1</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(integer, map.get(integer) + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Frequency&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> FrequencyCompartor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历map的key，并且将频率最高的放入优先队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key: map.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (priorityQueue.size() &lt; k)&#123;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; priorityQueue.peek().freq)&#123;</span><br><span class="line">        priorityQueue.poll();</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">      linkedList.add(priorityQueue.poll().k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是优先队列&quot;&gt;&lt;a href=&quot;#什么是优先队列&quot; class=&quot;headerlink&quot; title=&quot;什么是优先队列&quot;&gt;&lt;/a&gt;什么是优先队列&lt;/h2&gt;&lt;p&gt;  普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>集合与映射</title>
    <link href="https://francisqiang.github.io/2019/05/13/%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84/"/>
    <id>https://francisqiang.github.io/2019/05/13/集合与映射/</id>
    <published>2019-05-13T11:04:08.000Z</published>
    <updated>2019-05-13T14:47:39.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是集合-Set"><a href="#什么是集合-Set" class="headerlink" title="什么是集合(Set)"></a>什么是集合(Set)</h2><p>  简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。</p><a id="more"></a><h2 id="定义Set接口"><a href="#定义Set接口" class="headerlink" title="定义Set接口"></a>定义Set接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> size大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用二分搜索树实现集合"><a href="#使用二分搜索树实现集合" class="headerlink" title="使用二分搜索树实现集合"></a>使用二分搜索树实现集合</h2><p>  对于二分搜索树有一个很重要的特性就是它是根据元素的大小来放入元素到树中的，所以二分搜索树基本是不存在相同元素的，我们就可以通过二分搜索树底层实现集合</p><p>  这是上一篇博客写的二分搜索树的相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 20:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node left,right;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      left=<span class="keyword">null</span>;</span><br><span class="line">      right=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root = add(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.left = add(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMin(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode=node.right;</span><br><span class="line">      node.right=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.left=removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMax(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node leftNode=node.left;</span><br><span class="line">      node.left=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.right=removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root=remove(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      node.left=remove(node.left,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      node.right=remove(node.right,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果相等就要删除</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先判断这个树是不是只有一边的孩子</span></span><br><span class="line">      <span class="comment">//如果只有左边有孩子或者只有右边有孩子</span></span><br><span class="line">      <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果左右都有孩子</span></span><br><span class="line">      <span class="comment">//寻找该节点的后继节点</span></span><br><span class="line">      <span class="comment">//后继结点就是离该结点最近的节点（数值最近而且是大于该节点）</span></span><br><span class="line">      <span class="comment">//那么这个结点的后继结点就是该节点右孩子的最小结点</span></span><br><span class="line">      Node successorNode=minimum(node.right);</span><br><span class="line">      <span class="comment">//我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子</span></span><br><span class="line">      successorNode.right=removeMin(node.right);</span><br><span class="line">      successorNode.left=node.left;</span><br><span class="line">      node.left=node.right=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> successorNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      preOrder(node.left);</span><br><span class="line">      preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 非递归实现前序遍历</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perOrderWithoutRecurrence</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">      Node currentNode=stack.pop();</span><br><span class="line">      System.out.println(currentNode.e);</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 层序遍历(广度优先遍历)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        Node currentNode=queue.remove();</span><br><span class="line">        System.out.println(currentNode.e);</span><br><span class="line">        <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      inOrder(node.left);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      postOrder(node.left);</span><br><span class="line">      postOrder(node.right);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    generateBSTString(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成以node为根节点，深度为depth的描述二叉树的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> depth</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBSTString</span><span class="params">(Node node, <span class="keyword">int</span> depth, StringBuilder res)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      res.append(generateDepthString(depth) + <span class="string">"null\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.append(generateDepthString(depth) + node.e + <span class="string">"\n"</span>);</span><br><span class="line">    generateBSTString(node.left, depth + <span class="number">1</span>, res);</span><br><span class="line">    generateBSTString(node.right, depth + <span class="number">1</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">generateDepthString</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; depth ; i ++)&#123;</span><br><span class="line">      res.append(<span class="string">"--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这时候我们就可以使用二分搜索树来实现集合了，很简单，直接封装一个二分搜索树然后调用方法就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 21:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BinarySearchTree&lt;E&gt; binarySearchTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.binarySearchTree = <span class="keyword">new</span> BinarySearchTree&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用链表来实现集合"><a href="#使用链表来实现集合" class="headerlink" title="使用链表来实现集合"></a>使用链表来实现集合</h2><p>  链表中有一个contains方法，我们可以在调用add方法的时候使用contains方法判断原来集合中是否已经存在该元素了，如果已经存在那么就添加失败。其他的也是直接调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 10:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否已经存在该元素</span></span><br><span class="line">    <span class="keyword">if</span> (!linkedList.contains(e))&#123;</span><br><span class="line">      linkedList.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkedList.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树和链表实现集合的比较"><a href="#二分搜索树和链表实现集合的比较" class="headerlink" title="二分搜索树和链表实现集合的比较"></a>二分搜索树和链表实现集合的比较</h2><p>  在上面实现链表集合的时候我们很容易就会发现，链表集合的增加操作的时候需要先判断整个链表中是否存在该元素，那么这样就需要O(n)的时间复杂度了，在删除，查找元素的时候都是和普通链表一样O(n)的时间复杂度。可以说链表实现的集合的效率并不是很高。</p><p>  那么我们再来看一看二分搜索树实现的集合的时间复杂度。当我们添加元素的时候我们是依靠二分搜索树的特性来添加的</p><p>  <img src="/2019/05/13/集合与映射/1.jpg" alt="二分搜索树"></p><p>  比如我们需要添加一个元素的时候，我们就需要先判断大小，然后根据树的特性一层一层遍历，这个时候我们就会发现，我们的时间复杂度是和这个二分搜索树的高度呈线性关系的。</p><p>  <img src="/2019/05/13/集合与映射/2.jpg" alt="二分搜索树"></p><p>  <img src="/2019/05/13/集合与映射/3.jpg" alt="二分搜索树"></p><p>  然后我们通过运算就可以得出一个平衡二叉树h层一共有2的h次方-1个元素，我们就很容易得出时间复杂度为log2(n+1)，忽略常数，那么就是logn。</p><p>  <img src="/2019/05/13/集合与映射/4.jpg" alt="二分搜索树"></p><p>  而logn和n的差距在基数很大的时候差距特别明显</p><p>  <img src="/2019/05/13/集合与映射/5.jpg" alt="二分搜索树"></p><p>  所以说二分搜索树实现的集合会比链表实现的集合快很多。当然这也是考虑树的最好情况。当树不为平衡二叉树的时候，最坏情况也会是O(n)。</p><p>  <img src="/2019/05/13/集合与映射/6.jpg" alt="二分搜索树"></p><p>  如上图右边，我们看到当树成一边排列的时候，它的时间复杂度就是O(n)。</p><h2 id="LeetCode上解决关于集合的题目"><a href="#LeetCode上解决关于集合的题目" class="headerlink" title="LeetCode上解决关于集合的题目"></a>LeetCode上解决关于集合的题目</h2><p>  题目是这样的：</p><p>  <img src="/2019/05/13/集合与映射/7.jpg" alt="LeetCode804题目"></p><p>  对于这道题，我们可以遍历这个words数组，然后得到其中的某个元素再次遍历字符串的每个字母，然后通过原先定义的摩尔斯密码表数组和字符相对应，之后我们就可以获取到这个单词的摩尔斯密码，我们循环完一次之后，我们就把得到的摩尔斯密码拼接成字符串然后存入到set中，最终循环完成之后我们只要返回set的size就行了。</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 13:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预先定义摩尔斯密码表</span></span><br><span class="line">    String[] codes = &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length() ; i ++)&#123;</span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        stringBuilder.append(codes[word.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//存入set中</span></span><br><span class="line">      set.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是映射-Map-字典"><a href="#什么是映射-Map-字典" class="headerlink" title="什么是映射(Map,字典)"></a>什么是映射(Map,字典)</h2><ol><li><p>映射，在定义域中每一个值在值域都有一个值与他对应</p></li><li><p>存储(键，值)数据对的数据结构（Key，Value）</p></li><li><p>根据键(Key)，寻找值(Value)</p><p><img src="/2019/05/13/集合与映射/8.jpg" alt="映射的概念"></p></li></ol><h2 id="定义Map接口"><a href="#定义Map接口" class="headerlink" title="定义Map接口"></a>定义Map接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> key对应的value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">remove</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置相应key的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某个key对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否包含</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否包含</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取映射的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 映射大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断映射是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现Map"><a href="#链表实现Map" class="headerlink" title="链表实现Map"></a>链表实现Map</h2><p>  使用链表实现Map其实只需要将私有类Node里面的字段e更改为key和value就行。当然BinarySearchTree也是如此</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node next)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> key.toString() + <span class="string">" : "</span> + value.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">    Node currentNode = dummyHead.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.key.equals(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否已经存在该key的映射</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      dummyHead.next = <span class="keyword">new</span> Node(k, v, dummyHead.next);</span><br><span class="line">      size ++ ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果存在则更新</span></span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node preNode = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (preNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (preNode.next.key.equals(k))&#123;</span><br><span class="line">        Node delNode = preNode.next;</span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">        delNode.next = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        preNode = preNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否存在该key的映射，如果不存在则抛出异常</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(k + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树实现映射-Map"><a href="#二分搜索树实现映射-Map" class="headerlink" title="二分搜索树实现映射(Map)"></a>二分搜索树实现映射(Map)</h2><p>  对于BinarySearchTree来说实现Map也是利用它原先的方法</p><p>  代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//辅助方法，在删除，修改映射的value时候会用到</span></span><br><span class="line">  <span class="comment">//获取相应key对应的Node(递归)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果递归到节点为null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候继续递归该结点的左子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//大于的时候继续递归该结点的右子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不然就是相等，则直接返回该结点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归到最底层，直接添加节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候直接递归该结点的左子树</span></span><br><span class="line">      node.left = add(node.left, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="comment">   * 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode = node.right;</span><br><span class="line">      node.right = <span class="keyword">null</span>;</span><br><span class="line">      size --;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从二分搜索树中删除键为key的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      root = remove(root, key);</span><br><span class="line">      <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.left = remove(node.left , key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.right = remove(node.right, key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">      <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">      Node successor = minimum(node.right);</span><br><span class="line">      successor.right = removeMin(node.right);</span><br><span class="line">      successor.left = node.left;</span><br><span class="line"></span><br><span class="line">      node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(root, k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(root, k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表Map和二分搜索树Map比较"><a href="#链表Map和二分搜索树Map比较" class="headerlink" title="链表Map和二分搜索树Map比较"></a>链表Map和二分搜索树Map比较</h2><p>  测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testMap</span><span class="params">(Map&lt;String, Integer&gt; map, String filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    System.out.println(filename);</span><br><span class="line">    ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(FileOperation.readFile(filename, words)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Total words: "</span> + words.size());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String word : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(word))&#123;</span><br><span class="line">          map.set(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          map.add(word, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Total different words: "</span> + map.getSize());</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PRIDE: "</span> + map.get(<span class="string">"pride"</span>));</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PREJUDICE: "</span> + map.get(<span class="string">"prejudice"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String filename = <span class="string">"I:\\data_structure\\src\\pride-and-prejudice.txt"</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; bstMap = <span class="keyword">new</span> BinarySearchTreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time1 = testMap(bstMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"BST Map: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; linkedListMap = <span class="keyword">new</span> LinkedListMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time2 = testMap(linkedListMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"Linked List Map: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  两者时间差异:</p><p>  <img src="/2019/05/13/集合与映射/9.jpg" alt="测试结果"></p><p>  可以看出，二分搜索树实现的Map的时间性能是远高于链表实现的Map的。</p><p>  因为对于链表实现修改某一映射对应的value值的时间复杂度是O(n),我们需要一个一个去遍历知道找到key符合的元素。</p><p>  而对于二分搜索树实现的Map来说，它修改一个value的时间复杂度是跟二叉树的高度相关的，也就是说它的时间复杂度是O(logn)级别的，所以当数据量大的时候，二分搜索树的优势非常明显。当然我们还需要考虑最坏的情况，那就是这个二分搜索树变成了类似于链表的树，那这时候时间复杂度就是O(n)了。</p><p>  <img src="/2019/05/13/集合与映射/10.jpg" alt="两种map的时间复杂度比较"></p><p>  但是有个细节需要注意的是，链表实现的Map的key是无序的，上文中的set也是无序的。但是二分搜索树实现的set和map都是有序的(这也是它这么快的一部分原因)。</p><h2 id="使用Map来实现Set"><a href="#使用Map来实现Set" class="headerlink" title="使用Map来实现Set"></a>使用Map来实现Set</h2><p>  我们可以发现，其实Set就是一个没有value的的Map。所以，当我们底层实现了一个映射，集合我们就可以理解成Map&lt;K, V&gt;中value为null的情况，对于不管是k，它所对应的的value都为null。</p><p>  所以当我们在Map中只考虑K的时候，整个Map数据结构就变成了K的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是集合-Set&quot;&gt;&lt;a href=&quot;#什么是集合-Set&quot; class=&quot;headerlink&quot; title=&quot;什么是集合(Set)&quot;&gt;&lt;/a&gt;什么是集合(Set)&lt;/h2&gt;&lt;p&gt;  简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合RabbitMQ以及四种交换模式</title>
    <link href="https://francisqiang.github.io/2019/05/09/SpringBoot%E6%95%B4%E5%90%88RabbitMQ%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/</id>
    <published>2019-05-09T12:25:32.000Z</published>
    <updated>2019-05-09T16:35:49.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>  在google的时候发现知乎一个很好的回答，很生动形象。</p><p>  作者：ScienJus<br>  <a href="https://www.zhihu.com/question/34243607/answer/58314162" target="_blank" rel="noopener">原文链接</a></p><p>  个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。使用场景的话，举个例子：假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：校验用户名等信息，如果没问题会在数据库中添加一个用户记录如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他发送给用户一个包含操作指南的系统通知等等……但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了。</p><p>  我理解的消息队列就是当你的一个接口访问量大或者需要进行的操作很多，就比如注册这些功能(里面有发邮件，插入数据各种操作)，但是用户只需要知道是否注册成功，他们需要马上收到注册结果(提高用户体验性)，所以当用户的信息插入到数据库中我们就可以直接返回结果，至于后面的操作可以放入消息队列异步慢慢处理。</p><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><ul><li><p>maven配置</p><p>首先当然是maven配置了，springboot中为我们提供了amqp的start,amqp是一个消息队列的协议，RabbitMQ实现了这个协议。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>springboot配置文件的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">  password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">  virtual-host:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  listener:</span></span><br><span class="line"><span class="attr">    simple:</span></span><br><span class="line"><span class="attr">      concurrency:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      max-concurrency:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      prefetch:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      auto-startup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      default-requeue-rejected:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    retry:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      initial-interval:</span> <span class="number">1000</span><span class="string">ms</span></span><br><span class="line"><span class="attr">      max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      max-interval:</span> <span class="number">10000</span><span class="string">ms</span></span><br><span class="line"><span class="attr">      multiplier:</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>除了host，port什么的其他都可以不写，springboot已经默认帮我们配置好了。</p></li><li><p>RabbitMQ的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE,<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>消息发送者(提供者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"send"</span>);</span><br><span class="line">  <span class="comment">//标注需要发送的某个队列</span></span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.QUEUE,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息接收者(消费者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RabbitListener注解需要标注刚刚我们的队列名</span></span><br><span class="line"><span class="comment">//其作用就是监听那个队列是否有消息，有消息则接收</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.QUEUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span>+message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RabbitMQ的四种模式"><a href="#RabbitMQ的四种模式" class="headerlink" title="RabbitMQ的四种模式"></a>RabbitMQ的四种模式</h2><p>  RabbitMQ分为四种模式</p><pre><code>* Direct模式* Topic模式* Fanout模式* Headers模式</code></pre><ul><li><p>Direct模式(直接交换模式)</p><p>刚刚我们的配置类，接受者和发送者实现的就是Direct模式，其流程就是发送者指定一个Queue来发送消息给那个队列，然后消费者一直监听那个队列，有消息则接收</p></li><li><p>Topic模式</p></li></ul><p>首先是Topic的配置类，这里定义两个Queue，并且生成一个TopicExchange(Topic交换机)。</p><p>然后我们通过Binding来将A和B的消息队列绑定到我们刚刚生成的TopicExchange和指定routingKey中</p><p><img src="/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/1.jpg" alt="RabbitMQ的topic模式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE_A, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE_B, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBindingA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(topicQueueA()).to(topicExchange()).with(<span class="string">"topic.keyA"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBindingB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(topicQueueB()).to(topicExchange()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的消息发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicSend</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"topic send"</span>);</span><br><span class="line">  <span class="comment">//我们指定某个routingkey发送到这个交换机上</span></span><br><span class="line">  <span class="comment">//然后这个topic交换机会将我们的routingKey审核</span></span><br><span class="line">  <span class="comment">//如果这个key和某个队列绑定的key匹配那么这个消息就会发送到这个队列里</span></span><br><span class="line">  <span class="comment">//在队列绑定routingKey的时候可以使用#,*这些通配符,所以就会出现我发送一个消息，两个队列都收到了，我发送两个消息都是一个队列收到等情况，如图所示。</span></span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, <span class="string">"topic.keyA"</span>, message);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, <span class="string">"topic.keyB"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的消息消费者(接收者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收很简单，只要指定队列就行</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.TOPIC_QUEUE_A)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicReceiveA</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.TOPIC_QUEUE_B)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicReceiveB</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Fanout模式</li></ul><p>首先是Fanout的配置类,跟上面的topic查不到，我们先配置一个FanoutExchange类，然后通过Binding将队列绑定到那个Exchange中，我们可以绑定多个队列到Exchange中。</p><p><img src="/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/1.jpg" alt="RabbitMQ的topic模式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(FANOUT_QUEUE_A, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(FANOUT_QUEUE_B, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBindingA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueA()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBindingB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueB()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是我们的发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们只要将消息发送给交换机就好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutSend</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanout send"</span>);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class="string">""</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的消费者,这时候我们会发现这个Fanout模式就是类似于广播模式，我们将所有需要的队列都绑定上Fanout的Exchange中，然后我们发送者只需要将消息发送给Exchange，然后我们的消费者在所有的Queue中都能接收到消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.FANOUT_QUEUE_A)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutReceiveA</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanoutA receive:"</span>+message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.FANOUT_QUEUE_B)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutReceiveB</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanoutB receive:"</span>+message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Headers模式</li></ul><p>首先是我们的配置类，这个Header跟上面几种有些不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">headersQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(HEADERS_QUEUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeadersExchange <span class="title">headersExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前面两个和上述三种都差不多，这里的Binding有些不一样</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">headersBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  map.put(<span class="string">"HeadersAKey"</span>,<span class="string">"HeadersAValue"</span>);</span><br><span class="line">  map.put(<span class="string">"HeadersBKey"</span>,<span class="string">"HeadersBValue"</span>);</span><br><span class="line">  <span class="comment">//我们需要创建一个map存入键值对，然后绑定队列到交换机上，并且有个要求就是where什么什么加入map需要匹配，我们先看消息发送者</span></span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headersSend</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"headers send"</span>);</span><br><span class="line">  <span class="comment">//这里的发送者的发送方法需要的是一个交换机名称，还有一个就是Message对象</span></span><br><span class="line">  <span class="comment">//这个Message对象存入了真正消息的字符数组和消息的配置类，这里的消息配置类就是MessageProperties</span></span><br><span class="line">  <span class="comment">//我们需要对这个MessageProperties设置头，这个头就是键值对，就是我们配置类设置的map</span></span><br><span class="line">  <span class="comment">//我们发送消息给队列，这个消息的头被设置为我配置类书写的那两个map才行，因为我设置了whereAll.match，所以我发送消息给交换机，这个交换机会帮我去匹配请求头和我设置的符合的Queue并把消息存入那个队列中</span></span><br><span class="line">  MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">  messageProperties.setHeader(<span class="string">"HeadersAKey"</span>,<span class="string">"HeadersAValue"</span>);</span><br><span class="line">  messageProperties.setHeader(<span class="string">"HeadersBKey"</span>,<span class="string">"HeadersBValue"</span>);</span><br><span class="line">  Message headersMessage = <span class="keyword">new</span> Message(message.getBytes(),messageProperties);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.HEADERS_EXCHANGE, <span class="string">""</span>, headersMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个时候我们接收的就是字符数组了，因为我们再发送者的方法中是将消息变成byte[]再作为参数进行入队的</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.HEADERS_QUEUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headersReceive</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"headers receive:"</span>+<span class="keyword">new</span> String(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是消息队列&quot;&gt;&lt;a href=&quot;#什么是消息队列&quot; class=&quot;headerlink&quot; title=&quot;什么是消息队列&quot;&gt;&lt;/a&gt;什么是消息队列&lt;/h2&gt;&lt;p&gt;  在google的时候发现知乎一个很好的回答，很生动形象。&lt;/p&gt;
&lt;p&gt;  作者：ScienJu
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://francisqiang.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>二分搜索树的遍历</title>
    <link href="https://francisqiang.github.io/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://francisqiang.github.io/2019/05/06/二分搜索树的遍历/</id>
    <published>2019-05-06T08:46:46.000Z</published>
    <updated>2019-05-06T09:27:53.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分搜索树的遍历"><a href="#二分搜索树的遍历" class="headerlink" title="二分搜索树的遍历"></a>二分搜索树的遍历</h2><p>  其实这里就是二叉树的遍历，只是因为二分搜索树因为是依靠它的特定规则而排列的，所以再经过不同方法遍历之后，它的顺序会有很多特点。</p><p>  我们是依靠根节点顺序来命名的，记住！是根结点。</p><p>  前序遍历就是先遍历根结点，然后遍历左结点，最后遍历右结点。</p><p>  中序遍历就是先遍历左结点，然后遍历根结点，最后遍历右结点。</p><p>  后序遍历就是先遍历左结点，然后遍历右结点，最后遍历根结点。</p><p>  最后要注意，这个提示可能不是适合所有人，对于我来说，我书写一个二叉树的前中后序遍历的时候都告诫自己要等待一个结点能遍历的时候才能遍历，什么意思呢？就是要遍历一个结点的时候需要把它的子节点先遍历了（子节点优先遍历），其实这个前中后序遍历另一个名字就是深度优先遍历，跟这个有关。</p><p>  慕课网中有另一种快速书写三种遍历方式遍历后的顺序结果的方法，如图:</p><p>  <img src="/2019/05/06/二分搜索树的遍历/1.jpg" alt="三种深度优先遍历"></p><p>  它是在每个结点上画上三个点，然后不管什么遍历方式都从根节点到左节点到右节点的方式遍历(比较图中)，每个结点其实都会经过三次，当中序遍历就去中间的点作为顺序参照，前序遍历就取左边的点作为顺序参照，后序遍历就取右边的点作为顺序参照。</p><p>  如果中序和后序的图看不懂，那么就将前序遍历那些顺序线放入中序和后序的图中，然后根据那个顺序线依次找蓝色的点，最后这些点连接成的就是遍历顺序了。</p><h2 id="深度优先遍历的递归代码实现"><a href="#深度优先遍历的递归代码实现" class="headerlink" title="深度优先遍历的递归代码实现"></a>深度优先遍历的递归代码实现</h2><p>  前面说了，前中后序遍历都可以称为深度优先遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//先打印根节点</span></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    <span class="comment">//然后遍历左节点</span></span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    <span class="comment">//遍历右结点</span></span><br><span class="line">    preOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//优先遍历左节点</span></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//先遍历左节点</span></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    <span class="comment">//然后遍历右结点</span></span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    <span class="comment">//最后遍历根结点</span></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归实现深度优先遍历很简单，只需要记住顺序就行了。</p><h2 id="非递归实现前序遍历"><a href="#非递归实现前序遍历" class="headerlink" title="非递归实现前序遍历"></a>非递归实现前序遍历</h2><p>  其实非递归实现前序遍历就是模拟系统方法栈，这时候我们不通过递归，我们就要自己使用栈来实现前序遍历。</p><p>  比如说我们需要将一个树前序遍历，这时候我们先将根结点放入我们new的一个栈中，然后我们把栈中这个结点元素取出来，对它进行打印(或者其他操作)，然后我们将它的右孩子，左孩子依次放入栈中(因为栈是先进后出)。然后我们再次取出栈中的一个元素，这时候我们取的是根结点的左孩子，然后我们对这个节点进行打印，然后把这个结点的右左孩子依次放入栈中，继续进行出栈操作。。。</p><p>  <img src="/2019/05/06/二分搜索树的遍历/2.jpg" alt="非递归实现前序遍历"></p><p>  代码实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归实现前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perOrderWithoutRecurrence</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//栈中元素不为空那么就出栈操作</span></span><br><span class="line">    Node currentNode=stack.pop();</span><br><span class="line">    System.out.println(currentNode.e);</span><br><span class="line">    <span class="comment">//依次将右左孩子放入栈中</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(currentNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(currentNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p>  层序遍历又是广度优先遍历，它是将树一层一层地进行遍历的。</p><p>  <img src="/2019/05/06/二分搜索树的遍历/3.jpg" alt="广度优先遍历"></p><p>  比如上图，我们广度优先遍历（层序遍历）的顺序就是28,16,30,13,22,29,42.</p><p>  我们如何实现呢？其实我们这时候需要一个队列，这个队列里将根结点放入，然后把根结点取出来进行操作（同时也要将队列里的根节点删除，后面的结点被取出来的时候也要删除），然后把根节点的左孩子，右孩子依次进行入队，这时候我们再取出队列里的第一个元素（根节点的左孩子结点），然后我们对它进行操作并删除队列里它的元素，然后将他的左右孩子依次入队，之后我们再取出来队列的第一个元素（根节点的右孩子），后面依次同上操作，如图所示。</p><p>  代码实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层序遍历(广度优先遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">      Node currentNode=queue.remove();</span><br><span class="line">      System.out.println(currentNode.e);</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(currentNode.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(currentNode.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分搜索树的遍历&quot;&gt;&lt;a href=&quot;#二分搜索树的遍历&quot; class=&quot;headerlink&quot; title=&quot;二分搜索树的遍历&quot;&gt;&lt;/a&gt;二分搜索树的遍历&lt;/h2&gt;&lt;p&gt;  其实这里就是二叉树的遍历，只是因为二分搜索树因为是依靠它的特定规则而排列的，所以再经过不
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二分搜索树的增删改查</title>
    <link href="https://francisqiang.github.io/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>https://francisqiang.github.io/2019/05/06/二分搜索树的增删改查/</id>
    <published>2019-05-06T05:01:10.000Z</published>
    <updated>2019-05-06T05:49:32.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是二分搜索树"><a href="#什么是二分搜索树" class="headerlink" title="什么是二分搜索树"></a>什么是二分搜索树</h2><p>  首先我们要先知道二叉树是什么，二叉树其实就是从一个根节点左右两端延伸出左右结点，延伸出的结点再次延伸出结点，然后一直延伸下去，所以树这种数据结构天生满足递归特性。</p><p>  而二分搜索树就是对二叉树做了一个限制，首先二分搜索树中的元素必须是可比较的（对于Java来说就是必须继承Comparable接口）。为什么需要它可比较呢？就是因为，二分搜索树的排列需要根据数值来排列。</p><p>  二分搜索树的某个结点的左孩子必须小于原来的节点且某个结点的左子树的所有结点必须比这个结点小。</p><p>  右边同上。</p><p>  <img src="/2019/05/06/二分搜索树的增删改查/1.jpg" alt="什么是二分搜索树和二叉树"></p><h2 id="二分搜索树的基本定义"><a href="#二分搜索树的基本定义" class="headerlink" title="二分搜索树的基本定义"></a>二分搜索树的基本定义</h2><p>  根据上面的定义，我们很容易就能写出代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node left,right;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      left=<span class="keyword">null</span>;</span><br><span class="line">      right=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root=<span class="keyword">null</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树的一些方法"><a href="#二分搜索树的一些方法" class="headerlink" title="二分搜索树的一些方法"></a>二分搜索树的一些方法</h2><ul><li>首先就是getSize()和isEmpty()方法，很容易，返回size和判断size是否为0就行了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>添加元素</p><p>添加元素的时候我们只需要在树的叶子节点中添加就行了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果根节点为空，那么直接new</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        add(root,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果这个结点不等于这个时候才能添加元素</span></span><br><span class="line">  <span class="keyword">if</span> (!e.equals(node.e))&#123;</span><br><span class="line">    <span class="comment">//如果插入元素小于该结点的元素且该结点的左孩子为空</span></span><br><span class="line">    <span class="comment">//那么直接插入左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>&amp;&amp;node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      node.left=<span class="keyword">new</span> Node(e);</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个同上</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>&amp;&amp;node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      node.right=<span class="keyword">new</span> Node(e);</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果小于，那么就递归调用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      add(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//同上</span></span><br><span class="line">      add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当然添加方法还有优化的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">  add(root,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//该结点为空，那么直接返回给上一级new出来的元素为e的节点，这里就是添加，只是现在遍历到最后了而已</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如果小于，那么该结点的左孩子就是下一层二分搜索树的添加元素后的二分搜索树</span></span><br><span class="line">    node.left=add(node.left,e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如果大于，那么该结点的右孩子就是下一层二分搜索树的添加元素后的二分搜索树</span></span><br><span class="line">    node.right=add(node.right,e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最后return被添加过结点的根节点</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>查询元素</p><ul><li><p>这里就是判断二分搜索树是否包含某个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果该树的根节点就是空，那么直接false</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果查询到了那么返回该结点</span></span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//小于的时候遍历左孩子树</span></span><br><span class="line">    <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//大于的时候遍历右孩子树</span></span><br><span class="line">    <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取最小元素和最大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当树的大小为0就不能删除</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当遍历到最后的某个结点的左孩子为null，那么这个结点就是最小元素</span></span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除元素，其中删除元素是最复杂的，对于删除最小最大元素来说并不复杂，因为只需要往左往右遍历二分搜索树就行了，但是对于任意元素的删除就要考虑多种情况。</p><ul><li>删除最小元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> removeMin(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果左孩子为空，那么这个结点就是要删除的结点</span></span><br><span class="line">  <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//将该结点的右子树放入临时变量</span></span><br><span class="line">    Node rightNode=node.right;</span><br><span class="line">    <span class="comment">//将这个结点的右子树置为null，然后返回刚刚的临时变量rightNode</span></span><br><span class="line">    node.right=<span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> rightNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不然就一直向左遍历，并且将下一级删除后返回的二分搜索树赋值给上一级的结点</span></span><br><span class="line">  node.left=removeMin(node.left);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除最大元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> removeMax(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">    Node leftNode=node.left;</span><br><span class="line">    node.left=<span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> leftNode;</span><br><span class="line">  &#125;</span><br><span class="line">  node.right=removeMax(node.right);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除某个结点</li></ul><p>我们可以通过寻找需要被删除节点的后继或者前驱，并且把它从原来树中删除然后代替被删除节点的位置</p><p><img src="/2019/05/06/二分搜索树的增删改查/2.jpg" alt="通过后继删除元素"></p><p><img src="/2019/05/06/二分搜索树的增删改查/3.jpg" alt="通过前驱删除元素"></p><p>这里我只写了通过后继删除某个元素，当然前驱书写方式也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">  root=remove(root,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    node.left=remove(node.left,e);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    node.right=remove(node.right,e);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果相等就要删除</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//首先判断这个树是不是只有一边的孩子</span></span><br><span class="line">    <span class="comment">//如果只有左边有孩子或者只有右边有孩子</span></span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//如果只有左子树</span></span><br><span class="line">      <span class="comment">//那么我们将该结点的左子树返回给上一节点的左子树</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> node.left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左右都有孩子</span></span><br><span class="line">    <span class="comment">//寻找该节点的后继节点</span></span><br><span class="line">    <span class="comment">//后继结点就是离该结点最近的节点（数值最近而且是大于该节点）</span></span><br><span class="line">    <span class="comment">//那么这个结点的后继结点就是该节点右孩子的最小结点</span></span><br><span class="line">    Node successorNode=minimum(node.right);</span><br><span class="line">    <span class="comment">//我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子</span></span><br><span class="line">    successorNode.right=removeMin(node.right);</span><br><span class="line">    successorNode.left=node.left;</span><br><span class="line">    node.left=node.right=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> successorNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是二分搜索树&quot;&gt;&lt;a href=&quot;#什么是二分搜索树&quot; class=&quot;headerlink&quot; title=&quot;什么是二分搜索树&quot;&gt;&lt;/a&gt;什么是二分搜索树&lt;/h2&gt;&lt;p&gt;  首先我们要先知道二叉树是什么，二叉树其实就是从一个根节点左右两端延伸出左右结点，延伸出的
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Git中.gitignore文件修改后不起作用</title>
    <link href="https://francisqiang.github.io/2019/05/05/Git%E4%B8%AD-gitignore%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>https://francisqiang.github.io/2019/05/05/Git中-gitignore文件修改后不起作用/</id>
    <published>2019-05-05T08:18:50.000Z</published>
    <updated>2019-05-05T08:33:17.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>  当我使用git上传项目的时候，有些本应该忽略的文件没有被忽略，这时候我修改.gitignore文件再次上传的时候，本该忽略的文件还是在那里</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>  这是因为git缓存的原因，如果某些文件已经被纳入版本管理中，就算是在.gitignore文件中声明了忽略文件的路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再add和push。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol><li><p>首先清除本地缓存<br>git rm -r –cached .</p></li><li><p>再次add文件<br>git add .</p></li><li><p>提交<br>git commit -m “chore:update .gitignore”</p></li><li><p>push<br>git push</p></li></ol><h2 id="gitignore书写格式"><a href="#gitignore书写格式" class="headerlink" title=".gitignore书写格式"></a>.gitignore书写格式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;  当我使用git上传项目的时候，有些本应该忽略的文件没有被忽略，这时候我修改.gitignore文件再次上传的时候，本该忽
      
    
    </summary>
    
      <category term="Git" scheme="https://francisqiang.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>从源文件到可执行文件</title>
    <link href="https://francisqiang.github.io/2019/05/05/%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://francisqiang.github.io/2019/05/05/从源文件到可执行文件/</id>
    <published>2019-05-05T05:36:18.000Z</published>
    <updated>2019-05-05T07:04:04.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>  这篇文章是我阅读《程序是怎样跑起来的》这本书第八章后写的读后感，也说不上读后感，就是把原文一些东西整理一下，方便日后阅读记忆。学校图书馆真是一个好地方，原本以为没有什么好的图书，后面去借阅几次发现了很多好书，这本书也是我在图书馆中借阅的。</p><h2 id="计算机只能运行本地代码"><a href="#计算机只能运行本地代码" class="headerlink" title="计算机只能运行本地代码"></a>计算机只能运行本地代码</h2><p>  什么是源文件和源代码，就是使用某种编程语言编写的程序就称为源代码，保存源代码的文件就是源文件。比如说以.c或者.java为扩展名的文件就是源文件。</p><p>  但是源文件是无法直接运行的，这是因为CPU能直接解析并运行的不是源代码而是本地代码的程序。</p><p>  本地(native)，对于CPU来说就是母语的意思，任何编程语言编写的源代码最后都要翻译成本地代码，否则CPU就看不懂。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/1.jpg" alt="转换为本地代码后就变成了同样的语言"></p><h2 id="本地代码的内容"><a href="#本地代码的内容" class="headerlink" title="本地代码的内容"></a>本地代码的内容</h2><p>  比如说Windows中的EXE文件里面就是本地代码。</p><p>  我们使用文本工具打开exe文件可以看到类似下图的代码</p><p>  <img src="/2019/05/05/从源文件到可执行文件/2.jpg" alt="用记事本打卡exe文件"></p><p>  这时候我们将它转变成十六进制</p><p>  <img src="/2019/05/05/从源文件到可执行文件/3.jpg" alt="转换为十六进制"></p><p>  计算机指令也是数值的罗列，这些就是本地代码。</p><h2 id="编译器负责转换源代码"><a href="#编译器负责转换源代码" class="headerlink" title="编译器负责转换源代码"></a>编译器负责转换源代码</h2><p>  能够把C语言等高级语言转换为本地代码的程序成为编译器，相当于现实中的翻译，每个编程语言都需要专用的编译器，C语言的就叫C编译器，这类似于现实中中文翻译成英文需要专业的英文翻译者。</p><p>  编译器读入代码内容，然后通过一些对照表把源代码对照翻译成本地代码，当然不仅仅是这么简单，其中还有语法解析，句法解析，语义解析等等，最后才能生成本地代码。</p><p>  根据CPU的不同，本地代码的类型也不同，所以编译器不仅和编程语言相关还和CPU相关，列入x86系列的CPU用的C编译器就和PowerPC这种CPU的C编译器不同。</p><p>  还有就是编译器也是一种程序，所以也需要运行环境，那么windows用的C编译器和Linux用的C编译器就不同。还有就是交叉编译器，他生产的是和运行环境中的CPU不同的CPU所使用的的本地代码。</p><h2 id="仅靠编译时无法得到可执行文件的"><a href="#仅靠编译时无法得到可执行文件的" class="headerlink" title="仅靠编译时无法得到可执行文件的"></a>仅靠编译时无法得到可执行文件的</h2><p>  C和C++中编译之后生成的是.obj目标文件，这时候还需要链接才能得到可执行的exe文件。</p><p>  比如说我们书写了一个函数</p><p>  <img src="/2019/05/05/从源文件到可执行文件/4.jpg" alt="代码"><br>  <img src="/2019/05/05/从源文件到可执行文件/5.jpg" alt="代码"></p><p>  其中我们调用了MessageBox函数，sprintf函数。但是在我们的源代码中没有这两个函数的相关实现，比如这个文件生成的是sample.obj，那么这个文件就需要和MessageBox，sprintf的目标文件相结合(链接)，才能生成完整的程序。试想一下这个sample是exe文件，那么这个文件就是不完整的，是无法执行的。</p><p>  运行连接的程序就称为链接器。</p><h2 id="启动及库文件"><a href="#启动及库文件" class="headerlink" title="启动及库文件"></a>启动及库文件</h2><p>  当我们执行上述sample.c文件的编译 链接操作的时候，我们需要指定两个文件。一个是sample.obj生成的目标文件，另一个是C0w32.obj文件，这个文件是记录着同所有程序气死位置相结合的处理内容，程序程序的启动。</p><p>  后面我们还需要指定库文件，比如说32.lib cw32.lib库文件，这里面存放着sprintf函数的目标文件和MessageBox函数的目标文件(实际上是在 user32.dll文件中，这是动态链接库)</p><p>  链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件</p><p>  <img src="/2019/05/05/从源文件到可执行文件/6.jpg" alt="编译链接的命令"></p><p>  如果不指定库文件就会发生无法识别sprintf函数和MessageBox函数的错误</p><p>  <img src="/2019/05/05/从源文件到可执行文件/7.jpg" alt="编译器报错"></p><h2 id="DLL文件及导入库"><a href="#DLL文件及导入库" class="headerlink" title="DLL文件及导入库"></a>DLL文件及导入库</h2><p>  Windows以函数的形式为应用提供了各种功能，这些函数被称为API(Application Programming Interface应用程序接口)  上面讲到的MessageBox()函数并不是C语言的标准库函数，而是Windows提供的API，这些API的目标文件存储在名为DLL(Dynamic Link Library)文件的特殊库文件中，它是程序运行动态结合的文件，上面我们提到MessageBox的目标文件存储在import32.lib文件中，其实这个文件只存储了两个信息——MessageBox()存储在user32.dll文件中，还有就是这个dll文件的文件夹信息。</p><p>  我们把类似于import32.lib这样的库文件称为导入库。</p><p>  DLL文件的好处：DLL文件中的函数可以被多个程序共用，因此借助该功能可以节约内存和磁盘。此外，在对函数的内容做修正的时候不需要重新连接(静态链接)。</p><p>  另一个就是静态链接库，就是sprintf，存储着sprintf()的cw32.lib就是静态链接库。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/8.jpg" alt="windows中编译和链接机制"></p><h2 id="可执行文件运行时的必要条件"><a href="#可执行文件运行时的必要条件" class="headerlink" title="可执行文件运行时的必要条件"></a>可执行文件运行时的必要条件</h2><p>  存储在硬盘中的exe文件运行时要读入内存中执行，在exe文件中我们会给变量和函数分配虚拟的内存地址，在程序运行的时候，这些虚拟内存地址会转换为实际内存地址，链接器会在exe文件的开头，追加转换内存地址所需的必要信息，这个信息称为再配置信息。</p><p>  可以这么理解，再配置信息里存放了变量和函数的相对地址，这个相对地址就是相对于基地址的偏移量，这样各个变量的内存地址就可以用变量组的基地址加上偏移量作为地址，而这些基地址是在程序运行时被计算机分配的。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/9.jpg" alt="链接后的exe文件构造"></p><h2 id="程序加载时会生成堆和栈"><a href="#程序加载时会生成堆和栈" class="headerlink" title="程序加载时会生成堆和栈"></a>程序加载时会生成堆和栈</h2><p>  当程序加载到内存中，出再配置信息，变量组，函数组等还会额外生成两个组，那就是堆和栈。栈是用来存储函数内部使用的临时变量以及函数调用时所用的参数的内存区域。堆是用来存储程序运行时的任意数据和对象的内存领域。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/10.jpg" alt="内存中的组"></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>  对于栈来说，它会在函数调用的时候自动分配内存，在函数执行完毕后自动释放内存。但是对于堆来说，C语言需要程序员使用malloc申请分配，free()函数来释放，C++中需要使用new来申请分配，delete来释放，Java和C#这些语言户进行自动垃圾回收，如果我们忘记释放内存，那么这个内存空间就会一直被使用，久而久之就会造成内存泄露(memory leak)从而导致内存不足而卡死，就比如一晚上忘关水龙头，水盆中的水装满并溢出一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于本文&quot;&gt;&lt;a href=&quot;#关于本文&quot; class=&quot;headerlink&quot; title=&quot;关于本文&quot;&gt;&lt;/a&gt;关于本文&lt;/h2&gt;&lt;p&gt;  这篇文章是我阅读《程序是怎样跑起来的》这本书第八章后写的读后感，也说不上读后感，就是把原文一些东西整理一下，方便日后阅读
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="https://francisqiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis插入字段并返回主键的小问题</title>
    <link href="https://francisqiang.github.io/2019/05/04/Mybatis%E6%8F%92%E5%85%A5%E5%AD%97%E6%AE%B5%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/05/04/Mybatis插入字段并返回主键的小问题/</id>
    <published>2019-05-04T14:54:14.000Z</published>
    <updated>2019-05-04T15:07:58.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>  这几天在写秒杀项目，其中有一个需求是生成订单并返回订单号（主键）然后再生成秒杀订单将刚刚返回的订单号作为某个字段插入秒杀订单中，也就是秒杀订单表中的order_id。这其中就使用到了插入信息并返回主键。</p><p>  我使用的是Mybatis逆向工程生成的Mapper文件，其中自动生成的insert方法返回的是影响的行数，我在使用的时候一直返回给我的是1，导致报错。</p><h2 id="相关Mapper的编写"><a href="#相关Mapper的编写" class="headerlink" title="相关Mapper的编写"></a>相关Mapper的编写</h2><p>  其中最关键的就是在insert标签上增加useGeneratedKeys和keyProperty</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertOrderAndReturnOrderId"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">parameterType</span>=<span class="string">"com.lgq.miaosha.domain.OrderInfo"</span>&gt;</span></span><br><span class="line">  insert into t_order_info (id, user_id, goods_id,</span><br><span class="line">  delivey_addr_id, goods_name, goods_count,</span><br><span class="line">  goods_price, order_channel, status,</span><br><span class="line">  create_date, pay_date)</span><br><span class="line">  values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=BIGINT&#125;, #&#123;goodsId,jdbcType=BIGINT&#125;,</span><br><span class="line">  #&#123;deliveyAddrId,jdbcType=BIGINT&#125;, #&#123;goodsName,jdbcType=VARCHAR&#125;, #&#123;goodsCount,jdbcType=INTEGER&#125;,</span><br><span class="line">  #&#123;goodsPrice,jdbcType=DECIMAL&#125;, #&#123;orderChannel,jdbcType=TINYINT&#125;, #&#123;status,jdbcType=TINYINT&#125;,</span><br><span class="line">  #&#123;createDate,jdbcType=TIMESTAMP&#125;, #&#123;payDate,jdbcType=TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  其中keyProperty=”id”，这个id就是传入对象中的某个属性值，比如说这里就是OrderInfo对象，执行成功之后就会自动将主键的值赋给对象中的id属性。然后原本作为参数的OrderInfo对象中的id就得到了更新，这时候我们再取这个对象的id字段就可以获取到主键的值了。</p><h2 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成订单</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> user 用户</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> goodsVo 商品</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 订单详情</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">createOrder</span><span class="params">(User user, GoodsVo goodsVo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里主要就是生成OrderInfo对象</span></span><br><span class="line">    OrderInfo orderInfo=<span class="keyword">new</span> OrderInfo();</span><br><span class="line">    orderInfo.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">    orderInfo.setDeliveyAddrId(<span class="number">0L</span>);</span><br><span class="line">    orderInfo.setGoodsCount(<span class="number">1</span>);</span><br><span class="line">    orderInfo.setGoodsId(goodsVo.getId());</span><br><span class="line">    orderInfo.setGoodsName(goodsVo.getGoodsName());</span><br><span class="line">    orderInfo.setGoodsPrice(goodsVo.getMiaoshaPrice());</span><br><span class="line">    <span class="keyword">byte</span> b=<span class="number">1</span>;</span><br><span class="line">    orderInfo.setOrderChannel(b);</span><br><span class="line">    b=<span class="number">0</span>;</span><br><span class="line">    orderInfo.setStatus(b);</span><br><span class="line">    orderInfo.setUserId(user.getId());</span><br><span class="line">    <span class="comment">//插入订单</span></span><br><span class="line">    orderInfoMapper.insertOrderAndReturnOrderId(orderInfo);</span><br><span class="line">    <span class="comment">//最关键的一步</span></span><br><span class="line">    <span class="comment">//获取到刚刚对象中的id字段就是主键的值了</span></span><br><span class="line">    Long orderId=orderInfo.getId();</span><br><span class="line">    MiaoshaOrder miaoshaOrder=<span class="keyword">new</span> MiaoshaOrder();</span><br><span class="line">    miaoshaOrder.setGoodsId(goodsVo.getId());</span><br><span class="line">    <span class="comment">//这里不是很严谨，意思是将MiaoShaOrder的id设置成和OrderInfo的id一样</span></span><br><span class="line">    miaoshaOrder.setId(orderId);</span><br><span class="line">    miaoshaOrder.setUserId(user.getId());</span><br><span class="line">    <span class="comment">//将miaosha_order表中的order_id字段设置为order_id表中的主键</span></span><br><span class="line">    miaoshaOrder.setOrderId(orderId);</span><br><span class="line">    miaoshaOrderMapper.insert(miaoshaOrder);</span><br><span class="line">    <span class="keyword">return</span> orderInfo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用背景&quot;&gt;&lt;a href=&quot;#使用背景&quot; class=&quot;headerlink&quot; title=&quot;使用背景&quot;&gt;&lt;/a&gt;使用背景&lt;/h2&gt;&lt;p&gt;  这几天在写秒杀项目，其中有一个需求是生成订单并返回订单号（主键）然后再生成秒杀订单将刚刚返回的订单号作为某个字段插入秒杀
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://francisqiang.github.io/categories/Mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="https://francisqiang.github.io/2019/05/03/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
    <id>https://francisqiang.github.io/2019/05/03/SpringBoot整合Redis/</id>
    <published>2019-05-03T15:00:57.000Z</published>
    <updated>2019-05-03T15:36:05.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>  最近在写一个秒杀的项目，是跟着慕课网的一个教程学习的。其中用到了redis进行session共享等等功能，现如今做到的步骤是使用redis将用户信息存入redis中，并且同时将用户的唯一token值存入cookie中（cookie的有效期和redis键值的有效期一样），当我们用户跳转到某个页面的时候，先查询cookie中是否存在键值为user的cookie，如果存在就获取到cookieValue（token值），然后通过这个token作为键去查询redis中查找对应token的用户信息。</p><p>  五一玩了几天，这几天没怎么进食新东西，今天趁着假期学校不熄灯，继续写一篇博客。</p><h2 id="引入依赖和配置变量"><a href="#引入依赖和配置变量" class="headerlink" title="引入依赖和配置变量"></a>引入依赖和配置变量</h2><p>  首先是pom.xml的依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后我们需要在application.yaml文件中写入redis的配置环境</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">host:</span> <span class="number">119.82</span><span class="number">.123</span><span class="number">.134</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h2 id="配置类的编写"><a href="#配置类的编写" class="headerlink" title="配置类的编写"></a>配置类的编写</h2><p>  编写RedisConfig配置类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里是引入刚刚yaml文件的配置变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;redis.host&#125;"</span>) String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;redis.port&#125;"</span>) <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//引入JedisConnection工厂，主要负责的是redis的连接</span></span><br><span class="line">  <span class="comment">//其中要设置地址和端口号</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisStandaloneConfiguration redisStandaloneConfiguration = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">    redisStandaloneConfiguration.setHostName(host);</span><br><span class="line">    redisStandaloneConfiguration.setPort(port);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory(redisStandaloneConfiguration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//配置redis模板，这个主要是进行一些redis的操作，就像jdbc的模板类一样</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">    RedisTemplate&lt;String,Object&gt; redisTemplate=<span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(factory);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关操作的编写"><a href="#相关操作的编写" class="headerlink" title="相关操作的编写"></a>相关操作的编写</h2><p>  关于redis的操作有很多，我也学的不是很好，这里面只写了最简单的set和get</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-18 23:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引入刚刚我们设置的redis模板</span></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这是redis单独印出来的string的模板——因为对于redis的操作大部分都是以String类型为基础的，这里没有用到</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 往redis中缓存数据,这里使用T模板更加灵活</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,T value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将value对象转换为json字符串</span></span><br><span class="line">    String jsonString=beanToString(value);</span><br><span class="line">    <span class="comment">//valueOperations用来set和get 它是由redisTemplate产生的</span></span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">//这里是将value对象转换为jsonString，因为项目中User是一个java对象</span></span><br><span class="line">    valueOperations.set(key,jsonString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 往redis中缓存数据并加上过期时间</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> time 过期时间，秒</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,T value,<span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个方法跟上面差不多，多加了一个设置过期时间，为的是与项目需求设置redis过期时间和cookie相等</span></span><br><span class="line">    String jsonString=beanToString(value);</span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    valueOperations.set(key, jsonString, time,TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从redis1中获取数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">//这里其实获取的是存在redis中对象的json字符串</span></span><br><span class="line">    Object object=valueOperations.get(key);</span><br><span class="line">    <span class="comment">//如果获取的不为空，那么就像这个json字符串转换为java对象</span></span><br><span class="line">    <span class="keyword">if</span> (object!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> stringToBean(object.toString(),clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取为空就return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将对象转换为json</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> json数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>  &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; clazz=value.getClass();</span><br><span class="line">    <span class="comment">//如果value是int类型或者Integer类型的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (clazz==<span class="keyword">int</span>.class||clazz==Integer.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz==String.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> (String)value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (clazz==<span class="keyword">long</span>.class||clazz==Long.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将jsonString转换为java的对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jsonString json字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz 类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> java对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String jsonString,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (jsonString==<span class="keyword">null</span>||jsonString.length()&lt;=<span class="number">0</span>||clazz==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)Integer.valueOf(jsonString);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)jsonString;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">      <span class="keyword">return</span>  (T)Long.valueOf(jsonString);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(jsonString), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码使用了阿里巴巴的fastJson作为json和java对象转换的工具，具体的pom依赖为:</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  对于这个SpringBoot整合Redis虽然是跟着视频写的，但是也踩了很多坑，因为版本更新非常快，我使用的SpringBoot和Redis都是最新版的，很多地方配置和代码书写都和视频中和网上绝大数整合教程不相同，我也是查看很多资料才写好这个整合的，对于英文文档不感冒是真的吃亏，所以英语能力一定要提高！！！</p><p>  还有就是在整合redis的时候，如果连接的是远程服务器中的redis的话一定要更改服务器上的redis.conf文件，最重要的两点就是将bind后面的地址修改或者直接注释掉bind那一行配置，还有就是将protected-mode更改为no，不然远程电脑连接不上。</p><p>  当然还有很多细节问题都需要注意，留下这篇文章作为踩坑记录，希望下面敲代码的日子会越来越顺利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;p&gt;  最近在写一个秒杀的项目，是跟着慕课网的一个教程学习的。其中用到了redis进行session共享等等功能，现如今做到的步
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://francisqiang.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>链表和递归</title>
    <link href="https://francisqiang.github.io/2019/04/28/%E9%93%BE%E8%A1%A8%E5%92%8C%E9%80%92%E5%BD%92/"/>
    <id>https://francisqiang.github.io/2019/04/28/链表和递归/</id>
    <published>2019-04-28T11:58:04.000Z</published>
    <updated>2019-04-28T13:18:33.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从一道leetcode题目开始"><a href="#从一道leetcode题目开始" class="headerlink" title="从一道leetcode题目开始"></a>从一道leetcode题目开始</h2><p>  题目描述：</p><p>  <img src="/2019/04/28/链表和递归/1.jpg" alt="avatar"></p><p>  看一下题目内容其实很简单就是删除一个链表中值为val的所有节点并且返回被删除完的链表。</p><p>  上篇文章讲了如何进行链表操作，这时候我们其实就可以通过老方法遍历整个链表，然后通过比较每个节点的值和val的值是否相等，相等则删除，不相等则保留。</p><p>  示例代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="comment">//这里的ListNode是leetcode给定的，里面包含next和val字段</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个虚拟头结点</span></span><br><span class="line">    ListNode virtualNode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//虚拟头结点的next节点是头结点</span></span><br><span class="line">    virtualNode.next=head;</span><br><span class="line">    <span class="comment">//将虚拟头结点赋值给currentNode当前节点</span></span><br><span class="line">    ListNode currentNode=virtualNode;</span><br><span class="line">    <span class="keyword">while</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//通过遍历当前节点来删除元素</span></span><br><span class="line">      <span class="keyword">if</span> (currentNode.next.val==val)&#123;</span><br><span class="line">        <span class="comment">//如果当前头结点的next元素的val值等于给定的val</span></span><br><span class="line">        <span class="comment">//则将当前节点的next元素直接指向next的next</span></span><br><span class="line">        <span class="comment">//那么原来next节点就直接被删除了</span></span><br><span class="line">        currentNode.next=currentNode.next.next;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不相等则跳到下一个节点，循环知道currentNode的next节点为null</span></span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回虚拟头结点的next，这里就是被删除元素的原来的头结点</span></span><br><span class="line">    <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="/2019/04/28/链表和递归/2.jpg" alt="avatar"></p><p>  在考虑递归如何写的时候我们先需要了解递归的宏观语意。</p><p>  一个递归函数其实本质就是函数调用，只不过它是自己调用自己。</p><p>  递归函数就是将原来的问题转化为更小的问题，知道最后求出最基本的解。</p><p>  最基本的解一般是我们通过if条件判断来终结的，如果不添加if判断给递归函数一个终结（最基本的解，例如求阶乘的时候等于1等于0的时候就是最基本的解），那么计算机就会无限产生递归调用，这会导致cpu的方法栈（写栈的时候提过，函数调用就是通过栈来实现的）爆满从而报错。</p><p>  <img src="/2019/04/28/链表和递归/3.jpg" alt="avatar"></p><p>  如何写一个递归函数，我们不要去考虑它的实现细节，最好是通过宏观语意来完成它。</p><p>  首先我们最能确定的就是它的最基本解，然后我们需要在原本函数里面再次调用该函数并修改参数（目的是将原问题转换为更小的问题）。上图的代码只是最简单的示例，当递归函数稍微再复杂点的时候，我们就需要获取到递归调用函数产生的值并对这个return的值来做些修改最后再返回给上一级调用这个级别的递归函数的函数。</p><h2 id="使用递归来实现链表的删除-上述题目"><a href="#使用递归来实现链表的删除-上述题目" class="headerlink" title="使用递归来实现链表的删除(上述题目)"></a>使用递归来实现链表的删除(上述题目)</h2><p>  首先完成一个递归函数我们需要先确定我们怎么把这个递归函数变为更小的函数。</p><p>  这里，我们将这个删除长度n的链表中元素的问题转换成先判断从第二个节点开始到最后节点中删除符合条件的节点，然后再转换为从第三个节点到最后节点删除符合条件的节点，直到我们的问题变成了删除最后一个空节点中符合条件的元素，当然这个时候空节点里面是不可能有的，所以我们这时候直接返回head，这样最基本解就出来了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  之后就是转换为更小的问题了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将问题转换为小问题</span></span><br><span class="line">ListNode result=removeElements(head.next,val);</span><br><span class="line"><span class="comment">//每次return都是return给上一级递归的结果</span></span><br><span class="line"><span class="comment">//如果当前节点的val值和给定val相等</span></span><br><span class="line"><span class="comment">//则直接return给上一级不包含该节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果不相等说明不需要删除</span></span><br><span class="line">    <span class="comment">//则需要将返回的结果前面加上头结点head在返回head</span></span><br><span class="line">    head.next=result;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  完整代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span>  ListNode <span class="title">removeElements</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"> <span class="comment">//首先考虑最基本的问题</span></span><br><span class="line"> <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ListNode resultNode=removeElements(head.next,val);</span><br><span class="line"> <span class="keyword">if</span> (head.val==val)&#123;</span><br><span class="line">   <span class="keyword">return</span> resultNode;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  head.next=resultNode;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其实整个问题可以这么理解，我需要删除一个链表中符合元素的节点，那么我把这个问题转化为小问题，将整个链表转换为从2开始到结尾的链表，然后S到从3开始到结尾的链表，最后到从结尾到结尾的节点（null），那么我就是从最后一个节点找需要删除的节点，假设如果最后一个节点是要删除的节点，那么这时候我们只需要将这个节点删除并且返回给上一级调用递归函数。这时候我们返回的null然后上一级接收到的result就是null，然后这个函数继续执行到if(head.val==val)，这时候就判断（第二级递归就是最后两个节点的链表）当前链表中的头结点的val是否满足，满足就跟刚刚一样“删除”该节点，不满足就将这个head的next设置为result，也就是将result的头结点暂时设置为当前head（将当前head设置为头结点并返回给上一级调用的函数），这样无限的返回，最后返回的就是原本链表中需要删除元素后的链表了。</p><p>  这个时候我们可以将递归写的更简单</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next=removeElements(head.next,val);</span><br><span class="line">    <span class="keyword">return</span> head.val==val?head.next:head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单实用递归实现链表的创建"><a href="#简单实用递归实现链表的创建" class="headerlink" title="简单实用递归实现链表的创建"></a>简单实用递归实现链表的创建</h2><p>  首先我们考虑如何通过递归实现该功能，创建一个链表，我们将问题缩小就是从创建节点开始。例如我们现在给定一个数组，然后我们通过这个数组来创建链表。首先这个数组的索引肯定是我们递归实现的条件，比如一个10个元素的数组，我们需要创建十个元素的链表，我们可以将问题变为创建从索引1开始到结束的链表，然后从索引2到结束，最后到从末尾到末尾（创建最后一个元素），所以这时候我们最基本条件就出来了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((index+<span class="number">1</span>)==array.length)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候我们就要来实现将问题转换为小问题<br>  其实很简单。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode result=createElement(array,index+<span class="number">1</span>);</span><br><span class="line">ListNode currentNode=<span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">currentNode.next=result;</span><br><span class="line"><span class="keyword">return</span> currentNode;</span><br></pre></td></tr></table></figure><p>  完整代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">createListNode</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((index+<span class="number">1</span>)==array.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    ListNode result=createListNode(array,index+<span class="number">1</span>);</span><br><span class="line">    ListNode currentNode=<span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">    currentNode.next=result;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>这个星期开始复习的信号系统，对于我这个学物联网的同学，不会什么高数，硬件是真的很烦躁，信号考完了，能不能过就靠老师助攻了。今天写篇博客来缓解一下一个星期没写代码的愧疚，这个递归还真的有点难理解，还需要勤敲勤练。加油吧！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从一道leetcode题目开始&quot;&gt;&lt;a href=&quot;#从一道leetcode题目开始&quot; class=&quot;headerlink&quot; title=&quot;从一道leetcode题目开始&quot;&gt;&lt;/a&gt;从一道leetcode题目开始&lt;/h2&gt;&lt;p&gt;  题目描述：&lt;/p&gt;
&lt;p&gt;  &lt;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现自定义验证注解</title>
    <link href="https://francisqiang.github.io/2019/04/20/Java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%B3%A8%E8%A7%A3/"/>
    <id>https://francisqiang.github.io/2019/04/20/Java实现自定义验证注解/</id>
    <published>2019-04-20T03:14:24.000Z</published>
    <updated>2019-04-20T06:42:46.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>  从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注释)。</p><p>  Annotation 其实就是代码里的特殊标记, <font color="red">这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。</font> 通过使用 Annotation, 程序员可以在<font color="red">不改变原有逻辑的情况下</font>, 在源文件中嵌入一些补充信息。</p><p>  Annotation 可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在 Annotation 的“name=value” 对中。</p><p>  例如<img src="/2019/04/20/Java实现自定义验证注解/1.jpg" alt="avatar"></p><p>  Annotation 能被用来为程序元素(类, 方法, 成员变量等) 设置元数据。</p><h2 id="基本的Annotation"><a href="#基本的Annotation" class="headerlink" title="基本的Annotation"></a>基本的Annotation</h2><p>  使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。 用于修饰它支持的程序元素。</p><p>  三个基本的 Annotation:</p><ul><li>@Override: 限定重写父类方法, 该注释只能用于方法</li><li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</li><li>@SuppressWarnings: 抑制编译器警告。</li></ul><h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>  定义新的 Annotation 类型使用 @interface 关键字</p><p>  Annotation 的成员变量在 Annotation 定义中以<font color="red">无参数方法</font>的形式来声明。 其方法名和返回值定义了该成员的名字和类型。</p><p>  可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</p><p>  没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation</p><p>  下面是java验证的NotNull注解的源码：</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/2.jpg" alt="avatar"></p><p>  其中所有的成员变量都是以无参方法定义的，default定义了某个成员变量的默认值，这是一个包含成员变量的 Annotation 所以我们也可以称为 元数据 Annotation。</p><p>  下面是Override注解的源码：</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/3.jpg" alt="avatar"></p><p>  这个注解没有成员变量，所以我们可以称为标记。而且可以注意的是这个注解的注解(元注解) @Retention是SOURCE类型的，编译器会直接丢弃这种策略的注释。也就是我们编译成class文件的时候是看不见@Override注解的，这个我们后面会讲。</p><h2 id="提取-Annotation-信息"><a href="#提取-Annotation-信息" class="headerlink" title="提取 Annotation 信息"></a>提取 Annotation 信息</h2><p>  JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注释的程序元素。</p><p>  <font color="red">当一个 Annotation 类型被定义为运行时 Annotation 后</font>, 该注释才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取。</p><p>  程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信息</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/4.jpg" alt="avatar"></p><h2 id="JDK-的元-Annotation"><a href="#JDK-的元-Annotation" class="headerlink" title="JDK 的元 Annotation"></a>JDK 的元 Annotation</h2><p>  JDK 的元 Annotation 用于修饰其他 Annotation 定义(注解的注解)</p><ul><li><p>@Retention注解</p><p> 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值</p><ul><li>RetentionPolicy.CLASS: 编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注释. 这是默认值</li><li>RetentionPolicy.RUNTIME:编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释</li><li>RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释</li></ul></li><li><p>@Target注解</p><p> 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。可以参考本文第一张图片。</p></li><li><p>@Documented注解</p><p> 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档</p></li><li><p>@Inherited注解</p><p> 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注释</p></li></ul><h2 id="实现自定义验证注解-IsMobile"><a href="#实现自定义验证注解-IsMobile" class="headerlink" title="实现自定义验证注解@IsMobile"></a>实现自定义验证注解@IsMobile</h2><p>  参考于<a href="https://www.cnblogs.com/xz816111/p/9484902.html" target="_blank" rel="noopener">实现自定义验证注解</a></p><p>  @IsMobile是一个验证是否为11位手机号码的验证注解。</p><p>  API开发中经常会遇到一些对请求数据进行验证的情况，这时候如果使用注解就有两个好处，一是验证逻辑和业务逻辑分离，代码清晰，二是验证逻辑可以轻松复用，只需要在要验证的地方加上注解就可以。</p><p>  Java提供了一些基本的验证注解，比如@NotNull、@Size，但是更多情况下需要自定义验证逻辑，这时候就可以自己实现一个验证注解，方法很简单，仅需要两个东西：</p><ul><li>一个自定义的注解，并且指定验证器</li><li>一个验证器的实现</li></ul><p>这个时候我们就可以结合刚刚所学的知识就可以根据前面两部来实现验证注解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个表示该注解能对于类型注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span><br><span class="line"><span class="comment">//这个表示在运行时起作用</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//@Constraint是最关键的，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = IsMobileValidator.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IsMobile &#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "手机号码格式错误"</span>;</span><br><span class="line">  <span class="comment">//groups()和payload()也为@Constraint要求，可默认为空</span></span><br><span class="line">  Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">  Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>@Target</p><p>@Target指明这个注解要作用在什么地方，可以是对象、域、构造器等，因为要作用在域上，因此这里可以选择FIELD（这里我是直接所有的可以）。参考了NotNull注解</p></li><li><p>@Retention</p><p>指明生命周期，这里选择RUNTIME</p></li><li><p>@Constraint</p><p>实现验证器最重要的注解，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器。</p></li><li><p>message()</p><p>验证失败之后返回的消息。此方法为@Constraint要求</p></li><li><p>groups()和payload()</p><p>groups()和payload()也为@Constraint要求，可默认为空，详细用途可以查看@Constraint文档</p></li></ul><p>下面是验证器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-20 10:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里实现ConstraintValidator接口需要重写initialize和isValid方法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * required指这个数据是否必须</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    required=constraintAnnotation.required();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是必须的，那么就验证是否为手机号</span></span><br><span class="line">    <span class="keyword">if</span> (required)&#123;</span><br><span class="line">      <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果非必须，那么空值和手机号都可以通过验证</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(value))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其细节说明在注释中。</p><p>这样我们就实现了一个自定义验证注解，我们只需要在要验证的元素的前面加上@IsMobile就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; class=&quot;headerlink&quot; title=&quot;什么是注解&quot;&gt;&lt;/a&gt;什么是注解&lt;/h2&gt;&lt;p&gt;  从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation
      
    
    </summary>
    
      <category term="Java SE" scheme="https://francisqiang.github.io/categories/Java-SE/"/>
    
    
  </entry>
  
  <entry>
    <title>自己动手写链表</title>
    <link href="https://francisqiang.github.io/2019/04/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E9%93%BE%E8%A1%A8/"/>
    <id>https://francisqiang.github.io/2019/04/18/自己动手写链表/</id>
    <published>2019-04-17T16:06:35.000Z</published>
    <updated>2019-05-13T11:22:20.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>  链表是一种重要的数据结构，是一种数据的存储方式。链表由多个链表元素组成，每个元素称为节点。链表存储的物理结构可能是连续的，但也可能是无序的。但是链表之间的元素（节点）是有序的逻辑相连。</p><p>  <img src="/2019/04/18/自己动手写链表/1.jpg" alt="avatar"></p><p>  链表是一种很灵活的数据结构，它不需要指定内存的大小，删除节点不需要要像数组那样讲数据整体向前移动，只需要更改节点的指向。但是链表的结构也决定了它的许多缺点，比如说访问需要遍历元素，不能像数组那样依靠索引，还有就是链表每个元素存的是一个对象，这是一笔非常大的内存开销。</p><p>  链表从方向可以分为单向链表，双向链表。<br>  从结构上可以分为单链表，环形链表。</p><p>  <img src="/2019/04/18/自己动手写链表/2.jpg" alt="avatar"></p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-17 18:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点里面的元素内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e,Node next)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 虚拟链表头，让add更加有逻辑</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 链表大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead=<span class="keyword">new</span> Node();</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 链表添加头元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    add(<span class="number">0</span>,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定位置添加元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">      <span class="comment">//当index非法排除异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取要插入的元素的前面的元素</span></span><br><span class="line">      Node pre=dummyHead;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index ; i ++)&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        pre = pre.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//首先调用的是new Node(e,pre.next)</span></span><br><span class="line">      <span class="comment">//为的是让新节点的next节点指向它要添加位置的前面一个元素的原来的next节点</span></span><br><span class="line">      <span class="comment">//再进行赋值操作为了将添加节点前面的节点的next改为该元素</span></span><br><span class="line">      pre.next = <span class="keyword">new</span> Node(e,pre.next);</span><br><span class="line">      size ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在链表末尾加入元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    add(size,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某个索引的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Node currentNode=dummyHead.next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currentNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 更新后的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;=size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node currentNode=dummyHead.next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode.e=e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包含某个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    Node currentNode=dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((currentNode.e).equals(e))&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除某个索引元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;=size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node currentNode=dummyHead;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//暂存被删除的节点</span></span><br><span class="line">      Node tempNode=currentNode.next;</span><br><span class="line">      <span class="comment">//将遍历到的节点（被删除节点前面一个）的next指向被删除节点的next节点</span></span><br><span class="line">      currentNode.next=tempNode.next;</span><br><span class="line">      <span class="comment">//将被删除的节点的next指向为null</span></span><br><span class="line">      tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> tempNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    Node currentNode=dummyHead.next;</span><br><span class="line">    <span class="comment">//遍历到节点的next为空</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//判断是否与需要判断的元素相等，如果相等则删除</span></span><br><span class="line">      <span class="keyword">if</span> (currentNode.e.equals(e))&#123;</span><br><span class="line">        Node tempNode=currentNode.next;</span><br><span class="line">        currentNode.next=tempNode.next;</span><br><span class="line">        tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用链表实现栈"><a href="#使用链表实现栈" class="headerlink" title="使用链表实现栈"></a>使用链表实现栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-17 20:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.linkedList=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">    linkedList.addFirst(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表和数组实现栈的比较"><a href="#链表和数组实现栈的比较" class="headerlink" title="链表和数组实现栈的比较"></a>链表和数组实现栈的比较</h2><p>  从复杂度来考虑，数组和链表实现的出栈入栈等操作的复杂度都相同，我们这里来测试一下。测试代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testStack</span><span class="params">(Stack&lt;Integer&gt; stack, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++) &#123;</span><br><span class="line">    stack.push(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++) &#123;</span><br><span class="line">    stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">  ArrayStack&lt;Integer&gt; arrayStack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time1 = testStack(arrayStack, opCount);</span><br><span class="line">  System.out.println(<span class="string">"ArrayStack, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  LinkedListStack&lt;Integer&gt; linkedListStack = <span class="keyword">new</span> LinkedListStack&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time2 = testStack(linkedListStack, opCount);</span><br><span class="line">  System.out.println(<span class="string">"LinkedListStack, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其实这个时间比较很复杂，因为LinkedListStack中包含更多的new操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果如下：<br>  <img src="/2019/04/18/自己动手写链表/3.jpg" alt="avatar"></p><p>  其实这个测试结果不会是稳定的，相比较之下，他们的快慢主要和环境有很大关系。</p><p>  当然，ArrayStack在添加元素时可能会执行扩容操作，这个时间复杂度是O(n)的，在LinkedListStack添加元素的时候虽然没有扩容的操作但是它会执行大量new对象操作，这也是非常占用资源的。总体来说，它们的增添和删除元素的时间复杂度都是O(1),所以可以说它们执行时间的差异并不是很大。</p><p>  <img src="/2019/04/18/自己动手写链表/5.jpg" alt="avatar"></p><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p>前面一篇文章专门讲到了Queue，队列就是（FIFO）的数据结构，我们主要去实现队列的入队（在队尾添加元素），出队（在队首删除元素）。回想我们前面实现的链表，在队首删除元素容易（时间复杂度是O1的），但是要在队尾添加元素就非常繁琐了，我们需要遍历整个链表，当数据量一大，我们的执行时间就会变得非常大，所以我们为了效率考虑，我们需要添加一个尾节点。</p><p>这时候我们怎么实现队列的操作呢？其实很简单，当我们入队的时候只需要将尾节点的next指向当前入队的新的节点，当然我们不得不把所有尾节点的next都置为null，为的是我们的逻辑和效率，浪费一个空间也不是大问题。</p><p>而当我们进行出队操作时，我们只需要将原来头结点变为原来头结点的next节点，返回出队节点的时候我们只需要将被删除的头结点的next节点变为null就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-18 19:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node head,tail;</span><br><span class="line">  <span class="comment">//维持链表元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head=<span class="keyword">null</span>;</span><br><span class="line">    tail=<span class="keyword">null</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队只能从尾部</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果尾节点为空，那么就代表整个链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (tail==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//需要将元素赋值给头节点和尾节点</span></span><br><span class="line">      head=<span class="keyword">new</span> Node(e);</span><br><span class="line">      tail=head;</span><br><span class="line">      size++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不为空则需要新节点赋值给尾节点的next</span></span><br><span class="line">      tail.next=<span class="keyword">new</span> Node(e);</span><br><span class="line">      <span class="comment">//尾节点变换</span></span><br><span class="line">      tail=tail.next;</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队操作，只能从第一个出队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 头节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当链表为空时无法进行出队操作</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the linkedListQueue is empty!"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node tempNode=head;</span><br><span class="line">      <span class="comment">//将原来头结点的next变为当前头结点</span></span><br><span class="line">      head=head.next;</span><br><span class="line">      <span class="comment">//将要返回的“头结点”的next置为null</span></span><br><span class="line">      tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> tempNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种实现对列的比较"><a href="#三种实现对列的比较" class="headerlink" title="三种实现对列的比较"></a>三种实现对列的比较</h2><p>前面我们使用了数组队列和循环队列，这时候我们加入我们刚刚实现的链表队列。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testQueue</span><span class="params">(Queue&lt;Integer&gt; q, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">      q.enqueue(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">      q.dequeue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    ArrayQueue&lt;Integer&gt; arrayQueue = <span class="keyword">new</span> ArrayQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time1 = testQueue(arrayQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"ArrayQueue, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    LoopQueue&lt;Integer&gt; loopQueue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time2 = testQueue(loopQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"LoopQueue, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    LinkedListQueue&lt;Integer&gt; linkedListQueue = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time3 = testQueue(linkedListQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"LinkedListQueue, time: "</span> + time3 + <span class="string">" s"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们能得到结果：<br><img src="/2019/04/18/自己动手写链表/4.jpg" alt="avatar"></p><p>通过我们实践和分析，链表实现的队列也是O(1)的时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是链表&quot;&gt;&lt;a href=&quot;#什么是链表&quot; class=&quot;headerlink&quot; title=&quot;什么是链表&quot;&gt;&lt;/a&gt;什么是链表&lt;/h2&gt;&lt;p&gt;  链表是一种重要的数据结构，是一种数据的存储方式。链表由多个链表元素组成，每个元素称为节点。链表存储的物理结构可能
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
