<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Francis的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://francisqiang.github.io/"/>
  <updated>2019-08-16T07:17:57.903Z</updated>
  <id>https://francisqiang.github.io/</id>
  
  <author>
    <name>Francis Qiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程学习——Java并发编程之美学习笔记五</title>
    <link href="https://francisqiang.github.io/2019/08/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <id>https://francisqiang.github.io/2019/08/16/Java并发编程学习——Java并发编程之美学习笔记五/</id>
    <published>2019-08-16T04:52:26.000Z</published>
    <updated>2019-08-16T07:17:57.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java并发包中并发List介绍"><a href="#Java并发包中并发List介绍" class="headerlink" title="Java并发包中并发List介绍"></a>Java并发包中并发List介绍</h2><p>  并发包中的List只有 <strong><em>CopyOnWriteArrayList</em></strong> 。 CopyOnWriteArrayList是一个线程安全的List，对其的修改操作都是在底层的一个复制的数组上进行的，也就是使用了 <strong><em>写时复制</em></strong> 策略。</p><p>  <img src="/2019/08/16/Java并发编程学习——Java并发编程之美学习笔记五/CopyOnWriteArrayList.jpg" alt="运行结果"></p><p>  在CopyOnWriteArrayList中，每个对象里有一个array数组对象用来存放具体元素，<strong>ReentrantLock独占锁对象用来保证同时只有一个线程能对array进行修改</strong>。</p><p>  如果让我们自己做一个写时复制的线程安全的List我们会怎么做？我们需要考虑什么？</p><ul><li><p>何时初始化list，初始化list元素为多少个，list是有限大小吗？</p></li><li><p>如何保证线程安全？</p></li><li><p>如何保证使用迭代器遍历list时的数据一致性。</p></li></ul><h2 id="主要方法解析"><a href="#主要方法解析" class="headerlink" title="主要方法解析"></a>主要方法解析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化个数0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个集合的时候，将集合复制到自身属性的array中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入为数组的时候直接复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取独占锁并加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取自身array并且复制一个快照</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在快照上进行操作</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将新的快照赋值给array属性</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取指定位置的元素"><a href="#获取指定位置的元素" class="headerlink" title="获取指定位置的元素"></a>获取指定位置的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  获取操作并没有加锁，可能会产生 <strong><em>弱一致性问题</em></strong> 。比如当线程A执行get，线程B执行删除操作。线程A这里可以分为两个步骤 1. 获取当前array  2. 通过获取到的array根据索引获得指定元素。</p><p>  假如这个时候当线程A执行完步骤1，然后线程B执行删除操作，我们假设线程A需要获得的是index为1的元素，此时线程B将原来array复制到新的array中然后对这个新array进行remove(1)的操作，之后把这个新的array重新赋值到对象中的array中，当这一系列操作完成后，线程A获取指定元素，而这个时候线程A是通过原来array获取的，所以它仍能获取到index为1的元素。</p><p>  例如对于以下程序 运行结果可能会是2或者3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">1</span>);</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">2</span>);</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">3</span>);</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">4</span>);</span><br><span class="line">    Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        copyOnWriteArrayList.remove(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(copyOnWriteArrayList.get(<span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadOne.start();</span><br><span class="line">    threadTwo.start();</span><br><span class="line">    threadTwo.join();</span><br><span class="line">    threadOne.join();</span><br><span class="line">    System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改指定元素"><a href="#修改指定元素" class="headerlink" title="修改指定元素"></a>修改指定元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁并加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取array</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取原来的指定元素</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 如果参数不和老值相同则进行更新</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制array</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 在新的array中进行更新</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 重新设置array</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            <span class="comment">// 确保volatile语义还是需要重新设置array</span></span><br><span class="line">            <span class="comment">// 因为对于volatile变量的写操作happens-before对volatile</span></span><br><span class="line">            <span class="comment">// 变量的读操作</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁并加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行快照的准备工作</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果删除的是最后一个</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 直接移除最后一个的空间</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个快照</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            <span class="comment">// 将array设置为快照</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弱一致性的迭代器"><a href="#弱一致性的迭代器" class="headerlink" title="弱一致性的迭代器"></a>弱一致性的迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数组的快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否还有下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历的方法</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    。。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在snapshot中保存着当前array的快照,也就是说迭代器所操作的是array的一个快照，所以当其他线程对array进行更改的时候，迭代器是感知不到的，这又会产生弱一致性问题。</p><p>  我们来看一下实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">1</span>);</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">2</span>);</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">3</span>);</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">4</span>);</span><br><span class="line">    copyOnWriteArrayList.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        copyOnWriteArrayList.set(<span class="number">1</span>,<span class="number">123</span>);</span><br><span class="line">        copyOnWriteArrayList.remove(<span class="number">2</span>);</span><br><span class="line">        copyOnWriteArrayList.remove(<span class="number">3</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 保证iterator先获取</span></span><br><span class="line">    Iterator&lt;Integer&gt; integerIterator = copyOnWriteArrayList.iterator();</span><br><span class="line"></span><br><span class="line">    threadOne.start();</span><br><span class="line"></span><br><span class="line">    threadOne.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (integerIterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(integerIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/08/16/Java并发编程学习——Java并发编程之美学习笔记五/1.jpg" alt="运行结果"></p><p>  我们可以看到运行结果是1 2 3 4 5</p><p>  我们来看一下创建iterator的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其实跟上面讲到的获取和删除的弱一致性一样，因为修改和删除操作时对一个快照进行修改和删除的，并且最终把新的快照地址重新赋值给array，虽然此时的array指向的地址已经变了，但是原来迭代器中获取array的地址并没有改变，所以迭代器操作的还是原来的array，这就是写时复制产生的弱一致性问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java并发包中并发List介绍&quot;&gt;&lt;a href=&quot;#Java并发包中并发List介绍&quot; class=&quot;headerlink&quot; title=&quot;Java并发包中并发List介绍&quot;&gt;&lt;/a&gt;Java并发包中并发List介绍&lt;/h2&gt;&lt;p&gt;  并发包中的List只有 
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——Java并发编程之美学习笔记四</title>
    <link href="https://francisqiang.github.io/2019/08/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <id>https://francisqiang.github.io/2019/08/14/Java并发编程学习——Java并发编程之美学习笔记四/</id>
    <published>2019-08-14T01:36:40.000Z</published>
    <updated>2019-08-16T06:57:09.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原子变量操作类"><a href="#原子变量操作类" class="headerlink" title="原子变量操作类"></a>原子变量操作类</h2><p>  在JUC并发包中有很多原子变量类，比如AtomicInteger，AtomicLong和AtomicBoolean等。他们原理类似，这里讲解AtomicLong类，AtomicLong是原子性递增和递减类，其内部使用Unsafe实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1927816293512124184L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取unsafe实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// 声明偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断JVM是否支持long类型无锁CAS</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> VM_SUPPORTS_LONG_CAS = VMSupportsCS8();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">VMSupportsCS8</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取value在Atomica中的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际的变量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedLong(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并设置long值，返回原来long的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndSetLong(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子性设置值为被给予的更新值如果当前值与参数中到的expect期望值相等的话</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和上面方法一样 但是可能会失败而且不提供保证 一般很少代替上面的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子性增加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子性减1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, -<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子性增加指定的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加1且返回更新后的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子性减1且返回更新后的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, -<span class="number">1L</span>) - <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子性更新循坏使用CAS 导致线程竞争</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndUpdate</span><span class="params">(LongUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsLong(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">updateAndGet</span><span class="params">(LongUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsLong(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入函数 自定义算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">long</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       LongBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.applyAsLong(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">long</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       LongBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.applyAsLong(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这里AtomicLong类可以直接获取Unsafe是因为它本身是在rt.jar下面的是通过Bootstrap类加载器加载的。</p><p>  上面的原子操作类都是使用的CAS非阻塞算法，性能更好，但是在高并发的情况下Atomicxxx还存放着性能问题(会导致线程一直竞争CAS，导致大量资源浪费)，在JDK1.8之后提供了高并发下的LongAdder类。</p><h2 id="JDK8新增的原子操作类LongAdder"><a href="#JDK8新增的原子操作类LongAdder" class="headerlink" title="JDK8新增的原子操作类LongAdder"></a>JDK8新增的原子操作类LongAdder</h2><p>  在AtomicLong中，在高并发的情况下大量线程会同时竞争更新同一个原子变量，这样会导致大量线程失败通过无线循环不断进行自旋尝试CAS的操作，这回白白浪费CPU资源。</p><p>  因为AtomicLong是多个线程竞争同一个原子变量，而LongAdder中则将原子变量和线程一一对应，比如设置一个Cell数组，其中的元素对应着每个线程(通过一定的算法实现)，然后最后获取值的时候将base(基础值)和cell数组中的元素值相加。</p><p>  <strong>LongAdder维护了一个延迟初始化的原子性更新数组(默认情况为null)和一个基础值base。由于cell占用的内存相对较大所以是在需要的时候创建，即惰性加载</strong>。</p><p>  因为cell是一个数组，数组中的元素内存地址是连续的，这就很容易导致伪共享的问题，在LongAdder中使用了@Contented注解来避免。</p><h3 id="LongAdder代码分析"><a href="#LongAdder代码分析" class="headerlink" title="LongAdder代码分析"></a>LongAdder代码分析</h3><p>  我们围绕着6个问题去分析源码</p><ol><li><p>LongAdder的结构是怎样的  答：继承了Striped64里面有一个base cell数组和cellBusy自旋操作标志</p></li><li><p>当前线程应该访问Cell数组里面的哪一个Cell元素  答：获取当前线程的探针(作为每个线程对应哪一个cell的算法基础)，根据当前线程的随机数ThreadLocalRandomProbe和cell元素个数计算当前要访问的cell元素的下标，如果发现对应下标的元素为空则新增一个Cell元素到数组中并在之前将cellBusy设置为1防止其他线程竞争</p></li><li><p>如何初始化Cell数组  答：懒加载 但需要操作的时候进行初始化操作</p></li><li><p>Cell数组如何进行扩容  答：当CPU个数大于cell元素进行扩容 这时会多个CPU(线程)争抢一个cell元素产生冲突</p></li><li><p>线程访问分配的Cell元素后有冲突后应该如何处理  答：进行扩容操作</p></li><li><p>如何保证线程操作被分配的Cell元素的原子性  答：使用volatile保证内存可见性，使用cas操作保证操作原子性</p><p><img src="/2019/08/14/Java并发编程学习——Java并发编程之美学习笔记四/1.jpg" alt="LongAdder"></p><p>我们可以看到LongAdder继承Striped64，而Striped64中维持着base，cellBusy，cell三个变量。</p><p>base是用来计算LongAdder的真实值的(base和cell元素相加),cellBusy是用来实现自旋锁的，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组的时候使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。</p><p>我们来看一下Cell的构造</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 维持着一个long,保证内存可见性声明为volatile</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// 进行cas操作，是更新时原子性的</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看一下LongAdder源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了Striped64</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246863182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongAdder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加指定的值 主要操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="comment">// 如果数组为空且cas失败会进入</span></span><br><span class="line">        <span class="comment">// 或者数组不为空并且没有cas操作的时候进入</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 当数组为空直接进入 这里就是数组为空且刚刚cas失败进入</span></span><br><span class="line">            <span class="comment">// 或者c数组不为空但再次cas失败则进入调用longAccumulate</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(-<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有的值即获取真正的value</span></span><br><span class="line">    <span class="comment">// 没有做加锁操作 所以并不是原子性的 会存在并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="keyword">long</span> sum = base;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置所有元素为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        base = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    a.value = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并重置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sumThenReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="keyword">long</span> sum = base;</span><br><span class="line">        base = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += a.value;</span><br><span class="line">                    a.value = <span class="number">0L</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246863182397L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The current value returned by sum().</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">        SerializationProxy(LongAdder a) &#123;</span><br><span class="line">            value = a.sum();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Return a &#123;<span class="doctag">@code</span> LongAdder&#125; object with initial state</span></span><br><span class="line"><span class="comment">         * held by this proxy.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> LongAdder&#125; object with initial state</span></span><br><span class="line"><span class="comment">         * held by this proxy.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LongAdder a = <span class="keyword">new</span> LongAdder();</span><br><span class="line">            a.base = value;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.InvalidObjectException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Proxy required"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看一下longAccumulate函数源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的探针(作为每个线程对应哪一个cell的算法基础)</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">            <span class="comment">// 如果cell不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 根据当前线程的随机数ThreadLocalRandomProbe和cell元素个数计算当前要访问的cell元素的下标，如果发现对应下标的元素为空则新增一个Cell元素到数组中并在之前将cellBusy设置为1防止其他线程竞争</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果cas已经知道失败则重置标志</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">                <span class="comment">// 进行cas操作成功直接返回</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                             fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果cell元素个数大于CPU个数会产生冲突 冲突则进行扩容操作</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                            <span class="comment">// 移位增加两倍</span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 扩容的时候进行cas操作避免其他线程进行扩容或者更新操作完成后设置cellBusy为0</span></span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果为空则进行初始化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="comment">// 初始化</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                        fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## LongAccumulator类原理探究</span><br><span class="line"></span><br><span class="line">  LongAccumulator比LongAdder更加强大，原因在于LongAdder中只有累加操作，而LongAccumulator中是自定义函数来实现的。我们来看一下LongAccumulator的accumulate函数和LongAdder中的add方法的区别</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v, r; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> ||</span><br><span class="line">            (r = function.applyAsLong(b = base, x)) != b &amp;&amp; !casBase(b, r)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  (r = function.applyAsLong(v = a.value, x)) == v ||</span><br><span class="line">                  a.cas(v, r)))</span><br><span class="line">                <span class="comment">// 这里传入了计算的值和一个函数</span></span><br><span class="line">                longAccumulate(x, function, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">                <span class="comment">// 传入了值和一个null 我们可以猜测 传入null的时候给我们默认进行增加操作了</span></span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  我们继续回顾一下刚刚上面的longAccumulate方法源码中最后一个else if</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很明显 当fn为null的时候使用了v + x操作 不然调用该fn的applyAsLong</span></span><br><span class="line"><span class="comment">// 我们可以继续猜测这里面进行了自定义</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">    fn.applyAsLong(v, x))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是一个函数接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LongBinaryOperator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this operator to the given operands.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left the first operand</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right the second operand</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the operator result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原子变量操作类&quot;&gt;&lt;a href=&quot;#原子变量操作类&quot; class=&quot;headerlink&quot; title=&quot;原子变量操作类&quot;&gt;&lt;/a&gt;原子变量操作类&lt;/h2&gt;&lt;p&gt;  在JUC并发包中有很多原子变量类，比如AtomicInteger，AtomicLong和Atom
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——Java并发编程之美读书笔记三</title>
    <link href="https://francisqiang.github.io/2019/08/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>https://francisqiang.github.io/2019/08/13/Java并发编程学习——Java并发编程之美读书笔记三/</id>
    <published>2019-08-13T06:51:26.000Z</published>
    <updated>2019-08-13T08:06:20.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Random类及其局限性"><a href="#Random类及其局限性" class="headerlink" title="Random类及其局限性"></a>Random类及其局限性</h2><p>  在JDK7之前包括现在Random都是使用比较广泛的随机数生成工具。在java.lang.Math中随机数生成也是使用的java.util.Random的实例。</p><p>  下面是Random的一种常见的使用方式。</p><p>  基本步骤就是生成一个Random实例，然后通过这个实例的方法去生成随机数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      System.out.println(random.nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  随机数的生成需要一个默认的<em>种子</em>，这个种子是一个long类型的数字。我们可以查看一下Random的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造函数其实是通过当前时间生成long类型的种子的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用的是有参构造函数</span></span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == Random.class)</span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(initialScramble(seed));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// subclass might have overriden setSeed</span></span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看一下nextInt()方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参nextInt方法调用了next方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="comment">// 获取当前的seed</span></span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        <span class="comment">// 通过旧种子生成新种子</span></span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        <span class="comment">// CAS操作更新种子</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="comment">// 还是调用的next方法</span></span><br><span class="line">    <span class="comment">// 后面通过计算控制范围</span></span><br><span class="line">    <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>)  <span class="comment">// i.e., bound is a power of 2</span></span><br><span class="line">        r = (<span class="keyword">int</span>)((bound * (<span class="keyword">long</span>)r) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r;</span><br><span class="line">             u - (r = u % bound) + m &lt; <span class="number">0</span>;</span><br><span class="line">             u = next(<span class="number">31</span>))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  看了以上的代码，我们先不管种子是否是原子变量，如果多个线程去调用这个随机方法获得种子然后生成随机数，因为方法里新种子的生成依赖于旧种子，而旧种子是存放在共享变量里的，这里就会导致线程不安全问题，如果线程1生成一个种子，然后线程2和线程3同时调用该方法然后生成新种子，这个时候两个线程调用的旧种子是一样的，又因为旧种子变成新种子的算法是固定的，所以这两个线程得到的是同一个新种子，那么就意味着他们会生成同样的随机数。</p><p>  而我们要注意的是在next方法里seed是被声明成AtomicLong类型的，它是原子变量，所以这样就可以解决线程安全的问题了(同一时刻只有一个线程能对这个原子变量进行操作)，后面原子变量的更新操作使用的是CAS操作，同一时刻只有一个线程能更新成功，这样就会 <strong><em>导致大量线程自旋重试</em></strong> ，这样就极大地降低了并发性能。</p><h2 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h2><p>  ThreadLocalRandom很好的解决了Random在高并发场景下的缺陷和不足。与ThreadLocal的原理一样ThreadLocalRandom使用的也是 <strong><em>线程封闭技术</em></strong> 。</p><p>  使用方式和Random差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(threadLocalRandom.nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  因为在Random中种子是共享变量，所以在多线程环境下会出现线程安全问题。而ThreadLocalRandom则是把种子变为线程本地变量。这样每个线程就会通过自己线程里的旧种子去更新种子。</p><h2 id="ThreadLocalRandom源码分析"><a href="#ThreadLocalRandom源码分析" class="headerlink" title="ThreadLocalRandom源码分析"></a>ThreadLocalRandom源码分析</h2><p>  <img src="/2019/08/13/Java并发编程学习——Java并发编程之美读书笔记三/1.jpg" alt="ThreadLocalRandom源码"></p><p>  我们可以发现ThreadLocalRandom是继承了Random类的，<strong>但是需要注意的是ThreadLocalRandom并没有使用Random的seed变量，具体的变量存放在Thread中的ThreadLocalRandomSeed中(存放在线程中)。当调用ThreadLocalRandom的nextInt方法的时候，会获取当前线程的ThreadLocalRandomSeed变量并通过这个种子更新种子然后使用新种子来随机生成数字</strong>。</p><p>  其中ThreadLocalRandom中的seeder和probeGenerator是两个原子性变量，在初始化调用线程的种子和探针的时候会用到他们，<em>每个线程只会调用一次</em>。</p><p>  另外instance是ThreadLocalRandom的一个实例而且是static的，也就是说多个线程获取的是同一个实例，但是因为种子是存放在线程中的，所以不会产生安全问题。</p><h3 id="Unsafe机制"><a href="#Unsafe机制" class="headerlink" title="Unsafe机制"></a>Unsafe机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取Unsafe实例</span></span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">        <span class="comment">// 获取threadLocalRandomSeed，threadLocalRandomProbe，</span></span><br><span class="line">        <span class="comment">// threadLocalRandomSecondarySeed在Thread中的偏移量</span></span><br><span class="line">        SEED = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSeed"</span>));</span><br><span class="line">        PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">        SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSecondarySeed"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalRandom-current-方法"><a href="#ThreadLocalRandom-current-方法" class="headerlink" title="ThreadLocalRandom.current()方法"></a>ThreadLocalRandom.current()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为第一次调用，为0则为第一次调用，如果是做初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>)</span><br><span class="line">        localInit();</span><br><span class="line">    <span class="comment">// 返回统一的static实例</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化当前线程的种子变量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化探针</span></span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="comment">// 初始化seed</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-nextInt-int-bound-方法"><a href="#int-nextInt-int-bound-方法" class="headerlink" title="int nextInt(int bound)方法"></a>int nextInt(int bound)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="comment">// 根据当前线程中的种子计算新种子</span></span><br><span class="line">    <span class="keyword">int</span> r = mix32(nextSeed());</span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>) <span class="comment">// power of two</span></span><br><span class="line">        r &amp;= m;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// reject over-represented candidates</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">             u + m - (r = u % bound) &lt; <span class="number">0</span>;</span><br><span class="line">             u = mix32(nextSeed()) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; <span class="keyword">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">    <span class="comment">// 更新种子</span></span><br><span class="line">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">    <span class="comment">// 这里获取线程种子并进行 + GAMMA操作</span></span><br><span class="line">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  因为Random的种子生成随机数的方法，在Random中的种子是共享的所以多线程会出现并发问题，而Random中将种子声明成原子变量并且使用CAS更新会导致在多线程环境下多个线程去竞争资源，从而导致大量线程自旋，浪费资源和降低并发能力。</p><p>  在ThreadLocalRandom中使用了线程封闭技术来解决这个问题，线程封闭即使线程本地化，将共享变量进行本地化，从而避免了线程安全问题和提高了并发能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Random类及其局限性&quot;&gt;&lt;a href=&quot;#Random类及其局限性&quot; class=&quot;headerlink&quot; title=&quot;Random类及其局限性&quot;&gt;&lt;/a&gt;Random类及其局限性&lt;/h2&gt;&lt;p&gt;  在JDK7之前包括现在Random都是使用比较广泛的随机
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——隐藏在并发包中的管程</title>
    <link href="https://francisqiang.github.io/2019/08/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%9A%90%E8%97%8F%E5%9C%A8%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B/"/>
    <id>https://francisqiang.github.io/2019/08/12/Java并发编程学习——隐藏在并发包中的管程/</id>
    <published>2019-08-12T11:35:23.000Z</published>
    <updated>2019-08-12T11:59:11.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-SDK并发包中的管程"><a href="#Java-SDK并发包中的管程" class="headerlink" title="Java SDK并发包中的管程"></a>Java SDK并发包中的管程</h2><p>  <strong><em>在Java SDK并发包中通过Lock和Condition两个接口来实现管程，其中Lock用于解决互斥问题，Condition用来解决同步问题</em></strong>。</p><h2 id="再造管程的理由"><a href="#再造管程的理由" class="headerlink" title="再造管程的理由"></a>再造管程的理由</h2><p>  在Java 1.5之前synchronized是不如SDK中的Lock的，但1.6版本之后synchronized做了很多优化，将性能追了上来，所以为什么还要重新“造轮子”的原因不是性能问题，而是 <strong><em>死锁问题中的不可抢占条件</em></strong> 。</p><p>  我们知道，synchronized是无法破坏不可抢占条件的，因为当线程申请不到锁的时候会直接阻塞。这个阻塞不会释放资源。</p><p>  而让我们重新去设计一把互斥锁，其实有三种方法去解决。</p><ol><li><p><strong>能够响应中断</strong>。因为申请不到锁之后阻塞也不释放资源，所以我们希望阻塞线程能被通知中断唤醒并且释放曾经拥有过的资源。</p></li><li><p><strong>支持超时</strong>。如果线程在一段时间内没有获取到锁，不是进入阻塞状态而是返回一个错误，这样线程也将右机会释放曾经获得的锁了。</p></li><li><p><strong>非阻塞地获取锁</strong>。获取失败的时候不是进入阻塞状态而是直接返回，这样线程就有机会释放曾经持有的锁了。</p><p>而这三种方案，在Lock接口中都有对应的API</p><p><img src="/2019/08/12/Java并发编程学习——隐藏在并发包中的管程/1.jpg" alt="Lock接口"></p><p>对应的lockInterruptibly()是支持中断的API，tryLock()是支持非阻塞获取锁的API，tryLock(long time,TimeUnit unit)是支持超时的API。</p></li></ol><h2 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h2><p>  对于synchronized来说因为happends-before规则可以保证可见性，而在ReentrantLock实现类中内部持有了一个volatile变量state，并且在lock和unlock的时候读写state， <strong><em>通过volatile的happens-before规则</em></strong> 。</p><h2 id="锁的最佳实践"><a href="#锁的最佳实践" class="headerlink" title="锁的最佳实践"></a>锁的最佳实践</h2><ol><li><p>永远只在更新对象的变量时加锁</p></li><li><p>永远只在访问可变的成员变量的时候加锁</p></li><li><p>永远不再调用其他对象的方法的时候加锁(也许其他方法里面有线程sleep()或者IO操作，其他类也可能加锁会导致死锁)</p></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock</span><br><span class="line">          = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account tar, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.lock.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (tar.lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">              tar.balance += amt;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              tar.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="comment">//if</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">  &#125;<span class="comment">//transfer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面的代码不会产生死锁，但是可能会产生活锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-SDK并发包中的管程&quot;&gt;&lt;a href=&quot;#Java-SDK并发包中的管程&quot; class=&quot;headerlink&quot; title=&quot;Java SDK并发包中的管程&quot;&gt;&lt;/a&gt;Java SDK并发包中的管程&lt;/h2&gt;&lt;p&gt;  &lt;strong&gt;&lt;em&gt;在Jav
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——Java并发编程之美读书笔记二</title>
    <link href="https://francisqiang.github.io/2019/08/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>https://francisqiang.github.io/2019/08/12/Java并发编程学习——Java并发编程之美读书笔记二/</id>
    <published>2019-08-12T04:41:22.000Z</published>
    <updated>2019-08-12T06:14:20.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是多线程并发编程"><a href="#什么是多线程并发编程" class="headerlink" title="什么是多线程并发编程"></a>什么是多线程并发编程</h2><p>  并发：同一个时间段多个任务同时都在执行。</p><p>  并行：多个任务在单位时间内同时执行。</p><p>  也就是说并发使用cpu在短时间内切换进程造成了多个任务同时执行的假象。而在多线程编程实践中，<em>线程的个数往往大于CPU个数</em>，所以一般都称多线程并发编程而不是多线程并行编程(意味着一个核上存在多个线程，所以是并发)。</p><h2 id="为什么要进行多线程并发编程"><a href="#为什么要进行多线程并发编程" class="headerlink" title="为什么要进行多线程并发编程"></a>为什么要进行多线程并发编程</h2><p>  多核CPU时代打破了单核CPU对多线程效能的限制(频繁切换线程会带来额外开销)，多线程并发编程可以显著提高性能以应对海量数据和请求。</p><h2 id="Java中的线程安全问题"><a href="#Java中的线程安全问题" class="headerlink" title="Java中的线程安全问题"></a>Java中的线程安全问题</h2><p>  多个线程去改变或读取(至少有一个去改变)一个共享资源会产生线程安全问题。</p><h2 id="Java中共享变量的内存可见性问题"><a href="#Java中共享变量的内存可见性问题" class="headerlink" title="Java中共享变量的内存可见性问题"></a>Java中共享变量的内存可见性问题</h2><p>  <img src="/2019/08/12/Java并发编程学习——Java并发编程之美读书笔记二/1.jpg" alt="1.jpg"></p><p>  Java内存规定，将所有变量都存放在主内存， <strong><em>当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫工作内存</em></strong> 。</p><p>  而这个线程的工作内存又是怎样的呢？</p><p>  <img src="/2019/08/12/Java并发编程学习——Java并发编程之美读书笔记二/2.jpg" alt="2.jpg"></p><p>  上图是一个双核CPU系统架构，每个核都有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有CPU共享的二级缓存。 <strong><em>那么Java内存模型里面的工作内存，就对应着这里的L1或者L2或者CPU的寄存器</em></strong> 。</p><p>  由于cache的存在会导致内存不可见，比如线程A和线程B要对一个共享变量x做增加的操作。</p><p>  线程A首先去获取共享变量x的值，由于两级缓存都没有命中，那么线程A从主存中取出x的值为0并做增加操作，并且放入一级缓存和二级缓存，线程B也去获取共享变量x的值，首先一级缓存没有命中，二级缓存命中(刚刚线程A写入了二级共享缓存)，然后发现二级缓存中的值为1，然后进行增加操作并写入自己的一级缓存和二级缓存，主存。</p><p>  这样看来没什么问题，但是如果线程A继续进行增加操作呢？线程A首先会去获取共享变量x的值，一级缓存命中！并且获取到了x的值为1，然后进行增加操作变为2，问题就出现了。</p><p>  <strong>线程自己的工作内存(自己的缓存)会导致内存不可见性</strong>。</p><h2 id="Java中的synchronized关键字"><a href="#Java中的synchronized关键字" class="headerlink" title="Java中的synchronized关键字"></a>Java中的synchronized关键字</h2><p>  synchronized是Java提供的一种原子性内置锁，由于Java的线程和操作系统中的线程一一对应，所有当阻塞一个线程的时候，需要从用户态切换到内核态执行阻塞操作，这是一个很耗时的操作。而synchronized就会导致上下文切换。</p><h3 id="synchronized的内存语意"><a href="#synchronized的内存语意" class="headerlink" title="synchronized的内存语意"></a>synchronized的内存语意</h3><p>  synchronized代码块中的变量会 <strong><em>从线程的工作内存中清除</em></strong> ，也就是说synchronized可以解决内存的不可见性。</p><h3 id="Java中的volatile关键字"><a href="#Java中的volatile关键字" class="headerlink" title="Java中的volatile关键字"></a>Java中的volatile关键字</h3><p>  使用synchronized的方式可以解决内存不可见，volatile也可以。</p><p>  <strong><em>当变量声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是把值刷新会主内存</em></strong> 。</p><p>  volatile虽然解决了内存可见性问题，但是并不是原子操作，所以在多线程并发时也会出现异常。而一般在什么时候使用volatile关键字呢？</p><ol><li><p>写入变量不依赖与变量的当前值(加一和赋值操作),因为如果依赖于当前值，那么获取——计算——写入这三步不是原子操作，而不保证volatile的原子性。</p></li><li><p>读写变量时没有加锁。加锁已经保证了内存可见性，所以没必要把变量再声明为volatile了。</p></li></ol><h2 id="java中的原子性操作"><a href="#java中的原子性操作" class="headerlink" title="java中的原子性操作"></a>java中的原子性操作</h2><p>  因为 <strong><em>线程切换是CPU指令级别的</em></strong> ，而Java中的一条语句通常是由很多指令组成的，所以在多线程环境下线程切换会导致很多并发不安全的问题，而synchronized会保证同时只有一个线程执行。</p><h2 id="Java中的CAS操作"><a href="#Java中的CAS操作" class="headerlink" title="Java中的CAS操作"></a>Java中的CAS操作</h2><p>  CAS即Compare and Swap，是JDK提供的<em>非阻塞原子性操作</em>，它通过硬件保证了比较——更新操作的原子性。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>  当线程1使用CAS修改初始值为A的变量X，那么线程1会首先获取当前变量X的值，然后使用CAS操作尝试修改X的值为B，但是这个时候线程2使用CAS修改变量的值为B然后又通过CAS操作修改变脸的值为A，此时线程1执行CAS的时候X的值虽然是A，然是这个A已经不是线程1获取时的A了。</p><p>  解决：ABA问题就是变量的状态发生了环形转换，可以提供给变量的状态值配置一个时间戳来避免ABA问题产生。</p><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p>  Unsafe类提供了硬件级别的原子性操作，里面的方法都是native方法，他们使用JNI方式访问本地C++实现库。</p><p>  当我们要使用Unsafe类的时候，在本身getUnsafe()方法中会判断当前类加载是否是Bootstrap类加载器，如果不是抛出异常，而我们启动main函数所在的类是使用AppClassLoader加载的，所以在main函数这里面加载Unsafe类的时候，根据委托机制，会委托给Bootstrap去加载Unsafe类。</p><p>  如果不加以限制，我们可以直接通过Unsafe操作内存，这是不安全的，所以我们需要在rt.jar包下使用Unsafe类，我们也可以通过万能的反射来实现。</p><h2 id="Java指令重排序"><a href="#Java指令重排序" class="headerlink" title="Java指令重排序"></a>Java指令重排序</h2><p>  <strong>Java内存模型允许编译器和处理器对指令重排序以提高运行性能</strong>。而多线程的环境下指令重排序会导致一些并发问题，而如果使用volatile修饰变量可以避免一些重排序和内存可见性问题。</p><p>  写volatile变量的时候，可以确保volatile变量写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保对volatile变量读之后的操作不会被编译器重排序到volatile读之前。</p><h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h3><p>  为了解决内存和CPU之间的速度差异，CPU会添加一个或多个缓存存储器，而缓存在内部是 <strong><em>按行存储</em></strong> 的。因为局部性原理，当一个变量要存入缓存中其实是连带着周围的变量存入缓存的。所以存入Cache行的<strong>是内存而不是单个变量</strong>。</p><p>  比如现在两个CPU，有两个变量x，y放入了缓存行，当线程1对CPU1的缓存行进行修改变量x的值的时候，因为缓存一致性协议，会导致CPU2对应的缓存行失效。所以线程2需要写入x或y的值的时候就要去二级缓存中查找。</p><h3 id="为何出现伪共享"><a href="#为何出现伪共享" class="headerlink" title="为何出现伪共享"></a>为何出现伪共享</h3><p>  因为放入缓存行的是多个数据(是一个内存空间)。</p><h3 id="如何避免伪共享"><a href="#如何避免伪共享" class="headerlink" title="如何避免伪共享"></a>如何避免伪共享</h3><p>  填充缓存行(创建一个对象封装相应的变量使对象空间和缓存行空间一样大)。</p><p>  JDK8后使用sun.misc.Contended注解(会自动补齐缓存行)。</p><h2 id="锁的概述"><a href="#锁的概述" class="headerlink" title="锁的概述"></a>锁的概述</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>  悲观锁：对数据被外界修改保持保守态度，认为数据很容易就被其他线程修改，在对数据处理之前先加锁。</p><p>  乐观锁：认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而在进行数据提交更新的时候，才会正式对数据冲突与否进行检测。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>  公平锁：先来先获得锁。</p><p>  非公平：后来的也可以抢占锁。</p><p>  在一般情况下使用非公平锁，公平锁会带来额外开销。</p><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p>  独占锁：只能一个线程拥有</p><p>  共享锁：多个线程拥有，比如说ReadWriteLock读写锁允许一个资源被多个线程进行读操作。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>  可重入锁：已经获得了锁的资源再次申请该锁的时候不会被阻塞，synchronized就是一个可重入锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>  当前线程在获取锁的时候，如果发现锁已经被占用，它不马上阻塞自己，而是在不放弃CPU使用权的情况下，多次(默认情况下是10次)尝试获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是多线程并发编程&quot;&gt;&lt;a href=&quot;#什么是多线程并发编程&quot; class=&quot;headerlink&quot; title=&quot;什么是多线程并发编程&quot;&gt;&lt;/a&gt;什么是多线程并发编程&lt;/h2&gt;&lt;p&gt;  并发：同一个时间段多个任务同时都在执行。&lt;/p&gt;
&lt;p&gt;  并行：多个任
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——Java并发编程之美读书笔记一</title>
    <link href="https://francisqiang.github.io/2019/08/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>https://francisqiang.github.io/2019/08/11/Java并发编程学习——Java并发编程之美读书笔记一/</id>
    <published>2019-08-11T06:04:03.000Z</published>
    <updated>2019-08-11T11:36:41.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>  在操作系统中，进程是资源分配的基本单位，线程是资源调度的基本单位，因为<strong>真正占用CPU的是线程</strong>。</p><p>  <img src="/2019/08/11/Java并发编程学习——Java并发编程之美读书笔记一/1.jpg" alt="Java进程模型"></p><p>  对于整个Java应用程序来说是一个进程，里面有很多线程。在操作系统中说，线程不独立拥有资源(进程是拥有资源的基本单位)，但是线程还是会拥有自己独立的一些资源的比如说程序计数器，栈等。</p><p>  程序计数器：<strong>用来记录当前线程要执行的指令地址</strong>。我的理解是，第一为了确定线程要执行的后面的指令地址，第二是为了<strong>确保线程切换的时候，线程能记住它的执行状态(当前执行到哪了)，当下一次再次获得CPU资源的时候，线程能从它私有的程序计数器中获取指令地址继续执行</strong>。但是如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行Java代码的时候记录的才是下一条指令的地址。</p><p>  栈：对于任何语言来说，线程是需要有栈的，这个栈中存放是就是<strong>栈帧</strong>。因为，对于CPU来说，是没有方法层面的，当高级语言进行方法调用的时候其实对于CPU来说还是执行相应地址中的指令，所以在高级语言中需要有一个<strong>方法调用栈</strong>，每执行一次方法调用的时候将参数，返回地址存入栈帧中并压入方法栈，等到被调用的方法执行完再出栈取出返回地址继续执行指令。而因为<strong>栈帧和方法同生死共命运</strong>，所以局部变量，参数等都是放入栈帧中的。</p><p>  总结：线程中这个栈是方法调用栈，其中基本单位是栈帧，每次该线程进行方法调用的时候创建栈帧并压入方法调用栈，栈帧中有相应的方法参数，返回地址，和局部变量(<strong>Java中局部变量在栈中的原因</strong>)</p><p>  堆：堆是进程中最大的一块内存，堆是被进程中的所有线程所共享的。堆中主要存放的是new操作创建的对象实例(Java对象在堆中)。</p><p>  方法区：用来存放JVM加载的类，常量及静态变量等信息，也是所有线程共享的。</p><h2 id="线程创建与运行"><a href="#线程创建与运行" class="headerlink" title="线程创建与运行"></a>线程创建与运行</h2><p>  线程创建有三种方式</p><ol><li><p>实现Runnable接口并重写run方法</p></li><li><p>继承Thread类并重写run方法</p></li><li><p>使用FutureTask创建</p><p>使用继承的好处是，获取当前线程直接使用this就可以了，但是Java不支持多继承，所以该类继承了Thread类之后不能再继承其他类了(降低了可扩展性)，而且继承Thread类即将任务代码和线程耦合了。</p><p>实现Runnable接口并重写run方法，最后将该实现接口实例作为参数传入Thread构造函数中，这种方法将任务代码和线程之间解耦，并且解决了多继承的问题。</p><p>而对于上面两种创建线程的方法来说，线程是没有返回值的，因为run方法是void方法。要使线程具有返回值可以通过FutureTask创建线程。</p><p>具体的步骤是：</p></li><li><p>创建一个类实现Callable接口并重写call()方法</p></li><li>将该类作为参数传入Thread构造方法并启动线程</li><li>最后通过FutureTask.get()等待任务执行完毕返回结果</li></ol><h2 id="线程等待与通知"><a href="#线程等待与通知" class="headerlink" title="线程等待与通知"></a>线程等待与通知</h2><h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h3><p>  它是Object中的一个方法，在并发编程中，它的调用者其实是<strong>共享变量</strong>，因为只有获得了synchronized隐式锁的线程才能使用wait方法，如果没有则会抛出IllegalMonitorStateException。</p><p>  当线程调用这个wait方法的时候会被<strong>阻塞挂起</strong>，只有</p><ol><li>其他线程调用了该共享变量的notify或者notifyAll(也就是说wait方法会释放当前共享变量的锁)</li><li><p>其他线程调用了该线程的interrupt()方法，该线程抛出InterruptedException异常并返回。</p><p>为了防范<em>虚假唤醒</em>，所以wait方法有它的编程范式</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait-long-timeout"><a href="#wait-long-timeout" class="headerlink" title="wait(long timeout)"></a>wait(long timeout)</h3><p>  增加wait时间限制，如果超出时间限制，不管上文提到的两个情况是否满足，该线程<strong>还是会因为超时而返回</strong>。</p><h3 id="wait-long-timeout-int-nanos"><a href="#wait-long-timeout-int-nanos" class="headerlink" title="wait(long timeout, int nanos)"></a>wait(long timeout, int nanos)</h3><p>  差不多，内部其实调用的是wait(long timeout)函数</p><h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><p>  会<strong>随机</strong>唤醒一个在该共享变量下调用wait()方法而阻塞的线程。</p><p>  被唤醒的线程不能直接执行，还需要重新获得共享变量的锁，才能继续执行。</p><h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h3><p>  通知所有在该共享变量下因为调用wait而阻塞的线程。</p><h2 id="等待线程执行终止的join方法"><a href="#等待线程执行终止的join方法" class="headerlink" title="等待线程执行终止的join方法"></a>等待线程执行终止的join方法</h2><p>  join方法是Thread直接提供的无参且返回值为void的方法。</p><p>  作用是<strong>等待线程执行完毕</strong>。</p><h2 id="让线程睡眠的sleep-方法"><a href="#让线程睡眠的sleep-方法" class="headerlink" title="让线程睡眠的sleep()方法"></a>让线程睡眠的sleep()方法</h2><p>  会让线程暂时让出指定时间的执行权，也就是在这期间不参与<strong>CPU调度</strong>，但是线程持有的监视器资源(比如锁)是<strong>不会释放</strong>的。</p><h2 id="让出CPU执行权的yield-方法"><a href="#让出CPU执行权的yield-方法" class="headerlink" title="让出CPU执行权的yield()方法"></a>让出CPU执行权的yield()方法</h2><p>  当一个线程调用这个方法的时候就是在暗示线程调度器 当前线程请求让出自己的CPU使用，<strong>但是，线程调度器可以无条件忽略这个暗示</strong>。我们知道时间片轮转会让某个线程持有CPU资源一段时间，线程如果还没使用完这个时间就不想使用了，可以调用这个方法来告诉线程调度器可以进行下一轮的线程调度了。</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>  <strong>线程中断是线程之间的一种协作模式</strong>，通过设置<em>中断标志</em>不能直接终止线程的执行，而是 <strong><em>线程根据中断状态自己去处理</em></strong> 。</p><p>  下面三个方法是关于线程中断的</p><ol><li><p>void interrupt()方法 中断线程，例如线程A执行时，线程B可以通过调用线程A的interrupt()方法来设置线程A的<strong>中断标志为true，并立即返回</strong>，注意：仅仅是设置中断标志，线程A并没有真正被中断。若线程A调用了wait(),join(),sleep()方法而被阻塞挂起的时候，线程B调用线程A的interrupt()方法会在 <strong><em>调用这些方法的地方抛出InterruptedException而返回(注意：这里是wait()这些方法，而不是interrupt()方法)</em></strong> 。</p></li><li><p>boolean isInterrupted()方法 检测当前线程是否被中断，如果是返回true，否则false。</p></li><li><p>boolean interrupted()方法 检测 <strong><em>当前线程</em></strong> 是否被中断，如果是返回true，否则false。并且它还会<strong>清除中断状态</strong>。它是Thread的静态方法，不管在哪调用返回的都是当前执行的线程的中断状态并清楚中断状态。</p><p>如果某个线程为了等待某些条件发生而阻塞(一般会调用sleep，wait或join函数)，比如这个线程调用了sleep(3000)函数去等待某种条件发生，但是在1秒的时候条件已经满足，这个时候可以调用该线程的interrupt()方法来 <strong><em>强制sleep()抛出InterruptedException而返回，线程恢复到激活状态</em></strong>。</p></li></ol><h2 id="理解线程上下文切换"><a href="#理解线程上下文切换" class="headerlink" title="理解线程上下文切换"></a>理解线程上下文切换</h2><p>  正如一开始所讲的程序计数器，程序技术器中保存了相应的下一个执行指令地址，栈中保存了执行的一些信息。这些就是线程上下文切换所需要的资源。</p><p>  线程上下文切换的时机</p><ol><li><p>当前线程CPU时间使用完处于就绪状态。</p></li><li><p>当前线程被其他线程中断。</p></li></ol><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>  死锁的四个必要条件：1. 互斥，2. 请求并占有， 3. 不可剥夺， 4. 环路等待</p><p>  避免：破坏一个必要条件。</p><h2 id="守护线程与用户线程"><a href="#守护线程与用户线程" class="headerlink" title="守护线程与用户线程"></a>守护线程与用户线程</h2><p>  Java中的线程分为两类：分别为daemon线程和user线程。JVM在启动时会调用main函数，main函数所在的线程是user线程，其实JVM在启动时还启动了好多daemon线程比如垃圾回收线程。</p><p>  用户线程和守护线程的区别：当最后一个用户线程结束的时候JVM会退出，而守护线程的消亡不会影响到JVM的退出。</p><p>  比如在main函数中启动一个无限循环的用户线程，当主线程执行完毕的时候JVM不会退出，但是如果把这个无限循环的线程改为守护线程，那么在主线程结束后JVM会自动退出。</p><p>  如何设置守护线程？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deamonThread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>  main线程运行结束后，JVM会自动启动一个叫做DestroyJavaVM的线程，该线程会等待所有 <strong><em>用户线程</em></strong> 结束后终止JVM进程。</p><p>  而Tomcat的NIO实现NioEndPoint中会开启一组接受线程来接受用户的连接请求以及一组处理线程负责具体处理用户请求，这些线程线程被设置成了守护线程，即当tomcat收到shutdown命令之后并且没有其他用户线程存在的情况下，tomcat进程会马上消亡而<strong>不会等待处理线程处理完当前的请求</strong>。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>  线程本地化，可以将共享变量复制到线程本地存储空间。这是一种无锁的同步方式。</p><p>  使用方式： 创建ThreadLocal变量，在线程运行方法中设置刚刚的threadLocal变量实例。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>  <img src="/2019/08/11/Java并发编程学习——Java并发编程之美读书笔记一/2.jpg" alt="ThreadLocal原理"></p><p>  当ThreadLocal实例在线程执行的时候第一次调用set或者get方法的时候会在线程中创建相应的threadLocals(这个是一个ThreadLocalMap，一种定制化的HashMap，里面存放了许多线程本地化变量)，key为当前ThreadLocal实例的引用，值为自己设置的值。后面调用就直接会在线程的threadLocals这个Map中进行操作。</p><p>  注意当本地变量不再使用的时候最好使用remove将其删除，避免内存溢出。还要注意的是ThreadLocal不支持继承，也就是说子线程不会拥有父线程的threadLocals变量。</p><p>  但是可以使用InheritableThreadLocal类，可以追溯Thread创建的源码，Thread在创建的过程中会判断父线程的inheritableThreadLocals(上图的Thread中有这个私有变量)是否为空，如果不为空那么将其复制到子线程的inheritableThreadLocals中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;  在操作系统中，进程是资源分配的基本单位，线程是资源调度的基本单位，因为&lt;strong&gt;真正占用CPU的是线程&lt;/
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——为什么局部变量是线程安全的</title>
    <link href="https://francisqiang.github.io/2019/08/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84/"/>
    <id>https://francisqiang.github.io/2019/08/10/Java并发编程学习——为什么局部变量是线程安全的/</id>
    <published>2019-08-10T09:32:30.000Z</published>
    <updated>2019-08-10T09:58:58.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="局部变量不存在数据竞争"><a href="#局部变量不存在数据竞争" class="headerlink" title="局部变量不存在数据竞争"></a>局部变量不存在数据竞争</h2><p>  在并发编程领域里，<strong>没有共享就没有伤害</strong>。对于局部变量是不存在数据竞争的，为什么呢？</p><p>  比如，下面代码里的 fibonacci() 这个方法，会根据传入的参数 n ，返回 1 到 n 的斐波那契数列，斐波那契数列类似这样： 1、1、2、3、5、8、13、21、34……第 1 项和第 2 项是 1，从第 3 项开始，每一项都等于前两项之和。在这个方法里面，有个局部变量：数组 r 用来保存数列的结果，每次计算完一项，都会更新数组 r 对应位置中的值。你可以思考这样一个问题，当多个线程调用 fibonacci() 这个方法的时候，数组 r 是否存在数据竞争（Data Race）呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回斐波那契数列</span></span><br><span class="line"><span class="keyword">int</span>[] fibonacci(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="comment">// 创建结果数组</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 初始化第一、第二个数</span></span><br><span class="line">  r[<span class="number">0</span>] = r[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// ①</span></span><br><span class="line">  <span class="comment">// 计算 2..n</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">      r[i] = r[i-<span class="number">2</span>] + r[i-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们试想一下貌似多个线程同时执行fibonacci方法的时候对数组r的写入读取会发生数据竞争。</p><h2 id="方法是如何被执行的"><a href="#方法是如何被执行的" class="headerlink" title="方法是如何被执行的"></a>方法是如何被执行的</h2><p>  对于CPU来说是没有方法这一层面的，对于它来说任何操作都是一条条指令，那么CPU如果进行一个方法调用总要进行返回到调用方法的代码片段(地址)去执行，这个CPU是怎么做到的呢？</p><p>  答案就是栈，在我的关于栈的文章中提到过方法栈，CPU就是通过栈来实现返回到原来调用方法的地址的。</p><p>  <img src="/2019/08/10/Java并发编程学习——为什么局部变量是线程安全的/1.jpg" alt="方法栈"></p><p>  在线程执行进入方法的时候，会将这个方法的一些信息作为<strong>栈帧</strong>压入<strong>方法栈</strong>中。一些信息可能有参数，返回地址(这个肯定是必要的，因为出栈的时候需要用到，不然无法返回了)。但栈帧出栈的时候就意味着这个方法执行完了，所以隐含意思就是<strong>一个栈帧对应着一次一个方法的执行，栈帧和一次一个方法的执行是同生死共命运的</strong>。</p><p>  而我们也知道，对于局部变量来说，在方法执行完就会消失，所以局部变量和栈帧就有着同样的性质了，即局部变量，栈帧，一次一个方法的执行这三者是同时消亡的。所以把局部变量放入栈帧中是最合适不过的了，现实也是这么做的。这也解释了<strong>Java中为什么局部变量是存放在栈中的</strong>，想要跨越方法的边界，那么变量就必须放入堆中。</p><p>  <img src="/2019/08/10/Java并发编程学习——为什么局部变量是线程安全的/2.jpg" alt="方法栈"></p><h2 id="线程与方法栈"><a href="#线程与方法栈" class="headerlink" title="线程与方法栈"></a>线程与方法栈</h2><p> <img src="/2019/08/10/Java并发编程学习——为什么局部变量是线程安全的/3.jpg" alt="方法栈"></p><p>  从操作系统层面来说，每个线程不独立拥有资源，但是它还是拥有一些必要的资源比如线程控制块(也不算资源)，用户栈，内核栈。。所以线程是拥有自己的栈的，也就是说每个线程执行过程中都拥有自己的方法调用栈，而栈帧是在这个方法栈中的，栈帧里面拥有着局部变量，所以可以说，每个线程的局部变量根本不是一个地址，所以就不会出现数据竞争了，所以局部变量是线程安全的。</p><h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>  因为局部变量不存在并发问题，现在也成为了一个解决并发问题的重要思路了，叫<strong>线程封闭</strong>。</p><p>  采用线程封闭技术的案例非常多，例如从数据库连接池里获取的连接 Connection，在 JDBC 规范里并没有要求这个 Connection 必须是线程安全的。数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程，从而保证了 Connection 不会有并发问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;局部变量不存在数据竞争&quot;&gt;&lt;a href=&quot;#局部变量不存在数据竞争&quot; class=&quot;headerlink&quot; title=&quot;局部变量不存在数据竞争&quot;&gt;&lt;/a&gt;局部变量不存在数据竞争&lt;/h2&gt;&lt;p&gt;  在并发编程领域里，&lt;strong&gt;没有共享就没有伤害&lt;/stro
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——创建多少线程才是合适的</title>
    <link href="https://francisqiang.github.io/2019/08/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E6%89%8D%E6%98%AF%E5%90%88%E9%80%82%E7%9A%84/"/>
    <id>https://francisqiang.github.io/2019/08/10/Java并发编程学习——创建多少线程才是合适的/</id>
    <published>2019-08-10T08:24:39.000Z</published>
    <updated>2019-08-10T08:55:16.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h2><p>  减少<strong>延迟</strong>，提高<strong>吞吐量</strong>。</p><p>  延迟指从发出请求到收到响应过程的时间，吞吐量指单位时间内能完成的请求个数。</p><h2 id="多线程应用场景"><a href="#多线程应用场景" class="headerlink" title="多线程应用场景"></a>多线程应用场景</h2><p>  想要降低延迟提高吞吐量主要有两个维度的方法，第一个是优化算法，第二个是最大化硬件的利用率。前者属于算法范畴，后者就和并发编程息息相关了。而对于计算机硬件来说最主要的就是两个硬件，一个是IO一个是CPU。在操作系统层面，操作系统已经为我们对硬件的利用率做了很大的优化，但是还是不够，在CPU与IO配合使用的利用率更加需要我们程序员去优化。也就是说，<strong>我们需要去解决CPU和IO设备综合利用率的问题</strong></p><p>  <img src="/2019/08/10/Java并发编程学习——创建多少线程才是合适的/1.jpg" alt="单线程"></p><p>  例如在单线程中，假设CPU和IO的执行时间相同，那么这个时候CPU和IO设备的利用率都是50%。</p><p>  但在双线程中，CPU和IO设备执行时间都是一样的，这个时候，CPU在等待IO的时候又可以去执行下一个线程的，这个时候CPU和IO的利用率就是100%。</p><p>  <img src="/2019/08/10/Java并发编程学习——创建多少线程才是合适的/2.jpg" alt="双线程"></p><p>  所以，<strong>如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来提高吞吐量。</strong></p><p>  在单核时代，多线程主要就是用来平衡 CPU 和 I/O 设备的。如果程序只有 CPU 计算，而没有 I/O 操作的话，多线程不但不会提升性能，还会使性能变得更差，原因是<strong>增加了线程切换的成本</strong>。但是在多核时代，这种纯计算型的程序也可以利用多线程来提升性能。为什么呢？因为利用多核可以降低响应时间。</p><p>  例如计算 1+2+… … +100 亿的值，如果在 4 核的 CPU 上利用 4 个线程执行，线程 A 计算 [1，25 亿)，线程 B 计算 [25 亿，50 亿)，线程 C 计算 [50，75 亿)，线程 D 计算 [75 亿，100 亿]，之后汇总，那么理论上应该比一个线程计算 [1，100 亿] 快将近 4 倍，响应时间能够降到 25%。一个线程，对于 4 核的 CPU，CPU 的利用率只有 25%，而 4 个线程，则能够将 CPU 的利用率提高到 100%。</p><p>  <img src="/2019/08/10/Java并发编程学习——创建多少线程才是合适的/3.jpg" alt="双线程"></p><h2 id="创建多少线程合适"><a href="#创建多少线程合适" class="headerlink" title="创建多少线程合适"></a>创建多少线程合适</h2><p>  创建多少线程合适需要考虑应用场景，通常情况下我们的程序都是由IO操作和CPU操作一起执行的，而IO操作相对于CPU操作来说是非常耗时的。所以大部分情况下，I/O 操作执行的时间相对于 CPU 计算来说都非常长，这种场景我们一般都称为 I/O 密集型计算。</p><p>  和 I/O 密集型计算相对的就是 CPU 密集型计算了，CPU 密集型计算大部分场景下都是纯 CPU 计算。I/O 密集型程序和 CPU 密集型程序，计算最佳线程数的方法是不同的。</p><p>  对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的 CPU，每个核一个线程，理论上创建 4 个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，对于 CPU 密集型的计算场景，理论上<strong>线程的数量 =CPU 核数</strong>就是最合适的。不过在工程上，线程的数量一般会设置为<strong>CPU 核数 +1</strong>，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。</p><p>  对于 I/O 密集型的计算场景，比如前面我们的例子中，如果 CPU 计算和 I/O 操作的耗时是 1:1，那么 2 个线程是最合适的。如果 CPU 计算和 I/O 操作的耗时是 1:2，那多少个线程合适呢？是 3 个线程，如下图所示：CPU 在 A、B、C 三个线程之间切换，对于线程 A，当 CPU 从 B、C 切换回来时，线程 A 正好执行完 I/O 操作。这样 CPU 和 I/O 设备的利用率都达到了 100%。</p><p>  <img src="/2019/08/10/Java并发编程学习——创建多少线程才是合适的/4.jpg" alt="IO密集型计算"></p><p>  最佳线程数 =1 +（I/O 耗时 / CPU 耗时）</p><p>  对于多核来说只需要乘上核数就行：最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用多线程&quot;&gt;&lt;a href=&quot;#为什么使用多线程&quot; class=&quot;headerlink&quot; title=&quot;为什么使用多线程&quot;&gt;&lt;/a&gt;为什么使用多线程&lt;/h2&gt;&lt;p&gt;  减少&lt;strong&gt;延迟&lt;/strong&gt;，提高&lt;strong&gt;吞吐量&lt;/strong&gt;
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——Java线程的生命周期</title>
    <link href="https://francisqiang.github.io/2019/08/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://francisqiang.github.io/2019/08/10/Java并发编程学习——Java线程的生命周期/</id>
    <published>2019-08-10T05:16:09.000Z</published>
    <updated>2019-08-10T06:26:48.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通用线程模型"><a href="#通用线程模型" class="headerlink" title="通用线程模型"></a>通用线程模型</h2><p>  在操作系统中线程有五种状态，这也是通用的线程模型。这五种状态分别是<strong>初始状态(创建)</strong>,<strong>可运行状态(就绪)</strong>,<strong>运行状态</strong>,<strong>休眠状态(阻塞)</strong>,<strong>终止状态(消亡)</strong>。</p><p>  <img src="/2019/08/10/Java并发编程学习——Java线程的生命周期/1.jpg" alt="通用线程模型"></p><p>  对于这五种状态，不同的编程语言会对他们进行简化合并或者细化，就比如Java把这五种状态进行了相应的更改。</p><h2 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h2><p>  Java线程一共有六种状态，分别是：NEW（初始化状态），RUNNABLE（可运行 / 运行状态），BLOCKED（阻塞状态），WAITING（无时限等待），TIMED_WAITING（有时限等待），TERMINATED（终止状态）。</p><p>  <img src="/2019/08/10/Java并发编程学习——Java线程的生命周期/2.jpg" alt="Java线程模型"></p><p>  而对于BLOCKED，WAITTING，TIMED_WATTING这三种状态可以归于通用线程模型中的休眠状态(阻塞)，而对于通用线程中的运行状态和就绪(可运行状态)，在Java中则对他们进行了合并，合并成了Runnable状态。</p><h3 id="Runnable与Blocked状态之间的转换"><a href="#Runnable与Blocked状态之间的转换" class="headerlink" title="Runnable与Blocked状态之间的转换"></a>Runnable与Blocked状态之间的转换</h3><p>  对于Runnable转换成Blocked状态只有一种情况，那就是在获取synchronized隐式锁失败的时候，线程会从可运行(Runnable)状态转换为Blocked阻塞状态。而当线程获取到了synchronized隐式锁的时候又会从Blocked状态转换到Runnable状态。</p><p>  但是<strong>线程调用阻塞式API的时候不会从Runnable状态转换到Blocked状态</strong>，在操作系统层面，线程会进入休眠(阻塞状态)，但是在JVM层面，线程的状态是不会发生变化的，也就是说线程状态还是Runnable。<strong>JVM 层面并不关心操作系统调度相关的状态</strong>，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。</p><h3 id="Runnable和Waitting状态之间的转换"><a href="#Runnable和Waitting状态之间的转换" class="headerlink" title="Runnable和Waitting状态之间的转换"></a>Runnable和Waitting状态之间的转换</h3><ol><li><p>获得synchronized隐式锁的线程调用Object的wait方法</p></li><li><p>调用无参数的Thread.join(),其中的 join() 是一种线程同步方法，例如有一个线程对象 thread A，当调用 A.join() 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。</p></li><li><p>调用 LockSupport.park() 方法。其中的 LockSupport 对象，也许你有点陌生，其实 Java 并发包中的锁，都是基于它实现的。调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。</p></li></ol><h3 id="Runnable与Timed-Waitting状态之间的转换"><a href="#Runnable与Timed-Waitting状态之间的转换" class="headerlink" title="Runnable与Timed_Waitting状态之间的转换"></a>Runnable与Timed_Waitting状态之间的转换</h3><ol><li><p>调用带超时参数的 Thread.sleep(long millis) 方法</p></li><li><p>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法</p></li><li><p>调用带超时参数的 Thread.join(long millis) 方法</p></li><li><p>调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；</p></li><li><p>调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。</p></li></ol><h3 id="从New到Runnable状态"><a href="#从New到Runnable状态" class="headerlink" title="从New到Runnable状态"></a>从New到Runnable状态</h3><p>  首先当线程创建的时候就是New状态，而创建线程有两种方式。</p><p>  一是继承Thread类并重写run方法。</p><p>  二是实现Runnable接口重写run方法并将该类作为创建Thread的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义线程对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程需要执行的代码</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程需要执行的代码</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner());</span><br></pre></td></tr></table></figure><p>  而对于从New状态到Runnable状态只需要调用线程的start()方法。</p><h3 id="从Runnable状态到Terminated状态"><a href="#从Runnable状态到Terminated状态" class="headerlink" title="从Runnable状态到Terminated状态"></a>从Runnable状态到Terminated状态</h3><p>  调用stop()或者interrupt()方法，但是对于stop方法官方已经废弃，因为stop方法会直接杀死线程，如果线程已经获得隐式锁，那么这锁也会消失，也就意味着，其他线程再也获取不到这个锁了。类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了。</p><p>  而 interrupt() 方法就温柔多了，interrupt() 方法仅仅是<strong>通知线程</strong>，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是<strong>异常</strong>，另一种是<strong>主动检测</strong>。</p><p>  比如有线程A和线程B，线程A调用了线程B的interrupt()方法，这个意思是指线程A告诉线程B——你现在被设置成了中断状态。但是线程B还可以进行操作(因为它有个isInterrupted来决定被中断之后执行的操作)</p><p>  当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。</p><p>  上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件，都是调用了类似 wait()、join()、sleep() 这样的方法，我们看这些方法的签名，发现都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。</p><p>  <em>当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回</em>。</p><p>  上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的 interrupt() 方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通用线程模型&quot;&gt;&lt;a href=&quot;#通用线程模型&quot; class=&quot;headerlink&quot; title=&quot;通用线程模型&quot;&gt;&lt;/a&gt;通用线程模型&lt;/h2&gt;&lt;p&gt;  在操作系统中线程有五种状态，这也是通用的线程模型。这五种状态分别是&lt;strong&gt;初始状态(创建)&lt;/s
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——管程</title>
    <link href="https://francisqiang.github.io/2019/08/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%A1%E7%A8%8B/"/>
    <id>https://francisqiang.github.io/2019/08/09/Java并发编程学习——管程/</id>
    <published>2019-08-09T14:04:37.000Z</published>
    <updated>2019-08-09T14:49:41.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h2><p>  管程：<strong>管理共享变量和操作共享变量的过程</strong>。为了解决信号量配对的复杂性以及分散在程序中降低了程序的可读性，管程通过一种数据结构对共享变量和对共享变量的操作进行了封装。</p><p>  管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程更容易使用，所以 Java 选择了管程。</p><p>  在Java1.5之前提供的是synchronized，wait，notify和notifyAll，这是java管程实现的一部分。</p><h2 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h2><p>  在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。</p><h3 id="MESA模型实现互斥"><a href="#MESA模型实现互斥" class="headerlink" title="MESA模型实现互斥"></a>MESA模型实现互斥</h3><p>  <img src="/2019/08/09/Java并发编程学习——管程/1.jpg" alt="互斥"></p><p>  这里的共享变量被封装起来了，其中对于共享变量queue的操作只能通过enq和deq，而这两个方法保证互斥性，只允许一个线程进入管程。</p><h3 id="MESA墨香实现同步"><a href="#MESA墨香实现同步" class="headerlink" title="MESA墨香实现同步"></a>MESA墨香实现同步</h3><p>  <img src="/2019/08/09/Java并发编程学习——管程/2.jpg" alt="同步"></p><p>  对于同步则通过增加<strong>条件变量和相应的等待队列</strong>。</p><p>  如果当条件变量不满足的时候则进入相应的等待队列，因为某个操作而导致条件允许的时候则唤醒相应的等待队列中的线程，并且再次获取锁来执行。因为要再次获取锁，所以这个条件只能是曾经满足过，所以当阻塞线程被唤醒再次获取锁需要执行的时候，有可能这个时候的条件又不允许了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于入队操作，如果队列已满，就需要等待直到队列不满，所以这里用了notFull.await();。</p><p>对于出队操作，如果队列为空，就需要等待直到队列不空，所以就用了notEmpty.await();。</p><p>如果入队成功，那么队列就不空了，就需要通知条件变量：队列不空notEmpty对应的等待队列。</p><p>如果出队成功，那就队列就不满了，就需要通知条件变量：队列不满notFull对应的等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock =</span><br><span class="line">    <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 条件变量：队列不满  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notFull =</span><br><span class="line">    lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量：队列不空  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty =</span><br><span class="line">    lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enq</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已满)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不满</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 省略入队操作...</span></span><br><span class="line">      <span class="comment">// 入队后, 通知可出队</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deq</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已空)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略出队操作...</span></span><br><span class="line">      <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里的await和signal就类似于wait和notify。</p><p>  对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 wait()。这个是 MESA 管程特有的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">  wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，如何通知相关线程。管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？</p><ol><li><p>Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。</p></li><li><p>Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。</p></li><li><p>MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。</p></li></ol><h2 id="notify-何时可以使用"><a href="#notify-何时可以使用" class="headerlink" title="notify() 何时可以使用"></a>notify() 何时可以使用</h2><p>  满足以下三个条件：</p><ol><li><p>所有等待线程拥有相同的等待条件</p></li><li><p>所有等待线程被唤醒之后，执行相同的操作。</p></li><li><p>只需要唤醒一个线程。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是管程&quot;&gt;&lt;a href=&quot;#什么是管程&quot; class=&quot;headerlink&quot; title=&quot;什么是管程&quot;&gt;&lt;/a&gt;什么是管程&lt;/h2&gt;&lt;p&gt;  管程：&lt;strong&gt;管理共享变量和操作共享变量的过程&lt;/strong&gt;。为了解决信号量配对的复杂性以及分散在程
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——安全性，活跃性以及性能问题</title>
    <link href="https://francisqiang.github.io/2019/08/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/08/09/Java并发编程学习——安全性，活跃性以及性能问题/</id>
    <published>2019-08-09T06:11:27.000Z</published>
    <updated>2019-08-09T06:44:09.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>  在并发编程中需要考虑三个基本问题——安全性，活跃性以及性能。</p><p>  所谓安全性就是指程序能否按照我们预期的执行。就比如线程安全这个概念，所谓线程安全和不安全无非就是指程序能否保证它的正确性，而这个正确性就是我们让程序按照我们所期望地执行。</p><p>  而这种情况下只有<strong>存在共享数据并且该数据会发生变化</strong>的时候需要考虑安全性问题，通俗来讲就是是否存在多个线程对这个资源进行读写操作(至少有一个线程进行写操作)。</p><p>  当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做<strong>数据竞争</strong>（Data Race）。</p><p>  就比如以下的add10k方法，当多个线程调用的时候就会发生数据竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  那是不是在访问数据的地方，我们加个锁保护一下就能解决所有的并发问题了呢？显然没有这么简单。例如，对于上面示例，我们稍作修改，增加两个被 synchronized 修饰的 get() 和 set() 方法， add10K() 方法里面通过 get() 和 set() 方法来访问 value 变量，修改后的代码如下所示。对于修改后的代码，所有访问共享变量 value 的地方，我们都增加了互斥锁，此时是不存在数据竞争的。但很显然修改后的 add10K() 方法并不是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count；</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    count = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      set(get()+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来解读一下，这时候同时存在两个线程访问add10k方法然后同时进入while循环，然后同时调用get方法，但是因为get方法是synchronized修饰的所以同时只有一个线程能访问，比如这个时候线程A获得了优先权进行调用，读取到count为0，然后这个时候get方法执行完线程A释放锁，线程B获得了锁进入get方法也读取到count为0，然后可能这个时候线程B有执行了加一操作并且获得了set方法的锁进入set方法将count设置为1，这个时候可能线程A也执行了+1操作并且获得了线程B刚刚释放的锁来进行set操作，这个时候count又会被设置为1，其实本该结果为2(因为进行了两次加一操)，但是因为线程执行顺序的问题而导致程序不是按照我们期望的执行，所以这个是咸亨不安全的。</p><p>  这种问题，有个官方的称呼，叫<strong>竞态条件</strong>（Race Condition）。所谓竞态条件，指的是程序的执行结果依赖线程执行的顺序。例如上面的例子，如果两个线程完全同时执行，那么结果是 1；如果两个线程是前后执行，那么结果就是 2。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大 Bug。</p><p>  下面再结合一个例子来说明下竞态条件，就是前面文章中提到的转账操作。转账操作里面有个判断条件——转出金额不能大于账户余额，但在并发环境里面，如果不加控制，当多个线程同时对一个账号执行转出操作时，就有可能出现超额转出问题。假设账户 A 有余额 200，线程 1 和线程 2 都要从账户 A 转出 150，在下面的代码里，有可能线程 1 和线程 2 同时执行到第 6 行，这样线程 1 和线程 2 都会发现转出金额 150 小于账户余额 200，于是就会发生超额转出的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用<strong>互斥</strong>这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：<strong>锁</strong>。</p><h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><p>  所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是<strong>活锁</strong>和<strong>饥饿</strong>。</p><p>  但有时线程虽然<strong>没有发生阻塞</strong>，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。</p><p>  可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。</p><p>  解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p><p>  那“饥饿”该怎么去理解呢？所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。“不患寡，而患不均”，如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。</p><p>  解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p><p>  那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>  使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。</p><p>  所以我们要尽量减少串行，那串行对性能的影响是怎么样的呢？假设串行百分比是 5%，我们用多核多线程相比单核单线程能提速多少呢？</p><p>  有个阿姆达尔（Amdahl）定律，代表了处理器并行运算之后效率提升的能力，它正好可以解决这个问题，具体公式如下：</p><p>  <img src="/2019/08/09/Java并发编程学习——安全性，活跃性以及性能问题/2.jpg" alt="Amdahl"></p><p>  公式里的 n 可以理解为 CPU 的核数，p 可以理解为并行百分比，那（1-p）就是串行百分比了，也就是我们假设的 5%。我们再假设 CPU 的核数（也就是 n）无穷大，那加速比 S 的极限就是 20。也就是说，如果我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。</p><p>  所以使用锁的时候一定要关注对性能的影响。 那怎么才能避免锁带来的性能问题呢？这个问题很复杂，Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。</p><p>  不过从方案层面，我们可以这样来解决这个问题。</p><p>  第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……</p><p>  第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</p><p>  性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。</p><ol><li>吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。</li><li>延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。</li><li>并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  总之并发编程从微观上来讲就是要关注原子性，可见性，顺序性的问题。从宏观上来讲就要关注安全性，活跃性，性能的问题。而微观上三个问题的目的都是为了解决安全性的问题，但是解决问题的同时还可能产生新的问题，这就是活跃性的问题，而如何利用三个微观问题去解决安全问题随之带来了性能问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安全性问题&quot;&gt;&lt;a href=&quot;#安全性问题&quot; class=&quot;headerlink&quot; title=&quot;安全性问题&quot;&gt;&lt;/a&gt;安全性问题&lt;/h2&gt;&lt;p&gt;  在并发编程中需要考虑三个基本问题——安全性，活跃性以及性能。&lt;/p&gt;
&lt;p&gt;  所谓安全性就是指程序能否按照我们
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——使用等待通知机制优化循环等待</title>
    <link href="https://francisqiang.github.io/2019/08/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/"/>
    <id>https://francisqiang.github.io/2019/08/09/Java并发编程学习——使用等待通知机制优化循环等待/</id>
    <published>2019-08-09T04:56:22.000Z</published>
    <updated>2019-08-09T05:23:03.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是等待通知机制"><a href="#什么是等待通知机制" class="headerlink" title="什么是等待通知机制"></a>什么是等待通知机制</h2><p>  在前面提到的破坏占用且等待条件的时候使用了死循环来获取资源，当apply()操作历时非常长或者并发量很大的时候，这个死循环是非常占cpu资源的，所以这种场景下可以使用等待通知机制来优化循环等待。</p><p>  什么是等待通知机制？所谓等待就是当线程获取锁进入临界区想要获取相应资源而条件不满足获取不到的时候，线程自己进入阻塞状态(等待)并且释放锁，等到线程需要的资源都有的时候则<strong>通知</strong>线程它需要的资源<strong>曾经</strong>满足过。</p><p>  为什么说曾经满足过，因为当线程被通知唤醒的时候还需要重新获得互斥锁，在这个阶段是有时差的，所以这个时候可能会出现一些情况导致刚刚满足的资源又被其它线程拿走了。</p><h2 id="完美的就医流程"><a href="#完美的就医流程" class="headerlink" title="完美的就医流程"></a>完美的就医流程</h2><p>  就医流程就可以比作这个等待通知机制。</p><ol><li>患者需要挂号，等待叫号</li><li>等到叫到自己的号的时候就可以找医生就诊了。(获取互斥锁)</li><li>就诊过程医生可能要叫患者去做一些检查。同时叫下一个患者(因为某种条件，资源不符合线程释放锁进入阻塞状态)</li><li>患者做完检查，拿着报告重新分诊(资源满足要重新获得互斥锁)</li><li>医生再次叫到自己号的时候，患者再去找医生就诊(条件资源满足重新获得锁)</li></ol><h2 id="使用synchronized实现等待-通知机制"><a href="#使用synchronized实现等待-通知机制" class="headerlink" title="使用synchronized实现等待-通知机制"></a>使用synchronized实现等待-通知机制</h2><p>  在Java语言中可以通过synchronized结合wait(),notify(),notifyAll()这三个方法来实现等待-通知机制。</p><p>  在下面这个图里，左边有一个等待队列，同一时刻，只允许一个线程进入 synchronized 保护的临界区（这个临界区可以看作大夫的诊室），当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列里等待（相当于患者分诊等待）。<strong>这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列</strong>。</p><p>  <img src="/2019/08/09/Java并发编程学习——使用等待通知机制优化循环等待/1.jpg" alt="wait原理"></p><p>  在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。如上图所示，当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。 线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p><p>  上面我们一直强调 wait()、notify()、notifyAll() 方法操作的等待队列是互斥锁的等待队列，所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait()、this.notify()、this.notifyAll()；如果 synchronized 锁定的是 target，那么对应的一定是 target.wait()、target.notify()、target.notifyAll() 。而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als;</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 经典写法</span></span><br><span class="line">    <span class="comment">// 不满足则等待(释放锁并阻塞自己)</span></span><br><span class="line">    <span class="keyword">while</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    als.add(from);</span><br><span class="line">    als.add(to);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尽量使用notifyAll"><a href="#尽量使用notifyAll" class="headerlink" title="尽量使用notifyAll"></a>尽量使用notifyAll</h2><p>  notify会随机通知等待队列中的某一个线程，而notifyAll会通知等待队列中的所有线程。</p><p>  所以使用notify的风险就是有些线程可能永远不会被唤醒，所以除非经过深思熟虑，不然尽量避免使用notify。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是等待通知机制&quot;&gt;&lt;a href=&quot;#什么是等待通知机制&quot; class=&quot;headerlink&quot; title=&quot;什么是等待通知机制&quot;&gt;&lt;/a&gt;什么是等待通知机制&lt;/h2&gt;&lt;p&gt;  在前面提到的破坏占用且等待条件的时候使用了死循环来获取资源，当apply()操作
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——如何解决死锁</title>
    <link href="https://francisqiang.github.io/2019/08/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81/"/>
    <id>https://francisqiang.github.io/2019/08/08/Java并发编程学习——如何解决死锁/</id>
    <published>2019-08-08T11:34:25.000Z</published>
    <updated>2019-08-08T14:11:14.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h2><p>  前面我们使用Account.class来作为转账的锁，即当发生一个转账操作的时候，所有的用户操作都会被阻塞，这效率简直太低下。</p><p>  现实世界里，账户转账操作是支持并发的，而且绝对是真正的并行，银行所有的窗口都可以做转账操作。只要我们能仿照现实世界做转账操作，串行的问题就解决了。</p><p>  我们试想在古代，没有信息化，账户的存在形式真的就是一个账本，而且每个账户都有一个账本，这些账本都统一存放在文件架上。银行柜员在给我们做转账时，要去文件架上把转出账本和转入账本都拿到手，然后做转账。这个柜员在拿账本的时候可能遇到以下三种情况：</p><p>  文件架上恰好有转出账本和转入账本，那就同时拿走；<br>  如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；<br>  转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。</p><p>  而编程世界解决这个问题就是使用两把锁去控制两个转账账户。</p><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/1.jpg" alt="两个锁"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候仿佛问题已经解决了，但是随之而来又是一个新的问题。</p><h2 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h2><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/2.jpg" alt="两个锁"></p><p>  试想一下，如果这个时候A账户要转账给B账户，B账户要转账给A账户，然后A转账给B的时候申请到了A的锁，同时B转账给A的时候申请到了B的锁，这个时候线程1申请B的锁不成功(因为B的锁被线程2给拿走了)，线程2申请A的锁不成功(因为A的锁被线程1给拿走了)，这个时候两个线程就会因为获得不到锁而发生阻塞(Java中只要synchronized不成功，线程便会进入阻塞状态)，两个线程互相等待锁，却都不释放锁，那么这个时候就产生了死锁。</p><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/3.jpg" alt="两个锁"></p><h2 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h2><p>  首先，当死锁产生的时候一般只有杀死进程或者结束应用来解决，所以解决死锁的代价是很大的。对于死锁，最好的办法就是规避死锁。</p><p>  coffman于1971年提出了死锁产生的四个必要条件</p><ol><li>互斥条件：一个资源一次只能有一个线程(或进程)占用</li><li>部分分配条件(占有且等待)：即一个线程(或进程)不能一次性获得所有需要的资源</li><li>不可抢占条件：一个资源只能由它占有的线程(或进程)来释放，不能通被其他线程(或进程)抢占使用。</li><li><p>循环等待条件：每个线程(或进程)占有若干资源，并且又在等待下一个线程(或进程)所拥有的资源。</p><p>反过来讲，我们只需要破坏一个条件就可以避免死锁的产生。对于第一个互斥条件来说，我们无法破坏，因为我们就是需要使用锁的互斥条件来达到并发的目的。剩下三个我们都能破话。</p></li></ol><ol><li>部分分配条件(占有且等待)：我们只需要同时将资源一次性分配给线程</li><li>不可抢占条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>循环等待条件：按序申请资源，即 使资源是有线性顺序的。</li></ol><h2 id="破坏部分分配条件-占有且等待"><a href="#破坏部分分配条件-占有且等待" class="headerlink" title="破坏部分分配条件(占有且等待)"></a>破坏部分分配条件(占有且等待)</h2><p>  一次性申请所有资源，对于转账来说，因为涉及到两个资源，所以我们需要一次性申请两个资源AccountA和AccountB，在现实生活中我们可以通过一个账本管理员来负责一个业务员只能同时获取到转账双发的账本，要么都获取不到。</p><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/4.jpg" alt="两个锁"></p><p>  编程中我们也可以定义一个管理员，并且对资源的回收和发放都要是原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als =</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      als.add(from);</span><br><span class="line">      als.add(to);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// actr 应该为单例</span></span><br><span class="line">  <span class="keyword">private</span> Allocator actr;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line">    <span class="keyword">while</span>(!actr.apply(<span class="keyword">this</span>, target))</span><br><span class="line">      ；</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 锁定转出账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">// 锁定转入账户</span></span><br><span class="line">        <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      actr.free(<span class="keyword">this</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h2><p>  破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p><p>  你可能会质疑，“Java 作为排行榜第一的语言，这都解决不了？”你的怀疑很有道理，Java 在语言层次确实没有解决这个问题，不过在 SDK 层面还是解决了的，java.util.concurrent 这个包下面提供的 Lock 是可以轻松解决这个问题的。</p><h2 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h2><p>  破坏这个条件需要对资源进行排序，这样申请资源申请锁的时候就不会出现循环等待了。</p><p>  这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    Account left = <span class="keyword">this</span>        ①</span><br><span class="line">    Account right = target;    ②</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; target.id) &#123; ③</span><br><span class="line">      left = target;           ④</span><br><span class="line">      right = <span class="keyword">this</span>;            ⑤</span><br><span class="line">    &#125;                          ⑥</span><br><span class="line">    <span class="comment">// 锁定序号小的账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(left)&#123;</span><br><span class="line">      <span class="comment">// 锁定序号大的账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(right)&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">          <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  当我们使用细粒度锁来解决问题的时候，需要注意死锁问题。</p><p>  预防死锁有三个解决方案，在上述中我们使用了两种方式避免死锁，但是显然破坏循环等待条件的做法明显优于破坏部分分配条件，所以在选用避免死锁的方法的时候还要仔细斟酌</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现实世界&quot;&gt;&lt;a href=&quot;#现实世界&quot; class=&quot;headerlink&quot; title=&quot;现实世界&quot;&gt;&lt;/a&gt;现实世界&lt;/h2&gt;&lt;p&gt;  前面我们使用Account.class来作为转账的锁，即当发生一个转账操作的时候，所有的用户操作都会被阻塞，这效率简直太
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——互斥锁</title>
    <link href="https://francisqiang.github.io/2019/08/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <id>https://francisqiang.github.io/2019/08/08/Java并发编程学习——互斥锁/</id>
    <published>2019-08-08T03:13:50.000Z</published>
    <updated>2019-08-08T05:30:54.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何解决原子性问题"><a href="#如何解决原子性问题" class="headerlink" title="如何解决原子性问题"></a>如何解决原子性问题</h2><p>  原子性问题的源头就是<strong>线程切换</strong>，而我们禁用线程切换就能解决，而操作系统进行线程切换是依赖于CPU中断的，所以我们禁用CPU中断就能禁用线程切换。</p><p>  在早期单核CPU的情况下，统一时刻只有一个线程执行(多线程是利用时间片切换)，所以禁用了线程切换就导致了获得CPU使用权的线程可以不间断的执行，就比如说在32位机器上写入一个long变量分为写入高32位和低32位，那么如果禁用CPU中断，该线程就不会被打断，所以这时候写入高32和低32这两个操作就具有原子性，即要么不被执行要么都被执行。</p><p>  但是对于现代多核CPU，这时候就有多个线程同一时刻在不同cpu上执行，这个时候如果禁用CPU中断是不能禁止同一时刻只有一个线程执行的。它只能保证这时的执行线程不会被切换，如果这时候同时有两个变量要写入long型变量，由于多线程竞争的问题，在线程A写入高32位的时候线程B也写入高32位，然后线程B写入低32位之后线程A写入低32位，这时候就会出现写入数值出现异常值的bug。</p><p>  <strong>同一时刻只有一个线程执行</strong>这个概念非常重要，我们称之为<strong>互斥</strong>。如果我们对于某一共享变量的操作都是互斥的，无论是单核还是多核CPU都能实现原子性。</p><h2 id="简易锁模型"><a href="#简易锁模型" class="headerlink" title="简易锁模型"></a>简易锁模型</h2><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/1.jpg" alt="简易锁模型"></p><p>  而解决原子性的问题最重要的解决办法就是<strong>锁</strong>。比如线程A要执行临界区的一段代码，必须先进行加锁，枷锁完成后进入临界区并执行，当线程B要进入的时候由于获得不到锁，那么线程B得不到执行。当线程A执行完成后便释放锁，之后线程B就可以获得锁并且进入临界区执行了。</p><p>  但是我们常常忽略的两个问题——我们的锁是什么？我们保护的资源又是什么？</p><h2 id="改进后的锁模型"><a href="#改进后的锁模型" class="headerlink" title="改进后的锁模型"></a>改进后的锁模型</h2><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/2.jpg" alt="简易锁模型"></p><p>  改进后的锁模型则对资源和锁进行了定义，就像现实生活中，自家门对应着自家门的锁，别人家的对应别人的锁。</p><h2 id="Java语言提供的锁技术——synchronized"><a href="#Java语言提供的锁技术——synchronized" class="headerlink" title="Java语言提供的锁技术——synchronized"></a>Java语言提供的锁技术——synchronized</h2><p>  Java语言提供的锁技术就是synchronized关键字，它可以应用于方法中也可以是代码块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰代码块</span></span><br><span class="line">  Object obj = <span class="keyword">new</span> Object()；</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中锁的实现是Java编译器帮我们自动实现的，而synchronized并没有指定锁到底是什么，其实这里java是有默认规则的。</p><p>  具体的默认规则如下：</p><ol><li>当synchronized修饰的是静态方法的时候，默认锁住的是当前类的class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span>(X.class) <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当修饰的是非静态方法的时候默认锁着的是当前对象即this</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用synchronized来解决count-1的问题"><a href="#用synchronized来解决count-1的问题" class="headerlink" title="用synchronized来解决count+=1的问题"></a>用synchronized来解决count+=1的问题</h2><p>  SafeCalc 这个类有两个方法：一个是 get() 方法，用来获得 value 的值；另一个是 addOne() 方法，用来给 value 加 1，并且 addOne() 方法我们用 synchronized 修饰。那么我们使用的这两个方法有没有并发问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于synchronized的存在，假使有1000个线程去执行addOne方法，因为同一时刻只能有一个线程去执行，所以最后的value肯定是1000。</p><p>  但是对于get方法就不是了，如果有线程去执行get方法，因为上述代码有了管程中锁机制的happens-before规则(前一个线程加锁后进入临界区对共享资源的修改对于后一个线程解锁后进入是可见的)，这个时候get方法就不是可见的了。所以这时候将get方法也synchronized一下就可以了，因为前面对addOne的操作对于get就可见了。</p><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/3.jpg" alt="简易锁模型"></p><h2 id="锁和受保护资源的关系"><a href="#锁和受保护资源的关系" class="headerlink" title="锁和受保护资源的关系"></a>锁和受保护资源的关系</h2><p>  <strong>受保护资源和锁之间的关联关系是 N:1 的关系</strong>，如果我们将上述代码改一下。把 value 改成静态变量，把 addOne() 方法改成静态方法，此时 get() 方法和 addOne() 方法是否存在并发问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/4.jpg" alt="简易锁模型"></p><p>  这个时候是通过不同的锁来保护不同的资源，那么get方法就会像刚刚那样出现并发问题了。</p><h2 id="锁不能是可变对象"><a href="#锁不能是可变对象" class="headerlink" title="锁不能是可变对象"></a>锁不能是可变对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">      value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果将锁变为这样，是不允许的，因为锁应该是不可变的。</p><h2 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="headerlink" title="保护没有关联关系的多个资源"></a>保护没有关联关系的多个资源</h2><p>  被保护资源和锁应该是N：1的关系，那么保护没有关联关系的多个资源呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 锁：保护账户余额</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object balLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户余额  </span></span><br><span class="line">  <span class="keyword">private</span> Integer balance;</span><br><span class="line">  <span class="comment">// 锁：保护账户密码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object pwLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户密码</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取款</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看余额</span></span><br><span class="line">  <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改密码</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(String pw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">this</span>.password = pw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看密码</span></span><br><span class="line">  <span class="function">String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  很简单，使用不同的锁去保护没有关联关系的不同资源就行了，这里使用两个锁pwlock和ballock来保护密码和余额。</p><p>  当然，我们也可以用一把互斥锁来保护多个资源，例如我们可以用 this 这一把锁来管理账户类里所有的资源：账户余额和用户密码。具体实现很简单，示例程序中所有的方法都增加同步关键字 synchronized 就可以了。</p><p>  但是用一把锁有个问题，就是性能太差，会导致取款、查看余额、修改密码、查看密码这四个操作都是串行的。而我们用两把锁，取款和修改密码是可以并行的。<strong>用不同的锁对受保护资源进行精细化管理，能够提升性能</strong>。这种锁还有个名字，叫<strong>细粒度锁</strong>。</p><h2 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="headerlink" title="保护有关联关系的多个资源"></a>保护有关联关系的多个资源</h2><p>  如果多个资源是有关联的，比如转账，将A账户的钱转到B账户中，这两个账户的余额就是相关联的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果通过synchronized关键字，你会发现你锁住的仅仅是当前账户的余额，而target的余额就不能保证原子性。比如你同时进行target账户的收款和打钱的操作，那么target就会出现并发问题。</p><p>  假设有 A、B、C 三个账户，余额都是 200 元，我们用两个线程分别执行两个转账操作：账户 A 转给账户 B 100 元，账户 B 转给账户 C 100 元，最后我们期望的结果应该是账户 A 的余额是 100 元，账户 B 的余额是 200 元， 账户 C 的余额是 300 元。</p><p>  我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗？我们期望是，但实际上并不是。因为线程 1 锁定的是账户 A 的实例（A.this），而线程 2 锁定的是账户 B 的实例（B.this），所以这两个线程可以同时进入临界区 transfer()。同时进入临界区的结果是什么呢？线程 1 和线程 2 都会读到账户 B 的余额为 200，导致最终账户 B 的余额可能是 300（线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖），可能是 100（线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖），就是不可能是 200。</p><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/5.jpg" alt="简易锁模型"></p><p>  这时候我们就可以通过增大锁的细粒度来保护资源，我们可以将Account.class作为锁对象，这时候就可以解决并发问题。</p><p>  问题是解决了，但是使用class作为锁的意思就是当一个账户执行操作的时候，其他账户都不能使用，这样可是会严重影响性能的。</p><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/6.jpg" alt="简易锁模型"></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>  “原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以解决原子性问题，是要保证<strong>中间状态对外不可见</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何解决原子性问题&quot;&gt;&lt;a href=&quot;#如何解决原子性问题&quot; class=&quot;headerlink&quot; title=&quot;如何解决原子性问题&quot;&gt;&lt;/a&gt;如何解决原子性问题&lt;/h2&gt;&lt;p&gt;  原子性问题的源头就是&lt;strong&gt;线程切换&lt;/strong&gt;，而我们禁用线程切
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——Java如何解决可见性和有序性问题</title>
    <link href="https://francisqiang.github.io/2019/08/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/08/07/Java并发编程学习——Java如何解决可见性和有序性问题/</id>
    <published>2019-08-07T07:19:15.000Z</published>
    <updated>2019-08-07T09:01:25.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>  导致可见性的原因是缓存，导致有序性的原因是编译优化，那么解决可见性和有序性的最直接的方法就是禁用缓存和编译优化，但是如果禁用那么就会导致程序的性能下降。</p><p>  所以合理的方案就是按需禁用缓存和编译优化，而何时禁用这件事情是程序员决定的，这时候就应该请出主角Java内存模型了。</p><p>  Java内存模型是一个很复杂的概念，站在程序员的角度来看，Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括<strong>volatile</strong>，<strong>synchronized</strong>和<strong>final</strong>三个关键字以及六项<strong>Happens-Before规则</strong>。</p><h2 id="使用volatile的困惑"><a href="#使用volatile的困惑" class="headerlink" title="使用volatile的困惑"></a>使用volatile的困惑</h2><p>  volatile关键字并不是Java语言的特产，C语言也有，它最原始的意义就是禁用CPU缓存。</p><p>  例如我们声明一个volatile变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  它表达的是：告诉编译器，对这个变量的读写，不能使用CPU缓存，必须从内存中读取或者写入。</p><p>  例如以下代码,在1.5版本之前打印结果可能为0(因为CPU缓存的原因，线程2读取的是自身缓存的值)，在JDK1.5之后肯定为40，因为在1.5版本之后JDK做了volatile的语意增强，这个增强其实就是一项Happens-Before规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">40</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Noxxxxxxxxxxxxxxxxxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      Test test = <span class="keyword">new</span> Test();</span><br><span class="line">      Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        test.write();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        test.read();</span><br><span class="line">      &#125;);</span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line"></span><br><span class="line">      thread1.join();</span><br><span class="line"></span><br><span class="line">      thread2.join();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h2><p>  Happens-Before规则并不是先于发生的意思，而具体意思是指<strong>前一个操作的结果对于后一个操作时可见的</strong>。</p><h3 id="程序的顺序性规则"><a href="#程序的顺序性规则" class="headerlink" title="程序的顺序性规则"></a>程序的顺序性规则</h3><p>  在一个线程中，前面的操作Happens-Before后面的操作。</p><h3 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h3><p>  一个对于volatile变量的写操作Happens-Before于后续对这个变量的读操作。</p><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><p>  如果 A Happens-Before B 且 B Happens-Before C 那么 A Happens-Before C</p><p>  这条规则和volatile变量规则结合起来看前面的代码，其实就是上面代码示例的结果原理，在线程A中x=40的操作happens-before对于volatile变量v的写操作，然后线程A中对于volatile变量v的写操作happens-before于对线程B的对volatile变量v的读操作，所以x = 40happens-before线程B中的对于volatile变量v的读操作，也就是说x = 40对于线程B的那个操作是可见的，而JDK1.5之后就是通过这个原则来增强volatile语意的。</p><h3 id="管程中的锁规则"><a href="#管程中的锁规则" class="headerlink" title="管程中的锁规则"></a>管程中的锁规则</h3><p>  管程是一种通用的同步原语。在Java中指的就是synchronized，synchronized就是java对管程的一种实现。</p><p>  管程中的锁是java隐式帮我们实现的，在进入同步块代码的时候Java会帮我们上锁，执行完成会帮我们释放锁，这个是由编译器帮我们实现的，为的是防止程序员忘记释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入同步代码块加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.x == <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行完成释放锁</span></span><br></pre></td></tr></table></figure><h3 id="线程的start-规则"><a href="#线程的start-规则" class="headerlink" title="线程的start()规则"></a>线程的start()规则</h3><p>  主线程启动子线程B，子线程能看到主线程在启动子线程B之前的操作。换言之就是线程A中调用的线程B的start方法happens-before线程B中的任意操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 主线程调用 B.start() 之前</span></span><br><span class="line">  <span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line">  <span class="comment">// 此例中，var==77</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line"><span class="keyword">var</span> = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br></pre></td></tr></table></figure><h3 id="线程join规则"><a href="#线程join规则" class="headerlink" title="线程join规则"></a>线程join规则</h3><p>  主线程等待子线程完成，当子线程完成后，主线程能看到子线程的操作。<strong>其实就是，在主线程A中调用了子线程B的join方法，这时候子线程B的任意操作happens-before主线程调用线程B的join方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line">  <span class="keyword">var</span> = <span class="number">66</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"><span class="comment">// 则这个修改结果对线程 B 可见</span></span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br><span class="line">B.join()</span><br><span class="line"><span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"><span class="comment">// 在主线程调用 B.join() 之后皆可见</span></span><br><span class="line"><span class="comment">// 此例中，var==66</span></span><br></pre></td></tr></table></figure><h3 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h3><p>  对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p><h3 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h3><p>  一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>  final 修饰变量时，初衷是告诉编译器：<strong>这个变量生而不变，可以可劲儿优化</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>为什么定义Java内存模型？</p><p>现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。</p></li><li><p>三个基本原则</p><p> 原子性、可见性、有序性。</p></li><li><p>Java内存模型涉及的几个关键词</p><p>锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Java内存模型&quot;&gt;&lt;a href=&quot;#什么是Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;什么是Java内存模型&quot;&gt;&lt;/a&gt;什么是Java内存模型&lt;/h2&gt;&lt;p&gt;  导致可见性的原因是缓存，导致有序性的原因是编译优化，那么解决可见
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——可见性,原子性,有序性问题</title>
    <link href="https://francisqiang.github.io/2019/08/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/</id>
    <published>2019-08-06T08:20:42.000Z</published>
    <updated>2019-08-06T09:28:54.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发程序幕后的故事"><a href="#并发程序幕后的故事" class="headerlink" title="并发程序幕后的故事"></a>并发程序幕后的故事</h2><p>  此系列文章为极客时间java并发编程课程的学习笔记。</p><p>  计算机中由于CPU，内存，I/O设备三者硬件速度之间的差异，而面对三者的差异，计算机体系结构，操作系统，编译程序都为之做出了自己的贡献。</p><p>  比如CPU增加了缓存机制，操作系统增加了进程，线程，分时复用CPU的理念，编译程序则会优化指令顺序。</p><p>  而这些，其实就是并发程序bug的根源所在。</p><h2 id="根源一：缓存导致的可见性问题"><a href="#根源一：缓存导致的可见性问题" class="headerlink" title="根源一：缓存导致的可见性问题"></a>根源一：缓存导致的可见性问题</h2><p>  在早期的PC中，一般使用的是单核的CPU，CPU缓存与内存的数据一致性问题很好解决。因为不同线程都是对同一个cpu缓存进行操作，一个线程对于cpu缓存的数据更改另一个线程肯定是可见的，所以如果线程A更改了缓存中的V值，对于线程B再取出V的值就是线程A已经更改的值。</p><p>  <img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/1.jpg" alt="单个CPU的缓存可见性问题模型"></p><p>  但是现如今多核时代，每个CPU都有自己的缓存，这时候缓存的可见性问题并没有那么简单了。</p><p>  <img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/2.jpg" alt="单个CPU的缓存可见性问题模型"></p><p>  如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add10k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      test.add10k();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      test.add10k();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(Test.calc());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码表示创建两个线程，这两个线程同时为count做100000次自增，如果按照常理得到的结果应该是200000，但是其实输出的是100000到200000之间的数字。其原因在于在线程A和线程B执行的过程中，两个线程会将count都放入自己的寄存器中然后进行+操作，但是对于放回内存中这样的操作就会出现重叠，例如线程A计算出count为1了放入内存，线程B计算出count为1了放入内存，此时count就会为1而不是我们真正想看到的2。</p><h2 id="根源二：线程切换带来的原子性问题"><a href="#根源二：线程切换带来的原子性问题" class="headerlink" title="根源二：线程切换带来的原子性问题"></a>根源二：线程切换带来的原子性问题</h2><p>  因为CPU执行速度是非常快的，所以在早期的PC时代中人们就发明了多进程的理念，即CPU通过切换时间片来使多个进程看似在同时执行。</p><p>  <img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/3.jpg" alt="单个CPU的缓存可见性问题模型"></p><p>  在一个时间片内，如果一个进程进行一个IO操作，例如读文件，这个时候该进程可以把自己标记为“休眠状态”并让出CPU的使用权，待文件读入内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得CPU的使用权了。</p><p>  这里的进程在等待IO时会释放CPU使用权，是为了提高CPU使用率。此外，如果这时有另外一个进程读文件，那么读文件的操作就会排队，磁盘驱动在完成一个进程的读操作之后，会立即进行下一个操作，这样IO的使用率也提升了。而这个就是多进程分时复用，这个操作在操作系统中具有里程碑的意义，Unix就是因为解决这个问题而名噪天下的。</p><p>  早期的操作系统基于进程来调度CPU，不同进程间是不共享内存空间的，所以要做进程任务切换就要切换内存映射地址，而一个进程创建的所有线程中，他们都是共享内存空间的，所以线程做任务切换的成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p><p>  Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。</p><ol><li><p>将count从内存中取出放入寄存器</p></li><li><p>在寄存器中进行加操作</p></li><li><p>从寄存器中取出放入内存中（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p><p>操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p><p><img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/4.jpg" alt="任务切换带来的BUG"></p><p>如果我们将这条语句作为原子操作那是可以的，而对于线程切换，它的基本单位是cpu指令而不是语句，我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。</p></li></ol><h2 id="源头三：编译优化带来的有序性问题"><a href="#源头三：编译优化带来的有序性问题" class="headerlink" title="源头三：编译优化带来的有序性问题"></a>源头三：编译优化带来的有序性问题</h2><p>  Java的编译优化是很智能的，为了提高程序的性能，编译器有时候会更改语句执行顺序，按照常理有些语句的顺序变更是不会影响结果的，但是在多线程的情境下就变得复杂起来了。</p><p>  例如在单例模式的双重检查中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">           instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  假如现有两个线程A，B同时进入getInstance方法他们同时判断instance是否为空，此时为空两个线程同时进入语句，由于synchronized的存在，JVM只会让一个线程进入并且上锁。假设此时A进入B等待锁，那么A获得锁判断instance是否为空，为空则创建对象，然后A释放锁，此时B获得锁并进入语句判断instance不为空跳出语句并return不为空的instance。一切看起来完美，但是我们一直以为的new操作是这样的。</p><ol><li><p>在内存中开辟一个地址空间M</p></li><li><p>在地址空间M中初始化Singleton对象</p></li><li><p>将地址赋值给instance变量</p><p>但经过了编译优化它是这样的</p></li><li><p>在内存中开辟一个地址空间M</p></li><li><p>将地址赋值给instance变量</p></li><li><p>在地址空间初始化Singleton对象</p><p>试想一下，如果在执行2指令的时候进行了线程切换，线程B会判断instance是否为空，此时不为空那么直接返回，但是在返回instance的地址空间并没有Singleton对象，所以之后如果调用instance的变量，方法就会产生空指针异常。</p><p><img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/5.jpg" alt="编译优化带来的BUG"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发程序幕后的故事&quot;&gt;&lt;a href=&quot;#并发程序幕后的故事&quot; class=&quot;headerlink&quot; title=&quot;并发程序幕后的故事&quot;&gt;&lt;/a&gt;并发程序幕后的故事&lt;/h2&gt;&lt;p&gt;  此系列文章为极客时间java并发编程课程的学习笔记。&lt;/p&gt;
&lt;p&gt;  计算机中
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——解释器模式</title>
    <link href="https://francisqiang.github.io/2019/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/06/设计模式——解释器模式/</id>
    <published>2019-08-06T04:13:39.000Z</published>
    <updated>2019-08-06T04:21:44.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是解释器模式"><a href="#什么是解释器模式" class="headerlink" title="什么是解释器模式"></a>什么是解释器模式</h2><p>  原文链接<a href="https://www.cnblogs.com/liaojie970/p/5495795.html" target="_blank" rel="noopener">解释器模式</a></p><p>  解释器模式的定义是一种按照规定语法进行解析的方案，在现在项目中使用的比较少，其定义如下：</p><p>  Given a language, define a representation for its grammar along with an interpreter that uses the<br>  representation to interpret sentences in the language.</p><p>  给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表达式来解释语言中的句子。</p><p>  <img src="/2019/08/06/设计模式——解释器模式/1.jpg" alt="UML"></p><p>  解释器角色：</p><ol><li><p>AbstractExpression抽象解释器：具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和NonterminalExpression</p></li><li><p>TerminalExpression终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结表达式，但有多个实例，对应不同的终结符。</p></li><li><p>NonterminalExpression非终结符表达式：文法中的每条规则对应于一个非终结表达式，非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式</p></li><li><p>Context环境角色</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象表达式</span></span><br><span class="line"><span class="comment">/*抽象表达式是生产语法集合(也叫语法树)的关键，每个语法集合完成指定语法解析任务，它是通过递归调用的方式，最终</span></span><br><span class="line"><span class="comment">由最小的语法单元进行解析完成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="comment">//每个表达式必须有一个解析任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">interpreter</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结符表达式  主要是处理场景元素和数据的转换 如：a+b+c中的"a""b""c"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="comment">//通常终结符表达式只有一个，但是有多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非终结符表达式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个非终结符表达式都代表一个文法规则，并且每个文法规则都只关心自己周边的文法规则结果(注意是结果),因此</span></span><br><span class="line"><span class="comment">    这就产生了每个终结符表达式调用自己周边的非终结符表达式，然后最终，最小的文法规则就是终结符表达式，终</span></span><br><span class="line"><span class="comment">    结符表达式的概念就是如此，不能在参与比自己更小的文法运算了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="comment">//每个非终结符表达式都会对其他表达式产生依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonterminalExpression</span><span class="params">(Expression... expression)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//进行文法处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Context context=<span class="keyword">new</span> Context();</span><br><span class="line">        <span class="comment">//通常一个语法容器，容纳一个具体的表达式，通常为ListArray，LinkedList，Stack等类型</span></span><br><span class="line">        Stack&lt;Expression&gt; stack=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="comment">//进行语法判断，并产生递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//产生一个完整的语法树，由各个具体的语法分析进行解析</span></span><br><span class="line">        Expression expression=stack.pop();</span><br><span class="line">        <span class="comment">//具体元素进入场景</span></span><br><span class="line">        expression.interpreter(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释器的优缺点"><a href="#解释器的优缺点" class="headerlink" title="解释器的优缺点"></a>解释器的优缺点</h2><p>  优点:</p><p>  解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了</p><p>  缺点:</p><ol><li><p>解释器模式会引发类膨胀：每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。</p></li><li><p>解释器模式采用递归调用方法：每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层的剥茧，无论是面向过程的语言还是面向对象的语言，递归都是在必要条件下是使用的，它导致调试非常复杂</p></li><li><p>效率问题：解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题</p></li></ol><h2 id="解释器模式应用场景"><a href="#解释器模式应用场景" class="headerlink" title="解释器模式应用场景"></a>解释器模式应用场景</h2><ol><li><p>重复发生的问题可以使用解释器模式</p></li><li><p>一个简单语法需要解释的场景</p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>  尽量不要再重要的模块中使用解释器模式，否则维护会一个很大的问题。在项目中可以使用shell，jRuby，Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。</p><p>  常用的解释器模式工具包：Expression4J,MESP(Math Expression String parser),Jep等开源的解析工具包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是解释器模式&quot;&gt;&lt;a href=&quot;#什么是解释器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是解释器模式&quot;&gt;&lt;/a&gt;什么是解释器模式&lt;/h2&gt;&lt;p&gt;  原文链接&lt;a href=&quot;https://www.cnblogs.com/liaojie
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——中介者模式</title>
    <link href="https://francisqiang.github.io/2019/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/05/设计模式——中介者模式/</id>
    <published>2019-08-05T14:42:16.000Z</published>
    <updated>2019-08-06T02:50:50.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是中介者模式"><a href="#什么是中介者模式" class="headerlink" title="什么是中介者模式"></a>什么是中介者模式</h2><p>  中介者模式是一种行为模式，其中最重要的角色就是中介者了，中介者的作用就是封装一系列对象的交互逻辑。比如在一个智能家居系统中有许多设备比如TV，屏幕，摄像头，报警器等等的启动，一般来说系统的启动需要这些设备的相互协调交互，如果这些全部暴露给Client，那么整体逻辑就会变得非常的复杂，先如今通过中介者来包装系统中的一些列对象的交互逻辑。</p><h2 id="中介者模式UML图"><a href="#中介者模式UML图" class="headerlink" title="中介者模式UML图"></a>中介者模式UML图</h2><p>  <img src="/2019/08/05/设计模式——中介者模式/1.jpg" alt="UML"></p><p>  Mediator是中介者，它用来封装一系列的Colleague对象之间的相互调用。即它需要知道所有的具体的同事类，即以一个集合来管理并接受某个同事对象消息，完成相应的任务。</p><p>  具体的同事类会有很多，每个同事只知道自己的行为，而不了解其他同事对象的行为，但是他们都依赖中介者对象。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每个同事类中都含有对应的中介者</span></span><br><span class="line">  <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">  <span class="comment">// 同事对象的名字</span></span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="comment">// 构造的时候讲中介者和名字传入初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取中介者，因为它需要向中介者发送消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mediator <span class="title">GetMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.mediator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Alarm</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mediator, name);</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendAlarm</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    SendMessage(stateChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Curtains</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Curtains</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mediator, name);</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpCurtains</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"I am holding Up Curtains!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CoffeeMachine</span><span class="params">(Mediator mediator, String name&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">super</span>(mediator, name)</span></span>;</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"It's time to startcoffee!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinishCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"After 5 minutes!"</span>);System.out.println(<span class="string">"Coffee is ok!"</span>);</span><br><span class="line">    SendMessage(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TV</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mediator, name);</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartTv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"It's time to StartTv!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopTv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"StopTv!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将同事注册到中介者对象中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取同事发送的消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    colleagueMap = <span class="keyword">new</span> HashMap&lt;String, Colleague&gt;();</span><br><span class="line">    interMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> </span>&#123;</span><br><span class="line">    colleagueMap.put(colleagueName, colleague);</span><br><span class="line">    <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">      interMap.put(<span class="string">"Alarm"</span>, colleagueName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">    interMap.put(<span class="string">"CoffeeMachine"</span>, colleagueName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">      interMap.put(<span class="string">"TV"</span>, colleagueName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">      interMap.put(<span class="string">"Curtains"</span>, colleagueName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中介者协调各个同事之间的工作</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果我接受到的是Alarm那么。。。</span></span><br><span class="line">    <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">      <span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">        ((CoffeeMachine) (colleagueMap.get(interMap.get(<span class="string">"CoffeeMachine"</span>)))).StartCoffee();</span><br><span class="line">        ((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StartTv();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">        ((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StopTv();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是咖啡，那么、、、</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">      ((Curtains) (colleagueMap.get(interMap.get(<span class="string">"Curtains"</span>))))</span><br><span class="line">      .UpCurtains();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">    Alarm alarm = <span class="keyword">new</span> Alarm(mediator, <span class="string">"alarm"</span>);</span><br><span class="line">    CoffeeMachine coffeeMachine = <span class="keyword">new</span> CoffeeMachi   (mediator,<span class="string">"coffeeMachine"</span>);</span><br><span class="line">    Curtains curtains = <span class="keyword">new</span> Curtains(mediator, <span class="string">"curtains"</span>);</span><br><span class="line">    TV tV = <span class="keyword">new</span> TV(mediator, <span class="string">"TV"</span>);</span><br><span class="line">    alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">    coffeeMachine.FinishCoffee();</span><br><span class="line">    alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是中介者模式&quot;&gt;&lt;a href=&quot;#什么是中介者模式&quot; class=&quot;headerlink&quot; title=&quot;什么是中介者模式&quot;&gt;&lt;/a&gt;什么是中介者模式&lt;/h2&gt;&lt;p&gt;  中介者模式是一种行为模式，其中最重要的角色就是中介者了，中介者的作用就是封装一系列对象的
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——状态模式</title>
    <link href="https://francisqiang.github.io/2019/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/05/设计模式——状态模式/</id>
    <published>2019-08-05T07:57:13.000Z</published>
    <updated>2019-08-05T08:55:49.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是状态模式"><a href="#什么是状态模式" class="headerlink" title="什么是状态模式"></a>什么是状态模式</h2><p>  一个事物在发展过程中都会产生不同的状态，比如人在成长过程中会有小孩，成人，老人等状态。但是这个状态是依赖聚合于对象本身的，因为状态是随着对象的行为而发生变化的，状态本身就是对象的一部分。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>  <img src="/2019/08/05/设计模式——状态模式/1.jpg" alt="UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaffleActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State canRaffleState = <span class="keyword">new</span> CanRaffleState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State noRaffleState = <span class="keyword">new</span> NoRaffleState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State dispenseState = <span class="keyword">new</span> DispenseState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State dispenseOutState = <span class="keyword">new</span> DispenseOutState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RaffleActivity</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">this</span>.noRaffleState;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    state.deduceMoney();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state.raffle()) &#123;</span><br><span class="line">      state.dispensePrize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCanRaffleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCanRaffleState</span><span class="params">(State canRaffleState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.canRaffleState = canRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getNoRaffleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> noRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNoRaffleState</span><span class="params">(State noRaffleState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.noRaffleState = noRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getDispenseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispenseState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispenseState</span><span class="params">(State dispenseState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dispenseState = dispenseState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getDispenseOutState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispenseOutState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispenseOutState</span><span class="params">(State dispenseOutState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dispenseOutState = dispenseOutState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoRaffleState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NoRaffleState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"扣除50元余额，您可以开始抽奖了。"</span>);</span><br><span class="line">    raffleActivity.setState(raffleActivity.getCanRaffleState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前不可以抽奖。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"不能发放奖品。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanRaffleState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CanRaffleState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (raffleActivity.getCount() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"抽奖活动已结束！请下次再来！"</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> num = random.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"恭喜您！中奖了！"</span>);</span><br><span class="line">      raffleActivity.setCount(raffleActivity.getCount() - <span class="number">1</span>);</span><br><span class="line">      raffleActivity.setState(raffleActivity.getDispenseState());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"很遗憾！未中奖！"</span>);</span><br><span class="line">      raffleActivity.setState(raffleActivity.getNoRaffleState());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请先抽奖！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DispenseState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品！"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"正在发送奖品！请稍等！"</span>);</span><br><span class="line">    raffleActivity.setState(raffleActivity.getDispenseOutState());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseOutState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DispenseOutState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"奖品已发送完毕！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RaffleActivity raffleActivity = <span class="keyword">new</span> RaffleActivity(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"这是第"</span> + i + <span class="string">"次抽奖"</span>);</span><br><span class="line"></span><br><span class="line">      raffleActivity.deduceMoney();</span><br><span class="line">      raffleActivity.raffle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是状态模式&quot;&gt;&lt;a href=&quot;#什么是状态模式&quot; class=&quot;headerlink&quot; title=&quot;什么是状态模式&quot;&gt;&lt;/a&gt;什么是状态模式&lt;/h2&gt;&lt;p&gt;  一个事物在发展过程中都会产生不同的状态，比如人在成长过程中会有小孩，成人，老人等状态。但是这个状
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——备忘录模式</title>
    <link href="https://francisqiang.github.io/2019/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/04/设计模式——备忘录模式/</id>
    <published>2019-08-04T09:32:16.000Z</published>
    <updated>2019-08-04T13:16:18.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是备忘录模式"><a href="#什么是备忘录模式" class="headerlink" title="什么是备忘录模式"></a>什么是备忘录模式</h2><p>  备忘录是指在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象外部保存状态。而状态保存的地方就是备忘录对象，并且再创建一个备忘录的管理类来管理一系列的状态，在用户操作的时候，用户不与备忘录直接耦合而与备忘录的管理类相耦合。相应的我们就可以做一些操作比如回滚，撤销等。</p><h2 id="备忘录的UML图"><a href="#备忘录的UML图" class="headerlink" title="备忘录的UML图"></a>备忘录的UML图</h2><p>  <img src="/2019/08/04/设计模式——备忘录模式/1.jpg" alt="UML"></p><p>  originator是指需要保存状态的对象，Memento是聚合了状态的备忘录对象，CareTaker是存储了备忘录对象集合的备忘录管理类。</p><p>  在originator中需要有一个方法是将状态保存到备忘录对象中，并且在备忘录管理类中需要有备忘录对象的增加删除方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Memento <span class="title">saveToMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前状态为:"</span> + <span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">    mementoList.add(memento);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line"></span><br><span class="line">    CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line"></span><br><span class="line">    originator.setState(<span class="string">"状态1"</span>);</span><br><span class="line">    careTaker.addMemento(originator.saveToMemento());</span><br><span class="line"></span><br><span class="line">    originator.display();</span><br><span class="line"></span><br><span class="line">    originator.setState(<span class="string">"状态2"</span>);</span><br><span class="line">    careTaker.addMemento(originator.saveToMemento());</span><br><span class="line"></span><br><span class="line">    originator.display();</span><br><span class="line"></span><br><span class="line">    originator.setState(careTaker.getMemento(<span class="number">0</span>).getState());</span><br><span class="line"></span><br><span class="line">    originator.display();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是备忘录模式&quot;&gt;&lt;a href=&quot;#什么是备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;什么是备忘录模式&quot;&gt;&lt;/a&gt;什么是备忘录模式&lt;/h2&gt;&lt;p&gt;  备忘录是指在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象外部保存状态。而状态保
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
