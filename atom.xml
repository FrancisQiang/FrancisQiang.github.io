<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Francis的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://francisqiang.github.io/"/>
  <updated>2019-05-23T11:37:53.356Z</updated>
  <id>https://francisqiang.github.io/</id>
  
  <author>
    <name>Francis Qiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式——观察者模式</title>
    <link href="https://francisqiang.github.io/2019/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/23/设计模式——观察者模式/</id>
    <published>2019-05-23T10:29:21.000Z</published>
    <updated>2019-05-23T11:37:53.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h2><p>  观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>  <img src="/2019/05/23/设计模式——观察者模式/1.jpg" alt="观察者模式结构图"></p><p>  在观察者模式中有如下角色：</p><ul><li><p>Subject：</p><p>抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p></li><li><p>ConcreteSubject：</p><p>具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p></li><li><p>Observer：</p><p>抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p></li><li><p>ConcrereObserver：</p><p>具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p></li></ul><h2 id="简单实现观察者模式"><a href="#简单实现观察者模式" class="headerlink" title="简单实现观察者模式"></a>简单实现观察者模式</h2><p>  这里我们简单实现一下观察者模式，首先我们定义一个被观察者的接口Subject，然后我们再定义一个观察者的接口Observer</p><p>  其中Subject中有三个方法，attach()用来增加用户的，detach()用来移除用户的，notify()用来提醒订阅的用户的。</p><p>  其中Observer中有个update()方法，这是notify()里会调用用来提醒所有订阅用户消息的</p><p>  具体代码如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User实现观察者接口，并实现update方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"User"</span> + name + <span class="string">"receive the update message:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体被观察者实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面存放观察者的列表</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Observer&gt; observerArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加观察者</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">  observerArrayList.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当要通知的时候遍历观察者列表调用他们的update方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Observer observer : observerArrayList) &#123;</span><br><span class="line">    observer.update(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  测试方法和结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"></span><br><span class="line">  User first = <span class="keyword">new</span> User(<span class="string">"first"</span>);</span><br><span class="line">  User second = <span class="keyword">new</span> User(<span class="string">"second"</span>);</span><br><span class="line">  User third = <span class="keyword">new</span> User(<span class="string">"third"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.attach(first);</span><br><span class="line">  concreteSubject.attach(second);</span><br><span class="line">  concreteSubject.attach(third);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第一次更新"</span>);</span><br><span class="line"></span><br><span class="line">  concreteSubject.detach(second);</span><br><span class="line"></span><br><span class="line">  concreteSubject.notify(<span class="string">"第二次更新"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/05/23/设计模式——观察者模式/2.jpg" alt="结果"></p><h2 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h2><p>  在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p><p>  我们再刚刚实现的观察者模式中，观察者和被观察者是要互相知道对方的存在的(上述代码只实现了被观察者增加观察者，当然也可以在观察者里面关联被观察者)，不然无法增加和删除观察者列表中的用户。</p><p>  但是发布订阅则是通过一个消息中间者来实现，他们之间通过消息代理，可以说更加松耦合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;观察者模式的定义&quot;&gt;&lt;a href=&quot;#观察者模式的定义&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的定义&quot;&gt;&lt;/a&gt;观察者模式的定义&lt;/h2&gt;&lt;p&gt;  观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://francisqiang.github.io/2019/05/23/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://francisqiang.github.io/2019/05/23/线段树/</id>
    <published>2019-05-23T07:29:30.000Z</published>
    <updated>2019-05-23T08:33:22.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><p>  按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。</p><p>  当然时间复杂度的减少，空间也就会有相应的损失，当我们要通过线段树存储一个线性结构，空间的开销就会增大。比如我们存储的线性结构的大小正好是2的整数幂，那么我们所有的叶子节点都会是单个区间的值，这个叶子节点的数量就是n，我们知道对于一个满二叉树来说，叶子节点的数量就是上层所有节点的和，那么这时候我们需要开辟的空间就是2n。但是当我们存储的大小不是2的整数幂的时候，这时候单个区间节点就不全在叶子节点上，假设我们为了使线段树尽量满足满二叉树的结构，那么在倒数第二层的单个区间的值也需要两个左右孩子节点(虽然他们是空，但还是需要空间的)，那么这时候我们就需要开辟2n*2(4n)的空间。</p><p>  <img src="/2019/05/23/线段树/1.jpg" alt="线段树"></p><h2 id="线段树的实现"><a href="#线段树的实现" class="headerlink" title="线段树的实现"></a>线段树的实现</h2><p>  对于线段树的实现，我们需要使用递归调用。</p><p>  具体思路如下:</p><p>  不考虑动态规划的情况，我们需要将整个区间一分为二，这个 middleIndex 就是(left + right) / 2,然后我们再依次递归到最后的叶子节点，当我们需要划分的left = right的时候也就是区间为1的时候(即一个区间的值)我们返回，然后我们通过后序遍历的思想将两个左右子节点的值相融合赋值给父节点。</p><p>  具体实现代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = data[left];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取左右孩子的节点索引</span></span><br><span class="line">  <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取中间索引</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//int middleIndex = (left + right) / 2;</span></span><br><span class="line">  <span class="comment">//为了防止整型溢出</span></span><br><span class="line"></span><br><span class="line">  buildSegmentTree(leftChildIndex, left, middleIndex);</span><br><span class="line">  buildSegmentTree(rightChildIndex, middleIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[leftChildIndex], tree[rightChildIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的搜索"><a href="#线段树的搜索" class="headerlink" title="线段树的搜索"></a>线段树的搜索</h2><p>  基本思路:</p><p>  其实还是递归的思想，我们需要获取某个区间的值，即我们创建一个query方法，其中参数有treeIndex(遍历的根节点的index)，left(在什么区间查询的左边界index),right(在什么区间查询的右边界index),queryLeft(需要查询的左边界index),queryRight(需要查询的右边界的index)。</p><p>  最根本的条件就是当我们所查询的左右边界值分别和我们需要查询的左右边界值相等，那么我们直接返回这个tree[treeIndex]。</p><p>  我们使用递归转换为小问题的思路就是通过left right，queryLeft queryRight的关系，我们设置一个middleIndex(这个middleIndex也是根据left,right得来的)，我们通过queryLeft和middle比较，如果queryLeft比当前所查询区间的的middle要大的话，那么我们就去查询右子树，如果queryRight比middle要小的话我们就去查询左子树，因为我们查询的一个区间基本可能实现一个大区间的子集中，那么为了精确，我们就需要在大区间的左右孩子树中查找结果然后我们再将左右结果融合在一起然后返回。</p><p>  代码实现:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> queryLeft, <span class="keyword">int</span> queryRight)</span></span>&#123;</span><br><span class="line">  <span class="comment">//当left == queryLeft &amp;&amp; right == queryRight时就说明是我们需要查询的区间直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (left == queryLeft &amp;&amp; right == queryRight)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line">  <span class="comment">//缩小查询范围</span></span><br><span class="line">  <span class="keyword">if</span> (queryLeft &gt;= middle + <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryRight &lt;= middle)&#123;</span><br><span class="line">    <span class="keyword">return</span> query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们查询的区间必定是某个大区间的左右孩子树查询结果的融合</span></span><br><span class="line">  E leftResult = query(childLeftIndex, left, middle, queryLeft, queryRight);</span><br><span class="line">  E rightResult = query(childRightIndex, middle + <span class="number">1</span>, right, queryLeft, queryRight);</span><br><span class="line">  <span class="keyword">return</span> merger.merger(leftResult, rightResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树查询的LeetCode题目"><a href="#线段树查询的LeetCode题目" class="headerlink" title="线段树查询的LeetCode题目"></a>线段树查询的LeetCode题目</h2><p>  题目描述:</p><p>  <img src="/2019/05/23/线段树/2.jpg" alt="LeetCode题目"></p><p>  解题思路:</p><p>  题目要求需要我们获得一个数组中某个区间段的值，并且这个sumRange函数会不断被调用，那么我们就可以使用线段树的查询操作(使merge融合改成相加就行了)</p><p>  具体代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SegmentTree&lt;Integer&gt; segmentTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  Integer[] integers = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">  <span class="keyword">if</span> (nums.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">      integers[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//λ表达式，直接实现接口</span></span><br><span class="line">    segmentTree = <span class="keyword">new</span> SegmentTree&lt;&gt;(integers, (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segmentTree.query(i, j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树的修改"><a href="#线段树的修改" class="headerlink" title="线段树的修改"></a>线段树的修改</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>  这里我们主要实现对线段树的某个单区间的修改操作，对于单个线段树的修改操作势必会牵连到其父节点的修改，这里我们还是可以使用后序遍历的思想再更新完子节点之后将父节点更新。</p><p>  相关代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//最根本条件就是我们查询的区间左右相等</span></span><br><span class="line">  <span class="comment">//这时候我们直接对该结点更新就行</span></span><br><span class="line">  <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">    tree[treeIndex] = e;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//后面也是拿index和left，right比较</span></span><br><span class="line">  <span class="comment">//通过index和left，right的关系将问题变小</span></span><br><span class="line">  <span class="keyword">int</span> middleIndex = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> childLeftIndex = leftChild(treeIndex);</span><br><span class="line">  <span class="keyword">int</span> childRightIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt;= middleIndex)&#123;</span><br><span class="line">    set(childLeftIndex, left, middleIndex, index, e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= middleIndex + <span class="number">1</span>)&#123;</span><br><span class="line">    set(childRightIndex, middleIndex, right, index, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过后序遍历的思想将父节点更新</span></span><br><span class="line">  tree[treeIndex] = merger.merger(tree[childLeftIndex], tree[childRightIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关的LeetCode题目"><a href="#相关的LeetCode题目" class="headerlink" title="相关的LeetCode题目"></a>相关的LeetCode题目</h3><p>  <img src="/2019/05/23/线段树/3.jpg" alt="LeetCode题目"></p><p>  这里其实就是增加一个update方法，题目又增加了修改单个结点的值，那么我们将更新方法加入原来实现的代码中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  segmentTree.update(i, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是线段树&quot;&gt;&lt;a href=&quot;#什么是线段树&quot; class=&quot;headerlink&quot; title=&quot;什么是线段树&quot;&gt;&lt;/a&gt;什么是线段树&lt;/h2&gt;&lt;p&gt;  按照我的简单理解，线段树其实是每个结点存放一个区间的值，使我们查询一个区间的时间复杂度从n变为logn。
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="https://francisqiang.github.io/2019/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/21/设计模式——策略模式/</id>
    <published>2019-05-21T12:11:37.000Z</published>
    <updated>2019-05-21T13:28:56.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><h3 id="继承一定好用吗？"><a href="#继承一定好用吗？" class="headerlink" title="继承一定好用吗？"></a>继承一定好用吗？</h3><p>  当我们做到一个项目类似于设计鸭子，鸭子呢有游泳和嘎嘎叫的能力，另外他们都有display显示外貌的方法。现在比如有两个鸭子，绿头鸭和红头鸭。绿头鸭的头是绿色的，可以游泳，叫声是ll声，红头鸭的头是红色的，可以游泳，叫声是rr声。</p><p>  如果我们要设计这两个鸭子类其实可以直接使用继承来实现，我们可以先设计一个Duck基类，类中有display方法，该方法是抽象的(所以类也是抽象的)，因为每个鸭子的外貌不一样。还有swim(),quack()方法，其中定义了基类默认的，比如说会游泳会嘎嘎叫等，之后绿头鸭红头鸭就需要实现display方法和重写swim(),quack()方法就行了。</p><p>  但是这时候，客户增加需求说要增加会飞行的鸭子。也许我们可以在父类里增加fly(),但是这对原先的子类都会有改动，如果绿头鸭不会飞我们还需要重新覆盖fly()方法，如果我们也像display方法变成抽象的，那么重写的代码太多，代码太冗余。</p><p>  <strong>继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应</strong></p><p>  <strong>超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式</strong></p><h3 id="使用组合更加灵活可扩展"><a href="#使用组合更加灵活可扩展" class="headerlink" title="使用组合更加灵活可扩展"></a>使用组合更加灵活可扩展</h3><p>  上面设计的鸭子类主要就是灵活性太差，其实我们可以使用分离的技巧，我们先来看鸭子这个类，它的方法中有变的和不变的，当我们增加需求或者改动需求的时候是只涉及变的的。</p><p>  比如我们现在将叫声和飞行分离出来变成一个行为，然后我们分别实现这两个行为接口QuackBehavior,FlyBehavior,这两个接口里各有方法quack和fly方法，当我们的叫声和飞行方法有变动的时候我们只需要实现要改变的方法的接口就行。比如我们现在需要有一个火箭飞行的行为那么我们创建一个RocketFlyBehavior实现FlyBehavior接口然后重写方法就行了。</p><p>  那么具体怎么使用呢？我们可以直接在Duck基类里增加两个接口字段QuackBehavior和FlyBehavior就行，然后我们基类的fly和quack方法中直接调用接口字段的fly方法和quack方法就行了，如果这时候我们需要给一个鸭子更换功能，我们直接调用接口字段的set方法就行了。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="Duck抽象类"><a href="#Duck抽象类" class="headerlink" title="Duck抽象类"></a>Duck抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> FlyBehavior mFlyBehavior;</span><br><span class="line">  <span class="keyword">protected</span> QuackBehavior mQuackBehavior;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractDuck</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mFlyBehavior.fly();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mQuackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span> </span>&#123;</span><br><span class="line">    mQuackBehavior = qb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = fb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~im swim~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个实现类"><a href="#两个实现类" class="headerlink" title="两个实现类"></a>两个实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GreenHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**GreenHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"~~no fly~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedHeadDuck</span> <span class="keyword">extends</span> <span class="title">AbstractDuck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    mQuackBehavior = <span class="keyword">new</span> GeGeQuackBehavior();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"**RedHead**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-21 20:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractDuck greenHeadDuck = <span class="keyword">new</span> GreenHeadDuck();</span><br><span class="line">    AbstractDuck redHeadDuck = <span class="keyword">new</span> RedHeadDuck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认调用</span></span><br><span class="line">    greenHeadDuck.display();</span><br><span class="line">    greenHeadDuck.fly();</span><br><span class="line">    greenHeadDuck.quack();</span><br><span class="line">    greenHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将红头鸭的飞行方法改成不能飞</span></span><br><span class="line">    redHeadDuck.setFlyBehavior(<span class="keyword">new</span> BadFlyBehavior());</span><br><span class="line">    redHeadDuck.display();</span><br><span class="line">    redHeadDuck.fly();</span><br><span class="line">    redHeadDuck.quack();</span><br><span class="line">    redHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们增加行为的时候增加相应接口然后实现相应接口并将接口加入基类字段并实现set方法和相应方法调用接口里面的方法就行了</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</p><p>  原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用背景&quot;&gt;&lt;a href=&quot;#应用背景&quot; class=&quot;headerlink&quot; title=&quot;应用背景&quot;&gt;&lt;/a&gt;应用背景&lt;/h2&gt;&lt;h3 id=&quot;继承一定好用吗？&quot;&gt;&lt;a href=&quot;#继承一定好用吗？&quot; class=&quot;headerlink&quot; title=&quot;继
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>优先队列和堆</title>
    <link href="https://francisqiang.github.io/2019/05/19/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/"/>
    <id>https://francisqiang.github.io/2019/05/19/优先队列和堆/</id>
    <published>2019-05-19T14:51:28.000Z</published>
    <updated>2019-05-19T15:36:49.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>  普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院挂急诊的优先级大于普通排队就诊的，比如在游戏中自动打怪设置，当地图中出现级别高的野怪先打级别高的等等。</p><p>  如果我们实现优先队列使用普通的线性结构，那么当我们入队的时候时间复杂度就是O(1)，但出队的时候我们的时间复杂度就是O(n)，因为出队的时候是优先级最高的出队，所以我们需要遍历整个队列寻找优先级最高的元素。</p><p>  如果我们实现优先队列使用的顺序线性结构，那么我们出队的时间复杂度就是O(1)，因为原本队列就是依靠优先级排列的，这时候我们出队只需要取出第一个元素就行了。但是，当我们进行入队操作的时候我们就需要维持队列的顺序性，这时候入队就是O(n)的时间复杂度了。</p><p>  相较于前面两种实现方法，使用堆来实现优先队列的入队操作和出队操作都是O(logn)的时间复杂度，这是非常快的。</p><p>  <img src="/2019/05/19/优先队列和堆/1.jpg" alt="优先队列的实现方法的时间复杂度比较"></p><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>  堆其实就是按照层由上到下，由左到右的树结构，其中可以分为最大堆和最小堆(根元素为最大的元素就是最大堆)</p><p>  <img src="/2019/05/19/优先队列和堆/2.jpg" alt="堆的数据结构"></p><p>  当我们使用数组实现堆的时候，这时候父子节点的索引值存在着一种数学关系。</p><p>  <img src="/2019/05/19/优先队列和堆/3.jpg" alt="堆的数据结构"></p><p>  当索引从0开始的时候，父亲节点的索引就是子节点的索引-1再除以2(取整的性质，所以左右孩子都一样)，相应的，左孩子就是父亲节点索引乘2+1，右孩子则是左孩子+1。</p><p>  通过这个关系我们就可以很轻松的使用数组存储二叉堆。</p><h2 id="最大堆的代码实现"><a href="#最大堆的代码实现" class="headerlink" title="最大堆的代码实现"></a>最大堆的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 17:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回index索引的父亲节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 父亲节点的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index-0 doesn't have parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取节点左孩子的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 节点索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 左孩子索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取右孩子索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 费节点的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 右孩子的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">    siftUp(array.getSize() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素上浮</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 指定上浮元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当父元素比指定元素小的时候交换，如果交换则继续去比较</span></span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; array.get(parent(index)).compareTo(array.get(index)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      array.swap(index, parent(index));</span><br><span class="line">      index = parent(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.getSize() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The heap is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    E temp = getMax();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将堆顶元素和堆的最后一个元素交换位置</span></span><br><span class="line">    array.swap(<span class="number">0</span>, array.getSize() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//删除最后一个元素(原来的堆顶元素)</span></span><br><span class="line">    array.removeLast();</span><br><span class="line"></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 堆中元素的下沉</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 需要下沉的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断index合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历堆，条件是左孩子存在</span></span><br><span class="line">    <span class="keyword">while</span> (leftChild(index) &lt; array.getSize())&#123;</span><br><span class="line">      <span class="keyword">int</span> j = leftChild(index);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果右孩子存在则比较左右孩子，将大的索引赋值给j</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; array.getSize() &amp;&amp; array.get(j).compareTo(array.get(j + <span class="number">1</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        j ++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (array.get(index).compareTo(array.get(j)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果需要下沉的节点已经比左右孩子最大的大了直接break</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        array.swap(index, j);</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大堆的入队和出队的操作"><a href="#最大堆的入队和出队的操作" class="headerlink" title="最大堆的入队和出队的操作"></a>最大堆的入队和出队的操作</h2><p>  在上述代码中，其他操作都是最基本的，但是对于插入和移除元素就会稍微复杂了。</p><p>  当我们插入元素的时候，我们需要在数组最后插入元素，但是插入元素的大小不一定性决定着我们需要重新排列这个二叉堆使它还满足最大堆的特性。所以我们只需要和插入元素的父亲节点比较，如果我们插入的节点大于父亲节点了则交换，然后再和交换后的父亲节点比较，一直到根节点或者子节点小于父亲节点了。</p><p>  当我们移除元素的时候，其实就是移除堆中的顶层元素，这时候如果直接移除的话，那么堆就会变成两个堆，这样整合成一个堆的话太复杂，这时候我们可以将堆底元素和堆顶元素交换，然后再删除堆底元素(原来堆顶元素),然后我们通过现在堆顶元素和它的左右孩子最大的作比较，如果小于最大的那么就交换，然后再次和左右孩子做比较直到自己没有左右孩子为止。</p><h2 id="使用堆来实现优先队列"><a href="#使用堆来实现优先队列" class="headerlink" title="使用堆来实现优先队列"></a>使用堆来实现优先队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-19 20:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="comment">//优先队列中的元素必须是可比较的</span></span><br><span class="line"> <span class="comment">//其他的方法直接复用堆中的方法就行了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    maxHeap.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.getMax();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于LeetCode中优先队列的问题"><a href="#关于LeetCode中优先队列的问题" class="headerlink" title="关于LeetCode中优先队列的问题"></a>关于LeetCode中优先队列的问题</h2><p><img src="/2019/05/19/优先队列和堆/4.jpg" alt="题目"></p><p>分析: 我们需要获取频率出现最高的元素，我们需要将频率和元素(key)存入一个map中，然后遍历这个数组，当map不存在相应key的数组中的元素，则将value设置为1，如果存在value++。</p><p>然后我们遍历这个map中的key，将key存入优先队列中(容量为k)，当k的容量存满了并且还需要添加元素到优先队列的时候就判断优先队列优先度最高的元素和插入元素的优先度，如果插入元素的优先度高于现在队列中最高的，那么就将元素插入到队列中，知道整个map遍历完。</p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个Frequency类</span></span><br><span class="line">  <span class="comment">//存放key和频率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Frequency</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> k, freq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frequency</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> freq)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.k = k;</span><br><span class="line">      <span class="keyword">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现比较器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyCompartor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Frequency</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Frequency o1, Frequency o2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o1.freq - o2.freq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//遍历数组并且将频率信息存入map中</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : nums)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!map.containsKey(integer))&#123;</span><br><span class="line">        map.put(integer, <span class="number">1</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(integer, map.get(integer) + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Frequency&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> FrequencyCompartor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历map的key，并且将频率最高的放入优先队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key: map.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (priorityQueue.size() &lt; k)&#123;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; priorityQueue.peek().freq)&#123;</span><br><span class="line">        priorityQueue.poll();</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Frequency(key, map.get(key)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">      linkedList.add(priorityQueue.poll().k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是优先队列&quot;&gt;&lt;a href=&quot;#什么是优先队列&quot; class=&quot;headerlink&quot; title=&quot;什么是优先队列&quot;&gt;&lt;/a&gt;什么是优先队列&lt;/h2&gt;&lt;p&gt;  普通队列是先进先出的数据结构，而对于优先队列则是以优先级为准则的，优先级越大的先出队。就比如医院
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>集合与映射</title>
    <link href="https://francisqiang.github.io/2019/05/13/%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84/"/>
    <id>https://francisqiang.github.io/2019/05/13/集合与映射/</id>
    <published>2019-05-13T11:04:08.000Z</published>
    <updated>2019-05-13T14:47:39.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是集合-Set"><a href="#什么是集合-Set" class="headerlink" title="什么是集合(Set)"></a>什么是集合(Set)</h2><p>  简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。</p><a id="more"></a><h2 id="定义Set接口"><a href="#定义Set接口" class="headerlink" title="定义Set接口"></a>定义Set接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> size大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用二分搜索树实现集合"><a href="#使用二分搜索树实现集合" class="headerlink" title="使用二分搜索树实现集合"></a>使用二分搜索树实现集合</h2><p>  对于二分搜索树有一个很重要的特性就是它是根据元素的大小来放入元素到树中的，所以二分搜索树基本是不存在相同元素的，我们就可以通过二分搜索树底层实现集合</p><p>  这是上一篇博客写的二分搜索树的相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 20:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node left,right;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      left=<span class="keyword">null</span>;</span><br><span class="line">      right=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root = add(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.left = add(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMin(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode=node.right;</span><br><span class="line">      node.right=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.left=removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeMax(root).e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      Node leftNode=node.left;</span><br><span class="line">      node.left=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.right=removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root=remove(root,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      node.left=remove(node.left,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      node.right=remove(node.right,e);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果相等就要删除</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先判断这个树是不是只有一边的孩子</span></span><br><span class="line">      <span class="comment">//如果只有左边有孩子或者只有右边有孩子</span></span><br><span class="line">      <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果左右都有孩子</span></span><br><span class="line">      <span class="comment">//寻找该节点的后继节点</span></span><br><span class="line">      <span class="comment">//后继结点就是离该结点最近的节点（数值最近而且是大于该节点）</span></span><br><span class="line">      <span class="comment">//那么这个结点的后继结点就是该节点右孩子的最小结点</span></span><br><span class="line">      Node successorNode=minimum(node.right);</span><br><span class="line">      <span class="comment">//我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子</span></span><br><span class="line">      successorNode.right=removeMin(node.right);</span><br><span class="line">      successorNode.left=node.left;</span><br><span class="line">      node.left=node.right=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> successorNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      preOrder(node.left);</span><br><span class="line">      preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 非递归实现前序遍历</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perOrderWithoutRecurrence</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">      Node currentNode=stack.pop();</span><br><span class="line">      System.out.println(currentNode.e);</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 层序遍历(广度优先遍历)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        Node currentNode=queue.remove();</span><br><span class="line">        System.out.println(currentNode.e);</span><br><span class="line">        <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          queue.add(currentNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      inOrder(node.left);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      postOrder(node.left);</span><br><span class="line">      postOrder(node.right);</span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    generateBSTString(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成以node为根节点，深度为depth的描述二叉树的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> depth</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBSTString</span><span class="params">(Node node, <span class="keyword">int</span> depth, StringBuilder res)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      res.append(generateDepthString(depth) + <span class="string">"null\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.append(generateDepthString(depth) + node.e + <span class="string">"\n"</span>);</span><br><span class="line">    generateBSTString(node.left, depth + <span class="number">1</span>, res);</span><br><span class="line">    generateBSTString(node.right, depth + <span class="number">1</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">generateDepthString</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; depth ; i ++)&#123;</span><br><span class="line">      res.append(<span class="string">"--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这时候我们就可以使用二分搜索树来实现集合了，很简单，直接封装一个二分搜索树然后调用方法就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-05 21:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BinarySearchTree&lt;E&gt; binarySearchTree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.binarySearchTree = <span class="keyword">new</span> BinarySearchTree&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    binarySearchTree.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchTree.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用链表来实现集合"><a href="#使用链表来实现集合" class="headerlink" title="使用链表来实现集合"></a>使用链表来实现集合</h2><p>  链表中有一个contains方法，我们可以在调用add方法的时候使用contains方法判断原来集合中是否已经存在该元素了，如果已经存在那么就添加失败。其他的也是直接调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 10:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否已经存在该元素</span></span><br><span class="line">    <span class="keyword">if</span> (!linkedList.contains(e))&#123;</span><br><span class="line">      linkedList.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.contains(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkedList.remove(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树和链表实现集合的比较"><a href="#二分搜索树和链表实现集合的比较" class="headerlink" title="二分搜索树和链表实现集合的比较"></a>二分搜索树和链表实现集合的比较</h2><p>  在上面实现链表集合的时候我们很容易就会发现，链表集合的增加操作的时候需要先判断整个链表中是否存在该元素，那么这样就需要O(n)的时间复杂度了，在删除，查找元素的时候都是和普通链表一样O(n)的时间复杂度。可以说链表实现的集合的效率并不是很高。</p><p>  那么我们再来看一看二分搜索树实现的集合的时间复杂度。当我们添加元素的时候我们是依靠二分搜索树的特性来添加的</p><p>  <img src="/2019/05/13/集合与映射/1.jpg" alt="二分搜索树"></p><p>  比如我们需要添加一个元素的时候，我们就需要先判断大小，然后根据树的特性一层一层遍历，这个时候我们就会发现，我们的时间复杂度是和这个二分搜索树的高度呈线性关系的。</p><p>  <img src="/2019/05/13/集合与映射/2.jpg" alt="二分搜索树"></p><p>  <img src="/2019/05/13/集合与映射/3.jpg" alt="二分搜索树"></p><p>  然后我们通过运算就可以得出一个平衡二叉树h层一共有2的h次方-1个元素，我们就很容易得出时间复杂度为log2(n+1)，忽略常数，那么就是logn。</p><p>  <img src="/2019/05/13/集合与映射/4.jpg" alt="二分搜索树"></p><p>  而logn和n的差距在基数很大的时候差距特别明显</p><p>  <img src="/2019/05/13/集合与映射/5.jpg" alt="二分搜索树"></p><p>  所以说二分搜索树实现的集合会比链表实现的集合快很多。当然这也是考虑树的最好情况。当树不为平衡二叉树的时候，最坏情况也会是O(n)。</p><p>  <img src="/2019/05/13/集合与映射/6.jpg" alt="二分搜索树"></p><p>  如上图右边，我们看到当树成一边排列的时候，它的时间复杂度就是O(n)。</p><h2 id="LeetCode上解决关于集合的题目"><a href="#LeetCode上解决关于集合的题目" class="headerlink" title="LeetCode上解决关于集合的题目"></a>LeetCode上解决关于集合的题目</h2><p>  题目是这样的：</p><p>  <img src="/2019/05/13/集合与映射/7.jpg" alt="LeetCode804题目"></p><p>  对于这道题，我们可以遍历这个words数组，然后得到其中的某个元素再次遍历字符串的每个字母，然后通过原先定义的摩尔斯密码表数组和字符相对应，之后我们就可以获取到这个单词的摩尔斯密码，我们循环完一次之后，我们就把得到的摩尔斯密码拼接成字符串然后存入到set中，最终循环完成之后我们只要返回set的size就行了。</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-12 13:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预先定义摩尔斯密码表</span></span><br><span class="line">    String[] codes = &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length() ; i ++)&#123;</span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        stringBuilder.append(codes[word.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//存入set中</span></span><br><span class="line">      set.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是映射-Map-字典"><a href="#什么是映射-Map-字典" class="headerlink" title="什么是映射(Map,字典)"></a>什么是映射(Map,字典)</h2><ol><li><p>映射，在定义域中每一个值在值域都有一个值与他对应</p></li><li><p>存储(键，值)数据对的数据结构（Key，Value）</p></li><li><p>根据键(Key)，寻找值(Value)</p><p><img src="/2019/05/13/集合与映射/8.jpg" alt="映射的概念"></p></li></ol><h2 id="定义Map接口"><a href="#定义Map接口" class="headerlink" title="定义Map接口"></a>定义Map接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> key对应的value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">remove</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置相应key的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某个key对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否包含</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否包含</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取映射的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 映射大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断映射是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现Map"><a href="#链表实现Map" class="headerlink" title="链表实现Map"></a>链表实现Map</h2><p>  使用链表实现Map其实只需要将私有类Node里面的字段e更改为key和value就行。当然BinarySearchTree也是如此</p><p>  实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node next)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> key.toString() + <span class="string">" : "</span> + value.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">    Node currentNode = dummyHead.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.key.equals(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否已经存在该key的映射</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      dummyHead.next = <span class="keyword">new</span> Node(k, v, dummyHead.next);</span><br><span class="line">      size ++ ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果存在则更新</span></span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node preNode = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (preNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (preNode.next.key.equals(k))&#123;</span><br><span class="line">        Node delNode = preNode.next;</span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">        delNode.next = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        preNode = preNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是否存在该key的映射，如果不存在则抛出异常</span></span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(k + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树实现映射-Map"><a href="#二分搜索树实现映射-Map" class="headerlink" title="二分搜索树实现映射(Map)"></a>二分搜索树实现映射(Map)</h2><p>  对于BinarySearchTree来说实现Map也是利用它原先的方法</p><p>  代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-13 20:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//辅助方法，在删除，修改映射的value时候会用到</span></span><br><span class="line">  <span class="comment">//获取相应key对应的Node(递归)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果递归到节点为null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候继续递归该结点的左子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//大于的时候继续递归该结点的右子树</span></span><br><span class="line">      <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不然就是相等，则直接返回该结点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归到最底层，直接添加节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//小于的时候直接递归该结点的左子树</span></span><br><span class="line">      node.left = add(node.left, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = add(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="comment">   * 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">      Node rightNode = node.right;</span><br><span class="line">      node.right = <span class="keyword">null</span>;</span><br><span class="line">      size --;</span><br><span class="line">      <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从二分搜索树中删除键为key的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      root = remove(root, key);</span><br><span class="line">      <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.left = remove(node.left , key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">      node.right = remove(node.right, key);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">      <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">      <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">      Node successor = minimum(node.right);</span><br><span class="line">      successor.right = removeMin(node.right);</span><br><span class="line">      successor.left = node.left;</span><br><span class="line"></span><br><span class="line">      node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(root, k);</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(root, k) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表Map和二分搜索树Map比较"><a href="#链表Map和二分搜索树Map比较" class="headerlink" title="链表Map和二分搜索树Map比较"></a>链表Map和二分搜索树Map比较</h2><p>  测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testMap</span><span class="params">(Map&lt;String, Integer&gt; map, String filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    System.out.println(filename);</span><br><span class="line">    ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(FileOperation.readFile(filename, words)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Total words: "</span> + words.size());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String word : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(word))&#123;</span><br><span class="line">          map.set(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          map.add(word, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Total different words: "</span> + map.getSize());</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PRIDE: "</span> + map.get(<span class="string">"pride"</span>));</span><br><span class="line">      System.out.println(<span class="string">"Frequency of PREJUDICE: "</span> + map.get(<span class="string">"prejudice"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String filename = <span class="string">"I:\\data_structure\\src\\pride-and-prejudice.txt"</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; bstMap = <span class="keyword">new</span> BinarySearchTreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time1 = testMap(bstMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"BST Map: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; linkedListMap = <span class="keyword">new</span> LinkedListMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time2 = testMap(linkedListMap, filename);</span><br><span class="line">    System.out.println(<span class="string">"Linked List Map: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  两者时间差异:</p><p>  <img src="/2019/05/13/集合与映射/9.jpg" alt="测试结果"></p><p>  可以看出，二分搜索树实现的Map的时间性能是远高于链表实现的Map的。</p><p>  因为对于链表实现修改某一映射对应的value值的时间复杂度是O(n),我们需要一个一个去遍历知道找到key符合的元素。</p><p>  而对于二分搜索树实现的Map来说，它修改一个value的时间复杂度是跟二叉树的高度相关的，也就是说它的时间复杂度是O(logn)级别的，所以当数据量大的时候，二分搜索树的优势非常明显。当然我们还需要考虑最坏的情况，那就是这个二分搜索树变成了类似于链表的树，那这时候时间复杂度就是O(n)了。</p><p>  <img src="/2019/05/13/集合与映射/10.jpg" alt="两种map的时间复杂度比较"></p><p>  但是有个细节需要注意的是，链表实现的Map的key是无序的，上文中的set也是无序的。但是二分搜索树实现的set和map都是有序的(这也是它这么快的一部分原因)。</p><h2 id="使用Map来实现Set"><a href="#使用Map来实现Set" class="headerlink" title="使用Map来实现Set"></a>使用Map来实现Set</h2><p>  我们可以发现，其实Set就是一个没有value的的Map。所以，当我们底层实现了一个映射，集合我们就可以理解成Map&lt;K, V&gt;中value为null的情况，对于不管是k，它所对应的的value都为null。</p><p>  所以当我们在Map中只考虑K的时候，整个Map数据结构就变成了K的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是集合-Set&quot;&gt;&lt;a href=&quot;#什么是集合-Set&quot; class=&quot;headerlink&quot; title=&quot;什么是集合(Set)&quot;&gt;&lt;/a&gt;什么是集合(Set)&lt;/h2&gt;&lt;p&gt;  简单来说，集合就是一个不能存放重复元素的数据结构，通常可以运用于客户统计(网站访问人数)，词汇量统计等等。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合RabbitMQ以及四种交换模式</title>
    <link href="https://francisqiang.github.io/2019/05/09/SpringBoot%E6%95%B4%E5%90%88RabbitMQ%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/</id>
    <published>2019-05-09T12:25:32.000Z</published>
    <updated>2019-05-09T16:35:49.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>  在google的时候发现知乎一个很好的回答，很生动形象。</p><p>  作者：ScienJus<br>  <a href="https://www.zhihu.com/question/34243607/answer/58314162" target="_blank" rel="noopener">原文链接</a></p><p>  个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。使用场景的话，举个例子：假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：校验用户名等信息，如果没问题会在数据库中添加一个用户记录如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他发送给用户一个包含操作指南的系统通知等等……但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了。</p><p>  我理解的消息队列就是当你的一个接口访问量大或者需要进行的操作很多，就比如注册这些功能(里面有发邮件，插入数据各种操作)，但是用户只需要知道是否注册成功，他们需要马上收到注册结果(提高用户体验性)，所以当用户的信息插入到数据库中我们就可以直接返回结果，至于后面的操作可以放入消息队列异步慢慢处理。</p><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><ul><li><p>maven配置</p><p>首先当然是maven配置了，springboot中为我们提供了amqp的start,amqp是一个消息队列的协议，RabbitMQ实现了这个协议。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>springboot配置文件的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">  password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">  virtual-host:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  listener:</span></span><br><span class="line"><span class="attr">    simple:</span></span><br><span class="line"><span class="attr">      concurrency:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      max-concurrency:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      prefetch:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      auto-startup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      default-requeue-rejected:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    retry:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      initial-interval:</span> <span class="number">1000</span><span class="string">ms</span></span><br><span class="line"><span class="attr">      max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      max-interval:</span> <span class="number">10000</span><span class="string">ms</span></span><br><span class="line"><span class="attr">      multiplier:</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>除了host，port什么的其他都可以不写，springboot已经默认帮我们配置好了。</p></li><li><p>RabbitMQ的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE,<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>消息发送者(提供者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"send"</span>);</span><br><span class="line">  <span class="comment">//标注需要发送的某个队列</span></span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.QUEUE,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息接收者(消费者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RabbitListener注解需要标注刚刚我们的队列名</span></span><br><span class="line"><span class="comment">//其作用就是监听那个队列是否有消息，有消息则接收</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.QUEUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span>+message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RabbitMQ的四种模式"><a href="#RabbitMQ的四种模式" class="headerlink" title="RabbitMQ的四种模式"></a>RabbitMQ的四种模式</h2><p>  RabbitMQ分为四种模式</p><pre><code>* Direct模式* Topic模式* Fanout模式* Headers模式</code></pre><ul><li><p>Direct模式(直接交换模式)</p><p>刚刚我们的配置类，接受者和发送者实现的就是Direct模式，其流程就是发送者指定一个Queue来发送消息给那个队列，然后消费者一直监听那个队列，有消息则接收</p></li><li><p>Topic模式</p></li></ul><p>首先是Topic的配置类，这里定义两个Queue，并且生成一个TopicExchange(Topic交换机)。</p><p>然后我们通过Binding来将A和B的消息队列绑定到我们刚刚生成的TopicExchange和指定routingKey中</p><p><img src="/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/1.jpg" alt="RabbitMQ的topic模式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE_A, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE_B, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBindingA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(topicQueueA()).to(topicExchange()).with(<span class="string">"topic.keyA"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBindingB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(topicQueueB()).to(topicExchange()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的消息发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicSend</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"topic send"</span>);</span><br><span class="line">  <span class="comment">//我们指定某个routingkey发送到这个交换机上</span></span><br><span class="line">  <span class="comment">//然后这个topic交换机会将我们的routingKey审核</span></span><br><span class="line">  <span class="comment">//如果这个key和某个队列绑定的key匹配那么这个消息就会发送到这个队列里</span></span><br><span class="line">  <span class="comment">//在队列绑定routingKey的时候可以使用#,*这些通配符,所以就会出现我发送一个消息，两个队列都收到了，我发送两个消息都是一个队列收到等情况，如图所示。</span></span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, <span class="string">"topic.keyA"</span>, message);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.TOPIC_EXCHANGE, <span class="string">"topic.keyB"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的消息消费者(接收者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收很简单，只要指定队列就行</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.TOPIC_QUEUE_A)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicReceiveA</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.TOPIC_QUEUE_B)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicReceiveB</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"receive:"</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Fanout模式</li></ul><p>首先是Fanout的配置类,跟上面的topic查不到，我们先配置一个FanoutExchange类，然后通过Binding将队列绑定到那个Exchange中，我们可以绑定多个队列到Exchange中。</p><p><img src="/2019/05/09/SpringBoot整合RabbitMQ以及四种交换模式/1.jpg" alt="RabbitMQ的topic模式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(FANOUT_QUEUE_A, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(FANOUT_QUEUE_B, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBindingA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueA()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBindingB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueB()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是我们的发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们只要将消息发送给交换机就好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutSend</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanout send"</span>);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class="string">""</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的消费者,这时候我们会发现这个Fanout模式就是类似于广播模式，我们将所有需要的队列都绑定上Fanout的Exchange中，然后我们发送者只需要将消息发送给Exchange，然后我们的消费者在所有的Queue中都能接收到消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.FANOUT_QUEUE_A)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutReceiveA</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanoutA receive:"</span>+message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.FANOUT_QUEUE_B)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutReceiveB</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"fanoutB receive:"</span>+message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Headers模式</li></ul><p>首先是我们的配置类，这个Header跟上面几种有些不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">headersQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(HEADERS_QUEUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeadersExchange <span class="title">headersExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前面两个和上述三种都差不多，这里的Binding有些不一样</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">headersBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  map.put(<span class="string">"HeadersAKey"</span>,<span class="string">"HeadersAValue"</span>);</span><br><span class="line">  map.put(<span class="string">"HeadersBKey"</span>,<span class="string">"HeadersBValue"</span>);</span><br><span class="line">  <span class="comment">//我们需要创建一个map存入键值对，然后绑定队列到交换机上，并且有个要求就是where什么什么加入map需要匹配，我们先看消息发送者</span></span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headersSend</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"headers send"</span>);</span><br><span class="line">  <span class="comment">//这里的发送者的发送方法需要的是一个交换机名称，还有一个就是Message对象</span></span><br><span class="line">  <span class="comment">//这个Message对象存入了真正消息的字符数组和消息的配置类，这里的消息配置类就是MessageProperties</span></span><br><span class="line">  <span class="comment">//我们需要对这个MessageProperties设置头，这个头就是键值对，就是我们配置类设置的map</span></span><br><span class="line">  <span class="comment">//我们发送消息给队列，这个消息的头被设置为我配置类书写的那两个map才行，因为我设置了whereAll.match，所以我发送消息给交换机，这个交换机会帮我去匹配请求头和我设置的符合的Queue并把消息存入那个队列中</span></span><br><span class="line">  MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">  messageProperties.setHeader(<span class="string">"HeadersAKey"</span>,<span class="string">"HeadersAValue"</span>);</span><br><span class="line">  messageProperties.setHeader(<span class="string">"HeadersBKey"</span>,<span class="string">"HeadersBValue"</span>);</span><br><span class="line">  Message headersMessage = <span class="keyword">new</span> Message(message.getBytes(),messageProperties);</span><br><span class="line">  amqpTemplate.convertAndSend(RabbitConfig.HEADERS_EXCHANGE, <span class="string">""</span>, headersMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个时候我们接收的就是字符数组了，因为我们再发送者的方法中是将消息变成byte[]再作为参数进行入队的</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitConfig.HEADERS_QUEUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headersReceive</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>&#123;</span><br><span class="line">  logger.info(<span class="string">"headers receive:"</span>+<span class="keyword">new</span> String(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是消息队列&quot;&gt;&lt;a href=&quot;#什么是消息队列&quot; class=&quot;headerlink&quot; title=&quot;什么是消息队列&quot;&gt;&lt;/a&gt;什么是消息队列&lt;/h2&gt;&lt;p&gt;  在google的时候发现知乎一个很好的回答，很生动形象。&lt;/p&gt;
&lt;p&gt;  作者：ScienJu
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://francisqiang.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>二分搜索树的遍历</title>
    <link href="https://francisqiang.github.io/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://francisqiang.github.io/2019/05/06/二分搜索树的遍历/</id>
    <published>2019-05-06T08:46:46.000Z</published>
    <updated>2019-05-06T09:27:53.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分搜索树的遍历"><a href="#二分搜索树的遍历" class="headerlink" title="二分搜索树的遍历"></a>二分搜索树的遍历</h2><p>  其实这里就是二叉树的遍历，只是因为二分搜索树因为是依靠它的特定规则而排列的，所以再经过不同方法遍历之后，它的顺序会有很多特点。</p><p>  我们是依靠根节点顺序来命名的，记住！是根结点。</p><p>  前序遍历就是先遍历根结点，然后遍历左结点，最后遍历右结点。</p><p>  中序遍历就是先遍历左结点，然后遍历根结点，最后遍历右结点。</p><p>  后序遍历就是先遍历左结点，然后遍历右结点，最后遍历根结点。</p><p>  最后要注意，这个提示可能不是适合所有人，对于我来说，我书写一个二叉树的前中后序遍历的时候都告诫自己要等待一个结点能遍历的时候才能遍历，什么意思呢？就是要遍历一个结点的时候需要把它的子节点先遍历了（子节点优先遍历），其实这个前中后序遍历另一个名字就是深度优先遍历，跟这个有关。</p><p>  慕课网中有另一种快速书写三种遍历方式遍历后的顺序结果的方法，如图:</p><p>  <img src="/2019/05/06/二分搜索树的遍历/1.jpg" alt="三种深度优先遍历"></p><p>  它是在每个结点上画上三个点，然后不管什么遍历方式都从根节点到左节点到右节点的方式遍历(比较图中)，每个结点其实都会经过三次，当中序遍历就去中间的点作为顺序参照，前序遍历就取左边的点作为顺序参照，后序遍历就取右边的点作为顺序参照。</p><p>  如果中序和后序的图看不懂，那么就将前序遍历那些顺序线放入中序和后序的图中，然后根据那个顺序线依次找蓝色的点，最后这些点连接成的就是遍历顺序了。</p><h2 id="深度优先遍历的递归代码实现"><a href="#深度优先遍历的递归代码实现" class="headerlink" title="深度优先遍历的递归代码实现"></a>深度优先遍历的递归代码实现</h2><p>  前面说了，前中后序遍历都可以称为深度优先遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//先打印根节点</span></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    <span class="comment">//然后遍历左节点</span></span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    <span class="comment">//遍历右结点</span></span><br><span class="line">    preOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//优先遍历左节点</span></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//先遍历左节点</span></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    <span class="comment">//然后遍历右结点</span></span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    <span class="comment">//最后遍历根结点</span></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归实现深度优先遍历很简单，只需要记住顺序就行了。</p><h2 id="非递归实现前序遍历"><a href="#非递归实现前序遍历" class="headerlink" title="非递归实现前序遍历"></a>非递归实现前序遍历</h2><p>  其实非递归实现前序遍历就是模拟系统方法栈，这时候我们不通过递归，我们就要自己使用栈来实现前序遍历。</p><p>  比如说我们需要将一个树前序遍历，这时候我们先将根结点放入我们new的一个栈中，然后我们把栈中这个结点元素取出来，对它进行打印(或者其他操作)，然后我们将它的右孩子，左孩子依次放入栈中(因为栈是先进后出)。然后我们再次取出栈中的一个元素，这时候我们取的是根结点的左孩子，然后我们对这个节点进行打印，然后把这个结点的右左孩子依次放入栈中，继续进行出栈操作。。。</p><p>  <img src="/2019/05/06/二分搜索树的遍历/2.jpg" alt="非递归实现前序遍历"></p><p>  代码实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归实现前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perOrderWithoutRecurrence</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//栈中元素不为空那么就出栈操作</span></span><br><span class="line">    Node currentNode=stack.pop();</span><br><span class="line">    System.out.println(currentNode.e);</span><br><span class="line">    <span class="comment">//依次将右左孩子放入栈中</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(currentNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(currentNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p>  层序遍历又是广度优先遍历，它是将树一层一层地进行遍历的。</p><p>  <img src="/2019/05/06/二分搜索树的遍历/3.jpg" alt="广度优先遍历"></p><p>  比如上图，我们广度优先遍历（层序遍历）的顺序就是28,16,30,13,22,29,42.</p><p>  我们如何实现呢？其实我们这时候需要一个队列，这个队列里将根结点放入，然后把根结点取出来进行操作（同时也要将队列里的根节点删除，后面的结点被取出来的时候也要删除），然后把根节点的左孩子，右孩子依次进行入队，这时候我们再取出队列里的第一个元素（根节点的左孩子结点），然后我们对它进行操作并删除队列里它的元素，然后将他的左右孩子依次入队，之后我们再取出来队列的第一个元素（根节点的右孩子），后面依次同上操作，如图所示。</p><p>  代码实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层序遍历(广度优先遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">      Node currentNode=queue.remove();</span><br><span class="line">      System.out.println(currentNode.e);</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(currentNode.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(currentNode.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分搜索树的遍历&quot;&gt;&lt;a href=&quot;#二分搜索树的遍历&quot; class=&quot;headerlink&quot; title=&quot;二分搜索树的遍历&quot;&gt;&lt;/a&gt;二分搜索树的遍历&lt;/h2&gt;&lt;p&gt;  其实这里就是二叉树的遍历，只是因为二分搜索树因为是依靠它的特定规则而排列的，所以再经过不
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二分搜索树的增删改查</title>
    <link href="https://francisqiang.github.io/2019/05/06/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>https://francisqiang.github.io/2019/05/06/二分搜索树的增删改查/</id>
    <published>2019-05-06T05:01:10.000Z</published>
    <updated>2019-05-06T05:49:32.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是二分搜索树"><a href="#什么是二分搜索树" class="headerlink" title="什么是二分搜索树"></a>什么是二分搜索树</h2><p>  首先我们要先知道二叉树是什么，二叉树其实就是从一个根节点左右两端延伸出左右结点，延伸出的结点再次延伸出结点，然后一直延伸下去，所以树这种数据结构天生满足递归特性。</p><p>  而二分搜索树就是对二叉树做了一个限制，首先二分搜索树中的元素必须是可比较的（对于Java来说就是必须继承Comparable接口）。为什么需要它可比较呢？就是因为，二分搜索树的排列需要根据数值来排列。</p><p>  二分搜索树的某个结点的左孩子必须小于原来的节点且某个结点的左子树的所有结点必须比这个结点小。</p><p>  右边同上。</p><p>  <img src="/2019/05/06/二分搜索树的增删改查/1.jpg" alt="什么是二分搜索树和二叉树"></p><h2 id="二分搜索树的基本定义"><a href="#二分搜索树的基本定义" class="headerlink" title="二分搜索树的基本定义"></a>二分搜索树的基本定义</h2><p>  根据上面的定义，我们很容易就能写出代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node left,right;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      left=<span class="keyword">null</span>;</span><br><span class="line">      right=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root=<span class="keyword">null</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树的一些方法"><a href="#二分搜索树的一些方法" class="headerlink" title="二分搜索树的一些方法"></a>二分搜索树的一些方法</h2><ul><li>首先就是getSize()和isEmpty()方法，很容易，返回size和判断size是否为0就行了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>添加元素</p><p>添加元素的时候我们只需要在树的叶子节点中添加就行了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果根节点为空，那么直接new</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        add(root,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果这个结点不等于这个时候才能添加元素</span></span><br><span class="line">  <span class="keyword">if</span> (!e.equals(node.e))&#123;</span><br><span class="line">    <span class="comment">//如果插入元素小于该结点的元素且该结点的左孩子为空</span></span><br><span class="line">    <span class="comment">//那么直接插入左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>&amp;&amp;node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      node.left=<span class="keyword">new</span> Node(e);</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个同上</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>&amp;&amp;node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      node.right=<span class="keyword">new</span> Node(e);</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果小于，那么就递归调用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      add(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//同上</span></span><br><span class="line">      add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当然添加方法还有优化的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">  add(root,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//该结点为空，那么直接返回给上一级new出来的元素为e的节点，这里就是添加，只是现在遍历到最后了而已</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如果小于，那么该结点的左孩子就是下一层二分搜索树的添加元素后的二分搜索树</span></span><br><span class="line">    node.left=add(node.left,e);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如果大于，那么该结点的右孩子就是下一层二分搜索树的添加元素后的二分搜索树</span></span><br><span class="line">    node.right=add(node.right,e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最后return被添加过结点的根节点</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>查询元素</p><ul><li><p>这里就是判断二分搜索树是否包含某个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果该树的根节点就是空，那么直接false</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果查询到了那么返回该结点</span></span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//小于的时候遍历左孩子树</span></span><br><span class="line">    <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//大于的时候遍历右孩子树</span></span><br><span class="line">    <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取最小元素和最大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当树的大小为0就不能删除</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当遍历到最后的某个结点的左孩子为null，那么这个结点就是最小元素</span></span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除元素，其中删除元素是最复杂的，对于删除最小最大元素来说并不复杂，因为只需要往左往右遍历二分搜索树就行了，但是对于任意元素的删除就要考虑多种情况。</p><ul><li>删除最小元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> removeMin(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果左孩子为空，那么这个结点就是要删除的结点</span></span><br><span class="line">  <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//将该结点的右子树放入临时变量</span></span><br><span class="line">    Node rightNode=node.right;</span><br><span class="line">    <span class="comment">//将这个结点的右子树置为null，然后返回刚刚的临时变量rightNode</span></span><br><span class="line">    node.right=<span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> rightNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不然就一直向左遍历，并且将下一级删除后返回的二分搜索树赋值给上一级的结点</span></span><br><span class="line">  node.left=removeMin(node.left);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除最大元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"BST is empty"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> removeMax(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">    Node leftNode=node.left;</span><br><span class="line">    node.left=<span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> leftNode;</span><br><span class="line">  &#125;</span><br><span class="line">  node.right=removeMax(node.right);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除某个结点</li></ul><p>我们可以通过寻找需要被删除节点的后继或者前驱，并且把它从原来树中删除然后代替被删除节点的位置</p><p><img src="/2019/05/06/二分搜索树的增删改查/2.jpg" alt="通过后继删除元素"></p><p><img src="/2019/05/06/二分搜索树的增删改查/3.jpg" alt="通过前驱删除元素"></p><p>这里我只写了通过后继删除某个元素，当然前驱书写方式也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">  root=remove(root,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (e.compareTo(node.e)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    node.left=remove(node.left,e);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    node.right=remove(node.right,e);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果相等就要删除</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//首先判断这个树是不是只有一边的孩子</span></span><br><span class="line">    <span class="comment">//如果只有左边有孩子或者只有右边有孩子</span></span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//如果只有左子树</span></span><br><span class="line">      <span class="comment">//那么我们将该结点的左子树返回给上一节点的左子树</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> node.left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左右都有孩子</span></span><br><span class="line">    <span class="comment">//寻找该节点的后继节点</span></span><br><span class="line">    <span class="comment">//后继结点就是离该结点最近的节点（数值最近而且是大于该节点）</span></span><br><span class="line">    <span class="comment">//那么这个结点的后继结点就是该节点右孩子的最小结点</span></span><br><span class="line">    Node successorNode=minimum(node.right);</span><br><span class="line">    <span class="comment">//我们需要删除该节点的后继结点并且将删除后的右孩子树赋值给我们获取到的successorNode的右孩子</span></span><br><span class="line">    successorNode.right=removeMin(node.right);</span><br><span class="line">    successorNode.left=node.left;</span><br><span class="line">    node.left=node.right=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> successorNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是二分搜索树&quot;&gt;&lt;a href=&quot;#什么是二分搜索树&quot; class=&quot;headerlink&quot; title=&quot;什么是二分搜索树&quot;&gt;&lt;/a&gt;什么是二分搜索树&lt;/h2&gt;&lt;p&gt;  首先我们要先知道二叉树是什么，二叉树其实就是从一个根节点左右两端延伸出左右结点，延伸出的
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Git中.gitignore文件修改后不起作用</title>
    <link href="https://francisqiang.github.io/2019/05/05/Git%E4%B8%AD-gitignore%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>https://francisqiang.github.io/2019/05/05/Git中-gitignore文件修改后不起作用/</id>
    <published>2019-05-05T08:18:50.000Z</published>
    <updated>2019-05-05T08:33:17.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>  当我使用git上传项目的时候，有些本应该忽略的文件没有被忽略，这时候我修改.gitignore文件再次上传的时候，本该忽略的文件还是在那里</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>  这是因为git缓存的原因，如果某些文件已经被纳入版本管理中，就算是在.gitignore文件中声明了忽略文件的路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再add和push。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol><li><p>首先清除本地缓存<br>git rm -r –cached .</p></li><li><p>再次add文件<br>git add .</p></li><li><p>提交<br>git commit -m “chore:update .gitignore”</p></li><li><p>push<br>git push</p></li></ol><h2 id="gitignore书写格式"><a href="#gitignore书写格式" class="headerlink" title=".gitignore书写格式"></a>.gitignore书写格式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;  当我使用git上传项目的时候，有些本应该忽略的文件没有被忽略，这时候我修改.gitignore文件再次上传的时候，本该忽
      
    
    </summary>
    
      <category term="Git" scheme="https://francisqiang.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>从源文件到可执行文件</title>
    <link href="https://francisqiang.github.io/2019/05/05/%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://francisqiang.github.io/2019/05/05/从源文件到可执行文件/</id>
    <published>2019-05-05T05:36:18.000Z</published>
    <updated>2019-05-05T07:04:04.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>  这篇文章是我阅读《程序是怎样跑起来的》这本书第八章后写的读后感，也说不上读后感，就是把原文一些东西整理一下，方便日后阅读记忆。学校图书馆真是一个好地方，原本以为没有什么好的图书，后面去借阅几次发现了很多好书，这本书也是我在图书馆中借阅的。</p><h2 id="计算机只能运行本地代码"><a href="#计算机只能运行本地代码" class="headerlink" title="计算机只能运行本地代码"></a>计算机只能运行本地代码</h2><p>  什么是源文件和源代码，就是使用某种编程语言编写的程序就称为源代码，保存源代码的文件就是源文件。比如说以.c或者.java为扩展名的文件就是源文件。</p><p>  但是源文件是无法直接运行的，这是因为CPU能直接解析并运行的不是源代码而是本地代码的程序。</p><p>  本地(native)，对于CPU来说就是母语的意思，任何编程语言编写的源代码最后都要翻译成本地代码，否则CPU就看不懂。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/1.jpg" alt="转换为本地代码后就变成了同样的语言"></p><h2 id="本地代码的内容"><a href="#本地代码的内容" class="headerlink" title="本地代码的内容"></a>本地代码的内容</h2><p>  比如说Windows中的EXE文件里面就是本地代码。</p><p>  我们使用文本工具打开exe文件可以看到类似下图的代码</p><p>  <img src="/2019/05/05/从源文件到可执行文件/2.jpg" alt="用记事本打卡exe文件"></p><p>  这时候我们将它转变成十六进制</p><p>  <img src="/2019/05/05/从源文件到可执行文件/3.jpg" alt="转换为十六进制"></p><p>  计算机指令也是数值的罗列，这些就是本地代码。</p><h2 id="编译器负责转换源代码"><a href="#编译器负责转换源代码" class="headerlink" title="编译器负责转换源代码"></a>编译器负责转换源代码</h2><p>  能够把C语言等高级语言转换为本地代码的程序成为编译器，相当于现实中的翻译，每个编程语言都需要专用的编译器，C语言的就叫C编译器，这类似于现实中中文翻译成英文需要专业的英文翻译者。</p><p>  编译器读入代码内容，然后通过一些对照表把源代码对照翻译成本地代码，当然不仅仅是这么简单，其中还有语法解析，句法解析，语义解析等等，最后才能生成本地代码。</p><p>  根据CPU的不同，本地代码的类型也不同，所以编译器不仅和编程语言相关还和CPU相关，列入x86系列的CPU用的C编译器就和PowerPC这种CPU的C编译器不同。</p><p>  还有就是编译器也是一种程序，所以也需要运行环境，那么windows用的C编译器和Linux用的C编译器就不同。还有就是交叉编译器，他生产的是和运行环境中的CPU不同的CPU所使用的的本地代码。</p><h2 id="仅靠编译时无法得到可执行文件的"><a href="#仅靠编译时无法得到可执行文件的" class="headerlink" title="仅靠编译时无法得到可执行文件的"></a>仅靠编译时无法得到可执行文件的</h2><p>  C和C++中编译之后生成的是.obj目标文件，这时候还需要链接才能得到可执行的exe文件。</p><p>  比如说我们书写了一个函数</p><p>  <img src="/2019/05/05/从源文件到可执行文件/4.jpg" alt="代码"><br>  <img src="/2019/05/05/从源文件到可执行文件/5.jpg" alt="代码"></p><p>  其中我们调用了MessageBox函数，sprintf函数。但是在我们的源代码中没有这两个函数的相关实现，比如这个文件生成的是sample.obj，那么这个文件就需要和MessageBox，sprintf的目标文件相结合(链接)，才能生成完整的程序。试想一下这个sample是exe文件，那么这个文件就是不完整的，是无法执行的。</p><p>  运行连接的程序就称为链接器。</p><h2 id="启动及库文件"><a href="#启动及库文件" class="headerlink" title="启动及库文件"></a>启动及库文件</h2><p>  当我们执行上述sample.c文件的编译 链接操作的时候，我们需要指定两个文件。一个是sample.obj生成的目标文件，另一个是C0w32.obj文件，这个文件是记录着同所有程序气死位置相结合的处理内容，程序程序的启动。</p><p>  后面我们还需要指定库文件，比如说32.lib cw32.lib库文件，这里面存放着sprintf函数的目标文件和MessageBox函数的目标文件(实际上是在 user32.dll文件中，这是动态链接库)</p><p>  链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件</p><p>  <img src="/2019/05/05/从源文件到可执行文件/6.jpg" alt="编译链接的命令"></p><p>  如果不指定库文件就会发生无法识别sprintf函数和MessageBox函数的错误</p><p>  <img src="/2019/05/05/从源文件到可执行文件/7.jpg" alt="编译器报错"></p><h2 id="DLL文件及导入库"><a href="#DLL文件及导入库" class="headerlink" title="DLL文件及导入库"></a>DLL文件及导入库</h2><p>  Windows以函数的形式为应用提供了各种功能，这些函数被称为API(Application Programming Interface应用程序接口)  上面讲到的MessageBox()函数并不是C语言的标准库函数，而是Windows提供的API，这些API的目标文件存储在名为DLL(Dynamic Link Library)文件的特殊库文件中，它是程序运行动态结合的文件，上面我们提到MessageBox的目标文件存储在import32.lib文件中，其实这个文件只存储了两个信息——MessageBox()存储在user32.dll文件中，还有就是这个dll文件的文件夹信息。</p><p>  我们把类似于import32.lib这样的库文件称为导入库。</p><p>  DLL文件的好处：DLL文件中的函数可以被多个程序共用，因此借助该功能可以节约内存和磁盘。此外，在对函数的内容做修正的时候不需要重新连接(静态链接)。</p><p>  另一个就是静态链接库，就是sprintf，存储着sprintf()的cw32.lib就是静态链接库。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/8.jpg" alt="windows中编译和链接机制"></p><h2 id="可执行文件运行时的必要条件"><a href="#可执行文件运行时的必要条件" class="headerlink" title="可执行文件运行时的必要条件"></a>可执行文件运行时的必要条件</h2><p>  存储在硬盘中的exe文件运行时要读入内存中执行，在exe文件中我们会给变量和函数分配虚拟的内存地址，在程序运行的时候，这些虚拟内存地址会转换为实际内存地址，链接器会在exe文件的开头，追加转换内存地址所需的必要信息，这个信息称为再配置信息。</p><p>  可以这么理解，再配置信息里存放了变量和函数的相对地址，这个相对地址就是相对于基地址的偏移量，这样各个变量的内存地址就可以用变量组的基地址加上偏移量作为地址，而这些基地址是在程序运行时被计算机分配的。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/9.jpg" alt="链接后的exe文件构造"></p><h2 id="程序加载时会生成堆和栈"><a href="#程序加载时会生成堆和栈" class="headerlink" title="程序加载时会生成堆和栈"></a>程序加载时会生成堆和栈</h2><p>  当程序加载到内存中，出再配置信息，变量组，函数组等还会额外生成两个组，那就是堆和栈。栈是用来存储函数内部使用的临时变量以及函数调用时所用的参数的内存区域。堆是用来存储程序运行时的任意数据和对象的内存领域。</p><p>  <img src="/2019/05/05/从源文件到可执行文件/10.jpg" alt="内存中的组"></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>  对于栈来说，它会在函数调用的时候自动分配内存，在函数执行完毕后自动释放内存。但是对于堆来说，C语言需要程序员使用malloc申请分配，free()函数来释放，C++中需要使用new来申请分配，delete来释放，Java和C#这些语言户进行自动垃圾回收，如果我们忘记释放内存，那么这个内存空间就会一直被使用，久而久之就会造成内存泄露(memory leak)从而导致内存不足而卡死，就比如一晚上忘关水龙头，水盆中的水装满并溢出一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于本文&quot;&gt;&lt;a href=&quot;#关于本文&quot; class=&quot;headerlink&quot; title=&quot;关于本文&quot;&gt;&lt;/a&gt;关于本文&lt;/h2&gt;&lt;p&gt;  这篇文章是我阅读《程序是怎样跑起来的》这本书第八章后写的读后感，也说不上读后感，就是把原文一些东西整理一下，方便日后阅读
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="https://francisqiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis插入字段并返回主键的小问题</title>
    <link href="https://francisqiang.github.io/2019/05/04/Mybatis%E6%8F%92%E5%85%A5%E5%AD%97%E6%AE%B5%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/05/04/Mybatis插入字段并返回主键的小问题/</id>
    <published>2019-05-04T14:54:14.000Z</published>
    <updated>2019-05-04T15:07:58.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>  这几天在写秒杀项目，其中有一个需求是生成订单并返回订单号（主键）然后再生成秒杀订单将刚刚返回的订单号作为某个字段插入秒杀订单中，也就是秒杀订单表中的order_id。这其中就使用到了插入信息并返回主键。</p><p>  我使用的是Mybatis逆向工程生成的Mapper文件，其中自动生成的insert方法返回的是影响的行数，我在使用的时候一直返回给我的是1，导致报错。</p><h2 id="相关Mapper的编写"><a href="#相关Mapper的编写" class="headerlink" title="相关Mapper的编写"></a>相关Mapper的编写</h2><p>  其中最关键的就是在insert标签上增加useGeneratedKeys和keyProperty</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertOrderAndReturnOrderId"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">parameterType</span>=<span class="string">"com.lgq.miaosha.domain.OrderInfo"</span>&gt;</span></span><br><span class="line">  insert into t_order_info (id, user_id, goods_id,</span><br><span class="line">  delivey_addr_id, goods_name, goods_count,</span><br><span class="line">  goods_price, order_channel, status,</span><br><span class="line">  create_date, pay_date)</span><br><span class="line">  values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=BIGINT&#125;, #&#123;goodsId,jdbcType=BIGINT&#125;,</span><br><span class="line">  #&#123;deliveyAddrId,jdbcType=BIGINT&#125;, #&#123;goodsName,jdbcType=VARCHAR&#125;, #&#123;goodsCount,jdbcType=INTEGER&#125;,</span><br><span class="line">  #&#123;goodsPrice,jdbcType=DECIMAL&#125;, #&#123;orderChannel,jdbcType=TINYINT&#125;, #&#123;status,jdbcType=TINYINT&#125;,</span><br><span class="line">  #&#123;createDate,jdbcType=TIMESTAMP&#125;, #&#123;payDate,jdbcType=TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  其中keyProperty=”id”，这个id就是传入对象中的某个属性值，比如说这里就是OrderInfo对象，执行成功之后就会自动将主键的值赋给对象中的id属性。然后原本作为参数的OrderInfo对象中的id就得到了更新，这时候我们再取这个对象的id字段就可以获取到主键的值了。</p><h2 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成订单</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> user 用户</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> goodsVo 商品</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 订单详情</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">createOrder</span><span class="params">(User user, GoodsVo goodsVo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里主要就是生成OrderInfo对象</span></span><br><span class="line">    OrderInfo orderInfo=<span class="keyword">new</span> OrderInfo();</span><br><span class="line">    orderInfo.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">    orderInfo.setDeliveyAddrId(<span class="number">0L</span>);</span><br><span class="line">    orderInfo.setGoodsCount(<span class="number">1</span>);</span><br><span class="line">    orderInfo.setGoodsId(goodsVo.getId());</span><br><span class="line">    orderInfo.setGoodsName(goodsVo.getGoodsName());</span><br><span class="line">    orderInfo.setGoodsPrice(goodsVo.getMiaoshaPrice());</span><br><span class="line">    <span class="keyword">byte</span> b=<span class="number">1</span>;</span><br><span class="line">    orderInfo.setOrderChannel(b);</span><br><span class="line">    b=<span class="number">0</span>;</span><br><span class="line">    orderInfo.setStatus(b);</span><br><span class="line">    orderInfo.setUserId(user.getId());</span><br><span class="line">    <span class="comment">//插入订单</span></span><br><span class="line">    orderInfoMapper.insertOrderAndReturnOrderId(orderInfo);</span><br><span class="line">    <span class="comment">//最关键的一步</span></span><br><span class="line">    <span class="comment">//获取到刚刚对象中的id字段就是主键的值了</span></span><br><span class="line">    Long orderId=orderInfo.getId();</span><br><span class="line">    MiaoshaOrder miaoshaOrder=<span class="keyword">new</span> MiaoshaOrder();</span><br><span class="line">    miaoshaOrder.setGoodsId(goodsVo.getId());</span><br><span class="line">    <span class="comment">//这里不是很严谨，意思是将MiaoShaOrder的id设置成和OrderInfo的id一样</span></span><br><span class="line">    miaoshaOrder.setId(orderId);</span><br><span class="line">    miaoshaOrder.setUserId(user.getId());</span><br><span class="line">    <span class="comment">//将miaosha_order表中的order_id字段设置为order_id表中的主键</span></span><br><span class="line">    miaoshaOrder.setOrderId(orderId);</span><br><span class="line">    miaoshaOrderMapper.insert(miaoshaOrder);</span><br><span class="line">    <span class="keyword">return</span> orderInfo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用背景&quot;&gt;&lt;a href=&quot;#使用背景&quot; class=&quot;headerlink&quot; title=&quot;使用背景&quot;&gt;&lt;/a&gt;使用背景&lt;/h2&gt;&lt;p&gt;  这几天在写秒杀项目，其中有一个需求是生成订单并返回订单号（主键）然后再生成秒杀订单将刚刚返回的订单号作为某个字段插入秒杀
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://francisqiang.github.io/categories/Mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="https://francisqiang.github.io/2019/05/03/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
    <id>https://francisqiang.github.io/2019/05/03/SpringBoot整合Redis/</id>
    <published>2019-05-03T15:00:57.000Z</published>
    <updated>2019-05-03T15:36:05.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>  最近在写一个秒杀的项目，是跟着慕课网的一个教程学习的。其中用到了redis进行session共享等等功能，现如今做到的步骤是使用redis将用户信息存入redis中，并且同时将用户的唯一token值存入cookie中（cookie的有效期和redis键值的有效期一样），当我们用户跳转到某个页面的时候，先查询cookie中是否存在键值为user的cookie，如果存在就获取到cookieValue（token值），然后通过这个token作为键去查询redis中查找对应token的用户信息。</p><p>  五一玩了几天，这几天没怎么进食新东西，今天趁着假期学校不熄灯，继续写一篇博客。</p><h2 id="引入依赖和配置变量"><a href="#引入依赖和配置变量" class="headerlink" title="引入依赖和配置变量"></a>引入依赖和配置变量</h2><p>  首先是pom.xml的依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后我们需要在application.yaml文件中写入redis的配置环境</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">host:</span> <span class="number">119.82</span><span class="number">.123</span><span class="number">.134</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h2 id="配置类的编写"><a href="#配置类的编写" class="headerlink" title="配置类的编写"></a>配置类的编写</h2><p>  编写RedisConfig配置类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里是引入刚刚yaml文件的配置变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;redis.host&#125;"</span>) String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;redis.port&#125;"</span>) <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//引入JedisConnection工厂，主要负责的是redis的连接</span></span><br><span class="line">  <span class="comment">//其中要设置地址和端口号</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisStandaloneConfiguration redisStandaloneConfiguration = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">    redisStandaloneConfiguration.setHostName(host);</span><br><span class="line">    redisStandaloneConfiguration.setPort(port);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory(redisStandaloneConfiguration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//配置redis模板，这个主要是进行一些redis的操作，就像jdbc的模板类一样</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">    RedisTemplate&lt;String,Object&gt; redisTemplate=<span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(factory);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关操作的编写"><a href="#相关操作的编写" class="headerlink" title="相关操作的编写"></a>相关操作的编写</h2><p>  关于redis的操作有很多，我也学的不是很好，这里面只写了最简单的set和get</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-18 23:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引入刚刚我们设置的redis模板</span></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这是redis单独印出来的string的模板——因为对于redis的操作大部分都是以String类型为基础的，这里没有用到</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 往redis中缓存数据,这里使用T模板更加灵活</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,T value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将value对象转换为json字符串</span></span><br><span class="line">    String jsonString=beanToString(value);</span><br><span class="line">    <span class="comment">//valueOperations用来set和get 它是由redisTemplate产生的</span></span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">//这里是将value对象转换为jsonString，因为项目中User是一个java对象</span></span><br><span class="line">    valueOperations.set(key,jsonString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 往redis中缓存数据并加上过期时间</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> time 过期时间，秒</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,T value,<span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个方法跟上面差不多，多加了一个设置过期时间，为的是与项目需求设置redis过期时间和cookie相等</span></span><br><span class="line">    String jsonString=beanToString(value);</span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    valueOperations.set(key, jsonString, time,TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从redis1中获取数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">    ValueOperations&lt;String,Object&gt; valueOperations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">//这里其实获取的是存在redis中对象的json字符串</span></span><br><span class="line">    Object object=valueOperations.get(key);</span><br><span class="line">    <span class="comment">//如果获取的不为空，那么就像这个json字符串转换为java对象</span></span><br><span class="line">    <span class="keyword">if</span> (object!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> stringToBean(object.toString(),clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取为空就return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将对象转换为json</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> json数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>  &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; clazz=value.getClass();</span><br><span class="line">    <span class="comment">//如果value是int类型或者Integer类型的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (clazz==<span class="keyword">int</span>.class||clazz==Integer.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz==String.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> (String)value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (clazz==<span class="keyword">long</span>.class||clazz==Long.class)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将jsonString转换为java的对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jsonString json字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz 类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> java对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String jsonString,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (jsonString==<span class="keyword">null</span>||jsonString.length()&lt;=<span class="number">0</span>||clazz==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)Integer.valueOf(jsonString);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)jsonString;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">      <span class="keyword">return</span>  (T)Long.valueOf(jsonString);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(jsonString), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码使用了阿里巴巴的fastJson作为json和java对象转换的工具，具体的pom依赖为:</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  对于这个SpringBoot整合Redis虽然是跟着视频写的，但是也踩了很多坑，因为版本更新非常快，我使用的SpringBoot和Redis都是最新版的，很多地方配置和代码书写都和视频中和网上绝大数整合教程不相同，我也是查看很多资料才写好这个整合的，对于英文文档不感冒是真的吃亏，所以英语能力一定要提高！！！</p><p>  还有就是在整合redis的时候，如果连接的是远程服务器中的redis的话一定要更改服务器上的redis.conf文件，最重要的两点就是将bind后面的地址修改或者直接注释掉bind那一行配置，还有就是将protected-mode更改为no，不然远程电脑连接不上。</p><p>  当然还有很多细节问题都需要注意，留下这篇文章作为踩坑记录，希望下面敲代码的日子会越来越顺利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;p&gt;  最近在写一个秒杀的项目，是跟着慕课网的一个教程学习的。其中用到了redis进行session共享等等功能，现如今做到的步
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://francisqiang.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>链表和递归</title>
    <link href="https://francisqiang.github.io/2019/04/28/%E9%93%BE%E8%A1%A8%E5%92%8C%E9%80%92%E5%BD%92/"/>
    <id>https://francisqiang.github.io/2019/04/28/链表和递归/</id>
    <published>2019-04-28T11:58:04.000Z</published>
    <updated>2019-04-28T13:18:33.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从一道leetcode题目开始"><a href="#从一道leetcode题目开始" class="headerlink" title="从一道leetcode题目开始"></a>从一道leetcode题目开始</h2><p>  题目描述：</p><p>  <img src="/2019/04/28/链表和递归/1.jpg" alt="avatar"></p><p>  看一下题目内容其实很简单就是删除一个链表中值为val的所有节点并且返回被删除完的链表。</p><p>  上篇文章讲了如何进行链表操作，这时候我们其实就可以通过老方法遍历整个链表，然后通过比较每个节点的值和val的值是否相等，相等则删除，不相等则保留。</p><p>  示例代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="comment">//这里的ListNode是leetcode给定的，里面包含next和val字段</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个虚拟头结点</span></span><br><span class="line">    ListNode virtualNode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//虚拟头结点的next节点是头结点</span></span><br><span class="line">    virtualNode.next=head;</span><br><span class="line">    <span class="comment">//将虚拟头结点赋值给currentNode当前节点</span></span><br><span class="line">    ListNode currentNode=virtualNode;</span><br><span class="line">    <span class="keyword">while</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//通过遍历当前节点来删除元素</span></span><br><span class="line">      <span class="keyword">if</span> (currentNode.next.val==val)&#123;</span><br><span class="line">        <span class="comment">//如果当前头结点的next元素的val值等于给定的val</span></span><br><span class="line">        <span class="comment">//则将当前节点的next元素直接指向next的next</span></span><br><span class="line">        <span class="comment">//那么原来next节点就直接被删除了</span></span><br><span class="line">        currentNode.next=currentNode.next.next;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不相等则跳到下一个节点，循环知道currentNode的next节点为null</span></span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回虚拟头结点的next，这里就是被删除元素的原来的头结点</span></span><br><span class="line">    <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="/2019/04/28/链表和递归/2.jpg" alt="avatar"></p><p>  在考虑递归如何写的时候我们先需要了解递归的宏观语意。</p><p>  一个递归函数其实本质就是函数调用，只不过它是自己调用自己。</p><p>  递归函数就是将原来的问题转化为更小的问题，知道最后求出最基本的解。</p><p>  最基本的解一般是我们通过if条件判断来终结的，如果不添加if判断给递归函数一个终结（最基本的解，例如求阶乘的时候等于1等于0的时候就是最基本的解），那么计算机就会无限产生递归调用，这会导致cpu的方法栈（写栈的时候提过，函数调用就是通过栈来实现的）爆满从而报错。</p><p>  <img src="/2019/04/28/链表和递归/3.jpg" alt="avatar"></p><p>  如何写一个递归函数，我们不要去考虑它的实现细节，最好是通过宏观语意来完成它。</p><p>  首先我们最能确定的就是它的最基本解，然后我们需要在原本函数里面再次调用该函数并修改参数（目的是将原问题转换为更小的问题）。上图的代码只是最简单的示例，当递归函数稍微再复杂点的时候，我们就需要获取到递归调用函数产生的值并对这个return的值来做些修改最后再返回给上一级调用这个级别的递归函数的函数。</p><h2 id="使用递归来实现链表的删除-上述题目"><a href="#使用递归来实现链表的删除-上述题目" class="headerlink" title="使用递归来实现链表的删除(上述题目)"></a>使用递归来实现链表的删除(上述题目)</h2><p>  首先完成一个递归函数我们需要先确定我们怎么把这个递归函数变为更小的函数。</p><p>  这里，我们将这个删除长度n的链表中元素的问题转换成先判断从第二个节点开始到最后节点中删除符合条件的节点，然后再转换为从第三个节点到最后节点删除符合条件的节点，直到我们的问题变成了删除最后一个空节点中符合条件的元素，当然这个时候空节点里面是不可能有的，所以我们这时候直接返回head，这样最基本解就出来了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  之后就是转换为更小的问题了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将问题转换为小问题</span></span><br><span class="line">ListNode result=removeElements(head.next,val);</span><br><span class="line"><span class="comment">//每次return都是return给上一级递归的结果</span></span><br><span class="line"><span class="comment">//如果当前节点的val值和给定val相等</span></span><br><span class="line"><span class="comment">//则直接return给上一级不包含该节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果不相等说明不需要删除</span></span><br><span class="line">    <span class="comment">//则需要将返回的结果前面加上头结点head在返回head</span></span><br><span class="line">    head.next=result;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  完整代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span>  ListNode <span class="title">removeElements</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"> <span class="comment">//首先考虑最基本的问题</span></span><br><span class="line"> <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ListNode resultNode=removeElements(head.next,val);</span><br><span class="line"> <span class="keyword">if</span> (head.val==val)&#123;</span><br><span class="line">   <span class="keyword">return</span> resultNode;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  head.next=resultNode;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其实整个问题可以这么理解，我需要删除一个链表中符合元素的节点，那么我把这个问题转化为小问题，将整个链表转换为从2开始到结尾的链表，然后S到从3开始到结尾的链表，最后到从结尾到结尾的节点（null），那么我就是从最后一个节点找需要删除的节点，假设如果最后一个节点是要删除的节点，那么这时候我们只需要将这个节点删除并且返回给上一级调用递归函数。这时候我们返回的null然后上一级接收到的result就是null，然后这个函数继续执行到if(head.val==val)，这时候就判断（第二级递归就是最后两个节点的链表）当前链表中的头结点的val是否满足，满足就跟刚刚一样“删除”该节点，不满足就将这个head的next设置为result，也就是将result的头结点暂时设置为当前head（将当前head设置为头结点并返回给上一级调用的函数），这样无限的返回，最后返回的就是原本链表中需要删除元素后的链表了。</p><p>  这个时候我们可以将递归写的更简单</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next=removeElements(head.next,val);</span><br><span class="line">    <span class="keyword">return</span> head.val==val?head.next:head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单实用递归实现链表的创建"><a href="#简单实用递归实现链表的创建" class="headerlink" title="简单实用递归实现链表的创建"></a>简单实用递归实现链表的创建</h2><p>  首先我们考虑如何通过递归实现该功能，创建一个链表，我们将问题缩小就是从创建节点开始。例如我们现在给定一个数组，然后我们通过这个数组来创建链表。首先这个数组的索引肯定是我们递归实现的条件，比如一个10个元素的数组，我们需要创建十个元素的链表，我们可以将问题变为创建从索引1开始到结束的链表，然后从索引2到结束，最后到从末尾到末尾（创建最后一个元素），所以这时候我们最基本条件就出来了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((index+<span class="number">1</span>)==array.length)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候我们就要来实现将问题转换为小问题<br>  其实很简单。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode result=createElement(array,index+<span class="number">1</span>);</span><br><span class="line">ListNode currentNode=<span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">currentNode.next=result;</span><br><span class="line"><span class="keyword">return</span> currentNode;</span><br></pre></td></tr></table></figure><p>  完整代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">createListNode</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((index+<span class="number">1</span>)==array.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    ListNode result=createListNode(array,index+<span class="number">1</span>);</span><br><span class="line">    ListNode currentNode=<span class="keyword">new</span> ListNode(array[index]);</span><br><span class="line">    currentNode.next=result;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>这个星期开始复习的信号系统，对于我这个学物联网的同学，不会什么高数，硬件是真的很烦躁，信号考完了，能不能过就靠老师助攻了。今天写篇博客来缓解一下一个星期没写代码的愧疚，这个递归还真的有点难理解，还需要勤敲勤练。加油吧！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从一道leetcode题目开始&quot;&gt;&lt;a href=&quot;#从一道leetcode题目开始&quot; class=&quot;headerlink&quot; title=&quot;从一道leetcode题目开始&quot;&gt;&lt;/a&gt;从一道leetcode题目开始&lt;/h2&gt;&lt;p&gt;  题目描述：&lt;/p&gt;
&lt;p&gt;  &lt;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现自定义验证注解</title>
    <link href="https://francisqiang.github.io/2019/04/20/Java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%B3%A8%E8%A7%A3/"/>
    <id>https://francisqiang.github.io/2019/04/20/Java实现自定义验证注解/</id>
    <published>2019-04-20T03:14:24.000Z</published>
    <updated>2019-04-20T06:42:46.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>  从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注释)。</p><p>  Annotation 其实就是代码里的特殊标记, <font color="red">这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。</font> 通过使用 Annotation, 程序员可以在<font color="red">不改变原有逻辑的情况下</font>, 在源文件中嵌入一些补充信息。</p><p>  Annotation 可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在 Annotation 的“name=value” 对中。</p><p>  例如<img src="/2019/04/20/Java实现自定义验证注解/1.jpg" alt="avatar"></p><p>  Annotation 能被用来为程序元素(类, 方法, 成员变量等) 设置元数据。</p><h2 id="基本的Annotation"><a href="#基本的Annotation" class="headerlink" title="基本的Annotation"></a>基本的Annotation</h2><p>  使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。 用于修饰它支持的程序元素。</p><p>  三个基本的 Annotation:</p><ul><li>@Override: 限定重写父类方法, 该注释只能用于方法</li><li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</li><li>@SuppressWarnings: 抑制编译器警告。</li></ul><h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>  定义新的 Annotation 类型使用 @interface 关键字</p><p>  Annotation 的成员变量在 Annotation 定义中以<font color="red">无参数方法</font>的形式来声明。 其方法名和返回值定义了该成员的名字和类型。</p><p>  可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</p><p>  没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation</p><p>  下面是java验证的NotNull注解的源码：</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/2.jpg" alt="avatar"></p><p>  其中所有的成员变量都是以无参方法定义的，default定义了某个成员变量的默认值，这是一个包含成员变量的 Annotation 所以我们也可以称为 元数据 Annotation。</p><p>  下面是Override注解的源码：</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/3.jpg" alt="avatar"></p><p>  这个注解没有成员变量，所以我们可以称为标记。而且可以注意的是这个注解的注解(元注解) @Retention是SOURCE类型的，编译器会直接丢弃这种策略的注释。也就是我们编译成class文件的时候是看不见@Override注解的，这个我们后面会讲。</p><h2 id="提取-Annotation-信息"><a href="#提取-Annotation-信息" class="headerlink" title="提取 Annotation 信息"></a>提取 Annotation 信息</h2><p>  JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注释的程序元素。</p><p>  <font color="red">当一个 Annotation 类型被定义为运行时 Annotation 后</font>, 该注释才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取。</p><p>  程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信息</p><p>  <img src="/2019/04/20/Java实现自定义验证注解/4.jpg" alt="avatar"></p><h2 id="JDK-的元-Annotation"><a href="#JDK-的元-Annotation" class="headerlink" title="JDK 的元 Annotation"></a>JDK 的元 Annotation</h2><p>  JDK 的元 Annotation 用于修饰其他 Annotation 定义(注解的注解)</p><ul><li><p>@Retention注解</p><p> 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值</p><ul><li>RetentionPolicy.CLASS: 编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注释. 这是默认值</li><li>RetentionPolicy.RUNTIME:编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释</li><li>RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释</li></ul></li><li><p>@Target注解</p><p> 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。可以参考本文第一张图片。</p></li><li><p>@Documented注解</p><p> 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档</p></li><li><p>@Inherited注解</p><p> 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注释</p></li></ul><h2 id="实现自定义验证注解-IsMobile"><a href="#实现自定义验证注解-IsMobile" class="headerlink" title="实现自定义验证注解@IsMobile"></a>实现自定义验证注解@IsMobile</h2><p>  参考于<a href="https://www.cnblogs.com/xz816111/p/9484902.html" target="_blank" rel="noopener">实现自定义验证注解</a></p><p>  @IsMobile是一个验证是否为11位手机号码的验证注解。</p><p>  API开发中经常会遇到一些对请求数据进行验证的情况，这时候如果使用注解就有两个好处，一是验证逻辑和业务逻辑分离，代码清晰，二是验证逻辑可以轻松复用，只需要在要验证的地方加上注解就可以。</p><p>  Java提供了一些基本的验证注解，比如@NotNull、@Size，但是更多情况下需要自定义验证逻辑，这时候就可以自己实现一个验证注解，方法很简单，仅需要两个东西：</p><ul><li>一个自定义的注解，并且指定验证器</li><li>一个验证器的实现</li></ul><p>这个时候我们就可以结合刚刚所学的知识就可以根据前面两部来实现验证注解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个表示该注解能对于类型注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span><br><span class="line"><span class="comment">//这个表示在运行时起作用</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//@Constraint是最关键的，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = IsMobileValidator.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IsMobile &#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "手机号码格式错误"</span>;</span><br><span class="line">  <span class="comment">//groups()和payload()也为@Constraint要求，可默认为空</span></span><br><span class="line">  Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">  Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>@Target</p><p>@Target指明这个注解要作用在什么地方，可以是对象、域、构造器等，因为要作用在域上，因此这里可以选择FIELD（这里我是直接所有的可以）。参考了NotNull注解</p></li><li><p>@Retention</p><p>指明生命周期，这里选择RUNTIME</p></li><li><p>@Constraint</p><p>实现验证器最重要的注解，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器。</p></li><li><p>message()</p><p>验证失败之后返回的消息。此方法为@Constraint要求</p></li><li><p>groups()和payload()</p><p>groups()和payload()也为@Constraint要求，可默认为空，详细用途可以查看@Constraint文档</p></li></ul><p>下面是验证器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-20 10:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里实现ConstraintValidator接口需要重写initialize和isValid方法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * required指这个数据是否必须</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    required=constraintAnnotation.required();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是必须的，那么就验证是否为手机号</span></span><br><span class="line">    <span class="keyword">if</span> (required)&#123;</span><br><span class="line">      <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果非必须，那么空值和手机号都可以通过验证</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(value))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其细节说明在注释中。</p><p>这样我们就实现了一个自定义验证注解，我们只需要在要验证的元素的前面加上@IsMobile就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; class=&quot;headerlink&quot; title=&quot;什么是注解&quot;&gt;&lt;/a&gt;什么是注解&lt;/h2&gt;&lt;p&gt;  从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation
      
    
    </summary>
    
      <category term="Java SE" scheme="https://francisqiang.github.io/categories/Java-SE/"/>
    
    
  </entry>
  
  <entry>
    <title>自己动手写链表</title>
    <link href="https://francisqiang.github.io/2019/04/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E9%93%BE%E8%A1%A8/"/>
    <id>https://francisqiang.github.io/2019/04/18/自己动手写链表/</id>
    <published>2019-04-17T16:06:35.000Z</published>
    <updated>2019-05-13T11:22:20.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>  链表是一种重要的数据结构，是一种数据的存储方式。链表由多个链表元素组成，每个元素称为节点。链表存储的物理结构可能是连续的，但也可能是无序的。但是链表之间的元素（节点）是有序的逻辑相连。</p><p>  <img src="/2019/04/18/自己动手写链表/1.jpg" alt="avatar"></p><p>  链表是一种很灵活的数据结构，它不需要指定内存的大小，删除节点不需要要像数组那样讲数据整体向前移动，只需要更改节点的指向。但是链表的结构也决定了它的许多缺点，比如说访问需要遍历元素，不能像数组那样依靠索引，还有就是链表每个元素存的是一个对象，这是一笔非常大的内存开销。</p><p>  链表从方向可以分为单向链表，双向链表。<br>  从结构上可以分为单链表，环形链表。</p><p>  <img src="/2019/04/18/自己动手写链表/2.jpg" alt="avatar"></p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-17 18:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点里面的元素内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e,Node next)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 虚拟链表头，让add更加有逻辑</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 链表大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead=<span class="keyword">new</span> Node();</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 链表添加头元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    add(<span class="number">0</span>,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定位置添加元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">      <span class="comment">//当index非法排除异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取要插入的元素的前面的元素</span></span><br><span class="line">      Node pre=dummyHead;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index ; i ++)&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        pre = pre.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//首先调用的是new Node(e,pre.next)</span></span><br><span class="line">      <span class="comment">//为的是让新节点的next节点指向它要添加位置的前面一个元素的原来的next节点</span></span><br><span class="line">      <span class="comment">//再进行赋值操作为了将添加节点前面的节点的next改为该元素</span></span><br><span class="line">      pre.next = <span class="keyword">new</span> Node(e,pre.next);</span><br><span class="line">      size ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在链表末尾加入元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    add(size,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某个索引的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Node currentNode=dummyHead.next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currentNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 更新后的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;=size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node currentNode=dummyHead.next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode.e=e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包含某个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    Node currentNode=dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((currentNode.e).equals(e))&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除某个索引元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;=size)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the index is not valid"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node currentNode=dummyHead;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//暂存被删除的节点</span></span><br><span class="line">      Node tempNode=currentNode.next;</span><br><span class="line">      <span class="comment">//将遍历到的节点（被删除节点前面一个）的next指向被删除节点的next节点</span></span><br><span class="line">      currentNode.next=tempNode.next;</span><br><span class="line">      <span class="comment">//将被删除的节点的next指向为null</span></span><br><span class="line">      tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> tempNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    Node currentNode=dummyHead.next;</span><br><span class="line">    <span class="comment">//遍历到节点的next为空</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//判断是否与需要判断的元素相等，如果相等则删除</span></span><br><span class="line">      <span class="keyword">if</span> (currentNode.e.equals(e))&#123;</span><br><span class="line">        Node tempNode=currentNode.next;</span><br><span class="line">        currentNode.next=tempNode.next;</span><br><span class="line">        tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        currentNode=currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用链表实现栈"><a href="#使用链表实现栈" class="headerlink" title="使用链表实现栈"></a>使用链表实现栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-17 20:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.linkedList=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">    linkedList.addFirst(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedList.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表和数组实现栈的比较"><a href="#链表和数组实现栈的比较" class="headerlink" title="链表和数组实现栈的比较"></a>链表和数组实现栈的比较</h2><p>  从复杂度来考虑，数组和链表实现的出栈入栈等操作的复杂度都相同，我们这里来测试一下。测试代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testStack</span><span class="params">(Stack&lt;Integer&gt; stack, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++) &#123;</span><br><span class="line">    stack.push(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++) &#123;</span><br><span class="line">    stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">  ArrayStack&lt;Integer&gt; arrayStack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time1 = testStack(arrayStack, opCount);</span><br><span class="line">  System.out.println(<span class="string">"ArrayStack, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  LinkedListStack&lt;Integer&gt; linkedListStack = <span class="keyword">new</span> LinkedListStack&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time2 = testStack(linkedListStack, opCount);</span><br><span class="line">  System.out.println(<span class="string">"LinkedListStack, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其实这个时间比较很复杂，因为LinkedListStack中包含更多的new操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果如下：<br>  <img src="/2019/04/18/自己动手写链表/3.jpg" alt="avatar"></p><p>  其实这个测试结果不会是稳定的，相比较之下，他们的快慢主要和环境有很大关系。</p><p>  当然，ArrayStack在添加元素时可能会执行扩容操作，这个时间复杂度是O(n)的，在LinkedListStack添加元素的时候虽然没有扩容的操作但是它会执行大量new对象操作，这也是非常占用资源的。总体来说，它们的增添和删除元素的时间复杂度都是O(1),所以可以说它们执行时间的差异并不是很大。</p><p>  <img src="/2019/04/18/自己动手写链表/5.jpg" alt="avatar"></p><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p>前面一篇文章专门讲到了Queue，队列就是（FIFO）的数据结构，我们主要去实现队列的入队（在队尾添加元素），出队（在队首删除元素）。回想我们前面实现的链表，在队首删除元素容易（时间复杂度是O1的），但是要在队尾添加元素就非常繁琐了，我们需要遍历整个链表，当数据量一大，我们的执行时间就会变得非常大，所以我们为了效率考虑，我们需要添加一个尾节点。</p><p>这时候我们怎么实现队列的操作呢？其实很简单，当我们入队的时候只需要将尾节点的next指向当前入队的新的节点，当然我们不得不把所有尾节点的next都置为null，为的是我们的逻辑和效率，浪费一个空间也不是大问题。</p><p>而当我们进行出队操作时，我们只需要将原来头结点变为原来头结点的next节点，返回出队节点的时候我们只需要将被删除的头结点的next节点变为null就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-18 19:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e=e;</span><br><span class="line">      <span class="keyword">this</span>.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node head,tail;</span><br><span class="line">  <span class="comment">//维持链表元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedListQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head=<span class="keyword">null</span>;</span><br><span class="line">    tail=<span class="keyword">null</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队只能从尾部</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果尾节点为空，那么就代表整个链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (tail==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//需要将元素赋值给头节点和尾节点</span></span><br><span class="line">      head=<span class="keyword">new</span> Node(e);</span><br><span class="line">      tail=head;</span><br><span class="line">      size++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不为空则需要新节点赋值给尾节点的next</span></span><br><span class="line">      tail.next=<span class="keyword">new</span> Node(e);</span><br><span class="line">      <span class="comment">//尾节点变换</span></span><br><span class="line">      tail=tail.next;</span><br><span class="line">      size++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队操作，只能从第一个出队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 头节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当链表为空时无法进行出队操作</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the linkedListQueue is empty!"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      Node tempNode=head;</span><br><span class="line">      <span class="comment">//将原来头结点的next变为当前头结点</span></span><br><span class="line">      head=head.next;</span><br><span class="line">      <span class="comment">//将要返回的“头结点”的next置为null</span></span><br><span class="line">      tempNode.next=<span class="keyword">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> tempNode.e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种实现对列的比较"><a href="#三种实现对列的比较" class="headerlink" title="三种实现对列的比较"></a>三种实现对列的比较</h2><p>前面我们使用了数组队列和循环队列，这时候我们加入我们刚刚实现的链表队列。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testQueue</span><span class="params">(Queue&lt;Integer&gt; q, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">      q.enqueue(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">      q.dequeue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    ArrayQueue&lt;Integer&gt; arrayQueue = <span class="keyword">new</span> ArrayQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time1 = testQueue(arrayQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"ArrayQueue, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    LoopQueue&lt;Integer&gt; loopQueue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time2 = testQueue(loopQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"LoopQueue, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">    LinkedListQueue&lt;Integer&gt; linkedListQueue = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">double</span> time3 = testQueue(linkedListQueue, opCount);</span><br><span class="line">    System.out.println(<span class="string">"LinkedListQueue, time: "</span> + time3 + <span class="string">" s"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们能得到结果：<br><img src="/2019/04/18/自己动手写链表/4.jpg" alt="avatar"></p><p>通过我们实践和分析，链表实现的队列也是O(1)的时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是链表&quot;&gt;&lt;a href=&quot;#什么是链表&quot; class=&quot;headerlink&quot; title=&quot;什么是链表&quot;&gt;&lt;/a&gt;什么是链表&lt;/h2&gt;&lt;p&gt;  链表是一种重要的数据结构，是一种数据的存储方式。链表由多个链表元素组成，每个元素称为节点。链表存储的物理结构可能
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>redis初识与安装</title>
    <link href="https://francisqiang.github.io/2019/04/16/redis%E5%88%9D%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://francisqiang.github.io/2019/04/16/redis初识与安装/</id>
    <published>2019-04-16T09:57:15.000Z</published>
    <updated>2019-04-16T10:51:22.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>  redis是一款基于C语言的开源的基于键值的存储服务系统它支持丰富的数据类型，如：string、list、set、zset(sorted set)、hash。</p><p>  <img src="/2019/04/16/redis初识与安装/1.jpg" alt="avatar"></p><p>  Redis的创始人是意大利人Salvatore Sanfilippo，他的网名是antirez，我们可以通过<a href="https://github.com/antirez" target="_blank" rel="noopener">https://github.com/antirez</a>来访问他的主页。</p><h2 id="Redis的优势"><a href="#Redis的优势" class="headerlink" title="Redis的优势"></a>Redis的优势</h2><p>  Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。以设置和获取一个256字节字符串为例，它的读取速度可高达110000次/s，写速度高达81000次/s。当然这是官方声明的，但是实际应用达到w级是肯定没问题的。</p><p>  因此redis的性能非常好，而且可以支持多种数据结构和持久化（RDB实现方式和AOF实现方式）。</p><p>  redis可以支持多种编程语言，在java，php，python都有实现。</p><p>  redis可谓短小精悍，redis5.0的代码也就只有5w行，除去实现分布式的代码，它仅仅只有23000行代码，但是redis提供的功能非常丰富，比如发布订阅，Lua脚本，事务等。</p><p>  redis提供主从复制，这为后面实现高并发和高可用打下了基础。</p><h2 id="Redis典型应用场景"><a href="#Redis典型应用场景" class="headerlink" title="Redis典型应用场景"></a>Redis典型应用场景</h2><ul><li>缓存系统</li><li>计数器</li><li>消息队列系统</li><li>排行榜</li><li>社交网络</li><li>实时系统</li></ul><h2 id="Redis的安装和简单运行"><a href="#Redis的安装和简单运行" class="headerlink" title="Redis的安装和简单运行"></a>Redis的安装和简单运行</h2><ul><li>下载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure><p>可能会遇到DNS解析的问题，这时候要去更改<br>/etc/resolv.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8 #google域名服务器</span><br><span class="line">nameserver 8.8.4.4 #google域名服务器</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure><ul><li>创建文件并编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-5.0.3</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>进入目录并运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server</span><br></pre></td></tr></table></figure><ul><li>修改问题和警告</li></ul><p>这时候启动redis的时候难免会出现警告，首先肯定是关于配置文件的问题，redis建议你启动的时候附带配置文件路径</p><p>如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server redis.conf</span><br></pre></td></tr></table></figure><p>我们需要将redis以守护进程的方式启动以避免关闭命令行是redis不退出，我们只需要修改redis.conf文件，设置daemonize为yes就行。</p><p>我们运行之后会发现我们无法再进行其他操作了，这时候我们需要启动的时候添加一个&amp;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server redis.conf &amp;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>你可能还会遇到以下问题</p><ul><li>WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</li></ul><p>大概意思是你的tcp设置为128对于这个环境来说太小了，redis建议你设置为511</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 511 &gt; /proc/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><ul><li>you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis.</li></ul><p>解决办法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure><ul><li>overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.</li></ul><p>按照提示将vm.overcommit_memory = 1加入到/etc/sysctl.conf中并执行命令sysctl vm.overcommit_memory=1就好了</p><ul><li><p>简单的设置值和取值</p><p>命令：</p><pre><code>set key valueget key</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;&gt;&lt;/a&gt;什么是Redis&lt;/h2&gt;&lt;p&gt;  redis是一款基于C语言的开源的基于键值的存储服务系统它支持丰富的数据类型，如：str
      
    
    </summary>
    
      <category term="Redis" scheme="https://francisqiang.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>自己动手写Queue</title>
    <link href="https://francisqiang.github.io/2019/04/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Queue/"/>
    <id>https://francisqiang.github.io/2019/04/15/自己动手写Queue/</id>
    <published>2019-04-15T14:53:07.000Z</published>
    <updated>2019-04-15T15:51:15.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p><img src="/2019/04/15/自己动手写Queue/1.jpg"></p><p>  队列是一种先进先出的数据结构（First In First Out）。结合生活实际，这里的队列就是从生活中的排队得来的。比如我们正在排队办理业务，后来的人只能从队列最后一个进入队伍（入队），当前面的的人办理完业务的时候他就离开了队伍（出队）。由此我们可以发现，要实现队列其实最重要的就是出队和入队的操作。所以我们就可以定义我们的Queue接口了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 19:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 出队的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 队列大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取队头元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 队头元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组队列"><a href="#数组队列" class="headerlink" title="数组队列"></a>数组队列</h2><p>  了解队列的特点，我们不难就想到了上次使用数组实现栈，其实队列和栈也差不多，只不过更改了出和入的操作罢了，这里我就不明细讲了，直接上代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 19:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array=<span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    array=<span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>  我们来对上面的数组队列做一个时间复杂度分析</p><p>  当我们进行入队操作的时候时间复杂度肯定为O(1),这是非常高效的。但是，我们要进行出队的时候就大不相同了，因为我们每次出队，当移除头元素的时候我们就需要将后面的元素挨个往前移动，因为我们这个底层就是依靠动态数组实现的，所以就是调用动态数组删除某个索引元素的方法，那么这个时间复杂度就是O(n),也就是说当我们进行出队操作的时候，队伍量越大我们消耗的时间就越大，这是低效且我们不愿意看到的。在数据结构中，很多时候我们都会使用空间和时间的互换，时间换取空间资源，空间资源换取时间资源，所以我们这里可以使用循环队列来提高出队效率。</p><p>  <img src="/2019/04/15/自己动手写Queue/2.jpg"></p><p>  循环队列是什么，其实就相当于将队列的头和尾相连接</p><p>  如图：<br>  <img src="/2019/04/15/自己动手写Queue/3.jpg"></p><p>  我们增加了一个头索引和尾索引来达到虚拟的连接（这个当然不是真实的）。当我们初始化这个队列的时候，头索引和尾索引都是0,当头索引和尾索引相等的时候这个队列为空，首先记着这个（很好理解，就是头和尾中间没有间隔那不就是空了么）。当我们进行入队操作的时候，将元素放入循环队列的尾索引处，放置完成后将尾索引+1（后移一个单位）。当进行出队的时候，我们将头元素删除，并将头索引+1（后移一个单位）。是不是很简单？当然不可能这么简单，因为这个队列是循环的，头和尾是相连的，这里我们就可以利用相连的特性来使用我们刚刚可能出队的时候浪费的空间资源，怎么做？其实就是更改一下我们头索引和为索引相加的位置，我们将他们++操作更改为front=(front+1)%capacity就行，这里的capacity是指整个队列的容量。</p><p>  还有一个注意点就是当我们整个队列满的时候我们是无法判断队列是否为空的，因为这时候头索引和尾索引也是相等的，这个时候我们就需要牺牲一个存储单元来解决冲突。</p><p>  下面就直接贴代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 19:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> E[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> front, tail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    array = (E[])<span class="keyword">new</span> Object[capacity+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//头尾索引置为0</span></span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入队</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当使用长度和容量相等的时候进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (((tail - front + <span class="keyword">this</span>.getCapacity()+<span class="number">1</span>) % (<span class="keyword">this</span>.getCapacity()+<span class="number">1</span>)) == <span class="keyword">this</span>.getCapacity()) &#123;</span><br><span class="line">      resize(<span class="keyword">this</span>.getCapacity() * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将元素e放入队尾</span></span><br><span class="line">    array[tail]=e;</span><br><span class="line">    tail++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出队</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当队列为空抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (front==tail)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The loopQueue has no element"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//将头元素置为null并且将头索引向后移动一个单位</span></span><br><span class="line">      E temp=array[front];</span><br><span class="line">      array[front]=<span class="keyword">null</span>;</span><br><span class="line">      front=(front+<span class="number">1</span>)%array.length;</span><br><span class="line">      <span class="comment">//当队列只使用了四分之一时将队列缩容</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.getSize()==<span class="keyword">this</span>.getCapacity()/<span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.getCapacity()/<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        resize(<span class="keyword">this</span>.getCapacity()/<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取当前队列的实际长度（使用头尾索引计算）</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tail - front + <span class="keyword">this</span>.getCapacity()+<span class="number">1</span>) % (<span class="keyword">this</span>.getCapacity()+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array[front];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail==front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    E[] newArray = (E[])<span class="keyword">new</span> Object[capacity+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> size = (tail - front + <span class="keyword">this</span>.getCapacity()+<span class="number">1</span>) % (<span class="keyword">this</span>.getCapacity()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      newArray[i]=array[(front + i) % size];</span><br><span class="line">    &#125;</span><br><span class="line">    array = newArray;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = size ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i != tail; i = (i + <span class="number">1</span>) % array.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i + <span class="number">1</span>) % array.length == tail) &#123;</span><br><span class="line">        stringBuilder.append(array[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stringBuilder.append(array[i]).append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(<span class="string">"] tail container:"</span>).append(<span class="keyword">this</span>.getCapacity());</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LoopQueue&lt;Integer&gt; loopQueue=<span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line">      loopQueue.enqueue(i);</span><br><span class="line">      System.out.println(loopQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    loopQueue.dequeue();</span><br><span class="line">    loopQueue.dequeue();</span><br><span class="line">    loopQueue.dequeue();</span><br><span class="line">    System.out.println(loopQueue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/15/自己动手写Queue/4.jpg"></p><h2 id="数组队列和循环队列的比较"><a href="#数组队列和循环队列的比较" class="headerlink" title="数组队列和循环队列的比较"></a>数组队列和循环队列的比较</h2><p>  大数比较</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testQueue</span><span class="params">(Queue&lt;Integer&gt; q, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">    q.enqueue(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; opCount ; i ++)&#123;</span><br><span class="line">    q.dequeue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> opCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">  ArrayQueue&lt;Integer&gt; arrayQueue = <span class="keyword">new</span> ArrayQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time1 = testQueue(arrayQueue, opCount);</span><br><span class="line">  System.out.println(<span class="string">"ArrayQueue, time: "</span> + time1 + <span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">  LoopQueue&lt;Integer&gt; loopQueue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">double</span> time2 = testQueue(loopQueue, opCount);</span><br><span class="line">  System.out.println(<span class="string">"LoopQueue, time: "</span> + time2 + <span class="string">" s"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果： <img src="/2019/04/15/自己动手写Queue/5.jpg"></p><p>  可以看出，当数据量大的时候，LoopQueue完胜。</p><p>  当我们把数据量变为10的时候我们不难发现，LoopQueue还是胜出,并且速度比数组队列快一个量级。</p><p>  <img src="/2019/04/15/自己动手写Queue/6.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;headerlink&quot; title=&quot;什么是队列&quot;&gt;&lt;/a&gt;什么是队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/04/15/自己动手写Queue/1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;  队列是一种先进先
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>自己动手写Stack</title>
    <link href="https://francisqiang.github.io/2019/04/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Stack/"/>
    <id>https://francisqiang.github.io/2019/04/15/自己动手写Stack/</id>
    <published>2019-04-15T06:31:14.000Z</published>
    <updated>2019-04-15T07:24:10.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p><img src="/2019/04/15/自己动手写Stack/1.jpg"></p><p>我觉得栈是一个很简单的概念，栈是一种后进先出的数据结构(Last In And First Out)，大家都见过装羽毛球的筒吧，你会发现当你装完羽毛球之后第一个拿出来的肯定是最后一个放进去的。其实这就是栈，它是一种线性结构，我们学习了数组其实就很容易理解栈了。</p><p>为什么呢？我们可以先想一下，对于栈这样的数据结构，我们能对它进行什么样的操作。其实也就是入栈（将一个羽毛球放进去），出栈（将一个羽毛球拿出来），判断栈是否为空（羽毛球筒里面有没有羽毛球），计算栈的大小（计算羽毛球筒里有多少个羽毛球），获取栈顶元素（获取羽毛球筒中最上面的羽毛球）。无非就是这几个操作。所以我们现在可以定义栈的接口了，如下面代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 12:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取栈的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断栈是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将元素放入栈</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出栈</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 出栈的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得栈最上面的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与数组的关系"><a href="#栈与数组的关系" class="headerlink" title="栈与数组的关系"></a>栈与数组的关系</h2><p>之前我的一篇博客介绍了如何实现动态数组，那个动态数组中我们实现了添加删除元素，计算数组大小，判断数组是否为空，获取数组的元素等方法。其实我们对栈的操作也就是对数组操作的子集，计算大小，判断为空我们可以直接使用数组的方法，添加元素对于栈来说就是在末尾添加元素，删除就是删除末尾元素，而获取元素就是获取最后一个元素。所以我们可以直接定义我们的ArrayStack类了（这个类是实现了刚刚的Stack接口的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过数组实现栈</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Array&lt;E&gt; array=<span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入栈操作</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    array.addLast(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出栈操作</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//上篇博客中没有getLast和getFirst方法</span></span><br><span class="line">  <span class="comment">//这里是我后面添加的，其实实现这个方法很简单，只要固定index就行了</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.getLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里重写toString方法为了后面测试能清楚显示</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="string">"Stack ["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getSize(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i != <span class="keyword">this</span>.getSize() - <span class="number">1</span>) &#123;</span><br><span class="line">        stringBuilder.append(array.get(i)).append(<span class="string">","</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        stringBuilder.append(array.get(i)).append(<span class="string">"]pop"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的一些应用场景"><a href="#栈的一些应用场景" class="headerlink" title="栈的一些应用场景"></a>栈的一些应用场景</h2><ul><li>word和一些IDE中的撤销功能</li></ul><p>将用户的操作放入栈中，当实行撤销操作的时候把用户最近的操作撤销。</p><ul><li><p>程序调用的系统栈</p><p>  <img src="/2019/04/15/自己动手写Stack/2.jpg"><br>比如我们调用A方法需要调用B方法，调用B方法的时候我们需要调用C方法，这时候我们C方法执行完了之后我们系统是不知道我们下面应该执行什么方法的，所以这时候栈就登场了，当我们执行A方法需要调用B方法的时候我们将这时候跳转执行前的方法和代码行数记录到栈中（这时候我们执行的是A方法的第二行代码调用了B<br>方法，所以我们把A2存入栈中）。同理，我们运行B方法的时候在第二行调用了C方法，我们就把B2存入栈中，之后我们C方法执行完之后系统就看栈中有没有还需要返回的方法，如果有就跳回指定的方法的代码行数，比如C方法执行完，我们栈中有B2，我们就跳回B2执行并且把栈顶元素删除，接着我们B方法执行完了，我们看栈中还有A2，我们就跳转到A2执行代码并且把A方法执行完查看栈中没有元素的时候我们就把整个A方法执行完成了。</p></li></ul><h2 id="关于栈的算法题目"><a href="#关于栈的算法题目" class="headerlink" title="关于栈的算法题目"></a>关于栈的算法题目</h2><p>在leetcode中有一道使用栈解决的简单题目</p><p>题目是这样的：</p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>思考一下题目，其实就可以和栈结合起来了，我们将给出的串进行遍历获取字符，我们判断字符是否为”{“,”[“,”(“,为这三个我们就把字符存入栈中，如果不是我们就把它和栈素比较是否匹配，如果不匹配那么直接返回false。大致思是这样，具体细节代码注释里有详细解释。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个stack</span></span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//声明栈顶元素</span></span><br><span class="line">    Character topCharacter;</span><br><span class="line">    <span class="comment">//循环遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">      <span class="comment">//获取某个字符</span></span><br><span class="line">      Character character=s.charAt(i);</span><br><span class="line">      <span class="comment">//如果该字符等于'&#123;'或'['或'('的时候存入栈中</span></span><br><span class="line">      <span class="keyword">if</span> (character==<span class="string">'&#123;'</span>||character==<span class="string">'['</span>||character==<span class="string">'('</span>)&#123;</span><br><span class="line">        stack.push(character);</span><br><span class="line">        <span class="comment">//直接进入下一层循环</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果不是，那么就是与之相对的了</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//首先判断栈是否为空</span></span><br><span class="line">        <span class="comment">//因为如果栈中没有元素且这个字符是右边的括号</span></span><br><span class="line">        <span class="comment">//那么这个字符串肯定不符合要求</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//获取栈顶元素</span></span><br><span class="line">          topCharacter=stack.pop();</span><br><span class="line">          <span class="comment">//判断栈顶元素是否和该元素匹配，如不匹配直接false</span></span><br><span class="line">          <span class="keyword">if</span> (character==<span class="string">'&#125;'</span>&amp;&amp;topCharacter!=<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (character==<span class="string">']'</span>&amp;&amp;topCharacter!=<span class="string">'['</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (character==<span class="string">')'</span>&amp;&amp;topCharacter!=<span class="string">'('</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果循环都是正确的，那么还要判断栈是否为空</span></span><br><span class="line">    <span class="comment">//因为"&#123;","["这种类型的情况都是错误的</span></span><br><span class="line">    <span class="comment">//但是前面没有考虑到，所以只要判断后面直接没有元素匹配</span></span><br><span class="line">    <span class="comment">//也就是栈是否不为空</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是栈&quot;&gt;&lt;a href=&quot;#什么是栈&quot; class=&quot;headerlink&quot; title=&quot;什么是栈&quot;&gt;&lt;/a&gt;什么是栈&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/04/15/自己动手写Stack/1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我觉得栈是一个很简单的概念，
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>自己动手做Array</title>
    <link href="https://francisqiang.github.io/2019/04/13/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9AArray/"/>
    <id>https://francisqiang.github.io/2019/04/13/自己动手做Array/</id>
    <published>2019-04-13T11:23:13.000Z</published>
    <updated>2019-04-13T12:31:29.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习数据结构"><a href="#学习数据结构" class="headerlink" title="学习数据结构"></a>学习数据结构</h2><p>  一直以来在学习java web开发，里面很少涉及到数据结构相关的编程，再加上大一没有怎么好好学这门课程，这段时间开始慢慢捡回来，不说如何去精通它，但希望自己从数据结构开始训练自己的基础代码能力，如今用框架用的已经连代码都不会写了。。。</p><h2 id="Array代码"><a href="#Array代码" class="headerlink" title="Array代码"></a>Array代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-13 16:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 泛型数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> E[] array;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 有参构造方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//强制类型转换</span></span><br><span class="line">    array = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    <span class="comment">//size指向0</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认构造函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认容量为8</span></span><br><span class="line">    array = (E[]) <span class="keyword">new</span> Object[<span class="number">8</span>];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数组容量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数组元素个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回数组是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在index处插入一个新的元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 插入的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断index是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index is not valid!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断此时size和capacity是否相等，如果相等需要动态增加数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="keyword">this</span>.getCapacity()) &#123;</span><br><span class="line">      resize(size * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将index索引处后面的元素向后移一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">      array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array[index] = e;</span><br><span class="line">    ++size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态扩容</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> capacity 新的容量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新构建一个数组，将原来数组赋值上去</span></span><br><span class="line">    E[] temp = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      temp[i] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在头部添加元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用add方法</span></span><br><span class="line">    add(<span class="number">0</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在尾部添加元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取索引位置的元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 该索引处的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改索引位置的元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 要设置的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    array[index] = e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组中是否包含元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 布尔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E originalElement : array) &#123;</span><br><span class="line">      <span class="keyword">if</span> (originalElement.equals(e)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找数组中第一次出现该元素的索引，不存在则返回-1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i].equals(e)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除指定索引元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E removeElement = array[index];</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index is not valid!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size; i++) &#123;</span><br><span class="line">      array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    --size;</span><br><span class="line">    <span class="comment">//压缩空间</span></span><br><span class="line">    <span class="comment">//这里使用懒压缩，如果在size为容量一半的时候就缩减容量为一半，则当这个数组再次增加一个元素的时候，它又会进行扩容。所以这里给予一定的空间</span></span><br><span class="line">    <span class="keyword">if</span> (size==array.length/<span class="number">4</span>&amp;&amp;array.length/<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">      resize(array.length/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeElement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除第一个</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除最后一个元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除第一个出现的某个元素</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 需要删除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    remove(find(e));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(String.format(<span class="string">"Array: size = %d , capacity = %d\n"</span>, size, array.length));</span><br><span class="line">    res.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      res.append(array[i]);</span><br><span class="line">      <span class="keyword">if</span> (i != size - <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="string">", "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(<span class="string">']'</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  在Java中，数组的容量一旦声明就无法改变，这里我们通过封装实现了动态数组，并且实现了动态数组的增删改查等简单的功能。其中最为重要的是数组怎样实现增加，删除和动态扩容。</p><ul><li><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>当数组某个位置需要增加元素的时候，我们先要将该索引处后面的元素<font color="red">从最后一个元素开始把各自向后移动一个位置</font>。<img src="/2019/04/13/自己动手做Array/1.jpg"></p></li><li><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>当数组某个位置需要删除元素的时候，我们先要将该索引处后面的元素<font color="red">从索引处后面的元素开始依次将各自向前移动一个位置</font>。即为后面元素覆盖前面元素。</p></li><li><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><p>当数组进行增加的时候，如果数组容量不够时我们需要进行扩容。当数组中进行删除的时候，如果数组使用量已经远小于数组容量的时候我们需要进行压缩，来减少无用的空间。</p><p>我们上文代码实现扩容的方式是在数组增加和删除的时候重新构建一个数组并且将原来的数组赋值到新的数组中去。为了避免一直重复的重构容量大小，我们将扩充的容量变为原来容量的两倍(如果每次容量只是加1或者很少那么每次add之后都要执行重构容量，但是重构容量需要重新遍历数组，时间复杂度为O(n),极大地浪费时间，所以我们这里通过牺牲空间来节省时间)。当每次删除元素的时候，我们将判断数组使用量是否等于容量的四分之一，当为true的时候我们我们将容量变为原来一半以节省空间(这里为什么是四分之一和一半呢？其实具体数值并不是固定的，但是我们这里实现的是懒压缩，如果这里的判断条件为一半，当使用量为容量一半的时候我们就之间将容量变为原来一半，那么之后再次进行add方法时我们又需要扩容，从而引起复杂震荡，这是得不偿失的)。</p><p>上文Array代码基本是模仿JDK的ArrayList来实现的，在ArrayList中也是通过上述方法来实现的。</p><p>如实现动态扩容:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//这里使用了移位，为了使运算更加快速</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里设置的是最小容量和最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习数据结构&quot;&gt;&lt;a href=&quot;#学习数据结构&quot; class=&quot;headerlink&quot; title=&quot;学习数据结构&quot;&gt;&lt;/a&gt;学习数据结构&lt;/h2&gt;&lt;p&gt;  一直以来在学习java web开发，里面很少涉及到数据结构相关的编程，再加上大一没有怎么好好学这门课程，
      
    
    </summary>
    
      <category term="数据结构" scheme="https://francisqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>从对称加密到数字证书</title>
    <link href="https://francisqiang.github.io/2019/04/11/%E4%BB%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%88%B0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    <id>https://francisqiang.github.io/2019/04/11/从对称加密到数字证书/</id>
    <published>2019-04-11T11:08:16.000Z</published>
    <updated>2019-04-11T12:54:33.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>​    简单来说，对称加密是解决通信之间的安全问题的最初手段。如下图中张大胖同学通过网络结识了远在美国的Bill同学，两个人聊得水深火热，但是有一天张大胖开始变得疑神疑鬼，因为他们聊得内容越来越隐私。张大胖就跟Bill说我总感觉不安全，我感觉有个人通过截取我们的消息在偷窥我们讲话，Bill听了也连忙说，对！我们的消息都是明文传输，中间被人截获就直接被读出来了。那怎么办？加密呗！</p><p>​    说着，张大胖就提议，不是有个对称加密嘛？我们用那个进行对消息的加密，我们首先沟通好我们的私钥，保持一致性，我给你发消息的时候我通过私钥加密，你收到消息的时候你再通过私钥进行解密，这样即使被中间人截获他也看不懂啦！Bill连忙夸赞张大胖同学说：”dei dei dei这个办法好呀！”。</p><p>​    就如下图中一样，张大胖和Bill就通过对称加密来进行通信，看似安全了，但是真的安全了吗？</p><p><img src="/2019/04/11/从对称加密到数字证书/1.jpg"></p><p>​    可是，当张大胖和Bill开始协商秘钥的时候，问题又出现了！Bill说既然网络是不安全的，万一现在正好有人再偷窥我们协商秘钥，我们协商好之后通过网络传输，这个秘钥就是明文传输的呀！那么，我们的秘钥不就暴露了吗？张大胖听了Bill的一席话，幡然醒悟。“对呀！这个可怎么办？而且当两个人进行通信的时候就要一个秘钥，一个人如果需要同一百个，一万个好友进行通信的时候那么就要有一百个，一万个秘钥，这！这哪能记得住呀？“。Bill这时候说道：“不行不行！这个通信方式也不安全！我们得再想一个。”</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>​    张大胖和Bill得知这种办法也不行的时候就一直提心吊胆地通信着，都不敢涉及隐私了，这个偷窥者听得也没劲了。直到后来，Bill听说了一种叫RSA非对称加密的算法，他一下子来了灵感。</p><p><img src="/2019/04/11/从对称加密到数字证书/2.jpg"></p><p>&nbsp;    RSA算法意思是一个人同时拥有公钥和私钥，这个公钥是公开的，别人都可以知道，但是这个私钥是自己保存的，千万不能让别人知道。而且，当文本经过某个人的公钥加密的时候，只有通过这个人的私钥才能进行解密，所以当Bill向张大胖同学发消息的时候，他就使用张大胖的公钥对消息进行加密，当张大胖收到消息的时候他就使用自己的私钥进行解密。流程如下图：</p><p> <img src="/2019/04/11/从对称加密到数字证书/3.jpg">    </p><h2 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密+对称加密"></a>非对称加密+对称加密</h2><p>​    这样，非对称加密就一下子解决了对称加密的两个缺点（秘钥泛滥和秘钥被网络截取），但是它也带来了一个很致命的缺点，那就是——效率问题，对同样大小的文本对称加密的速度是非对称加密速度的几百倍（我曾经拿RSA算法对一个50kb的文件进行加密，电脑直接叫唤着我不行了，我不行了）。大家知道通信是很讲究速度效率的，这个非对称加密虽然安全但是速度太慢了，这叫人怎么能忍呢？</p><p>​    这么愚蠢的问题当然不会困惑张大胖和Bill很久，他们想出来了一个二者结合的方法！当张大胖和Bill要进行通信的时候，他们就先使用非对称加密沟通好对称加密的秘钥（也就是在这个非对称加密的通道里传输秘钥）这样秘钥就不会被截获了，就算截获也是密文，偷窥者没办法呀。然后双方就使用刚刚非对称加密通信产生的对称加密的秘钥来进行加密解密，这样一来安全问题和效率问题就得到了很好的解决啦！</p><h2 id="中间人劫持"><a href="#中间人劫持" class="headerlink" title="中间人劫持"></a>中间人劫持</h2><p>​    现在张大胖和Bill就很欢快地聊起来了，但是问题就这么简单地结束了吗？当然没有！张大胖把自己和Bill的聊天情况告诉了他女朋友，女朋友一听就发现了一个问题，她说：“Bill给别人，给你发公钥的时候也是通过网络传输的呀！那么这时候有个中间人把这个公钥给劫持了，再把自己的公钥换掉Bill的公钥发给你，你收到的就是中间人的公钥呀！那么你通过中间人的公钥进行消息加密发给Bill，这时候中间人再次劫持消息，通过他的私钥进行解密就直接能获得消息的内容了，然后他再把解密完的消息或者自己编造一个假消息然后使用Bill的公钥进行加密发给Bill，这样就神不知鬼不觉的解密了你们的消息并且还能冒充身份和造假消息！！！张大胖一听，后背就开始发凉，难道自己和Bill发的生活照都被中间人截取了吗？？？这可怎么防呀？</p><p><img src="/2019/04/11/从对称加密到数字证书/4.jpg"></p><h2 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h2><p>​    但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？这真的是一个很头痛的问题呀！可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。这让张大胖想到了一个现实中的问题——签名。像我们签合同，协议都是通过签名来确定这个本人，那么我们可以把它移植到网络上！怎么移植呢？</p><p>​    RSA算法给我们提供了一个很好的办法，因为它不仅可以通过公钥加密私钥解密，它还可以私钥加密公钥解密。这样我们发送公钥的时候可以通过某个消息摘要算法，首先这个消息摘要算法必须有两个特性——不可逆性和可变性。不可逆好理解，就是无法通过密文解出明文，这个可变性就是指当消息发生一点点变化的时候，它形成的密文就会发生翻天覆地的变化，这样就可以防止别人修改。这时候我们通过消息摘要算法来对公钥进行加密形成摘要，然后我们通过自己的私钥对这个摘要进行加密形成摘要密文，这个摘要密文就是我们的数字签名。这样，我们发公钥的时候就发送原本的消息附加上我们的数字签名，这样对方收到这个消息的时候就使用收到的公钥对这个数字签名进行解密（得到其实就是公钥的摘要），然后再通过同样的消息摘要算法对收到的公钥进行加密，如果对公要的加密密文和数字签名解密出来的东西是一样的，那么久说明这个公钥没有被修改过！</p><p>​    可能有点难理解，我们这么想，如果中间人对这个公钥进行了修改或者替换。比如张大胖和Bill在通信，张大胖把自己的公钥和数字签名发给了Bill，中间人截获这个消息，假如他替换了公钥（替换成自己的了），那么他也不能改动数字签名，使数字签名通过这个公钥来形成中间人公钥的信息摘要，因为这个数字签名就是密文，他不知道如何下手，所以如果只改公钥，那么这样肯定会被Bill发现。但是，作为一个狠角色，要干就要干狠一点，不能改公钥，不能改数字签名，老子干脆就把它全改了，全用自己的！</p><p>​    所以问题又来了，这时候我们就要请来大人物了——认证中心（CA），我们需要有一个具有公信力的中间商，当我们把自己的公钥和个人信息形成消息摘要的时候，我们使用CA的私钥进行加密形成数字签名。</p><p><img src="/2019/04/11/从对称加密到数字证书/5.jpg"></p><p>​    然后我们发送消息的时候我们把我们的公钥和个人信息再连带着使用CA的私钥加密过的数字签名发送给对方，这些东西合起来就有另一个名字——数字证书。</p><p><img src="/2019/04/11/从对称加密到数字证书/6.jpg"></p><p>​    如图所示，当Bill吧这个数字证书发给张大胖的时候，我就用同样的消息摘要算法对原本消息进行摘要，然后使用CA的公钥对数字签名进行解密获取摘要，然后对比我前后获取的摘要，如果一致那么就说明这个东西没有被篡改。你想想，如果中间人截获了这个证书，他把证书全改成自己的，但是张大胖使用的是CA的公钥解密摘要，然而中间人不知道CA的私钥，那么他这么做就露馅了！这时候张大胖就安全地拿到了Bill的公钥，后续的加密工作就可以顺利地进行了。当然，网络本就是不安全的，想必大家也想到了，当Bill获取CA的公钥的时候，这个中间人也可以发起攻击，直接篡改CA公钥，那么这样安全问题就无限的循环下去无法解决了！当然这些CA本身也有证书来证明自己的身份，并且CA的信用是像树一样分级的，高层的CA给底层的CA做信用背书，而操作系统／浏览器中会内置一些顶层的CA的证书，相当于你自动信任了他们。这些顶层的CA证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>​    这样，https也非常好理解了，看图就知道了。</p><p><img src="/2019/04/11/从对称加密到数字证书/7.jpg"></p><p>​    本博文参考于刘欣的《码农翻身》，特别感谢此书，也推荐大家阅读。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    好久没写博客了，因为这学期以来就有一大堆事情要解决处理，有时候学习完，就一直没时间写总结。总感觉自己像头狮子一样，想一口气吃成大胖子，什么都要学，什么都学不精，学了之后不总结，学了就忘。当然有好奇心也是好事，但是我可不想无法精通一门东西，昨天看这本《码农翻身》，书中提到了不要让碎片化信息侵蚀你深度思考的能力，确实如此，我们现在学习知识都是以一种常识的心态去学，我们只是记住了这个常识，死记硬背，并没有深度思考其中的原因和逻辑，所以我们无法精通一门技术，我想，这大概是我现阶段学习最大的问题吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h2&gt;&lt;p&gt;​    简单来说，对称加密是解决通信之间的安全问题的最初手段。如下图中张大胖同学通过网络结识了远在美国的Bill同学，两个
      
    
    </summary>
    
      <category term="安全" scheme="https://francisqiang.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
