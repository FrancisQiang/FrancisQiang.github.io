<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Francis的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://francisqiang.github.io/"/>
  <updated>2019-08-09T14:49:41.839Z</updated>
  <id>https://francisqiang.github.io/</id>
  
  <author>
    <name>Francis Qiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程学习——管程</title>
    <link href="https://francisqiang.github.io/2019/08/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%A1%E7%A8%8B/"/>
    <id>https://francisqiang.github.io/2019/08/09/Java并发编程学习——管程/</id>
    <published>2019-08-09T14:04:37.000Z</published>
    <updated>2019-08-09T14:49:41.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h2><p>  管程：<strong>管理共享变量和操作共享变量的过程</strong>。为了解决信号量配对的复杂性以及分散在程序中降低了程序的可读性，管程通过一种数据结构对共享变量和对共享变量的操作进行了封装。</p><p>  管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程更容易使用，所以 Java 选择了管程。</p><p>  在Java1.5之前提供的是synchronized，wait，notify和notifyAll，这是java管程实现的一部分。</p><h2 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h2><p>  在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。</p><h3 id="MESA模型实现互斥"><a href="#MESA模型实现互斥" class="headerlink" title="MESA模型实现互斥"></a>MESA模型实现互斥</h3><p>  <img src="/2019/08/09/Java并发编程学习——管程/1.jpg" alt="互斥"></p><p>  这里的共享变量被封装起来了，其中对于共享变量queue的操作只能通过enq和deq，而这两个方法保证互斥性，只允许一个线程进入管程。</p><h3 id="MESA墨香实现同步"><a href="#MESA墨香实现同步" class="headerlink" title="MESA墨香实现同步"></a>MESA墨香实现同步</h3><p>  <img src="/2019/08/09/Java并发编程学习——管程/2.jpg" alt="同步"></p><p>  对于同步则通过增加<strong>条件变量和相应的等待队列</strong>。</p><p>  如果当条件变量不满足的时候则进入相应的等待队列，因为某个操作而导致条件允许的时候则唤醒相应的等待队列中的线程，并且再次获取锁来执行。因为要再次获取锁，所以这个条件只能是曾经满足过，所以当阻塞线程被唤醒再次获取锁需要执行的时候，有可能这个时候的条件又不允许了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于入队操作，如果队列已满，就需要等待直到队列不满，所以这里用了notFull.await();。</p><p>对于出队操作，如果队列为空，就需要等待直到队列不空，所以就用了notEmpty.await();。</p><p>如果入队成功，那么队列就不空了，就需要通知条件变量：队列不空notEmpty对应的等待队列。</p><p>如果出队成功，那就队列就不满了，就需要通知条件变量：队列不满notFull对应的等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock =</span><br><span class="line">    <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 条件变量：队列不满  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notFull =</span><br><span class="line">    lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量：队列不空  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty =</span><br><span class="line">    lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enq</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已满)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不满</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 省略入队操作...</span></span><br><span class="line">      <span class="comment">// 入队后, 通知可出队</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deq</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已空)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略出队操作...</span></span><br><span class="line">      <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里的await和signal就类似于wait和notify。</p><p>  对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 wait()。这个是 MESA 管程特有的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">  wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，如何通知相关线程。管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？</p><ol><li><p>Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。</p></li><li><p>Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。</p></li><li><p>MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。</p></li></ol><h2 id="notify-何时可以使用"><a href="#notify-何时可以使用" class="headerlink" title="notify() 何时可以使用"></a>notify() 何时可以使用</h2><p>  满足以下三个条件：</p><ol><li><p>所有等待线程拥有相同的等待条件</p></li><li><p>所有等待线程被唤醒之后，执行相同的操作。</p></li><li><p>只需要唤醒一个线程。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是管程&quot;&gt;&lt;a href=&quot;#什么是管程&quot; class=&quot;headerlink&quot; title=&quot;什么是管程&quot;&gt;&lt;/a&gt;什么是管程&lt;/h2&gt;&lt;p&gt;  管程：&lt;strong&gt;管理共享变量和操作共享变量的过程&lt;/strong&gt;。为了解决信号量配对的复杂性以及分散在程
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——安全性，活跃性以及性能问题</title>
    <link href="https://francisqiang.github.io/2019/08/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/08/09/Java并发编程学习——安全性，活跃性以及性能问题/</id>
    <published>2019-08-09T06:11:27.000Z</published>
    <updated>2019-08-09T06:44:09.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>  在并发编程中需要考虑三个基本问题——安全性，活跃性以及性能。</p><p>  所谓安全性就是指程序能否按照我们预期的执行。就比如线程安全这个概念，所谓线程安全和不安全无非就是指程序能否保证它的正确性，而这个正确性就是我们让程序按照我们所期望地执行。</p><p>  而这种情况下只有<strong>存在共享数据并且该数据会发生变化</strong>的时候需要考虑安全性问题，通俗来讲就是是否存在多个线程对这个资源进行读写操作(至少有一个线程进行写操作)。</p><p>  当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做<strong>数据竞争</strong>（Data Race）。</p><p>  就比如以下的add10k方法，当多个线程调用的时候就会发生数据竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  那是不是在访问数据的地方，我们加个锁保护一下就能解决所有的并发问题了呢？显然没有这么简单。例如，对于上面示例，我们稍作修改，增加两个被 synchronized 修饰的 get() 和 set() 方法， add10K() 方法里面通过 get() 和 set() 方法来访问 value 变量，修改后的代码如下所示。对于修改后的代码，所有访问共享变量 value 的地方，我们都增加了互斥锁，此时是不存在数据竞争的。但很显然修改后的 add10K() 方法并不是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count；</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    count = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      set(get()+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来解读一下，这时候同时存在两个线程访问add10k方法然后同时进入while循环，然后同时调用get方法，但是因为get方法是synchronized修饰的所以同时只有一个线程能访问，比如这个时候线程A获得了优先权进行调用，读取到count为0，然后这个时候get方法执行完线程A释放锁，线程B获得了锁进入get方法也读取到count为0，然后可能这个时候线程B有执行了加一操作并且获得了set方法的锁进入set方法将count设置为1，这个时候可能线程A也执行了+1操作并且获得了线程B刚刚释放的锁来进行set操作，这个时候count又会被设置为1，其实本该结果为2(因为进行了两次加一操)，但是因为线程执行顺序的问题而导致程序不是按照我们期望的执行，所以这个是咸亨不安全的。</p><p>  这种问题，有个官方的称呼，叫<strong>竞态条件</strong>（Race Condition）。所谓竞态条件，指的是程序的执行结果依赖线程执行的顺序。例如上面的例子，如果两个线程完全同时执行，那么结果是 1；如果两个线程是前后执行，那么结果就是 2。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大 Bug。</p><p>  下面再结合一个例子来说明下竞态条件，就是前面文章中提到的转账操作。转账操作里面有个判断条件——转出金额不能大于账户余额，但在并发环境里面，如果不加控制，当多个线程同时对一个账号执行转出操作时，就有可能出现超额转出问题。假设账户 A 有余额 200，线程 1 和线程 2 都要从账户 A 转出 150，在下面的代码里，有可能线程 1 和线程 2 同时执行到第 6 行，这样线程 1 和线程 2 都会发现转出金额 150 小于账户余额 200，于是就会发生超额转出的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用<strong>互斥</strong>这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：<strong>锁</strong>。</p><h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><p>  所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是<strong>活锁</strong>和<strong>饥饿</strong>。</p><p>  但有时线程虽然<strong>没有发生阻塞</strong>，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。</p><p>  可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。</p><p>  解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p><p>  那“饥饿”该怎么去理解呢？所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。“不患寡，而患不均”，如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。</p><p>  解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p><p>  那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>  使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。</p><p>  所以我们要尽量减少串行，那串行对性能的影响是怎么样的呢？假设串行百分比是 5%，我们用多核多线程相比单核单线程能提速多少呢？</p><p>  有个阿姆达尔（Amdahl）定律，代表了处理器并行运算之后效率提升的能力，它正好可以解决这个问题，具体公式如下：</p><p>  <img src="/2019/08/09/Java并发编程学习——安全性，活跃性以及性能问题/2.jpg" alt="Amdahl"></p><p>  公式里的 n 可以理解为 CPU 的核数，p 可以理解为并行百分比，那（1-p）就是串行百分比了，也就是我们假设的 5%。我们再假设 CPU 的核数（也就是 n）无穷大，那加速比 S 的极限就是 20。也就是说，如果我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。</p><p>  所以使用锁的时候一定要关注对性能的影响。 那怎么才能避免锁带来的性能问题呢？这个问题很复杂，Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。</p><p>  不过从方案层面，我们可以这样来解决这个问题。</p><p>  第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……</p><p>  第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</p><p>  性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。</p><ol><li>吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。</li><li>延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。</li><li>并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  总之并发编程从微观上来讲就是要关注原子性，可见性，顺序性的问题。从宏观上来讲就要关注安全性，活跃性，性能的问题。而微观上三个问题的目的都是为了解决安全性的问题，但是解决问题的同时还可能产生新的问题，这就是活跃性的问题，而如何利用三个微观问题去解决安全问题随之带来了性能问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安全性问题&quot;&gt;&lt;a href=&quot;#安全性问题&quot; class=&quot;headerlink&quot; title=&quot;安全性问题&quot;&gt;&lt;/a&gt;安全性问题&lt;/h2&gt;&lt;p&gt;  在并发编程中需要考虑三个基本问题——安全性，活跃性以及性能。&lt;/p&gt;
&lt;p&gt;  所谓安全性就是指程序能否按照我们
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——使用等待通知机制优化循环等待</title>
    <link href="https://francisqiang.github.io/2019/08/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/"/>
    <id>https://francisqiang.github.io/2019/08/09/Java并发编程学习——使用等待通知机制优化循环等待/</id>
    <published>2019-08-09T04:56:22.000Z</published>
    <updated>2019-08-09T05:23:03.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是等待通知机制"><a href="#什么是等待通知机制" class="headerlink" title="什么是等待通知机制"></a>什么是等待通知机制</h2><p>  在前面提到的破坏占用且等待条件的时候使用了死循环来获取资源，当apply()操作历时非常长或者并发量很大的时候，这个死循环是非常占cpu资源的，所以这种场景下可以使用等待通知机制来优化循环等待。</p><p>  什么是等待通知机制？所谓等待就是当线程获取锁进入临界区想要获取相应资源而条件不满足获取不到的时候，线程自己进入阻塞状态(等待)并且释放锁，等到线程需要的资源都有的时候则<strong>通知</strong>线程它需要的资源<strong>曾经</strong>满足过。</p><p>  为什么说曾经满足过，因为当线程被通知唤醒的时候还需要重新获得互斥锁，在这个阶段是有时差的，所以这个时候可能会出现一些情况导致刚刚满足的资源又被其它线程拿走了。</p><h2 id="完美的就医流程"><a href="#完美的就医流程" class="headerlink" title="完美的就医流程"></a>完美的就医流程</h2><p>  就医流程就可以比作这个等待通知机制。</p><ol><li>患者需要挂号，等待叫号</li><li>等到叫到自己的号的时候就可以找医生就诊了。(获取互斥锁)</li><li>就诊过程医生可能要叫患者去做一些检查。同时叫下一个患者(因为某种条件，资源不符合线程释放锁进入阻塞状态)</li><li>患者做完检查，拿着报告重新分诊(资源满足要重新获得互斥锁)</li><li>医生再次叫到自己号的时候，患者再去找医生就诊(条件资源满足重新获得锁)</li></ol><h2 id="使用synchronized实现等待-通知机制"><a href="#使用synchronized实现等待-通知机制" class="headerlink" title="使用synchronized实现等待-通知机制"></a>使用synchronized实现等待-通知机制</h2><p>  在Java语言中可以通过synchronized结合wait(),notify(),notifyAll()这三个方法来实现等待-通知机制。</p><p>  在下面这个图里，左边有一个等待队列，同一时刻，只允许一个线程进入 synchronized 保护的临界区（这个临界区可以看作大夫的诊室），当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列里等待（相当于患者分诊等待）。<strong>这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列</strong>。</p><p>  <img src="/2019/08/09/Java并发编程学习——使用等待通知机制优化循环等待/1.jpg" alt="wait原理"></p><p>  在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。如上图所示，当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。 线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p><p>  上面我们一直强调 wait()、notify()、notifyAll() 方法操作的等待队列是互斥锁的等待队列，所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait()、this.notify()、this.notifyAll()；如果 synchronized 锁定的是 target，那么对应的一定是 target.wait()、target.notify()、target.notifyAll() 。而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als;</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 经典写法</span></span><br><span class="line">    <span class="comment">// 不满足则等待(释放锁并阻塞自己)</span></span><br><span class="line">    <span class="keyword">while</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    als.add(from);</span><br><span class="line">    als.add(to);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尽量使用notifyAll"><a href="#尽量使用notifyAll" class="headerlink" title="尽量使用notifyAll"></a>尽量使用notifyAll</h2><p>  notify会随机通知等待队列中的某一个线程，而notifyAll会通知等待队列中的所有线程。</p><p>  所以使用notify的风险就是有些线程可能永远不会被唤醒，所以除非经过深思熟虑，不然尽量避免使用notify。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是等待通知机制&quot;&gt;&lt;a href=&quot;#什么是等待通知机制&quot; class=&quot;headerlink&quot; title=&quot;什么是等待通知机制&quot;&gt;&lt;/a&gt;什么是等待通知机制&lt;/h2&gt;&lt;p&gt;  在前面提到的破坏占用且等待条件的时候使用了死循环来获取资源，当apply()操作
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——如何解决死锁</title>
    <link href="https://francisqiang.github.io/2019/08/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81/"/>
    <id>https://francisqiang.github.io/2019/08/08/Java并发编程学习——如何解决死锁/</id>
    <published>2019-08-08T11:34:25.000Z</published>
    <updated>2019-08-08T14:11:14.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h2><p>  前面我们使用Account.class来作为转账的锁，即当发生一个转账操作的时候，所有的用户操作都会被阻塞，这效率简直太低下。</p><p>  现实世界里，账户转账操作是支持并发的，而且绝对是真正的并行，银行所有的窗口都可以做转账操作。只要我们能仿照现实世界做转账操作，串行的问题就解决了。</p><p>  我们试想在古代，没有信息化，账户的存在形式真的就是一个账本，而且每个账户都有一个账本，这些账本都统一存放在文件架上。银行柜员在给我们做转账时，要去文件架上把转出账本和转入账本都拿到手，然后做转账。这个柜员在拿账本的时候可能遇到以下三种情况：</p><p>  文件架上恰好有转出账本和转入账本，那就同时拿走；<br>  如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；<br>  转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。</p><p>  而编程世界解决这个问题就是使用两把锁去控制两个转账账户。</p><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/1.jpg" alt="两个锁"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候仿佛问题已经解决了，但是随之而来又是一个新的问题。</p><h2 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h2><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/2.jpg" alt="两个锁"></p><p>  试想一下，如果这个时候A账户要转账给B账户，B账户要转账给A账户，然后A转账给B的时候申请到了A的锁，同时B转账给A的时候申请到了B的锁，这个时候线程1申请B的锁不成功(因为B的锁被线程2给拿走了)，线程2申请A的锁不成功(因为A的锁被线程1给拿走了)，这个时候两个线程就会因为获得不到锁而发生阻塞(Java中只要synchronized不成功，线程便会进入阻塞状态)，两个线程互相等待锁，却都不释放锁，那么这个时候就产生了死锁。</p><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/3.jpg" alt="两个锁"></p><h2 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h2><p>  首先，当死锁产生的时候一般只有杀死进程或者结束应用来解决，所以解决死锁的代价是很大的。对于死锁，最好的办法就是规避死锁。</p><p>  coffman于1971年提出了死锁产生的四个必要条件</p><ol><li>互斥条件：一个资源一次只能有一个线程(或进程)占用</li><li>部分分配条件(占有且等待)：即一个线程(或进程)不能一次性获得所有需要的资源</li><li>不可抢占条件：一个资源只能由它占有的线程(或进程)来释放，不能通被其他线程(或进程)抢占使用。</li><li><p>循环等待条件：每个线程(或进程)占有若干资源，并且又在等待下一个线程(或进程)所拥有的资源。</p><p>反过来讲，我们只需要破坏一个条件就可以避免死锁的产生。对于第一个互斥条件来说，我们无法破坏，因为我们就是需要使用锁的互斥条件来达到并发的目的。剩下三个我们都能破话。</p></li></ol><ol><li>部分分配条件(占有且等待)：我们只需要同时将资源一次性分配给线程</li><li>不可抢占条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>循环等待条件：按序申请资源，即 使资源是有线性顺序的。</li></ol><h2 id="破坏部分分配条件-占有且等待"><a href="#破坏部分分配条件-占有且等待" class="headerlink" title="破坏部分分配条件(占有且等待)"></a>破坏部分分配条件(占有且等待)</h2><p>  一次性申请所有资源，对于转账来说，因为涉及到两个资源，所以我们需要一次性申请两个资源AccountA和AccountB，在现实生活中我们可以通过一个账本管理员来负责一个业务员只能同时获取到转账双发的账本，要么都获取不到。</p><p>  <img src="/2019/08/08/Java并发编程学习——如何解决死锁/4.jpg" alt="两个锁"></p><p>  编程中我们也可以定义一个管理员，并且对资源的回收和发放都要是原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als =</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      als.add(from);</span><br><span class="line">      als.add(to);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// actr 应该为单例</span></span><br><span class="line">  <span class="keyword">private</span> Allocator actr;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line">    <span class="keyword">while</span>(!actr.apply(<span class="keyword">this</span>, target))</span><br><span class="line">      ；</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 锁定转出账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">// 锁定转入账户</span></span><br><span class="line">        <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      actr.free(<span class="keyword">this</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h2><p>  破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p><p>  你可能会质疑，“Java 作为排行榜第一的语言，这都解决不了？”你的怀疑很有道理，Java 在语言层次确实没有解决这个问题，不过在 SDK 层面还是解决了的，java.util.concurrent 这个包下面提供的 Lock 是可以轻松解决这个问题的。</p><h2 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h2><p>  破坏这个条件需要对资源进行排序，这样申请资源申请锁的时候就不会出现循环等待了。</p><p>  这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    Account left = <span class="keyword">this</span>        ①</span><br><span class="line">    Account right = target;    ②</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; target.id) &#123; ③</span><br><span class="line">      left = target;           ④</span><br><span class="line">      right = <span class="keyword">this</span>;            ⑤</span><br><span class="line">    &#125;                          ⑥</span><br><span class="line">    <span class="comment">// 锁定序号小的账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(left)&#123;</span><br><span class="line">      <span class="comment">// 锁定序号大的账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(right)&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">          <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  当我们使用细粒度锁来解决问题的时候，需要注意死锁问题。</p><p>  预防死锁有三个解决方案，在上述中我们使用了两种方式避免死锁，但是显然破坏循环等待条件的做法明显优于破坏部分分配条件，所以在选用避免死锁的方法的时候还要仔细斟酌</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现实世界&quot;&gt;&lt;a href=&quot;#现实世界&quot; class=&quot;headerlink&quot; title=&quot;现实世界&quot;&gt;&lt;/a&gt;现实世界&lt;/h2&gt;&lt;p&gt;  前面我们使用Account.class来作为转账的锁，即当发生一个转账操作的时候，所有的用户操作都会被阻塞，这效率简直太
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——互斥锁</title>
    <link href="https://francisqiang.github.io/2019/08/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <id>https://francisqiang.github.io/2019/08/08/Java并发编程学习——互斥锁/</id>
    <published>2019-08-08T03:13:50.000Z</published>
    <updated>2019-08-08T05:30:54.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何解决原子性问题"><a href="#如何解决原子性问题" class="headerlink" title="如何解决原子性问题"></a>如何解决原子性问题</h2><p>  原子性问题的源头就是<strong>线程切换</strong>，而我们禁用线程切换就能解决，而操作系统进行线程切换是依赖于CPU中断的，所以我们禁用CPU中断就能禁用线程切换。</p><p>  在早期单核CPU的情况下，统一时刻只有一个线程执行(多线程是利用时间片切换)，所以禁用了线程切换就导致了获得CPU使用权的线程可以不间断的执行，就比如说在32位机器上写入一个long变量分为写入高32位和低32位，那么如果禁用CPU中断，该线程就不会被打断，所以这时候写入高32和低32这两个操作就具有原子性，即要么不被执行要么都被执行。</p><p>  但是对于现代多核CPU，这时候就有多个线程同一时刻在不同cpu上执行，这个时候如果禁用CPU中断是不能禁止同一时刻只有一个线程执行的。它只能保证这时的执行线程不会被切换，如果这时候同时有两个变量要写入long型变量，由于多线程竞争的问题，在线程A写入高32位的时候线程B也写入高32位，然后线程B写入低32位之后线程A写入低32位，这时候就会出现写入数值出现异常值的bug。</p><p>  <strong>同一时刻只有一个线程执行</strong>这个概念非常重要，我们称之为<strong>互斥</strong>。如果我们对于某一共享变量的操作都是互斥的，无论是单核还是多核CPU都能实现原子性。</p><h2 id="简易锁模型"><a href="#简易锁模型" class="headerlink" title="简易锁模型"></a>简易锁模型</h2><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/1.jpg" alt="简易锁模型"></p><p>  而解决原子性的问题最重要的解决办法就是<strong>锁</strong>。比如线程A要执行临界区的一段代码，必须先进行加锁，枷锁完成后进入临界区并执行，当线程B要进入的时候由于获得不到锁，那么线程B得不到执行。当线程A执行完成后便释放锁，之后线程B就可以获得锁并且进入临界区执行了。</p><p>  但是我们常常忽略的两个问题——我们的锁是什么？我们保护的资源又是什么？</p><h2 id="改进后的锁模型"><a href="#改进后的锁模型" class="headerlink" title="改进后的锁模型"></a>改进后的锁模型</h2><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/2.jpg" alt="简易锁模型"></p><p>  改进后的锁模型则对资源和锁进行了定义，就像现实生活中，自家门对应着自家门的锁，别人家的对应别人的锁。</p><h2 id="Java语言提供的锁技术——synchronized"><a href="#Java语言提供的锁技术——synchronized" class="headerlink" title="Java语言提供的锁技术——synchronized"></a>Java语言提供的锁技术——synchronized</h2><p>  Java语言提供的锁技术就是synchronized关键字，它可以应用于方法中也可以是代码块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰代码块</span></span><br><span class="line">  Object obj = <span class="keyword">new</span> Object()；</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中锁的实现是Java编译器帮我们自动实现的，而synchronized并没有指定锁到底是什么，其实这里java是有默认规则的。</p><p>  具体的默认规则如下：</p><ol><li>当synchronized修饰的是静态方法的时候，默认锁住的是当前类的class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span>(X.class) <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当修饰的是非静态方法的时候默认锁着的是当前对象即this</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用synchronized来解决count-1的问题"><a href="#用synchronized来解决count-1的问题" class="headerlink" title="用synchronized来解决count+=1的问题"></a>用synchronized来解决count+=1的问题</h2><p>  SafeCalc 这个类有两个方法：一个是 get() 方法，用来获得 value 的值；另一个是 addOne() 方法，用来给 value 加 1，并且 addOne() 方法我们用 synchronized 修饰。那么我们使用的这两个方法有没有并发问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于synchronized的存在，假使有1000个线程去执行addOne方法，因为同一时刻只能有一个线程去执行，所以最后的value肯定是1000。</p><p>  但是对于get方法就不是了，如果有线程去执行get方法，因为上述代码有了管程中锁机制的happens-before规则(前一个线程加锁后进入临界区对共享资源的修改对于后一个线程解锁后进入是可见的)，这个时候get方法就不是可见的了。所以这时候将get方法也synchronized一下就可以了，因为前面对addOne的操作对于get就可见了。</p><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/3.jpg" alt="简易锁模型"></p><h2 id="锁和受保护资源的关系"><a href="#锁和受保护资源的关系" class="headerlink" title="锁和受保护资源的关系"></a>锁和受保护资源的关系</h2><p>  <strong>受保护资源和锁之间的关联关系是 N:1 的关系</strong>，如果我们将上述代码改一下。把 value 改成静态变量，把 addOne() 方法改成静态方法，此时 get() 方法和 addOne() 方法是否存在并发问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/4.jpg" alt="简易锁模型"></p><p>  这个时候是通过不同的锁来保护不同的资源，那么get方法就会像刚刚那样出现并发问题了。</p><h2 id="锁不能是可变对象"><a href="#锁不能是可变对象" class="headerlink" title="锁不能是可变对象"></a>锁不能是可变对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">      value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果将锁变为这样，是不允许的，因为锁应该是不可变的。</p><h2 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="headerlink" title="保护没有关联关系的多个资源"></a>保护没有关联关系的多个资源</h2><p>  被保护资源和锁应该是N：1的关系，那么保护没有关联关系的多个资源呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 锁：保护账户余额</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object balLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户余额  </span></span><br><span class="line">  <span class="keyword">private</span> Integer balance;</span><br><span class="line">  <span class="comment">// 锁：保护账户密码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object pwLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户密码</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取款</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看余额</span></span><br><span class="line">  <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改密码</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(String pw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">this</span>.password = pw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看密码</span></span><br><span class="line">  <span class="function">String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  很简单，使用不同的锁去保护没有关联关系的不同资源就行了，这里使用两个锁pwlock和ballock来保护密码和余额。</p><p>  当然，我们也可以用一把互斥锁来保护多个资源，例如我们可以用 this 这一把锁来管理账户类里所有的资源：账户余额和用户密码。具体实现很简单，示例程序中所有的方法都增加同步关键字 synchronized 就可以了。</p><p>  但是用一把锁有个问题，就是性能太差，会导致取款、查看余额、修改密码、查看密码这四个操作都是串行的。而我们用两把锁，取款和修改密码是可以并行的。<strong>用不同的锁对受保护资源进行精细化管理，能够提升性能</strong>。这种锁还有个名字，叫<strong>细粒度锁</strong>。</p><h2 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="headerlink" title="保护有关联关系的多个资源"></a>保护有关联关系的多个资源</h2><p>  如果多个资源是有关联的，比如转账，将A账户的钱转到B账户中，这两个账户的余额就是相关联的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果通过synchronized关键字，你会发现你锁住的仅仅是当前账户的余额，而target的余额就不能保证原子性。比如你同时进行target账户的收款和打钱的操作，那么target就会出现并发问题。</p><p>  假设有 A、B、C 三个账户，余额都是 200 元，我们用两个线程分别执行两个转账操作：账户 A 转给账户 B 100 元，账户 B 转给账户 C 100 元，最后我们期望的结果应该是账户 A 的余额是 100 元，账户 B 的余额是 200 元， 账户 C 的余额是 300 元。</p><p>  我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗？我们期望是，但实际上并不是。因为线程 1 锁定的是账户 A 的实例（A.this），而线程 2 锁定的是账户 B 的实例（B.this），所以这两个线程可以同时进入临界区 transfer()。同时进入临界区的结果是什么呢？线程 1 和线程 2 都会读到账户 B 的余额为 200，导致最终账户 B 的余额可能是 300（线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖），可能是 100（线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖），就是不可能是 200。</p><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/5.jpg" alt="简易锁模型"></p><p>  这时候我们就可以通过增大锁的细粒度来保护资源，我们可以将Account.class作为锁对象，这时候就可以解决并发问题。</p><p>  问题是解决了，但是使用class作为锁的意思就是当一个账户执行操作的时候，其他账户都不能使用，这样可是会严重影响性能的。</p><p>  <img src="/2019/08/08/Java并发编程学习——互斥锁/6.jpg" alt="简易锁模型"></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>  “原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以解决原子性问题，是要保证<strong>中间状态对外不可见</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何解决原子性问题&quot;&gt;&lt;a href=&quot;#如何解决原子性问题&quot; class=&quot;headerlink&quot; title=&quot;如何解决原子性问题&quot;&gt;&lt;/a&gt;如何解决原子性问题&lt;/h2&gt;&lt;p&gt;  原子性问题的源头就是&lt;strong&gt;线程切换&lt;/strong&gt;，而我们禁用线程切
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——Java如何解决可见性和有序性问题</title>
    <link href="https://francisqiang.github.io/2019/08/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/08/07/Java并发编程学习——Java如何解决可见性和有序性问题/</id>
    <published>2019-08-07T07:19:15.000Z</published>
    <updated>2019-08-07T09:01:25.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>  导致可见性的原因是缓存，导致有序性的原因是编译优化，那么解决可见性和有序性的最直接的方法就是禁用缓存和编译优化，但是如果禁用那么就会导致程序的性能下降。</p><p>  所以合理的方案就是按需禁用缓存和编译优化，而何时禁用这件事情是程序员决定的，这时候就应该请出主角Java内存模型了。</p><p>  Java内存模型是一个很复杂的概念，站在程序员的角度来看，Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括<strong>volatile</strong>，<strong>synchronized</strong>和<strong>final</strong>三个关键字以及六项<strong>Happens-Before规则</strong>。</p><h2 id="使用volatile的困惑"><a href="#使用volatile的困惑" class="headerlink" title="使用volatile的困惑"></a>使用volatile的困惑</h2><p>  volatile关键字并不是Java语言的特产，C语言也有，它最原始的意义就是禁用CPU缓存。</p><p>  例如我们声明一个volatile变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  它表达的是：告诉编译器，对这个变量的读写，不能使用CPU缓存，必须从内存中读取或者写入。</p><p>  例如以下代码,在1.5版本之前打印结果可能为0(因为CPU缓存的原因，线程2读取的是自身缓存的值)，在JDK1.5之后肯定为40，因为在1.5版本之后JDK做了volatile的语意增强，这个增强其实就是一项Happens-Before规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">40</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Noxxxxxxxxxxxxxxxxxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      Test test = <span class="keyword">new</span> Test();</span><br><span class="line">      Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        test.write();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        test.read();</span><br><span class="line">      &#125;);</span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line"></span><br><span class="line">      thread1.join();</span><br><span class="line"></span><br><span class="line">      thread2.join();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h2><p>  Happens-Before规则并不是先于发生的意思，而具体意思是指<strong>前一个操作的结果对于后一个操作时可见的</strong>。</p><h3 id="程序的顺序性规则"><a href="#程序的顺序性规则" class="headerlink" title="程序的顺序性规则"></a>程序的顺序性规则</h3><p>  在一个线程中，前面的操作Happens-Before后面的操作。</p><h3 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h3><p>  一个对于volatile变量的写操作Happens-Before于后续对这个变量的读操作。</p><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><p>  如果 A Happens-Before B 且 B Happens-Before C 那么 A Happens-Before C</p><p>  这条规则和volatile变量规则结合起来看前面的代码，其实就是上面代码示例的结果原理，在线程A中x=40的操作happens-before对于volatile变量v的写操作，然后线程A中对于volatile变量v的写操作happens-before于对线程B的对volatile变量v的读操作，所以x = 40happens-before线程B中的对于volatile变量v的读操作，也就是说x = 40对于线程B的那个操作是可见的，而JDK1.5之后就是通过这个原则来增强volatile语意的。</p><h3 id="管程中的锁规则"><a href="#管程中的锁规则" class="headerlink" title="管程中的锁规则"></a>管程中的锁规则</h3><p>  管程是一种通用的同步原语。在Java中指的就是synchronized，synchronized就是java对管程的一种实现。</p><p>  管程中的锁是java隐式帮我们实现的，在进入同步块代码的时候Java会帮我们上锁，执行完成会帮我们释放锁，这个是由编译器帮我们实现的，为的是防止程序员忘记释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入同步代码块加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.x == <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行完成释放锁</span></span><br></pre></td></tr></table></figure><h3 id="线程的start-规则"><a href="#线程的start-规则" class="headerlink" title="线程的start()规则"></a>线程的start()规则</h3><p>  主线程启动子线程B，子线程能看到主线程在启动子线程B之前的操作。换言之就是线程A中调用的线程B的start方法happens-before线程B中的任意操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 主线程调用 B.start() 之前</span></span><br><span class="line">  <span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line">  <span class="comment">// 此例中，var==77</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line"><span class="keyword">var</span> = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br></pre></td></tr></table></figure><h3 id="线程join规则"><a href="#线程join规则" class="headerlink" title="线程join规则"></a>线程join规则</h3><p>  主线程等待子线程完成，当子线程完成后，主线程能看到子线程的操作。<strong>其实就是，在主线程A中调用了子线程B的join方法，这时候子线程B的任意操作happens-before主线程调用线程B的join方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line">  <span class="keyword">var</span> = <span class="number">66</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"><span class="comment">// 则这个修改结果对线程 B 可见</span></span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br><span class="line">B.join()</span><br><span class="line"><span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"><span class="comment">// 在主线程调用 B.join() 之后皆可见</span></span><br><span class="line"><span class="comment">// 此例中，var==66</span></span><br></pre></td></tr></table></figure><h3 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h3><p>  对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p><h3 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h3><p>  一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>  final 修饰变量时，初衷是告诉编译器：<strong>这个变量生而不变，可以可劲儿优化</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>为什么定义Java内存模型？</p><p>现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。</p></li><li><p>三个基本原则</p><p> 原子性、可见性、有序性。</p></li><li><p>Java内存模型涉及的几个关键词</p><p>锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Java内存模型&quot;&gt;&lt;a href=&quot;#什么是Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;什么是Java内存模型&quot;&gt;&lt;/a&gt;什么是Java内存模型&lt;/h2&gt;&lt;p&gt;  导致可见性的原因是缓存，导致有序性的原因是编译优化，那么解决可见
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程学习——可见性,原子性,有序性问题</title>
    <link href="https://francisqiang.github.io/2019/08/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://francisqiang.github.io/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/</id>
    <published>2019-08-06T08:20:42.000Z</published>
    <updated>2019-08-06T09:28:54.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发程序幕后的故事"><a href="#并发程序幕后的故事" class="headerlink" title="并发程序幕后的故事"></a>并发程序幕后的故事</h2><p>  此系列文章为极客时间java并发编程课程的学习笔记。</p><p>  计算机中由于CPU，内存，I/O设备三者硬件速度之间的差异，而面对三者的差异，计算机体系结构，操作系统，编译程序都为之做出了自己的贡献。</p><p>  比如CPU增加了缓存机制，操作系统增加了进程，线程，分时复用CPU的理念，编译程序则会优化指令顺序。</p><p>  而这些，其实就是并发程序bug的根源所在。</p><h2 id="根源一：缓存导致的可见性问题"><a href="#根源一：缓存导致的可见性问题" class="headerlink" title="根源一：缓存导致的可见性问题"></a>根源一：缓存导致的可见性问题</h2><p>  在早期的PC中，一般使用的是单核的CPU，CPU缓存与内存的数据一致性问题很好解决。因为不同线程都是对同一个cpu缓存进行操作，一个线程对于cpu缓存的数据更改另一个线程肯定是可见的，所以如果线程A更改了缓存中的V值，对于线程B再取出V的值就是线程A已经更改的值。</p><p>  <img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/1.jpg" alt="单个CPU的缓存可见性问题模型"></p><p>  但是现如今多核时代，每个CPU都有自己的缓存，这时候缓存的可见性问题并没有那么简单了。</p><p>  <img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/2.jpg" alt="单个CPU的缓存可见性问题模型"></p><p>  如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add10k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      test.add10k();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      test.add10k();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(Test.calc());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码表示创建两个线程，这两个线程同时为count做100000次自增，如果按照常理得到的结果应该是200000，但是其实输出的是100000到200000之间的数字。其原因在于在线程A和线程B执行的过程中，两个线程会将count都放入自己的寄存器中然后进行+操作，但是对于放回内存中这样的操作就会出现重叠，例如线程A计算出count为1了放入内存，线程B计算出count为1了放入内存，此时count就会为1而不是我们真正想看到的2。</p><h2 id="根源二：线程切换带来的原子性问题"><a href="#根源二：线程切换带来的原子性问题" class="headerlink" title="根源二：线程切换带来的原子性问题"></a>根源二：线程切换带来的原子性问题</h2><p>  因为CPU执行速度是非常快的，所以在早期的PC时代中人们就发明了多进程的理念，即CPU通过切换时间片来使多个进程看似在同时执行。</p><p>  <img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/3.jpg" alt="单个CPU的缓存可见性问题模型"></p><p>  在一个时间片内，如果一个进程进行一个IO操作，例如读文件，这个时候该进程可以把自己标记为“休眠状态”并让出CPU的使用权，待文件读入内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得CPU的使用权了。</p><p>  这里的进程在等待IO时会释放CPU使用权，是为了提高CPU使用率。此外，如果这时有另外一个进程读文件，那么读文件的操作就会排队，磁盘驱动在完成一个进程的读操作之后，会立即进行下一个操作，这样IO的使用率也提升了。而这个就是多进程分时复用，这个操作在操作系统中具有里程碑的意义，Unix就是因为解决这个问题而名噪天下的。</p><p>  早期的操作系统基于进程来调度CPU，不同进程间是不共享内存空间的，所以要做进程任务切换就要切换内存映射地址，而一个进程创建的所有线程中，他们都是共享内存空间的，所以线程做任务切换的成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p><p>  Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。</p><ol><li><p>将count从内存中取出放入寄存器</p></li><li><p>在寄存器中进行加操作</p></li><li><p>从寄存器中取出放入内存中（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p><p>操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p><p><img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/4.jpg" alt="任务切换带来的BUG"></p><p>如果我们将这条语句作为原子操作那是可以的，而对于线程切换，它的基本单位是cpu指令而不是语句，我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。</p></li></ol><h2 id="源头三：编译优化带来的有序性问题"><a href="#源头三：编译优化带来的有序性问题" class="headerlink" title="源头三：编译优化带来的有序性问题"></a>源头三：编译优化带来的有序性问题</h2><p>  Java的编译优化是很智能的，为了提高程序的性能，编译器有时候会更改语句执行顺序，按照常理有些语句的顺序变更是不会影响结果的，但是在多线程的情境下就变得复杂起来了。</p><p>  例如在单例模式的双重检查中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">           instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  假如现有两个线程A，B同时进入getInstance方法他们同时判断instance是否为空，此时为空两个线程同时进入语句，由于synchronized的存在，JVM只会让一个线程进入并且上锁。假设此时A进入B等待锁，那么A获得锁判断instance是否为空，为空则创建对象，然后A释放锁，此时B获得锁并进入语句判断instance不为空跳出语句并return不为空的instance。一切看起来完美，但是我们一直以为的new操作是这样的。</p><ol><li><p>在内存中开辟一个地址空间M</p></li><li><p>在地址空间M中初始化Singleton对象</p></li><li><p>将地址赋值给instance变量</p><p>但经过了编译优化它是这样的</p></li><li><p>在内存中开辟一个地址空间M</p></li><li><p>将地址赋值给instance变量</p></li><li><p>在地址空间初始化Singleton对象</p><p>试想一下，如果在执行2指令的时候进行了线程切换，线程B会判断instance是否为空，此时不为空那么直接返回，但是在返回instance的地址空间并没有Singleton对象，所以之后如果调用instance的变量，方法就会产生空指针异常。</p><p><img src="/2019/08/06/Java并发编程学习——可见性-原子性-有序性问题/5.jpg" alt="编译优化带来的BUG"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发程序幕后的故事&quot;&gt;&lt;a href=&quot;#并发程序幕后的故事&quot; class=&quot;headerlink&quot; title=&quot;并发程序幕后的故事&quot;&gt;&lt;/a&gt;并发程序幕后的故事&lt;/h2&gt;&lt;p&gt;  此系列文章为极客时间java并发编程课程的学习笔记。&lt;/p&gt;
&lt;p&gt;  计算机中
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://francisqiang.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——解释器模式</title>
    <link href="https://francisqiang.github.io/2019/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/06/设计模式——解释器模式/</id>
    <published>2019-08-06T04:13:39.000Z</published>
    <updated>2019-08-06T04:21:44.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是解释器模式"><a href="#什么是解释器模式" class="headerlink" title="什么是解释器模式"></a>什么是解释器模式</h2><p>  原文链接<a href="https://www.cnblogs.com/liaojie970/p/5495795.html" target="_blank" rel="noopener">解释器模式</a></p><p>  解释器模式的定义是一种按照规定语法进行解析的方案，在现在项目中使用的比较少，其定义如下：</p><p>  Given a language, define a representation for its grammar along with an interpreter that uses the<br>  representation to interpret sentences in the language.</p><p>  给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表达式来解释语言中的句子。</p><p>  <img src="/2019/08/06/设计模式——解释器模式/1.jpg" alt="UML"></p><p>  解释器角色：</p><ol><li><p>AbstractExpression抽象解释器：具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和NonterminalExpression</p></li><li><p>TerminalExpression终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结表达式，但有多个实例，对应不同的终结符。</p></li><li><p>NonterminalExpression非终结符表达式：文法中的每条规则对应于一个非终结表达式，非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式</p></li><li><p>Context环境角色</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象表达式</span></span><br><span class="line"><span class="comment">/*抽象表达式是生产语法集合(也叫语法树)的关键，每个语法集合完成指定语法解析任务，它是通过递归调用的方式，最终</span></span><br><span class="line"><span class="comment">由最小的语法单元进行解析完成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="comment">//每个表达式必须有一个解析任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">interpreter</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结符表达式  主要是处理场景元素和数据的转换 如：a+b+c中的"a""b""c"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="comment">//通常终结符表达式只有一个，但是有多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非终结符表达式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个非终结符表达式都代表一个文法规则，并且每个文法规则都只关心自己周边的文法规则结果(注意是结果),因此</span></span><br><span class="line"><span class="comment">    这就产生了每个终结符表达式调用自己周边的非终结符表达式，然后最终，最小的文法规则就是终结符表达式，终</span></span><br><span class="line"><span class="comment">    结符表达式的概念就是如此，不能在参与比自己更小的文法运算了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="comment">//每个非终结符表达式都会对其他表达式产生依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonterminalExpression</span><span class="params">(Expression... expression)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//进行文法处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Context context=<span class="keyword">new</span> Context();</span><br><span class="line">        <span class="comment">//通常一个语法容器，容纳一个具体的表达式，通常为ListArray，LinkedList，Stack等类型</span></span><br><span class="line">        Stack&lt;Expression&gt; stack=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="comment">//进行语法判断，并产生递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//产生一个完整的语法树，由各个具体的语法分析进行解析</span></span><br><span class="line">        Expression expression=stack.pop();</span><br><span class="line">        <span class="comment">//具体元素进入场景</span></span><br><span class="line">        expression.interpreter(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释器的优缺点"><a href="#解释器的优缺点" class="headerlink" title="解释器的优缺点"></a>解释器的优缺点</h2><p>  优点:</p><p>  解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了</p><p>  缺点:</p><ol><li><p>解释器模式会引发类膨胀：每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。</p></li><li><p>解释器模式采用递归调用方法：每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层的剥茧，无论是面向过程的语言还是面向对象的语言，递归都是在必要条件下是使用的，它导致调试非常复杂</p></li><li><p>效率问题：解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题</p></li></ol><h2 id="解释器模式应用场景"><a href="#解释器模式应用场景" class="headerlink" title="解释器模式应用场景"></a>解释器模式应用场景</h2><ol><li><p>重复发生的问题可以使用解释器模式</p></li><li><p>一个简单语法需要解释的场景</p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>  尽量不要再重要的模块中使用解释器模式，否则维护会一个很大的问题。在项目中可以使用shell，jRuby，Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。</p><p>  常用的解释器模式工具包：Expression4J,MESP(Math Expression String parser),Jep等开源的解析工具包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是解释器模式&quot;&gt;&lt;a href=&quot;#什么是解释器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是解释器模式&quot;&gt;&lt;/a&gt;什么是解释器模式&lt;/h2&gt;&lt;p&gt;  原文链接&lt;a href=&quot;https://www.cnblogs.com/liaojie
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——中介者模式</title>
    <link href="https://francisqiang.github.io/2019/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/05/设计模式——中介者模式/</id>
    <published>2019-08-05T14:42:16.000Z</published>
    <updated>2019-08-06T02:50:50.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是中介者模式"><a href="#什么是中介者模式" class="headerlink" title="什么是中介者模式"></a>什么是中介者模式</h2><p>  中介者模式是一种行为模式，其中最重要的角色就是中介者了，中介者的作用就是封装一系列对象的交互逻辑。比如在一个智能家居系统中有许多设备比如TV，屏幕，摄像头，报警器等等的启动，一般来说系统的启动需要这些设备的相互协调交互，如果这些全部暴露给Client，那么整体逻辑就会变得非常的复杂，先如今通过中介者来包装系统中的一些列对象的交互逻辑。</p><h2 id="中介者模式UML图"><a href="#中介者模式UML图" class="headerlink" title="中介者模式UML图"></a>中介者模式UML图</h2><p>  <img src="/2019/08/05/设计模式——中介者模式/1.jpg" alt="UML"></p><p>  Mediator是中介者，它用来封装一系列的Colleague对象之间的相互调用。即它需要知道所有的具体的同事类，即以一个集合来管理并接受某个同事对象消息，完成相应的任务。</p><p>  具体的同事类会有很多，每个同事只知道自己的行为，而不了解其他同事对象的行为，但是他们都依赖中介者对象。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每个同事类中都含有对应的中介者</span></span><br><span class="line">  <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">  <span class="comment">// 同事对象的名字</span></span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="comment">// 构造的时候讲中介者和名字传入初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取中介者，因为它需要向中介者发送消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mediator <span class="title">GetMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.mediator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Alarm</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mediator, name);</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendAlarm</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    SendMessage(stateChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Curtains</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Curtains</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mediator, name);</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpCurtains</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"I am holding Up Curtains!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CoffeeMachine</span><span class="params">(Mediator mediator, String name&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">super</span>(mediator, name)</span></span>;</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"It's time to startcoffee!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinishCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"After 5 minutes!"</span>);System.out.println(<span class="string">"Coffee is ok!"</span>);</span><br><span class="line">    SendMessage(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TV</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mediator, name);</span><br><span class="line">    mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartTv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"It's time to StartTv!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopTv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"StopTv!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将同事注册到中介者对象中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取同事发送的消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    colleagueMap = <span class="keyword">new</span> HashMap&lt;String, Colleague&gt;();</span><br><span class="line">    interMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> </span>&#123;</span><br><span class="line">    colleagueMap.put(colleagueName, colleague);</span><br><span class="line">    <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">      interMap.put(<span class="string">"Alarm"</span>, colleagueName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">    interMap.put(<span class="string">"CoffeeMachine"</span>, colleagueName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">      interMap.put(<span class="string">"TV"</span>, colleagueName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">      interMap.put(<span class="string">"Curtains"</span>, colleagueName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中介者协调各个同事之间的工作</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果我接受到的是Alarm那么。。。</span></span><br><span class="line">    <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">      <span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">        ((CoffeeMachine) (colleagueMap.get(interMap.get(<span class="string">"CoffeeMachine"</span>)))).StartCoffee();</span><br><span class="line">        ((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StartTv();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">        ((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StopTv();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是咖啡，那么、、、</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">      ((Curtains) (colleagueMap.get(interMap.get(<span class="string">"Curtains"</span>))))</span><br><span class="line">      .UpCurtains();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">    Alarm alarm = <span class="keyword">new</span> Alarm(mediator, <span class="string">"alarm"</span>);</span><br><span class="line">    CoffeeMachine coffeeMachine = <span class="keyword">new</span> CoffeeMachi   (mediator,<span class="string">"coffeeMachine"</span>);</span><br><span class="line">    Curtains curtains = <span class="keyword">new</span> Curtains(mediator, <span class="string">"curtains"</span>);</span><br><span class="line">    TV tV = <span class="keyword">new</span> TV(mediator, <span class="string">"TV"</span>);</span><br><span class="line">    alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">    coffeeMachine.FinishCoffee();</span><br><span class="line">    alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是中介者模式&quot;&gt;&lt;a href=&quot;#什么是中介者模式&quot; class=&quot;headerlink&quot; title=&quot;什么是中介者模式&quot;&gt;&lt;/a&gt;什么是中介者模式&lt;/h2&gt;&lt;p&gt;  中介者模式是一种行为模式，其中最重要的角色就是中介者了，中介者的作用就是封装一系列对象的
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——状态模式</title>
    <link href="https://francisqiang.github.io/2019/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/05/设计模式——状态模式/</id>
    <published>2019-08-05T07:57:13.000Z</published>
    <updated>2019-08-05T08:55:49.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是状态模式"><a href="#什么是状态模式" class="headerlink" title="什么是状态模式"></a>什么是状态模式</h2><p>  一个事物在发展过程中都会产生不同的状态，比如人在成长过程中会有小孩，成人，老人等状态。但是这个状态是依赖聚合于对象本身的，因为状态是随着对象的行为而发生变化的，状态本身就是对象的一部分。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>  <img src="/2019/08/05/设计模式——状态模式/1.jpg" alt="UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaffleActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State canRaffleState = <span class="keyword">new</span> CanRaffleState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State noRaffleState = <span class="keyword">new</span> NoRaffleState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State dispenseState = <span class="keyword">new</span> DispenseState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State dispenseOutState = <span class="keyword">new</span> DispenseOutState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RaffleActivity</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">this</span>.noRaffleState;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    state.deduceMoney();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state.raffle()) &#123;</span><br><span class="line">      state.dispensePrize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCanRaffleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCanRaffleState</span><span class="params">(State canRaffleState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.canRaffleState = canRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getNoRaffleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> noRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNoRaffleState</span><span class="params">(State noRaffleState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.noRaffleState = noRaffleState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getDispenseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispenseState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispenseState</span><span class="params">(State dispenseState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dispenseState = dispenseState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getDispenseOutState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispenseOutState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispenseOutState</span><span class="params">(State dispenseOutState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dispenseOutState = dispenseOutState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoRaffleState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NoRaffleState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"扣除50元余额，您可以开始抽奖了。"</span>);</span><br><span class="line">    raffleActivity.setState(raffleActivity.getCanRaffleState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前不可以抽奖。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"不能发放奖品。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanRaffleState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CanRaffleState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (raffleActivity.getCount() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"抽奖活动已结束！请下次再来！"</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> num = random.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"恭喜您！中奖了！"</span>);</span><br><span class="line">      raffleActivity.setCount(raffleActivity.getCount() - <span class="number">1</span>);</span><br><span class="line">      raffleActivity.setState(raffleActivity.getDispenseState());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"很遗憾！未中奖！"</span>);</span><br><span class="line">      raffleActivity.setState(raffleActivity.getNoRaffleState());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请先抽奖！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DispenseState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品！"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"正在发送奖品！请稍等！"</span>);</span><br><span class="line">    raffleActivity.setState(raffleActivity.getDispenseOutState());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseOutState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RaffleActivity raffleActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DispenseOutState</span><span class="params">(RaffleActivity raffleActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.raffleActivity = raffleActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"您已抽中奖品"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"奖品已发送完毕！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RaffleActivity raffleActivity = <span class="keyword">new</span> RaffleActivity(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"这是第"</span> + i + <span class="string">"次抽奖"</span>);</span><br><span class="line"></span><br><span class="line">      raffleActivity.deduceMoney();</span><br><span class="line">      raffleActivity.raffle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是状态模式&quot;&gt;&lt;a href=&quot;#什么是状态模式&quot; class=&quot;headerlink&quot; title=&quot;什么是状态模式&quot;&gt;&lt;/a&gt;什么是状态模式&lt;/h2&gt;&lt;p&gt;  一个事物在发展过程中都会产生不同的状态，比如人在成长过程中会有小孩，成人，老人等状态。但是这个状
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——备忘录模式</title>
    <link href="https://francisqiang.github.io/2019/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/04/设计模式——备忘录模式/</id>
    <published>2019-08-04T09:32:16.000Z</published>
    <updated>2019-08-04T13:16:18.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是备忘录模式"><a href="#什么是备忘录模式" class="headerlink" title="什么是备忘录模式"></a>什么是备忘录模式</h2><p>  备忘录是指在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象外部保存状态。而状态保存的地方就是备忘录对象，并且再创建一个备忘录的管理类来管理一系列的状态，在用户操作的时候，用户不与备忘录直接耦合而与备忘录的管理类相耦合。相应的我们就可以做一些操作比如回滚，撤销等。</p><h2 id="备忘录的UML图"><a href="#备忘录的UML图" class="headerlink" title="备忘录的UML图"></a>备忘录的UML图</h2><p>  <img src="/2019/08/04/设计模式——备忘录模式/1.jpg" alt="UML"></p><p>  originator是指需要保存状态的对象，Memento是聚合了状态的备忘录对象，CareTaker是存储了备忘录对象集合的备忘录管理类。</p><p>  在originator中需要有一个方法是将状态保存到备忘录对象中，并且在备忘录管理类中需要有备忘录对象的增加删除方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Memento <span class="title">saveToMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前状态为:"</span> + <span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">    mementoList.add(memento);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line"></span><br><span class="line">    CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line"></span><br><span class="line">    originator.setState(<span class="string">"状态1"</span>);</span><br><span class="line">    careTaker.addMemento(originator.saveToMemento());</span><br><span class="line"></span><br><span class="line">    originator.display();</span><br><span class="line"></span><br><span class="line">    originator.setState(<span class="string">"状态2"</span>);</span><br><span class="line">    careTaker.addMemento(originator.saveToMemento());</span><br><span class="line"></span><br><span class="line">    originator.display();</span><br><span class="line"></span><br><span class="line">    originator.setState(careTaker.getMemento(<span class="number">0</span>).getState());</span><br><span class="line"></span><br><span class="line">    originator.display();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是备忘录模式&quot;&gt;&lt;a href=&quot;#什么是备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;什么是备忘录模式&quot;&gt;&lt;/a&gt;什么是备忘录模式&lt;/h2&gt;&lt;p&gt;  备忘录是指在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象外部保存状态。而状态保
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——Command模式</title>
    <link href="https://francisqiang.github.io/2019/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Command%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/04/设计模式——Command模式/</id>
    <published>2019-08-04T04:46:06.000Z</published>
    <updated>2019-08-04T06:37:00.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Command模式"><a href="#什么是Command模式" class="headerlink" title="什么是Command模式"></a>什么是Command模式</h2><p>  所谓命令模式，必然存在三个角色——命令发起者、命令、命令接收者。即命令这个角色使发起者和接收者实现了解耦。试想一下，如果没有中间层命令，那么命令发起者必须聚合接收者，如果有了命令，那么发起者和接受者则通过命令来实现联系。</p><h2 id="Command的UML图"><a href="#Command的UML图" class="headerlink" title="Command的UML图"></a>Command的UML图</h2><p><img src="/2019/08/04/设计模式——Command模式/1.jpg" alt="UML"></p><p>  Command是一个接口，其中定义了执行和撤销的方法，而ConcreteCommand是实现了Command的具体命令，这个具体命令是Invoker(发起者)和Receiver(接收者)的“桥梁”。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令的接收者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"on"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"off"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的命令角色 拥有命令接受者 并调用接收者的action</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> CommandReceiver commandReceiver;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(CommandReceiver commandReceiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.commandReceiver = commandReceiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commandReceiver.on();</span><br><span class="line">    System.out.println(<span class="string">"light on"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commandReceiver.off();</span><br><span class="line">    System.out.println(<span class="string">"light off"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> CommandReceiver commandReceiver;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(CommandReceiver commandReceiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.commandReceiver = commandReceiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commandReceiver.off();</span><br><span class="line">    System.out.println(<span class="string">"light off"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commandReceiver.on();</span><br><span class="line">    System.out.println(<span class="string">"light on"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空命令 也是一种设计模式 是我们少做空判断 加强逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令发起者 聚合的是命令的集合或者单个命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Command[] onCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Command[] offCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Command undoCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Command[] getOnCommands() &#123;</span><br><span class="line">    <span class="keyword">return</span> onCommands;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnCommands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onCommands[<span class="number">0</span>] = <span class="keyword">new</span> LightOnCommand(<span class="keyword">new</span> CommandReceiver());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Command[] getOffCommands() &#123;</span><br><span class="line">    <span class="keyword">return</span> offCommands;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOffCommands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    offCommands[<span class="number">0</span>] = <span class="keyword">new</span> LightOffCommand(<span class="keyword">new</span> CommandReceiver());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButton</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    undoCommand = <span class="keyword">this</span>.onCommands[n];</span><br><span class="line">    <span class="keyword">this</span>.onCommands[n].execute();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButton</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    undoCommand = <span class="keyword">this</span>.offCommands[n];</span><br><span class="line">    <span class="keyword">this</span>.offCommands[n].execute();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    undoCommand.undo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">    remoteControl.setOnCommands();</span><br><span class="line">    remoteControl.setOffCommands();</span><br><span class="line"></span><br><span class="line">    remoteControl.onButton(<span class="number">0</span>);</span><br><span class="line">    remoteControl.offButton(<span class="number">0</span>);</span><br><span class="line">    remoteControl.undo();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Command模式的优点和不足"><a href="#Command模式的优点和不足" class="headerlink" title="Command模式的优点和不足"></a>Command模式的优点和不足</h2><p>  实现命令发起者和接受者之间的解耦，命令发起者不需要知道接受者是谁。</p><p>  容易设计一个命令队列，并使用多线程去操作。</p><p>  但是提高了系统的复杂度，可能会导致命令的具体类过多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Command模式&quot;&gt;&lt;a href=&quot;#什么是Command模式&quot; class=&quot;headerlink&quot; title=&quot;什么是Command模式&quot;&gt;&lt;/a&gt;什么是Command模式&lt;/h2&gt;&lt;p&gt;  所谓命令模式，必然存在三个角色——命令发起者、命令、命令
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——JDK动态代理原理</title>
    <link href="https://francisqiang.github.io/2019/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/"/>
    <id>https://francisqiang.github.io/2019/08/02/设计模式——JDK动态代理原理/</id>
    <published>2019-08-02T06:10:57.000Z</published>
    <updated>2019-08-02T13:03:11.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h2><p>  动态代理就是在运行时生成动态的代理对象，静态代理是通过接口，封装来实现对特定对象的代理，而动态代理则可以在运行时通过反射或者字节码来动态生成代理对象，而不仅仅只针对于特定对象。</p><p>  动态代理分为两种: JDK动态代理和Cglib动态代理，前者是通过反射实现，后者是通过字节码实现，这篇博客主要讲解JDK动态代理的基本原理。</p><p>  我们知道，在静态代理中，我们的代理类需要实现和被代理对象相同的接口并且聚合该代理对象，在实现重写接口方法的时候调用本身聚合的对象的实现方法从而来解决代理问题。</p><p>  在JDK动态代理中，其实思想和静态代理差不多，最重要的区别只是JDK动态代理通过反射来实现静态代理，是静态模式动态化。</p><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Invoking sayHello"</span>);</span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDynamicProxy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HelloImpl hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">    MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(hello);</span><br><span class="line"></span><br><span class="line">    Hello proxyHello = (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(),hello.getClass().getInterfaces(),handler);</span><br><span class="line"></span><br><span class="line">    proxyHello.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h2><p>  我们要阅读源码首先要知道整个流程大概干了什么。</p><p>  我们先从使用中来猜测，我们实现了自己的InvocationHandler，这个Handler中有一个target字段，这个target指的就是被代理对象(即目标类),在被重写的invoke方法中我们通过method和args来调用target的与之对应的方法，并且在整个invoke方法中我们对它做了一些增加(即代理方法)。</p><p>  我们还可以发现，我们的HelloImpl被代理类需要实现一个接口，这也是JDK动态代理的要求，毕竟它是通过接口来实现的。</p><p>  在客户端主方法中我们new了一个HelloImpl对象然后将这个对象传入自己实现的InvocationHandler中，最后通过Proxy类中的newProxyInstance方法来获取代理对象，我们可以发现代理对象也是实现了Hello接口的，这和我们静态代理的实现方法是一样的！</p><p>  我们再来看一下newProxyInstance方法中的三个参数。</p><p>  首先第一个是ClassLoader这个就是指当前加载该类的类加载器，第二个是该类实现的接口，第三个就是handler。</p><p>  最容易理解的就是handler，因为我们具体代理逻辑是写在handler中的，所以肯定要传。而interfaces是因为整个JDK动态代理需要接口的支持，我们暂且不管，这个需要后面有个整体观念。而第一个类加载器是为什么，具体用来做什么？</p><p>  其实JDK动态代理就是通过传入handler和接口来通过反射来编写代理类的.java文件，然后通过编译器进行编译，最后通过类加载器load进内存。这样三个参数的作用就明了了</p><p>  动态代理做主要的就是那个newProxyInstance我们首先来看一下这个类具体做了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="comment">// 获取克隆的接口集</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="comment">// 做一些校验</span></span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成class</span></span><br><span class="line">        <span class="comment">// 其中包括获取生成.java 编译 类加载过程</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 校验</span></span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取class的构造器，这里params是InvocationHandler，所以在上面的代码会给我们生成，拥有InvocationHandler对象的代理类，并且有相应的构造方法。</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="comment">// 判断权限 如果是private 那么更改为public</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过构造器new出代理对象</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  我们再来看一下getProxyClass0方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法传入类加载器和接口</span></span><br><span class="line"><span class="comment">// 注意这里没有InvocationHandler，其实也可以理解，InvocationHandler只是个接口，对于代理对象的handler字段可以写死为InvacationHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果接口数量大于多少 抛出异常</span></span><br><span class="line"> <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里值 先从缓冲中取，如果没有那么从ProxyClassFactory中制造</span></span><br><span class="line">     <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">     <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">     <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">     <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看一下ProxyClassFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的前缀</span></span><br><span class="line">    <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一的值</span></span><br><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">             * interface to the same Class object.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取接口class</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">             * interface.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">// 验证是否是接口</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接包名逻辑</span></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">         * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">         * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">// 生成代理类的字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将字节码加载进JVM</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">             * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">             * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">             * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">             * exceeded).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看一下生成的字节码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、所有JDK动态代理  都是Proxy的子类  且自己是final类</span></span><br><span class="line"><span class="comment">// 2、实现了你所需要代理得接口</span></span><br><span class="line"><span class="comment">// 3、代理类整体看起来都是非常简单的  我们发现不管调用哪个方法，最终都是交给了InvocationHandler.invoke()方法  这也就是为什么需要我们提供这个接口的实现类的原因吧</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Helloworld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射给Method赋值   这里我们得出结论</span></span><br><span class="line">    <span class="comment">// Object的三个方法equals/toString/hashCode最终都是会被代理的</span></span><br><span class="line">    <span class="comment">// m3是我们HelloService自己的业务方法</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.proxy.Helloworld"</span>).getMethod(<span class="string">"sayHello"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="comment">// 传入了InvocationHandler</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用了handler的invoke方法</span></span><br><span class="line">            <span class="comment">// 而具体的代理逻辑都在handler的invoke方法中实现</span></span><br><span class="line">            <span class="comment">// handler中持有被代理对象 并且会在他自己的invoke中实现代理逻辑</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是动态代理&quot;&gt;&lt;a href=&quot;#什么是动态代理&quot; class=&quot;headerlink&quot; title=&quot;什么是动态代理&quot;&gt;&lt;/a&gt;什么是动态代理&lt;/h2&gt;&lt;p&gt;  动态代理就是在运行时生成动态的代理对象，静态代理是通过接口，封装来实现对特定对象的代理，而动态代
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——桥接模式</title>
    <link href="https://francisqiang.github.io/2019/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/08/01/设计模式——桥接模式/</id>
    <published>2019-08-01T05:02:09.000Z</published>
    <updated>2019-08-01T05:41:29.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桥接模式简介-Bridge"><a href="#桥接模式简介-Bridge" class="headerlink" title="桥接模式简介(Bridge)"></a>桥接模式简介(Bridge)</h2><p>  桥接模式是指将抽象和实现放入两个不同层次，使它们能任意改变。比如我们设计一个手机的类，其中有翻盖手机，直板手机，触屏手机。。然后每个手机又有不同的牌子，比如vivo，小米，华为。。。试想，如果我们通过面向对象继承来实现的话，我们需要创造n*n个类比如vivo翻盖，vivo直板，小米触屏。。。这样就会产生类爆炸，而且当我们想扩展比如一个旋转手机，那么我们还需要去创造不同品牌的手机先然后再创建xxx旋转手机的类，即当我们需要增加样式的时候，我们需要增加所有品牌的手机，这样就违反了单一职责原则。</p><p>  <img src="/2019/08/01/设计模式——桥接模式/1.jpg" alt="传统UML"></p><p>  而桥接模式基于类的最小设计原则，桥接模式是一种结构型模式，它通过聚合和继承来将两个变化的层次分离开来，从而保持类的可扩展性。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>  <img src="/2019/08/01/设计模式——桥接模式/2.jpg" alt="UML"></p><p>  其中Abstraction和RefinedAbstraction就是抽象层，而右边的Implementor就是实现层，在桥接模式中，抽象层就充当桥的部分将客户端和实现相连。在抽象层中聚合了实现，比如说我们可以将手机作为一个抽象Abstraction然后我们去实现不同类型的手机，比如说直板，触屏等，然后这个抽象类中聚合了一个品牌brand的接口,如果需要实现不同品牌类型的手机，只需要去实现brand接口然后将它聚合到抽象层中就行了。</p><p>  这样，手机就可以这样设计了</p><p>  <img src="/2019/08/01/设计模式——桥接模式/3.jpg" alt="手机UML"></p><p>  这样，桥接模式来代替继承可以有效地减少类的个数，而且易于扩展维护，有助于系统的分层设计，但是桥接模式需要辨别出两个变化的部分——抽象和实现，所以使用范围有一定的局限性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;桥接模式简介-Bridge&quot;&gt;&lt;a href=&quot;#桥接模式简介-Bridge&quot; class=&quot;headerlink&quot; title=&quot;桥接模式简介(Bridge)&quot;&gt;&lt;/a&gt;桥接模式简介(Bridge)&lt;/h2&gt;&lt;p&gt;  桥接模式是指将抽象和实现放入两个不同层次，使
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——享元模式</title>
    <link href="https://francisqiang.github.io/2019/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/07/31/设计模式——享元模式/</id>
    <published>2019-07-31T12:16:52.000Z</published>
    <updated>2019-07-31T12:43:31.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是享元模式"><a href="#什么是享元模式" class="headerlink" title="什么是享元模式"></a>什么是享元模式</h2><p>  池技术是享元模式运用的一个经典了，享元模式是使用户共享相似对象的一种设计模式，比如在数据库连接池中，里面会放置很多已经创建好的连接对象，如果要使用相似的对象可以直接在池中取，这样就节省了大量对象的创建。所以，享元模式一般运用在系统底层来提高系统性能，像String常量池，数据库连接池，缓冲池中都有使用。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>  <img src="/2019/07/31/设计模式——享元模式/1.jpg" alt="UML"></p><p>  这里最重要的就是FlyWeightFactory，这里面一般会存放一个map用来存储需要共享的元对象，当我们需要创建新对象的时候，会先检查池中是否已经有相似对象，如果有直接从池中取。</p><h2 id="外部状态和内部状态"><a href="#外部状态和内部状态" class="headerlink" title="外部状态和内部状态"></a>外部状态和内部状态</h2><p>  内部状态指的是共享对象的一些不可改变的状态，它们是固定的，比如我们需要共享一些棋子，对于棋子来说，其颜色黑白两色是它的内部状态是共享出去的，而且不会变。而棋子的内部状态来说可以使棋子的位置，这是一直会发生变化的，而且它不是共享出去的，是由使用者决定的。</p><h2 id="享元模式在Integer中的应用"><a href="#享元模式在Integer中的应用" class="headerlink" title="享元模式在Integer中的应用"></a>享元模式在Integer中的应用</h2><p>  在Integer的静态方法valueOf中我们创造一个Integer对象会先从预先定义好的缓冲池中去取。</p><p>  <img src="/2019/07/31/设计模式——享元模式/2.jpg" alt="Integer的valueOf方法"></p><p>  如果范围是-128~127会直接从缓冲池中取出对象，不然再创建新对象，这样就能减少对象的频繁创建。</p><p>  我们可以看到缓冲池中会预先给我们存放元对象于数组中(在静态块中执行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是享元模式&quot;&gt;&lt;a href=&quot;#什么是享元模式&quot; class=&quot;headerlink&quot; title=&quot;什么是享元模式&quot;&gt;&lt;/a&gt;什么是享元模式&lt;/h2&gt;&lt;p&gt;  池技术是享元模式运用的一个经典了，享元模式是使用户共享相似对象的一种设计模式，比如在数据库连接池
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——门面模式</title>
    <link href="https://francisqiang.github.io/2019/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/07/31/设计模式——门面模式/</id>
    <published>2019-07-31T11:42:17.000Z</published>
    <updated>2019-07-31T12:06:25.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是门面模式-Facade"><a href="#什么是门面模式-Facade" class="headerlink" title="什么是门面模式(Facade)"></a>什么是门面模式(Facade)</h2><p>  门面模式也叫外观模式，是一种结构型设计模式。门面模式屏蔽了系统方法调用的复杂性，呈现给客户端的是一个抽象简单的接口，降低了客户端使用系统的复杂度。让客户端和系统之间解耦，还能使我们更好地划分层次结构。而且在我们重新开发新系统，我们可以使用门面模式来复用旧系统中需要调用的一系列方法，并合并成一个接口来呈现给新系统api。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>  例如，我们需要设计一个家庭影院，其中启动家庭影院可能会有那么几步：</p><ol><li><p>启动荧幕</p></li><li><p>启动投影机</p></li><li><p>关闭房间等</p></li><li><p>打开爆米花等等</p><p>试想，如果我们提供给用户的是上述四个启动接口，对于用户来说实在是太不友好，所以我们可以设计一个接口包含四个对象然后在接口中实现一键启动，这样对于用户来说就非常方便了</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是门面模式-Facade&quot;&gt;&lt;a href=&quot;#什么是门面模式-Facade&quot; class=&quot;headerlink&quot; title=&quot;什么是门面模式(Facade)&quot;&gt;&lt;/a&gt;什么是门面模式(Facade)&lt;/h2&gt;&lt;p&gt;  门面模式也叫外观模式，是一种结构型设
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter——浅析Widget原理</title>
    <link href="https://francisqiang.github.io/2019/07/26/Flutter%E2%80%94%E2%80%94%E6%B5%85%E6%9E%90Widget%E5%8E%9F%E7%90%86/"/>
    <id>https://francisqiang.github.io/2019/07/26/Flutter——浅析Widget原理/</id>
    <published>2019-07-26T09:07:17.000Z</published>
    <updated>2019-07-26T10:41:00.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget渲染过程"><a href="#Widget渲染过程" class="headerlink" title="Widget渲染过程"></a>Widget渲染过程</h2><p>  在进行App开发的时候，我们往往会关注的一个问题是：如何结构化地组织视图数据，提供渲染引擎，最终完成界面显示。</p><p>  通常情况下，不同UI框架都会以不同方式去处理这一个问题，但无一例外都会用到视图树(View Tree)的概念，而Flutter将视图树的概念进行了扩展，把视图树的组织和渲染抽象为三部分，即Widget，Element和RenderObject。</p><p>  <img src="/2019/07/26/Flutter——浅析Widget原理/1.jpg" alt="widget,element和renderObject"></p><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>  很多人理解为Widget为一个组件其实并不是完全正确的，Widget只是一个数据配置信息，它是组件实现的基本逻辑单位，它里面存储了有关视图渲染的配置信息，比如布局，渲染属性，事件相应信息等等。</p><p>  当视图渲染信息发生变化的时候，Flutter会选择重建Widget树的方式进行数据更新。</p><p>  但，你可想到的是——当Widget树层次很深的时候，只要视图渲染信息发生变化的时候会涉及到大量的Widget的销毁和重建，这样会对垃圾回收造成一定的压力。但是Widget它只是一个数据配置对象，它是一个轻量级的数据结构，不涉及实际渲染位图，重建的成本很低。</p><p>  另外，由于Widget的不可变性，可以以较低成本进行渲染节点复用，因此在一个真实的渲染树中可能存在不同的Widget对应同一个渲染节点的情况，这无疑又降低了重建UI的成本。</p><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>  Element是Widget的一个实例化对象，它是配置信息到最终模型数据成型的桥梁。</p><p>  Flutter渲染过程，可以分为这三步：</p><ul><li><p>首先通过Widget树生成对应的Element树</p></li><li><p>然后，创建相应的RenderObject并关联到Element.renderObject属性上</p></li><li><p>最后，构建RenderObject树，来完成最终的渲染</p><p>可以看到其实Widget和Element都不负责视图的渲染，最终干活的只是RenderObject。Widget和Element只是负责发号施令，但是既然都是发号施令，为什么不直接通过Widget去控制RenderObject的渲染呢？其实本来三者就可以结合在一起，分为两者是为了数据信息和处理信息的解耦，而分为三者也是为了解耦。</p><p>因为Widget具有不可变性，每次改变都需要重建，如果Widget直接关联RenderObject，那么就意味着Widget的重建必然会导致RenderObject的重建，而RenderObject是负责渲染过程的，所以RenderObject的重建会非常影响性能，Element就是为了解决这个问题的，为了解决Widget和RenderObject的耦合问题，Element充当了中间的抽象层，它会和Widget中的数据进行同步，只将需要修改的部分同步到真实的RenderObject树中，最大程度降低对真实渲染视图的修改，提高渲染效率，而不是销毁整个渲染视图树。</p><p>这，就是Element存在的意义。</p></li></ul><h2 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h2><p>  RenderObject主要负责实现视图渲染的对象。</p><p>  渲染对象树在Flutter的展示过程分为四个阶段——布局，绘制，合成和渲染。其中，布局和绘制在RenderObject中完成，Flutter采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把他们绘制到不同图层。绘制完毕后，合成和渲染的工作则交给Skia搞定。</p><p>  我们可以先了解一下图像的绘制原理，图像绘制需要三大主角——CPU，GPU，显示器</p><p>  CPU负责图像数据计算，GPU负责图像数据渲染，显示器负责最终图像显示。</p><p>  整个过程就是CPU将计算好的模型数据交给GPU，GPU完成渲染之后放入帧缓冲区，随后视频控制器根据垂直同步信号(vsync)以每秒60次的速度，从帧缓冲区读取帧数据交给显示器完成图像显示</p><p>  <img src="/2019/07/26/Flutter——浅析Widget原理/2.jpg" alt="Flutter图像显示原理"></p><p>  在图中CPU线程所做的事情其实就是RenderObject需要做的事情，我们上文所说渲染对象树在Flutter的展示过程分为布局，绘制，合成和渲染。其中合成和渲染其实就是上图中的GPU线程合成数据交给Skia然后Skia交个自身图像渲染引擎OpenGL来完成渲染。前面的布局和绘制则是RenderObject完成的。</p><p>  上文我们可以知道Widget负责存储控件信息如位置，大小，渲染属性，事件回应信息等，其实位置和大小就是布局，而渲染属性和等等其他信息其实就是绘制这一层了，RenderObject通过Element抽象层来连接到Widget中的数据，然后对Widget数的数据创建渲染对象树，然后创建真正的渲染模型对象数据交给GPU线程去完成真正的视图渲染。</p><h2 id="RenderObjectWidget"><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h2><p>  在Flutter中有两个Widget，StatelessWidget和StatefulWidget，这两个Widget都是继承了Widget，但其实它们只是用来组装空间的容器并不负责组件最后的布局和绘制。在Flutter中，布局和绘制实际上是在Widget的另一个子类RenderObjectWidget内完成的。</p><p>  我们来看一下RenderObjectWidget的源码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> RenderObjectWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> didUnmountRenderObject(covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们可以看到这个类有创建Element和RenderObject两个方法，还有更新和didUnmountRenderObject方法</p><p>  对于Element对象的创建，Flutter会在遍历Widget树时，调用createElement去同步Widget自身配置从而生成对应节点的Element对象，而对于RenderObject的创建和更新其实是在RenderObjectElement类中完成的</p><h2 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Creates an element that uses the given widget as its configuration.</span></span><br><span class="line">  RenderObjectElement(RenderObjectWidget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The underlying [RenderObject] for this element.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObject <span class="keyword">get</span> renderObject =&gt; _renderObject;</span><br><span class="line">  RenderObject _renderObject;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123; _debugUpdateRenderObjectOwner(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;());</span><br><span class="line">    <span class="keyword">assert</span>(_slot == newSlot);</span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(covariant RenderObjectWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    <span class="keyword">assert</span>(widget == newWidget);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123; _debugUpdateRenderObjectOwner(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;());</span><br><span class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上是部分RenderObjectElement类的源码，这个类继承了Element类，它同时拥有了RenderObjectWidget和RenderObject对象，并在其中的mount方法中调用了widget的createRenderObject方法然后进行渲染树的插入工作，并且在update方法中调用了widget的updateRenderObject方法。</p><p>  我们还可以查看一些子类对于createRenderObject和updateRenderObject方法的实现</p><p>  这里我拿Align演示</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">RenderPositionedBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> RenderPositionedBox(</span><br><span class="line">    alignment: alignment,</span><br><span class="line">    widthFactor: widthFactor,</span><br><span class="line">    heightFactor: heightFactor,</span><br><span class="line">    textDirection: Directionality.of(context),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateRenderObject(BuildContext context, RenderPositionedBox renderObject) &#123;</span><br><span class="line">  renderObject</span><br><span class="line">    ..alignment = alignment</span><br><span class="line">    ..widthFactor = widthFactor</span><br><span class="line">    ..heightFactor = heightFactor</span><br><span class="line">    ..textDirection = Directionality.of(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们可以看到最终的图像渲染——布局和绘制最终都是交给RenderObject去实现的，比如create是通过RenderPositionedBox去实例化，而这个类正是继承了RenderObject。比如update中最终还是对renderObject对象进行级联操作。</p><p>  我们可以看一下RenderObject的源码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(constraints != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(constraints.debugAssertIsValid(</span><br><span class="line">    isAppliedConstraint: <span class="keyword">true</span>,</span><br><span class="line">    informationCollector: (<span class="built_in">StringBuffer</span> information) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stack = StackTrace.current.toString().split(<span class="string">'\n'</span>);</span><br><span class="line">      <span class="built_in">int</span> targetFrame;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Pattern</span> layoutFramePattern = <span class="built_in">RegExp</span>(<span class="string">r'^#[0-9]+ +RenderObject.layout \('</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; stack.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layoutFramePattern.matchAsPrefix(stack[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          targetFrame = i + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (targetFrame != <span class="keyword">null</span> &amp;&amp; targetFrame &lt; stack.length) &#123;</span><br><span class="line">        information.writeln(</span><br><span class="line">          <span class="string">'These invalid constraints were provided to <span class="subst">$runtimeType</span>\'s layout() '</span></span><br><span class="line">          <span class="string">'function by the following function, which probably computed the '</span></span><br><span class="line">          <span class="string">'invalid constraints in question:'</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Pattern</span> targetFramePattern = <span class="built_in">RegExp</span>(<span class="string">r'^#[0-9]+ +(.+)$'</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Match</span> targetFrameMatch = targetFramePattern.matchAsPrefix(stack[targetFrame]);</span><br><span class="line">        <span class="keyword">if</span> (targetFrameMatch != <span class="keyword">null</span> &amp;&amp; targetFrameMatch.groupCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          information.writeln(<span class="string">'  <span class="subst">$&#123;targetFrameMatch.group(<span class="number">1</span>)&#125;</span>'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          information.writeln(stack[targetFrame]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">assert</span>(!_debugDoingThisResize);</span><br><span class="line">  <span class="keyword">assert</span>(!_debugDoingThisLayout);</span><br><span class="line">  RenderObject relayoutBoundary;</span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    relayoutBoundary = parent._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    _debugCanParentUseSize = parentUsesSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="comment">// in case parentUsesSize changed since the last invocation, set size</span></span><br><span class="line">      <span class="comment">// to itself, so it has the right internal debug values.</span></span><br><span class="line">      _debugDoingThisResize = sizedByParent;</span><br><span class="line">      _debugDoingThisLayout = !sizedByParent;</span><br><span class="line">      <span class="keyword">final</span> RenderObject debugPreviousActiveLayout = _debugActiveLayout;</span><br><span class="line">      _debugActiveLayout = <span class="keyword">this</span>;</span><br><span class="line">      debugResetSize();</span><br><span class="line">      _debugActiveLayout = debugPreviousActiveLayout;</span><br><span class="line">      _debugDoingThisLayout = <span class="keyword">false</span>;</span><br><span class="line">      _debugDoingThisResize = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line">  <span class="keyword">assert</span>(!_debugMutationsLocked);</span><br><span class="line">  <span class="keyword">assert</span>(!_doingThisLayoutWithCallback);</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    _debugMutationsLocked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (debugPrintLayouts)</span><br><span class="line">      debugPrint(<span class="string">'Laying out (<span class="subst">$&#123;sizedByParent ? <span class="string">"with separate resize"</span> : <span class="string">"with resize allowed"</span>&#125;</span>) <span class="subst">$<span class="keyword">this</span><span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    return true;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;());</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  if (sizedByParent) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    assert(() &#123; _debugDoingThisResize = true; return true; &#125;());</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    try &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      performResize();</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      assert(() &#123; debugAssertDoesMeetConstraints(); return true; &#125;());</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &#125; catch (e, stack) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      _debugReportException('</span></span>performResize'</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123; _debugDoingThisResize = <span class="keyword">false</span>; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">  RenderObject debugPreviousActiveLayout;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    _debugDoingThisLayout = <span class="keyword">true</span>;</span><br><span class="line">    debugPreviousActiveLayout = _debugActiveLayout;</span><br><span class="line">    _debugActiveLayout = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    performLayout();</span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">    <span class="keyword">assert</span>(() &#123; debugAssertDoesMeetConstraints(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'performLayout'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    _debugActiveLayout = debugPreviousActiveLayout;</span><br><span class="line">    _debugDoingThisLayout = <span class="keyword">false</span>;</span><br><span class="line">    _debugMutationsLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这里我们就可以画出结构图</p><p>  <img src="/2019/07/26/Flutter——浅析Widget原理/3.jpg" alt="三者结构关系"></p><p>  <img src="/2019/07/26/Flutter——浅析Widget原理/4.jpg" alt="三者结构关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Widget渲染过程&quot;&gt;&lt;a href=&quot;#Widget渲染过程&quot; class=&quot;headerlink&quot; title=&quot;Widget渲染过程&quot;&gt;&lt;/a&gt;Widget渲染过程&lt;/h2&gt;&lt;p&gt;  在进行App开发的时候，我们往往会关注的一个问题是：如何结构化地组织视图
      
    
    </summary>
    
      <category term="Flutter" scheme="https://francisqiang.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql基础学习da——day2</title>
    <link href="https://francisqiang.github.io/2019/07/24/Mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94day2/"/>
    <id>https://francisqiang.github.io/2019/07/24/Mysql基础学习——day2/</id>
    <published>2019-07-24T10:59:09.000Z</published>
    <updated>2019-07-24T11:48:21.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql基础语句"><a href="#Mysql基础语句" class="headerlink" title="Mysql基础语句"></a>Mysql基础语句</h2><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u*** -p***</span><br></pre></td></tr></table></figure><h3 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> *** <span class="keyword">charset</span> utf8;</span><br></pre></td></tr></table></figure><p>  charset为可选参数</p><h3 id="删除一个数据库"><a href="#删除一个数据库" class="headerlink" title="删除一个数据库"></a>删除一个数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> ***;</span><br></pre></td></tr></table></figure><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>  数据库不能重命名</p><h3 id="展示所有数据库"><a href="#展示所有数据库" class="headerlink" title="展示所有数据库"></a>展示所有数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> ***;</span><br></pre></td></tr></table></figure><h3 id="创建简单表"><a href="#创建简单表" class="headerlink" title="创建简单表"></a>创建简单表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)<span class="keyword">engine</span> myisam <span class="keyword">charset</span> utf8;</span><br></pre></td></tr></table></figure><h3 id="删除指定表"><a href="#删除指定表" class="headerlink" title="删除指定表"></a>删除指定表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> ***;</span><br></pre></td></tr></table></figure><h3 id="展示所有表"><a href="#展示所有表" class="headerlink" title="展示所有表"></a>展示所有表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><h3 id="重命名指定表"><a href="#重命名指定表" class="headerlink" title="重命名指定表"></a>重命名指定表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> student <span class="keyword">to</span> stu;</span><br></pre></td></tr></table></figure><h3 id="插入简单数据"><a href="#插入简单数据" class="headerlink" title="插入简单数据"></a>插入简单数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">'zhangsan'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">'lisi'</span>);</span><br></pre></td></tr></table></figure><h3 id="选取表中所有信息"><a href="#选取表中所有信息" class="headerlink" title="选取表中所有信息"></a>选取表中所有信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure><h2 id="删除表中数据"><a href="#删除表中数据" class="headerlink" title="删除表中数据"></a>删除表中数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除表再重建，得到的是新表</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> ***;</span><br><span class="line"><span class="comment"># 删除表中所有数据，得到是旧表</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  重新温习一下Mysql顺便玩一下命令行使用Mysql，并且后要深入原理，加油吧！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mysql基础语句&quot;&gt;&lt;a href=&quot;#Mysql基础语句&quot; class=&quot;headerlink&quot; title=&quot;Mysql基础语句&quot;&gt;&lt;/a&gt;Mysql基础语句&lt;/h2&gt;&lt;h3 id=&quot;连接服务器&quot;&gt;&lt;a href=&quot;#连接服务器&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Mysql" scheme="https://francisqiang.github.io/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——责任链模式</title>
    <link href="https://francisqiang.github.io/2019/07/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/07/24/设计模式——责任链模式/</id>
    <published>2019-07-24T04:18:10.000Z</published>
    <updated>2019-07-24T07:21:30.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是责任链模式"><a href="#什么是责任链模式" class="headerlink" title="什么是责任链模式"></a>什么是责任链模式</h2><p>  责任链，顾名思义，首先责任就是对于需要被处理的请求对象进行处理的责任对象，而在责任链模式中，一个请求处理的对象通常对应一个处理者的链。而每个处理者通常都包含下一个处理者的引用。</p><h2 id="责任链模式UML"><a href="#责任链模式UML" class="headerlink" title="责任链模式UML"></a>责任链模式UML</h2><p>  <img src="/2019/07/24/设计模式——责任链模式/1.jpg" alt="UML"></p><p>  首先，一个请求会对应一个Handler处理链。在处理对象中有一个successor后继处理者和处理方法，在处理方法中会将请求作为入参，然后判断请求的类型或者数值等等，如果符合那么做一些处理，如果不符合过滤请求那么就调用下一个successor后继处理对象的处理方法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="处理者的抽象类"><a href="#处理者的抽象类" class="headerlink" title="处理者的抽象类"></a>处理者的抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApprover</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AbstractApprover abstractApprover;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AbstractApprover <span class="title">getAbstractApprover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> abstractApprover;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprover</span><span class="params">(AbstractApprover abstractApprover)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.abstractApprover = abstractApprover;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体处理者"><a href="#具体处理者" class="headerlink" title="具体处理者"></a>具体处理者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title">AbstractApprover</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DepartmentApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"这个请求被"</span> + <span class="keyword">this</span>.getName() + <span class="string">"处理了"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAbstractApprover().process(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollegeApprover</span> <span class="keyword">extends</span> <span class="title">AbstractApprover</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CollegeApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"这个请求被"</span> + <span class="keyword">this</span>.getName() + <span class="string">"处理了"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAbstractApprover().process(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViceSchoolMasterApprover</span> <span class="keyword">extends</span> <span class="title">AbstractApprover</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ViceSchoolMasterApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">30000</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"这个请求被"</span> + <span class="keyword">this</span>.getName() + <span class="string">"处理了"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAbstractApprover().process(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolMasterApprover</span> <span class="keyword">extends</span> <span class="title">AbstractApprover</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SchoolMasterApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">50000</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"这个请求被"</span> + <span class="keyword">this</span>.getName() + <span class="string">"处理了"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAbstractApprover().process(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需要被处理的请求-当然我们可以面向接口，但是这里直接就是实体类了"><a href="#需要被处理的请求-当然我们可以面向接口，但是这里直接就是实体类了" class="headerlink" title="需要被处理的请求(当然我们可以面向接口，但是这里直接就是实体类了)"></a>需要被处理的请求(当然我们可以面向接口，但是这里直接就是实体类了)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> price, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PurchaseRequest purchaseRequest = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>, <span class="number">40000</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AbstractApprover departmentApprover = <span class="keyword">new</span> DepartmentApprover(<span class="string">"主任"</span>);</span><br><span class="line">    AbstractApprover collegeApprover = <span class="keyword">new</span> CollegeApprover(<span class="string">"院长"</span>);</span><br><span class="line">    AbstractApprover viceSchoolMasterApprover = <span class="keyword">new</span> ViceSchoolMasterApprover(<span class="string">"副校长"</span>);</span><br><span class="line">    AbstractApprover schoolMasterApprover = <span class="keyword">new</span> SchoolMasterApprover(<span class="string">"校长"</span>);</span><br><span class="line"></span><br><span class="line">    departmentApprover.setApprover(collegeApprover);</span><br><span class="line">    collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">    viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line"></span><br><span class="line">    departmentApprover.process(purchaseRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  责任链模式的好处</p><ol><li><p>将处理对象和被处理者分开，如果不使用责任链的话，被处理对象要知道什么时候去调用处理方法，逻辑混合在一起，代码耦合严重。</p></li><li><p>简化了被处理对象，被处理对象不需要知道处理者的结构和链式结构。</p><p>责任链模式的缺点</p></li><li><p>当链比较长的时候 性能会受到影响，因此要控制链的总长度</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是责任链模式&quot;&gt;&lt;a href=&quot;#什么是责任链模式&quot; class=&quot;headerlink&quot; title=&quot;什么是责任链模式&quot;&gt;&lt;/a&gt;什么是责任链模式&lt;/h2&gt;&lt;p&gt;  责任链，顾名思义，首先责任就是对于需要被处理的请求对象进行处理的责任对象，而在责任链模式
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式——组合模式</title>
    <link href="https://francisqiang.github.io/2019/07/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://francisqiang.github.io/2019/07/23/设计模式——组合模式/</id>
    <published>2019-07-23T04:49:56.000Z</published>
    <updated>2019-07-23T10:19:37.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是组合模式-Composite"><a href="#什么是组合模式-Composite" class="headerlink" title="什么是组合模式(Composite)"></a>什么是组合模式(Composite)</h2><p>  组合模式属于结构型模式，它适用于对象层次为树形结构的类组合。</p><p>  组合模式使得用户对单个对象和组合对象的访问和操作具有一致性，即组合模式中，客户能以一致性的方式去处理单个对象和组合对象。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>  <img src="/2019/07/23/设计模式——组合模式/1.jpg" alt="UML"></p><p>  首先顶层应该是一个Component部分类，抽象类，接口，它是什么都行。我们现在假定它是一个接口，这个Component中定义了一些操作方法operation1，operation2等等。这些操作方法的定义其实是希望用户能够以一致性的方式去处理单个对象和组合对象，因为后面单个对象和组合对象都会实现或者继承这个Component。Component中还定义了add方法，接受的参数是Component意思就是在实现Component接口或者抽象类的类中会包含一个Component的容器(可能是list，set，map等等)，对于这个容器的操作还有get或者remove方法也在这个Component接口中定义了。</p><p>  我们可以肯定的是，组合对象需要实现Component中定义的对于装有Component的容器的增删获取等操作。而叶子节点因为底下不再包含Component类了，所以叶子节点只需要实现Component中定义的需要对单个对象和组合对象进行一致性处理的操作方法。</p><h2 id="组合模式代码示例"><a href="#组合模式代码示例" class="headerlink" title="组合模式代码示例"></a>组合模式代码示例</h2><p>  首先我们有一个学校，学校里面有许多学院，学院下面又有很多专业。</p><p>  我们现在需要打印出整个学校下面所有的学院和专业，我们就可以使用组合模式。</p><p>  组合模式特别适用于一些树形的类结构</p><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String  description;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.description = description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.description = description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合对象Composite-这里是University和College"><a href="#组合对象Composite-这里是University和College" class="headerlink" title="组合对象Composite(这里是University和College)"></a>组合对象Composite(这里是University和College)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  List&lt;OrganizationComponent&gt; organizationComponentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, description);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setName(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getDescription();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setDescription(description);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">    organizationComponentList.add(organizationComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">    organizationComponentList.remove(organizationComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"------"</span> + <span class="keyword">this</span>.getName() + <span class="string">"-------"</span>);</span><br><span class="line">    <span class="keyword">for</span> (OrganizationComponent organizationComponent: organizationComponentList) &#123;</span><br><span class="line">      organizationComponent.print();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, description);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;OrganizationComponent&gt; organizationComponentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setName(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getDescription();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setDescription(description);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">    organizationComponentList.add(organizationComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">    organizationComponentList.remove(organizationComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"---------"</span> + <span class="keyword">this</span>.getName() + <span class="string">"-----------"</span>);</span><br><span class="line">    <span class="keyword">for</span> (OrganizationComponent organizationComponent :organizationComponentList) &#123;</span><br><span class="line">      organizationComponent.print();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单个对象-叶子节点这里是Department"><a href="#单个对象-叶子节点这里是Department" class="headerlink" title="单个对象(叶子节点这里是Department)"></a>单个对象(叶子节点这里是Department)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setName(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getDescription();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setDescription(description);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, description);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"------"</span> + <span class="keyword">this</span>.getName() + <span class="string">"----"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">"江苏大学"</span>, <span class="string">"重点一本"</span>);</span><br><span class="line"></span><br><span class="line">    OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">"计算机学院"</span>, <span class="string">"计算机学院"</span>);</span><br><span class="line">    OrganizationComponent infoCollege = <span class="keyword">new</span> College(<span class="string">"信息工程学院"</span>, <span class="string">"信息工程学院"</span>);</span><br><span class="line"></span><br><span class="line">    computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"软件工程"</span>, <span class="string">"11"</span>));</span><br><span class="line">    computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"物联网工程"</span>, <span class="string">"22"</span>));</span><br><span class="line">    computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"计算机"</span>, <span class="string">"33"</span>));</span><br><span class="line"></span><br><span class="line">    infoCollege.add(<span class="keyword">new</span> Department(<span class="string">"通信工程"</span>, <span class="string">"44"</span>));</span><br><span class="line"></span><br><span class="line">    university.add(computerCollege);</span><br><span class="line">    university.add(infoCollege);</span><br><span class="line"></span><br><span class="line">    university.print();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h2><h3 id="Tomcat的运用"><a href="#Tomcat的运用" class="headerlink" title="Tomcat的运用"></a>Tomcat的运用</h3><p>  在Tomcat中，四大容器Engine，Host，Context，Warpper都继承了Container接口，在Container接口中定义了对容器的增删等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADD_CHILD_EVENT = <span class="string">"addChild"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADD_VALVE_EVENT = <span class="string">"addValve"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REMOVE_CHILD_EVENT = <span class="string">"removeChild"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REMOVE_VALVE_EVENT = <span class="string">"removeValve"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Log <span class="title">getLogger</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLogName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectName <span class="title">getObjectName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDomain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMBeanKeyProperties</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pipeline <span class="title">getPipeline</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cluster <span class="title">getCluster</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCluster</span><span class="params">(Cluster cluster)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBackgroundProcessorDelay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundProcessorDelay</span><span class="params">(<span class="keyword">int</span> delay)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Container container)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getParentClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Realm <span class="title">getRealm</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRealm</span><span class="params">(Realm realm)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backgroundProcess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addContainerListener</span><span class="params">(ContainerListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">findChild</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Container[] findChildren();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ContainerListener[] findContainerListeners();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeContainerListener</span><span class="params">(ContainerListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removePropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireContainerEvent</span><span class="params">(String type, Object data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAccess</span><span class="params">(Request request, Response response, <span class="keyword">long</span> time,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> useDefault)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccessLog <span class="title">getAccessLog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStartStopThreads</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartStopThreads</span><span class="params">(<span class="keyword">int</span> startStopThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getCatalinaBase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getCatalinaHome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/23/设计模式——组合模式/2.jpg" alt="tomcat"></p><p>上图是继承实现Container的类结构</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是组合模式-Composite&quot;&gt;&lt;a href=&quot;#什么是组合模式-Composite&quot; class=&quot;headerlink&quot; title=&quot;什么是组合模式(Composite)&quot;&gt;&lt;/a&gt;什么是组合模式(Composite)&lt;/h2&gt;&lt;p&gt;  组合模式属于
      
    
    </summary>
    
      <category term="Java设计模式" scheme="https://francisqiang.github.io/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
